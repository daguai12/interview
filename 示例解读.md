### 预设场景

为了让案例更具体，我们先假设当前 CPU 的寄存器和内存中有以下值：

**寄存器 (Register) 状态:**
* `%eax` 的值为 `0x100`
* `%ebx` 的值为 `0x200`
* `%ecx` 的值为 `4`
* `%edx` 的值我们用来存放操作结果

**内存 (Memory) 状态:**
* 地址 `0x100` 处存放的值是 `0xABCD`
* 地址 `0x200` 处存放的值是 `0x1111`
* 地址 `0x208` 处存放的值是 `0x2222`
* 地址 `0x300` 处存放的值是 `0x3333`
* 地址 `0x210` 处存放的值是 `0x4444`
* 地址 `0x218` 处存放的值是 `0x5555`

现在，我们开始逐个解释：

---

### 1. 立即数寻址 (Immediate Addressing)

* **格式:** `$Imm`
* **操作数值:** `Imm`
* **说明:** 操作数的值直接写在指令当中。这个值是一个常数，不需要去寄存器或内存中读取。格式中的 `$` 符号就是用来表示这是一个立即数。

* **案例:** `movl $0x123, %edx`
    * **解释:** 这条指令的意思是，将立即数（常数）`0x123` 移动到 `%edx` 寄存器中。
    * **操作:** CPU 直接将 `0x123` 这个值赋给 `%edx`。
    * **结果:** `%edx` 的值变为 `0x123`。

---

### 2. 寄存器寻址 (Register Addressing)

* **格式:** `%ra`
* **操作数值:** `R[ra]` (表示寄存器 `ra` 中的值)
* **说明:** 操作数的值已经存在于某个寄存器中。指令直接指定寄存器的名称。

* **案例:** `movl %eax, %edx`
    * **解释:** 将寄存器 `%eax` 中的值移动到 `%edx` 寄存器中。
    * **操作:** CPU 读取 `%eax` 的值（预设为 `0x100`），然后将这个值写入 `%edx`。
    * **结果:** `%edx` 的值变为 `0x100`。

---

### 3. 绝对寻址 (Absolute Addressing)

* **格式:** `Imm`
* **操作数值:** `M[Imm]` (表示内存地址 `Imm` 处的值)
* **说明:** 指令中直接给出了操作数所在的内存地址。

* **案例:** `movl 0x100, %edx`
    * **解释:** 将内存地址 `0x100` 处的数据移动到 `%edx` 寄存器中。
    * **操作:** CPU 读取内存地址 `0x100` 的内容（预设为 `0xABCD`），然后将其写入 `%edx`。
    * **结果:** `%edx` 的值变为 `0xABCD`。

---

### 4. 间接寻址 (Indirect Addressing)

* **格式:** `(%ra)`
* **操作数值:** `M[R[ra]]` (表示寄存器 `ra` 的值作为地址，再从该内存地址取值)
* **说明:** 操作数在内存中，而它的内存地址存放在一个寄存器里。括号 `()` 表示要去内存中取值。

* **案例:** `movl (%ebx), %edx`
    * **解释:** 将寄存器 `%ebx` 中的值（`0x200`）作为内存地址，读取该地址的数据，并存入 `%edx`。
    * **操作:**
        1.  CPU 读取 `%ebx` 的值，得到 `0x200`。
        2.  CPU 访问内存地址 `0x200`，读取其内容（预设为 `0x1111`）。
        3.  将 `0x1111` 写入 `%edx`。
    * **结果:** `%edx` 的值变为 `0x1111`。

---

### 5. (基址+偏移量)寻址 (Base + Displacement Addressing)

* **格式:** `Imm(%rb)`
* **操作数值:** `M[Imm + R[rb]]`
* **说明:** 操作数的内存地址由一个基址寄存器 (`%rb`) 的值加上一个立即数偏移量 (`Imm`) 计算得出。

* **案例:** `movl 0x8(%ebx), %edx`
    * **解释:** 将基址寄存器 `%ebx` 的值加上偏移量 `0x8`，得到最终的内存地址，然后从该地址取值。
    * **操作:**
        1.  计算地址：`R[%ebx] + 0x8` = `0x200 + 0x8` = `0x208`。
        2.  CPU 访问内存地址 `0x208`，读取其内容（预设为 `0x2222`）。
        3.  将 `0x2222` 写入 `%edx`。
    * **结果:** `%edx` 的值变为 `0x2222`。

---

### 6. 变址寻址 (Indexed Addressing)

变址寻址通常用于访问数组元素或复杂数据结构，它将两个寄存器的值相加来形成地址。

* **格式 1:** `(%rb, %ri)`
* **操作数值:** `M[R[rb] + R[ri]]`

    * **案例:** `movl (%eax, %ebx), %edx`
    * **解释:** 将基址寄存器 `%eax` 的值和变址寄存器 `%ebx` 的值相加，得到内存地址，然后取值。
    * **操作:**
        1.  计算地址：`R[%eax] + R[%ebx]` = `0x100 + 0x200` = `0x300`。
        2.  CPU 访问内存地址 `0x300`，读取其内容（预设为 `0x3333`）。
        3.  将 `0x3333` 写入 `%edx`。
    * **结果:** `%edx` 的值变为 `0x3333`。

* **格式 2:** `Imm(%rb, %ri)`
* **操作数值:** `M[Imm + R[rb] + R[ri]]`

    * **案例:** `movl 0x100(%eax, %ebx), %edx`
    * **解释:** 在上一种的基础上，再额外加上一个立即数偏移量。
    * **操作:**
        1.  计算地址：`0x100 + R[%eax] + R[%ebx]` = `0x100 + 0x100 + 0x200` = `0x400`。
        2.  假设内存 `0x400` 处的值为 `0x6666`。
        3.  将 `0x6666` 写入 `%edx`。
    * **结果:** `%edx` 的值变为 `0x6666`。

---

### 7. 比例变址寻址 (Scaled Indexed Addressing)

这是最通用、最强大的寻址模式，尤其适合访问数组。它允许将变址寄存器 `(%ri)` 的值乘以一个比例因子 `s`（`s` 只能是 1, 2, 4, 8），然后再进行地址计算。这正好对应了访问 `char` (1字节), `short` (2字节), `int/long` (4字节), `long long/double` (8字节) 等类型数组的场景。

* **最完整格式:** `Imm(%rb, %ri, s)`
* **操作数值:** `M[Imm + R[rb] + R[ri] * s]`

我们可以通过省略其中的某些部分得到表格中的其他格式。

* **案例 (完整格式):** `movl 0x8(%ebx, %ecx, 4), %edx`
    * **解释:** 这是最完整的形式。基地址在 `%ebx`，索引在 `%ecx`，比例因子是 `4`，还有一个 `0x8` 的固定偏移量。这常用于访问结构体中的数组成员。
    * **操作:**
        1.  计算地址：`Imm + R[%rb] + R[%ri] * s`
            = `0x8 + R[%ebx] + R[%ecx] * 4`
            = `0x8 + 0x200 + 4 * 4`
            = `0x8 + 0x200 + 0x10`
            = `0x218`。
        2.  CPU 访问内存地址 `0x218`，读取其内容（预设为 `0x5555`）。
        3.  将 `0x5555` 写入 `%edx`。
    * **结果:** `%edx` 的值变为 `0x5555`。

* **案例 (省略偏移量):** `movl (%ebx, %ecx, 4), %edx`
    * **解释:** C 语言中 `array[i]` 寻址的典型例子。`%ebx` 是数组基地址，`%ecx` 是索引 `i`，`4` 是数组元素大小（例如 `int`）。
    * **操作:**
        1.  计算地址：`R[%ebx] + R[%ecx] * 4` = `0x200 + 4 * 4` = `0x210`。
        2.  CPU 访问内存地址 `0x210`，读取其内容（预设为 `0x4444`）。
        3.  将 `0x4444` 写入 `%edx`。
    * **结果:** `%edx` 的值变为 `0x4444`。

表格中的 `(, %ri, s)` 和 `Imm(, %ri, s)` 是省略了基址寄存器 `%rb` 的情况，计算方法类似。

希望这些具体的案例能帮助你更好地理解这些操作数格式！



# 零扩展指令

好的，我们来通过具体的案例，逐一学习 `MOVZ`（**Mov**e with **Z**ero Extend）系列指令。

这些指令的核心功能是：**在将一个较小的数据（如8位或16位）移动到较大的寄存器时，用 `0` 来填充所有多出来的高位比特**。这对于处理无符号整数尤其重要，可以确保数值在扩展后保持不变。

---

### 预设场景

为了让案例更清晰，我们先假设 CPU 中有两个寄存器处于以下初始状态：

* **源寄存器 `%rax`** (64位):
    * 值为 `0x11223344AABBCCDD`
    * 这使得它的各个部分为：
        * `%eax` (32位) = `0xAABBCCDD`
        * `%ax` (16位) = `0xCCDD`
        * `%al` (8位) = `0xDD`
* **目的寄存器 `%rbx`** (64位):
    * 我们假设它的初始值是“脏”的，全为 `F`，即 `0xFFFFFFFFFFFFFFFF`。这样可以清晰地看到零扩展是如何清除高位的。

---

### 1. `movzbw`：将零扩展的字节传送到字

* **指令**: `movzbw S, R`
* **解释**: 将**字节(b)**源 `S` 零扩展后移动到**字(w)**目的 `R`。目的 `R` 必须是一个16位寄存器。
* **案例**: `movzbw %al, %bx`

    * **执行前**:
        * 源 `%al` = `0xDD` (8位)
        * 目的 `%bx` = `0xFFFF` (16位)
    * **操作**:
        1.  读取 `%al` 的值 `0xDD`。
        2.  将其放入 `%bx` 的低8位 (`%bl`)。
        3.  将 `%bx` 的高8位 (`%bh`) 用 `0` 填充。
    * **执行后**:
        * `%bx` 的值变为 `0x00DD`。
        * **注意**: 因为目的操作数是16位的 `%bx`，所以 `%rbx` 的高48位**不受影响**。`%rbx` 的完整值变为 `0xFFFFFFFFFFFF00DD`。

---

### 2. `movzbl`：将零扩展的字节传送到双字

* **指令**: `movzbl S, R`
* **解释**: 将**字节(b)**源 `S` 零扩展后移动到**双字(l)**目的 `R`。目的 `R` 必须是一个32位寄存器。
* **案例**: `movzbl %al, %ebx`

    * **执行前**:
        * 源 `%al` = `0xDD` (8位)
        * 目的 `%ebx` = `0xFFFFFFFF` (32位)
    * **操作**:
        1.  读取 `%al` 的值 `0xDD`。
        2.  将其放入 `%ebx` 的低8位。
        3.  将 `%ebx` 剩下的高24位全部用 `0` 填充。
    * **执行后**:
        * `%ebx` 的值变为 `0x000000DD`。
        * **重要**: 根据x86-64的规则，任何对32位寄存器（如 `%ebx`）的写操作，都会自动将其所属的64位寄存器（`%rbx`）的高32位清零。因此，`%rbx` 的完整值变为 `0x00000000000000DD`。

---

### 3. `movzwl`：将零扩展的字传送到双字

* **指令**: `movzwl S, R`
* **解释**: 将**字(w)**源 `S` 零扩展后移动到**双字(l)**目的 `R`。目的 `R` 必须是一个32位寄存器。
* **案例**: `movzwl %ax, %ebx`

    * **执行前**:
        * 源 `%ax` = `0xCCDD` (16位)
        * 目的 `%ebx` = `0xFFFFFFFF` (32位)
    * **操作**:
        1.  读取 `%ax` 的值 `0xCCDD`。
        2.  将其放入 `%ebx` 的低16位。
        3.  将 `%ebx` 的高16位用 `0` 填充。
    * **执行后**:
        * `%ebx` 的值变为 `0x0000CCDD`。
        * 同样，`%rbx` 的高32位被自动清零，其完整值变为 `0x000000000000CCDD`。

---

### 4. `movzbq`：将零扩展的字节传送到四字

* **指令**: `movzbq S, R`
* **解释**: 将**字节(b)**源 `S` 零扩展后移动到**四字(q)**目的 `R`。目的 `R` 必须是一个64位寄存器。
* **案例**: `movzbq %al, %rbx`

    * **执行前**:
        * 源 `%al` = `0xDD` (8位)
        * 目的 `%rbx` = `0xFFFFFFFFFFFFFFFF` (64位)
    * **操作**:
        1.  读取 `%al` 的值 `0xDD`。
        2.  将其放入 `%rbx` 的最低8位。
        3.  将 `%rbx` 剩下的高56位全部用 `0` 填充。
    * **执行后**:
        * `%rbx` 的值变为 `0x00000000000000DD`。

---

### 5. `movzwq`：将零扩展的字传送到四字

* **指令**: `movzwq S, R`
* **解释**: 将**字(w)**源 `S` 零扩展后移动到**四字(q)**目的 `R`。目的 `R` 必须是一个64位寄存器。
* **案例**: `movzwq %ax, %rbx`

    * **执行前**:
        * 源 `%ax` = `0xCCDD` (16位)
        * 目的 `%rbx` = `0xFFFFFFFFFFFFFFFF` (64位)
    * **操作**:
        1.  读取 `%ax` 的值 `0xCCDD`。
        2.  将其放入 `%rbx` 的低16位。
        3.  将 `%rbx` 剩下的高48位全部用 `0` 填充。
    * **执行后**:
        * `%rbx` 的值变为 `0x000000000000CCDD`。

---

### 特别说明：为什么没有 `movzlq` 指令？

正如说明中提到的，指令集里没有 `movzlq` (将零扩展的双字传送到四字)。

原因是 `movl` 指令已经完美地实现了这个功能。

**目标**: 我们想将 `%eax` (`0xAABBCCDD`) 中的无符号数零扩展到 `%rbx` 中。
* **如果 `movzlq` 存在**: 我们会写 `movzlq %eax, %rbx`。
* **实际的写法**: 我们只需要写 `movl %eax, %ebx`。

让我们看看 `movl %eax, %ebx` 做了什么：
1.  它将 `%eax` 的32位值 `0xAABBCCDD` 复制到 `%ebx`。
2.  因为目的操作数是32位寄存器 `%ebx`，x86-64架构的**硬件规则自动将 `%rbx` 的高32位清零**。

最终 `%rbx` 的值为 `0x00000000AABBCCDD`，这正是我们想要的零扩展结果。因为 `movl` 已经高效地完成了这项工作，所以再设计一条 `movzlq` 指令就是多余的了。

# 符号扩展MOV

好的，我们来详细解析 `MOVS`（**Mov**e with **S**ign Extend）系列指令。

这组指令与 `MOVZ` 系列的核心区别在于**如何填充高位**。`MOVS` 用于处理**有符号数**，它会复制源操作数的**符号位**（最高位）来填充目的寄存器所有多出来的高位。

* 如果源数的符号位是 `0`（代表正数），则用 `0` 填充高位。
* 如果源数的符号位是 `1`（代表负数），则用 `1` 填充高位。

这样做可以确保在扩展数据宽度的同时，数值大小保持不变（例如，8位的 `-1` 扩展到64位后仍然是 `-1`）。

---

### 预设场景

为了演示符号扩展，我们需要为不同大小的数据准备正数和负数两个案例。

* **字节源 (8-bit)**，存放在 `%al` 中:
    * **正数**: `%al = 0x7F` (十进制 127)。二进制为 `01111111`，**符号位是 0**。
    * **负数**: `%al = 0x80` (十进制 -128)。二进制为 `10000000`，**符号位是 1**。
* **字源 (16-bit)**，存放在 `%ax` 中:
    * **正数**: `%ax = 0x7FFF`。**符号位是 0**。
    * **负数**: `%ax = 0x8000`。**符号位是 1**。
* **双字源 (32-bit)**，存放在 `%eax` 中:
    * **正数**: `%eax = 0x7FFFFFFF`。**符号位是 0**。
    * **负数**: `%eax = 0x80000000`。**符号位是 1**。
* **目的寄存器 `%rbx`**，初始值为“脏数据” `0xCCCCCCCCCCCCCCCC`。

---

### 1. `movsbw` / `movsbl` / `movsbq` (源为字节)

#### `movsbq %al, %rbx`：将符号扩展的字节传送到四字

这是最能体现符号扩展到64位的指令。

* **案例1：正数 (`%al = 0x7F`)**
    * **指令**: `movsbq %al, %rbx`
    * **操作**: CPU检查 `%al` (`01111111`b) 的符号位，发现是 `0`。它将用 `0` 填充 `%rbx` 的高56位。
    * **结果**: `%rbx` 变为 `0x000000000000007F`。

* **案例2：负数 (`%al = 0x80`)**
    * **指令**: `movsbq %al, %rbx`
    * **操作**: CPU检查 `%al` (`10000000`b) 的符号位，发现是 `1`。它将用 `1` 填充 `%rbx` 的高56位（在十六进制中表现为 `F`）。
    * **结果**: `%rbx` 变为 `0xFFFFFFFFFFFFFF80`。

`movsbw` 和 `movsbl` 类似，只是扩展的目标宽度不同。

---

### 2. `movswl` / `movswq` (源为字)

#### `movswq %ax, %rbx`：将符号扩展的字传送到四字

* **案例1：正数 (`%ax = 0x7FFF`)**
    * **指令**: `movswq %ax, %rbx`
    * **操作**: `%ax` 的符号位是 `0`。用 `0` 填充 `%rbx` 的高48位。
    * **结果**: `%rbx` 变为 `0x0000000000007FFF`。

* **案例2：负数 (`%ax = 0x8000`)**
    * **指令**: `movswq %ax, %rbx`
    * **操作**: `%ax` 的符号位是 `1`。用 `1` 填充 `%rbx` 的高48位。
    * **结果**: `%rbx` 变为 `0xFFFFFFFFFFFF8000`。

---

### 3. `movslq` (源为双字)

这是非常重要的一条指令，用于将一个标准的32位有符号整数，正确地转换为64位。

#### `movslq %eax, %rbx`：将符号扩展的双字传送到四字

* **案例1：正数 (`%eax = 0x7FFFFFFF`)**
    * **指令**: `movslq %eax, %rbx`
    * **操作**: `%eax` 的符号位是 `0`。用 `0` 填充 `%rbx` 的高32位。
    * **结果**: `%rbx` 变为 `0x000000007FFFFFFF`。

* **案例2：负数 (`%eax = 0x80000000`)**
    * **指令**: `movslq %eax, %rbx`
    * **操作**: `%eax` 的符号位是 `1`。用 `1` 填充 `%rbx` 的高32位。
    * **结果**: `%rbx` 变为 `0xFFFFFFFF80000000`。

**重要对比**: 如果你错误地使用了 `movl %eax, %ebx` 来处理负数 `0x80000000`，`%ebx` 会得到 `0x80000000`，但因为 `movl` 会将 `%rbx` 的高位清零，所以 `%rbx` 的最终结果是 `0x0000000080000000`，这是一个巨大的正数，而不是原来的负数值。**因此，对于有符号32位到64位的扩展，必须使用 `movslq`**。

---

### 4. `cltq` (特殊指令)

`cltq` 是 "Convert Long to Quad" 的缩写。它是一条单字节、无操作数的指令，功能非常专一。

* **指令**: `cltq`
* **效果**: 与 `movslq %eax, %rax` 完全相同。
* **描述**: 读取 `%eax` 的值，并将其符号扩展到整个 `%rax` 寄存器。

**为什么需要 `cltq`?**
在C语言中，将 `int` 类型的变量赋值给 `long` 类型的变量是一个极其常见的操作。编译器为了生成最高效的代码，会使用 `cltq` 这条单字节指令，而不是需要更多字节来编码的 `movslq %eax, %rax`。

* **案例**:
    * **执行前**: 假设 `%eax = 0x80000000`。因为之前的操作，`%rax` 可能为 `0x0000000080000000`。
    * **指令**: `cltq`
    * **操作**: 指令检查 `%eax` 的符号位（是 `1`），并用 `1` 填充 `%rax` 的高32位。
    * **执行后**: `%rax` 变为 `0xFFFFFFFF80000000`。

### 总结表格

| 指令 | 源 | 目的 | 描述 |
| :--- | :--- | :--- | :--- |
| **`movsbq`** | 8-bit | 64-bit | 将字节符号扩展到64位。 |
| **`movswq`** | 16-bit | 64-bit | 将字符号扩展到64位。 |
| **`movslq`** | 32-bit | 64-bit | 将双字符号扩展到64位，是处理 `int` 到 `long` 的关键。 |
| **`cltq`** | `%eax` (32-bit) | `%rax` (64-bit) | `movslq %eax, %rax` 的高效单字节版本。 |

# popq/pushq

当然，通过一个具体的、分步的案例来理解 `push` 和 `pop` 是最好的方式。

我们将通过一个简单的指令序列，来追踪栈指针 `%rsp`、相关寄存器以及内存中栈区域的变化。

---

### 案例场景

想象一下，我们有两个寄存器 `%rax` 和 `%rbx` 存有重要数据。我们想临时使用这两个寄存器，但又不想丢失它们原来的值。最好的办法就是先把它们的值**压入栈中**保存起来，用完之后再**从栈中恢复**。

#### 第 0 步：初始状态

在执行任何操作之前，我们先设定一个初始状态。

* **寄存器状态**:
    * `%rax` = `0x1111111111111111`
    * `%rbx` = `0x2222222222222222`
    * `%rsp` (栈指针) 指向地址 `0x7fffffffe880`

* **内存中的栈区域 (部分)**:
    地址越高，越在“栈底”方向；地址越低，越在“栈顶”方向。

| 内存地址 | 内容 | 说明 |
| :--- | :--- | :--- |
| `0x7fffffffe888` | ... (旧数据) | |
| `0x7fffffffe880` | ... (旧数据) | **<-- %rsp 当前指向这里 (栈顶)** |
| `0x7fffffffe878` | ... (未使用) | |
| `0x7fffffffe870` | ... (未使用) | |

---

#### 第 1 步：执行 `pushq %rax`

我们要把 `%rax` 的值压入栈中。

* **指令**: `pushq %rax`
* **等价操作**:
    1.  **`%rsp` 减 8**: `%rsp` 从 `0x7fffffffe880` 变为 `0x7fffffffe878`。栈向低地址方向“增长”了。
    2.  **写入数据**: 将 `%rax` 的值 (`0x11...11`) 存入新的 `%rsp` 指向的内存地址 `0x7fffffffe878`。

* **执行后状态**:
    * `%rax` 依然是 `0x11...11` (push 不改变源寄存器)。
    * `%rsp` 现在是 `0x7fffffffe878`。

* **内存中的栈区域**:

| 内存地址 | 内容 | 说明 |
| :--- | :--- | :--- |
| `0x7fffffffe888` | ... (旧数据) | |
| `0x7fffffffe880` | ... (旧数据) | |
| `0x7fffffffe878` | `0x1111111111111111` | **<-- %rsp 现在指向这里 (新的栈顶)** |
| `0x7fffffffe870` | ... (未使用) | |

---

#### 第 2 步：执行 `pushq %rbx`

接着，我们把 `%rbx` 的值也压入栈中。

* **指令**: `pushq %rbx`
* **等价操作**:
    1.  **`%rsp` 再减 8**: `%rsp` 从 `0x7fffffffe878` 变为 `0x7fffffffe870`。
    2.  **写入数据**: 将 `%rbx` 的值 (`0x22...22`) 存入新的栈顶地址 `0x7fffffffe870`。

* **执行后状态**:
    * `%rbx` 依然是 `0x22...22`。
    * `%rsp` 现在是 `0x7fffffffe870`。

* **内存中的栈区域**:

| 内存地址 | 内容 | 说明 |
| :--- | :--- | :--- |
| `0x7fffffffe888` | ... (旧数据) | |
| `0x7fffffffe880` | ... (旧数据) | |
| `0x7fffffffe878` | `0x1111111111111111` | (旧的栈顶，现在是栈的第二个元素) |
| `0x7fffffffe870` | `0x2222222222222222` | **<-- %rsp 现在指向这里 (最新的栈顶)** |

**关键点**: `%rbx` 的值现在位于栈顶，它是最后被压入的。这完美体现了“后进先出”(LIFO)的原则。

---

#### 第 3 步：执行 `popq %rcx`

现在，假设我们完成了临时任务，需要恢复数据。我们执行 `pop` 操作。注意，我们可以将弹出的值放入**任何**寄存器，这里我们用 `%rcx` 来接收，以展示数据是如何被移动的。

* **指令**: `popq %rcx`
* **等价操作**:
    1.  **读取数据**: 从当前栈顶 (`%rsp` 指向的 `0x7fffffffe870`) 读取值 `0x22...22`，并将其存入 `%rcx`。
    2.  **`%rsp` 加 8**: `%rsp` 从 `0x7fffffffe870` 变回 `0x7fffffffe878`。栈向高地址方向“收缩”。

* **执行后状态**:
    * `%rcx` 接收了弹出的值，变为 `0x2222222222222222`。
    * `%rsp` 现在是 `0x7fffffffe878`。

* **内存中的栈区域**:

| 内存地址 | 内容 | 说明 |
| :--- | :--- | :--- |
| `0x7fffffffe888` | ... (旧数据) | |
| `0x7fffffffe880` | ... (旧数据) | |
| `0x7fffffffe878` | `0x1111111111111111` | **<-- %rsp 现在指向这里 (新的栈顶)** |
| `0x7fffffffe870` | `0x2222222222222222` | (这块内存中的值还在，但已在栈外，被视为无效数据) |

---

#### 第 4 步：执行 `popq %rax`

我们继续弹出下一个值，这次把它放回 `%rax`。

* **指令**: `popq %rax`
* **等价操作**:
    1.  **读取数据**: 从当前栈顶 (`%rsp` 指向的 `0x7fffffffe878`) 读取值 `0x11...11`，并存入 `%rax`。
    2.  **`%rsp` 再加 8**: `%rsp` 从 `0x7fffffffe878` 变回最初的 `0x7fffffffe880`。

* **执行后状态**:
    * `%rax` 恢复了它的原始值 `0x11...11`。
    * `%rsp` 回到了 `0x7fffffffe880`。

* **内存中的栈区域**:

| 内存地址 | 内容 | 说明 |
| :--- | :--- | :--- |
| `0x7fffffffe888` | ... (旧数据) | |
| `0x7fffffffe880` | ... (旧数据) | **<-- %rsp 回到初始位置** |
| `0x7fffffffe878` | `0x1111111111111111` | (无效数据) |
| `0x7fffffffe870` | `0x2222222222222222` | (无效数据) |

### 总结

这个案例清晰地展示了：

1.  **后进先出 (LIFO)**: 我们按 `%rax` -> `%rbx` 的顺序压栈，但必须按 `%rbx` 的值 -> `%rax` 的值的顺序弹栈。顺序是相反的。
2.  **栈向下增长**: 每次 `push`，`%rsp` 的地址值都会变小。
3.  **`%rsp` 始终指向栈顶**: 栈顶是最后压入的有效元素。
4.  **`push/pop` 是复合操作**: 它们不仅传送数据，还自动维护栈指针 `%rsp`。