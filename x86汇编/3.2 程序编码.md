### **3.2 程序编码 (Program Encoding)**

这段文字描述了将一个C程序（以两个源文件`p1.c`和`p2.c`为例）编译成可执行文件`p`的过程。

**编译命令示例:**

```bash
linux> gcc -Og -o p p1.c p2.c
```

  * `gcc`: GNU编译器集合（GCC）的命令，在Linux上通常是默认编译器。
  * `-Og`: 一个优化选项，它生成的机器代码能较好地对应原始C代码的结构，便于学习和调试。在实际应用中，为了追求更好的性能，通常会使用更高级别的优化，如`-O1`或`-O2`。

**编译过程的四个阶段:**

1.  **预处理 (Preprocessing)**: C预处理器 (`cpp`) 读取源代码，处理`#include`指令（插入头文件内容）和`#define`指令（扩展宏）。
2.  **编译 (Compilation)**: 编译器 (`cc`或`ccl`) 将预处理后的代码翻译成汇编代码（Assembly Code），生成`.s`文件（例如 `p1.s`, `p2.s`）。汇编代码是机器代码的可读文本形式。
3.  **汇编 (Assembly)**: 汇编器 (`as`) 将汇编代码转化成二进制的目标代码（Object Code），生成`.o`文件（例如 `p1.o`, `p2.o`）。目标代码是机器指令的二进制格式，但函数调用等的地址尚未确定。
4.  **链接 (Linking)**: 链接器 (`ld`) 将多个目标代码文件（如 `p1.o`, `p2.o`）与库函数（如 `printf`）的代码合并，解析地址引用，最终生成一个单一的可执行代码文件（例如 `p`）。

-----

### **3.2.1 机器级代码 (Machine-Level Code)**

机器级编程涉及两个关键的抽象：

1.  **指令集架构 (Instruction Set Architecture, ISA)**:

      * 定义了机器级程序的格式和行为。
      * 包括处理器状态、指令格式以及每条指令如何影响状态。
      * x86-64的ISA模型表现为指令是顺序执行的，尽管底层硬件为了性能会并行执行多条指令。

2.  **虚拟内存 (Virtual Memory)**:

      * 程序使用的内存地址是虚拟地址，展现为一个巨大的字节数组。
      * 实际的物理内存由硬件和操作系统共同管理。
      * x86-64的虚拟地址是64位的，但目前实现通常只使用低48位，提供了高达256TB的寻址空间。

**C代码与机器代码的差异:**

  * **处理器状态的可见性**: C语言隐藏了许多处理器细节，但在机器级是可见的：
      * **程序计数器 (PC, 在x86-64中是 `%rip`)**: 存放下一条要执行指令的内存地址。
      * **整数寄存器文件**: 16个64位的通用寄存器，用于存放整数数据或指针（内存地址）。
      * **条件码寄存器**: 存储最近算术或逻辑运算的状态（如结果是否为零、是否溢出等），用于实现`if`、`while`等条件控制。
      * **向量寄存器**: 用于存放一个或多个整数或浮点数值。
  * **数据类型的处理**:
      * C语言有丰富的数据类型（`int`, `float`, 数组, 结构体等）。
      * 机器代码将内存视为一个简单的、按字节寻址的数组。数组和结构体等复合类型被表示为连续的字节块。汇编代码不区分有符号/无符号整数，也不区分指针和整数。

-----

### **3.2.2 代码示例 (Code Example)**

这个例子通过一个C函数 `multstore` 来展示从源代码到汇编再到机器码的转换。

**C 源码 (`mstore.c`):**

```c
long mult2(long, long);

void multstore(long x, long y, long *dest) {
    long t = mult2(x, y);
    *dest = t;
}
```

1.  **生成汇编代码 (`.s` 文件):**

    ```bash
    linux> gcc -Og -S mstore.c
    ```

    生成的 `mstore.s` 文件包含了人类可读的汇编指令，例如：

    ```assembly
    multstore:
        pushq   %rbx
        movq    %rdx, %rbx
        call    mult2
        movq    %rax, (%rbx)
        popq    %rbx
        ret
    ```

2.  **生成目标代码 (`.o` 文件):**

    ```bash
    linux> gcc -Og -c mstore.c
    ```

    生成的 `mstore.o` 是二进制文件。`multstore` 函数对应的机器码（14个字节）的十六进制表示为：
    `53 48 89 d3 e8 00 00 00 00 48 89 03 5b c3`

3.  **反汇编 (Disassembly):**
    使用 `objdump` 工具可以查看目标文件中的代码：

    ```bash
    linux> objdump -d mstore.o
    ```

    `objdump` 会将二进制的机器码翻译回汇编语言格式，结果与 `.s` 文件中的指令基本一致。

**反汇编的几个特点:**

  * **变长指令**: x86-64指令长度从1到15字节不等。
  * **唯一解码**: 从任何给定位置开始，字节序列都可以被唯一地解码成指令。
  * **无需源码**: 反汇编器仅根据二进制文件就能工作，不需要C源代码。

<!-- end list -->

4.  **生成可执行文件并反汇编:**
    当链接器（通过 `gcc -o prog main.c mstore.c` 调用）生成最终的可执行文件 `prog` 后，`multstore` 函数的地址会改变，并且 `call` 指令的目标地址（对 `mult2` 的调用）会被填充为链接后 `mult2` 函数的实际地址。

-----

### **3.2.3 关于格式的注解 (Notes on Formatting)**

**ATT 与 Intel 汇编代码格式的对比:**

GCC、`objdump` 等GNU工具默认使用 **ATT格式**。而Intel和Microsoft的文档和工具则使用 **Intel格式**。两者有几个关键区别：

| 特性        | ATT 格式 (GNU)                | Intel 格式 (Intel/Microsoft) |
| :-------- | :-------------------------- | :------------------------- |
| **大小后缀**  | 有 (`movq`, `pushq`)         | 无 (`mov`, `push`)          |
| **寄存器前缀** | 有 (`%rbx`, `%rax`)          | 无 (`rbx`, `rax`)           |
| **内存寻址**  | `(%rbx)`                    | `QWORD PTR [rbx]`          |
| **操作数顺序** | `源, 目的` (`movq %rax, %rbx`) | `目的, 源` (`mov rbx, rax`)   |

书中主要使用ATT格式进行讲解。

**网络旁注：在C程序中结合汇编代码**

有时为了访问C语言无法直接触及的底层机器特性（例如，奇偶标志位PF），需要在C代码中嵌入汇编指令。有两种方法：

1.  **独立汇编文件**: 将整个函数用汇编语言写在一个单独的 `.s` 文件中，然后与C代码一起链接。
2.  **内联汇编 (Inline Assembly)**: 使用GCC的 `asm` 关键字，可以直接在C函数体中嵌入简短的汇编代码片段。这种方式可以减少与机器相关的代码量，但会使程序依赖于特定的硬件架构（如x86-64）。