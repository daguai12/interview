### **3.10 在机器级程序中将控制与数据结合起来**

到目前为止，我们已经分别讨论了机器级代码的控制流和数据结构。在本节中，我们将深入审视 C 语言中最重要的概念之一：指针。

#### **3.10.1 理解指针**

指针是 C 语言的核心特色。它们以一种统一的方式，对不同数据结构中的元素产生引用。以下是关于指针及其映射到机器代码的一些关键原则：

1.  **每个指针都对应一个类型**。
    这个类型表明该指针指向的是哪一类对象。例如：

    ```c
    int *ip;      // 一个指向 int 类型对象的指针
    char **cpp;   // 一个指向 (指向 char 类型对象的指针) 的指针
    ```

    指针类型是 C 语言提供的一种抽象，帮助程序员避免寻址错误，它本身不是机器代码的一部分。`void *` 类型代表通用指针。

2.  **每个指针都有一个值**。
    这个值是某个指定类型的对象的**地址**。特殊的 `NULL` (0) 值表示该指针没有指向任何地方。

3.  **指针用 `&` 运算符创建**。
    这个“取址”运算符可以应用到任何可以出现在赋值语句左边的表达式（`lvalue`）上。在机器代码层面，这常常通过 `leaq` 指令来实现。

4.  **`*` 操作符用于间接引用指针**。
    其结果是一个值，它的类型与该指针的类型一致。间接引用在机器代码中是用内存引用来实现的（例如，通过 `mov` 指令从指定地址读取或向其存储）。

5.  **数组与指针紧密联系**。

      * 数组的名字可以像一个指针变量一样被引用。
      * 数组引用 `a[3]` 与指针运算和间接引用 `*(a+3)` 的效果完全一样。
      * 指针运算 `p+i` 会被编译器自动伸缩。计算出的地址为 `p + L * i`，其中 `L` 是指针 `p` 所指向数据类型的大小。

6.  **将指针从一种类型强制转换成另一种类型，只改变它的类型，而不改变它的值（地址）**。
    强制类型转换的一个主要效果是改变指针运算的**伸缩**。例如，如果 `p` 是一个 `char *` 类型的指针：

      * `(int *)p + 7`: 先将 `p` 转换成 `int` 指针，然后指针加 7。实际地址计算为 `p + sizeof(int) * 7`，即 `p + 28`。
      * `(int *)(p + 7)`: 先执行 `char` 指针的运算，地址为 `p + 7`，然后再将结果转换为 `int` 指针。

7.  **指针也可以指向函数**。
    这提供了一个强大的功能，允许存储和传递对代码的引用。函数指针的值是该函数机器代码表示中第一条指令的地址。例如：

    ```c
    // 声明一个函数原型
    int fun(int x, int *p);

    // 声明一个函数指针 fp，并将其赋值为 fun
    int (*fp)(int, int*);
    fp = fun;

    // 通过函数指针调用函数
    int y = 1;
    int result = fp(3, &y);
    ```

-----

##### **如何解读函数指针声明**

函数指针的声明语法对新手来说可能难以理解。关键在于**从里往外读**。对于以下声明：

```c
int (*f)(int*);
```

1.  从变量名开始：`f`
2.  看到 `*f`：`f` 是一个**指针**。
3.  看到 `(*f)(int*)`：`f` 是一个指向**函数**的指针，这个函数接受一个 `int*` 作为参数。
4.  看到 `int (*f)(int*)`：这个函数返回一个 `int`。

`*f` 两边的括号是必需的。如果没有括号，声明会变成：

```c
int *f(int*);
```

这会被解释成一个**函数原型**，声明了一个名为 `f` 的函数，它接受一个 `int*` 参数，并返回一个 `int*` 类型（即指向 `int` 的指针）。


#### **3.10.2 应用：使用 GDB 调试器**
GNU 的调试器 GDB 提供了许多有用的特性，支持机器级程序的运行时评估和分析。通过 GDB，我们可以观察正在运行的程序，同时对程序的执行有相当的控制。

通常的方法是在程序中感兴趣的地方附近设置**断点 (breakpoint)**。当程序执行遇到断点时，会停下来并将控制权返回给用户。此时，我们能够以各种方式查看寄存器和内存位置，也可以单步跟踪程序。

##### **GDB 命令示例**
下表（对应原文图 3-39）给出了一些 GDB 命令的例子，这些命令有助于研究机器级 x86-64 程序。

**开始和停止**
* `quit`: 退出 GDB。
* `run`: 运行程序（可在此给出命令行参数）。
* `kill`: 停止正在运行的程序。

**断点 (Breakpoints)**
* `break multstore`: 在函数 `multstore` 的入口处设置断点。
* `break *0x400540`: 在内存地址 `0x400540` 处设置断点。
* `delete 1`: 删除 1 号断点。
* `delete`: 删除所有断点。

**执行**
* `stepi` (或 `si`): 执行 1 条机器指令。
* `stepi 4`: 执行 4 条机器指令。
* `nexti` (或 `ni`): 类似于 `stepi`，但会**越过 (step over)** 函数调用。
* `continue` (或 `c`): 继续执行，直到遇到下一个断点。
* `finish`: 运行直到当前函数返回。

**检查代码**
* `disas`: 反汇编当前函数。
* `disas multstore`: 反汇编函数 `multstore`。
* `disas 0x400540, 0x40054d`: 反汇编指定地址范围内的代码。
* `print /x $rip`: 以十六进制格式打印程序计数器 (`%rip`) 的值。

**检查数据**
* `print $rax`: 以十进制格式打印寄存器 `%rax` 的内容。
* `print /x $rax`: 以**十六进制**格式打印 `%rax` 的内容。
* `print /t $rax`: 以**二进制**格式打印 `%rax` 的内容。
* `print /x ($rsp + 8)`: 计算表达式 `%rsp + 8` 的值并以十六进制格式打印。
* `print *(long *)0x7fffffffe818`: 将内存地址 `0x7fffffffe818` 处的内容解释为一个 `long` 类型的指针并解引用，打印其值。
* `x/2g 0x7fffffffe818`: **检查 (examine)** 内存。从指定地址开始，显示 **2** 个 **g**iant words (8字节四字)。
* `x/20b multstore`: 检查函数 `multstore` 起始地址的前 **20** 个**b**ytes (字节)。

**有用的信息**
* `info frame`: 显示当前栈帧的详细信息。
* `info registers`: 显示所有寄存器的值。
* `help`: 获取 GDB 的帮助信息。

> GDB 的命令语法可能有些晦涩，但其内置的 `help` 命令非常有用。相对于命令行接口，许多程序员更愿意使用 `DDD` 等图形用户界面前端来操作 GDB。


#### **3.10.3 内存越界引用和缓冲区溢出**

C 语言对于数组引用不进行任何边界检查，同时，局部变量和函数调用的状态信息（如返回地址）都存放在栈中。这两种情况结合到一起，就能导致严重的安全漏洞。当对一个越界的数组元素进行写操作时，就可能会破坏存储在栈中的状态信息。当函数返回，试图使用这个被破坏的状态时，就会出现严重的错误。

一种特别常见的状态破坏称为**缓冲区溢出 (buffer overflow)**。通常，这种情况发生在程序读取一个字符串到栈上分配的某个字符数组（缓冲区）中，但输入的字符串长度超出了为数组分配的空间。

##### **`gets()` 示例**

库函数 `gets()` 是一个典型的例子，它存在严重的安全问题。

```c
/* gets() 函数的原理实现 */
char *gets(char *s) {
    int c;
    char *dest = s;
    while ((c = getchar()) != '\n' && c != EOF)
        *dest++ = c;
    if (c == EOF && dest == s)
        return NULL;
    *dest++ = '\0'; /* Terminate string */
    return s;
}

/* 一个使用 gets 的 echo 函数 */
void echo() {
    char buf[8]; /* 缓冲区设置得非常小! */
    gets(buf);
    puts(buf);
}
```

`gets()` 的问题在于它**没有办法**确定目标缓冲区 `s` 是否有足够的空间来保存读入的字符串。在 `echo` 示例中，我们故意将缓冲区 `buf` 设置得非常小，只有 8 个字节。任何长度超过 7 个字符的输入字符串都会导致写越界。

##### **`echo` 函数的栈组织**

`echo` 函数对应的汇编代码会为栈帧分配 24 个字节。其栈帧布局如下（对应原文图 3-40）：

  * 字符数组 `buf` 位于栈帧的最低地址处。
  * 在 `buf` 和**返回地址**之间，有 16 字节的未使用的栈空间。

##### **破坏栈**

当用户向 `echo` 函数输入一个过长的字符串时，`gets` 函数会盲目地将所有字符写入 `buf`，并不断越界覆盖更高地址的内存。随着字符串变长，下面的信息会被依次破坏：

  * **输入 0-7 个字符**: 安全。字符串（包括结尾的 `\0`）可以被完整地放入 `buf` 分配的 8 字节空间里。
  * **输入 8-23 个字符**: 会覆盖 `buf` 和返回地址之间的 16 字节未使用空间。通常没有立即的严重后果。
  * **输入 24-31 个字符**: 会覆盖栈上存储的**返回地址**。这是**致命的**。当 `echo` 函数执行 `ret` 指令时，它会从这个被篡改的地址处开始执行代码，而不是返回到正常的调用点。
  * **输入 32+ 个字符**: 会进一步破坏调用者 (`caller`) 的栈帧中保存的状态。

如果只看 C 代码，根本不可能看出会有上述行为。只有通过研究机器代码级别的程序，才能理解像 `gets` 这样的函数进行内存越界写操作的严重影响。

##### **解决方案和警告**

  * **安全替代方案**: 应该使用 `fgets` 函数，它包含一个参数，可以限制读入的最大字节数，从而防止溢出。
  * **其他危险函数**: 许多常用的库函数，包括 `strcpy`、`strcat` 和 `sprintf`，都存在类似的风险，因为它们在执行时也不需要知道目标缓冲区的大小。使用这些函数都是不好的编程习惯，它们是造成缓冲区溢出漏洞的常见原因。


#### **3.10.4 对抗缓冲区溢出攻击**

缓冲区溢出攻击的普遍发生，促使现代编译器和操作系统实现了多种机制来避免或限制此类攻击。

##### **1. 栈随机化 (Stack Randomization)**

  * **问题**: 在过去，程序的栈地址在不同机器上是相当固定的。攻击者可以轻易地预测栈上缓冲区的地址，从而构造出通用的攻击代码。
  * **解决方案**: **栈随机化**的思想使得栈的位置在程序**每次运行时都有变化**。
  * **实现**: 程序开始时，在栈上分配一段 0 到 n 字节之间的随机大小的空间。这虽然会浪费少量空间，但会导致程序每次执行时后续的栈位置都发生了变化，使得攻击者难以预测注入代码的准确地址。
  * **ASLR**: 栈随机化是更广泛的一类技术——**地址空间布局随机化 (Address-Space Layout Randomization, ASLR)**——的一部分。采用 ASLR，每次运行时程序的不同部分（代码、库、栈、堆等）都会被加载到内存的不同区域。
  * **局限性**: 执着的攻击者仍然可以通过**蛮力**（重复尝试）来克服随机化。一种常见的配合技巧是使用“**空操作雪橇 (nop sled)**”，即在实际的攻击代码前插入很长一段的 `nop`（无操作）指令。这样，攻击者只需要猜中雪橇中的任何一个地址，程序就会“滑过”这个序列，最终执行攻击代码。

##### **2. 栈破坏检测 (Stack Corruption Detection)**

  * **问题**: C 语言本身不提供防止数组越界写的可靠方法。
  * **解决方案**: 在发生越界写之后、但在造成任何有害结果（例如，从一个被篡改的返回地址返回）**之前**，尝试检测到它。
  * **实现 (栈保护者/金丝雀)**:
      * 最近的 GCC 版本采用了一种**栈保护者 (stack protector)** 机制。其思想是在栈帧中任何局部缓冲区与栈状态（如返回地址）之间，存储一个特殊的**金丝雀 (canary)** 值。
      * 这个金丝雀值是在程序每次运行时**随机**产生的。
      * 在函数返回之前，程序会检查这个栈上的金丝雀值是否被改变过。如果它被改变了（说明发生了缓冲区溢出，覆盖了金丝雀），程序就会立即异常中止，而不是继续执行并跳转到可能被篡改的返回地址。

**栈帧布局 (对应原文图 3-42)**
![[Pasted image 20250925225433.png]]
**带有栈保护的 `echo` 函数汇编代码**:

```s
echo:
    subq    $24, %rsp
    movq    %fs:40, %rax      // 从一个特殊段中取出随机的金丝雀值
    movq    %rax, 8(%rsp)     // 将金丝雀值存放在栈上 (buf 和返回地址之间)
    xorl    %eax, %eax
    ...
    call    gets              // 脆弱的函数调用
    ...
    call    puts
    movq    8(%rsp), %rax     // 从栈中重新取出金丝雀值
    xorq    %fs:40, %rax      // 与原始的金丝雀值进行异或比较
    je      .L9               // 如果相等 (结果为0)，则正常跳转
    call    __stack_chk_fail  // 如果不相等，调用错误处理例程，程序中止
.L9:
    addq    $24, %rsp
    ret
```

##### **3. 限制可执行代码区域**

  * **问题**: 攻击的核心是向程序中注入一段可执行的恶意代码。
  * **解决方案**: 消除攻击者向系统中插入**可执行**代码的能力。
  * **实现 (NX 位)**:
      * 现代处理器支持**内存保护**，可以将内存页标记为可读、可写、可执行。
      * **W^X (Write XOR Execute)**: 一种安全策略，即一个内存页要么是可写的，要么是可执行的，但**不能同时**是两者。
      * 栈必须是可读写的，因此它可以被标记为**不可执行**。
      * 最近的 AMD 和 Intel 处理器都提供了硬件级别的“**NX (No-Execute)**”位支持。有了这个特性，操作系统可以高效地将栈和堆标记为不可执行，如果程序试图执行位于栈上的代码，硬件会直接引发一个异常。

这些技术（随机化、栈保护、限制可执行代码区域）是目前用于最小化缓冲区溢出攻击漏洞的三种最常见机制。它们单独使用时都能降低漏洞的等级，组合起来则更加有效。

#### **3.10.5 支持变长栈帧**

到目前为止，我们看到的函数示例都有一个共同点：编译器能够在编译时就预先确定需要为栈帧分配多少空间。但是，有些函数需要的局部存储空间是变长的，例如：

  * 调用 `alloca()` 函数在栈上分配任意字节。
  * C99 标准引入的**变长数组 (Variable-Length Array, VLA)**。

##### **`vframe` 函数示例**

以下 C 代码声明了一个 `n` 个指针的局部变长数组 `p`，其中 `n` 是由函数参数在运行时决定的。

**图 3-43 a) C 代码**

```c
long vframe(long n, long idx, long *q)
{
    long i;
    long *p[n]; // n is determined at runtime
    p[0] = &i;
    for (i = 1; i < n; i++)
        p[i] = q;
    return *p[idx];
}
```

由于编译器无法在编译时确定 `n` 的值，也就无法确定要给该函数的栈帧分配多少空间。

##### **帧指针 (`%rbp`)**

为了管理变长栈帧，x86-64 代码使用寄存器 **`%rbp`** 作为**帧指针 (frame pointer)**，有时也称为**基指针 (base pointer)**。

  * **工作机制**:
    1.  在函数的开头，先将调用者（旧的）的 `%rbp` 值压入栈中保存。
    2.  然后将当前的栈指针 `%rsp` 的值复制到 `%rbp`。
    3.  在函数的整个执行过程中，`%rbp` 的值**保持不变**，作为一个稳定的“**锚点**”，指向当前栈帧的起始位置。
    4.  之后，`%rsp` 可以自由地向下移动，以分配变长数组等所需的空间。
    5.  函数可以通过一个**固定的、相对于 `%rbp` 的偏移量**来访问定长的局部变量（例如 `i`）。

**`vframe` 的栈帧结构 (对应原文图 3-44)**

##### **`vframe` 的汇编代码**

图 3-43b 是 GCC 为 `vframe` 生成的部分汇编代码，展示了帧指针的用法。

**图 3-43 b) 生成的部分汇编代码**

```s
// n in %rdi, idx in %rsi, q in %rdx
vframe:
    pushq   %rbp              // 保存旧的 %rbp
    movq    %rsp, %rbp        // 将 %rbp 设置为当前栈帧的基地址
    subq    $16, %rsp         // 为局部变量 i 和对齐填充分配 16 字节
    
    // ... 为变长数组 p 分配空间的复杂计算 ...
    leaq    22(,%rdi,8), %rax
    andq    $-16, %rax
    subq    %rax, %rsp
    
    // ... 初始化循环 ...
    movq    %rax, -8(%rbp)    // 访问相对于 %rbp 的局部变量
    
    // ... 函数结尾 ...
    leave                     // 恢复 %rbp 和 %rsp
    ret
```

  * **函数头部 (Prologue)**: 第 2-3 行的 `pushq %rbp` 和 `movq %rsp, %rbp` 是建立新栈帧的标准操作。
  * **局部变量访问**: 在代码中，对局部变量 `i` 的访问将通过固定的偏移量（如 `-8(%rbp)`）来引用。
  * **函数尾部 (Epilogue)**: `leave` 指令用于释放整个栈帧。它等价于执行下面两条指令：
    ```s
    movq %rbp, %rsp   // 1. 将栈指针恢复到帧指针的位置
    popq %rbp         // 2. 从栈中弹出旧值，恢复调用者的帧指针
    ```

> **历史注记**: 在早期的 x86 代码中，几乎每个函数调用都使用帧指针。而现在，现代的 GCC 编译器只有在栈帧长可变的情况下才使用帧指针，在其他情况下则将 `%rbp` 作为一个通用的被调用者保存寄存器，以提高效率。