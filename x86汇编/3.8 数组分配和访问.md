### **3.8 数组分配和访问**

C 语言中的数组是一种将标量数据聚合成更大数据类型的方式。C 语言实现数组的方式非常简单，因此很容易翻译成机器代码。C 语言的一个特点是可以产生指向数组中元素的指针，并对这些指针进行运算，在机器代码中，这些指针会被翻译成地址计算。

-----

#### **3.8.1 基本原则**

对于数据类型 `T` 和整型常数 `N`，声明如下：

```c
T A[N];
```

这个声明有两个效果：

1.  它在内存中分配一个 `L * N` 字节的**连续区域**，这里 `L` 是数据类型 `T` 的大小（单位为字节）。
2.  它引入了标识符 `A`，可以用 `A` 来作为指向数组开头的指针，这个指针的值就是数组的起始地址，我们称之为 `x_A`。

数组元素 `i` 会被存放在地址为 **`x_A + L * i`** 的地方。

##### **示例**

以下 C 语言声明会产生如下参数的数组：

```c
char    A[12];
char* B[8];
int     C[6];
double* D[5];
```

| 数组 | 元素大小 (L) | 总的大小 (L\*N) | 起始地址 | 元素 `i` 的地址 |
| :--- | :--- | :--- | :--- | :--- |
| `A` | 1 | 12 | `x_A` | `x_A + i` |
| `B` | 8 | 64 | `x_B` | `x_B + 8i` |
| `C` | 4 | 24 | `x_C` | `x_C + 4i` |
| `D` | 8 | 40 | `x_D` | `x_D + 8i` |

> *注：原文此处有一处描述错误，称 `int` 类型需要 8 字节，但根据 C 标准和 x86-64 约定，`int` 是 4 字节，`long` 才是 8 字节。上表已按正确的 4 字节 `int` 进行展示。*

##### **汇编代码中的数组访问**

x86-64 的内存引用指令（特别是带有**比例因子**的寻址模式）可以用来简化数组访问。

例如，假设 `E` 是一个 `int` 型的数组，我们想计算 `E[i]`。此时，`E` 的起始地址存放在寄存器 `%rdx` 中，而索引 `i` 存放在寄存器 `%rcx` 中。那么，一条指令就可以完成访问：

```s
movl (%rdx, %rcx, 4), %eax
```

  * **`%rdx`**: 基地址 `x_E`
  * **`%rcx`**: 索引 `i`
  * **`4`**: 比例因子 `L` (因为 `int` 类型大小为 4 字节)

硬件会直接计算出有效地址 `x_E + i * 4`，读取该内存位置的值，并将结果存放到寄存器 `%eax` 中。x86-64 允许的伸缩因子 1, 2, 4, 8 恰好覆盖了所有 C 语言基本数据类型的大小。

#### **3.8.2 指针运算**

C 语言允许对指针进行运算。当对一个指针进行算术操作时，计算出来的值会根据该指针引用的数据类型的大小进行**伸缩 (scaling)**。
* **规则**: 如果 `p` 是一个指向类型为 `T` 的数据的指针，`p` 的值为 `x_p`，那么表达式 **`p+i`** 的值为 **`x_p + L * i`**，这里 `L` 是数据类型 `T` 的大小（单位为字节）。

`&` (取址) 和 `*` (间接引用) 操作符可以产生指针和解引用指针。数组引用 **`A[i]`** 等同于表达式 **`*(A + i)`**。

##### **指针运算示例**
扩展前面的例子，假设整型数组 `E` 的起始地址和整数索引 `i` 分别存放在寄存器 `%rdx` 和 `%rcx` 中。下表展示了一些与 `E` 有关的表达式及其汇编代码实现。

| C 表达式 | 类型 | 值 (地址计算) | 汇编代码 |
| :--- | :--- | :--- | :--- |
| `E` | `int *` | `x_E` | `movq %rdx, %rax` |
| `E[0]` | `int` | `M[x_E]` | `movl (%rdx), %eax` |
| `E[i]` | `int` | `M[x_E + 4*i]` | `movl (%rdx, %rcx, 4), %eax` |
| `&E[2]` | `int *` | `x_E + 8` | `leaq 8(%rdx), %rax` |
| `E + i - 1`| `int *` | `x_E + 4*i - 4`| `leaq -4(%rdx, %rcx, 4), %rax`|
| `*(E + i - 3)`| `int` | `M[x_E + 4*i - 12]`| `movl -12(%rdx, %rcx, 4), %eax`|
| `&E[i] - E`| `long` | `i` | `movq %rcx, %rax` |

**解读**:
* 那些返回**指针**（类型为 `int *`）的操作，涉及 8 字节的四字操作，因此使用 `leaq` 或 `movq` 指令，并将结果存入 64 位寄存器（如 `%rax`）。
* 那些返回**值**（类型为 `int`）的操作，涉及 4 字节的双字操作，因此使用 `movl` 指令，并将结果存入 32 位寄存器（如 `%eax`）。
* 最后一个例子表明，计算同一个数组中的两个指针之差，结果是它们之间的**元素数量**（一个 `long` 类型的值），而不是字节差距。在汇编层面，这可以直接通过获取索引 `i` 来实现。


#### **3.8.3 嵌套的数组**

当我们创建数组的数组时，数组分配和引用的一般原则也是成立的。例如，声明：

```c
int A[5][3];
```

这在概念上等价于：

```c
typedef int row3_t[3];
row3_t A[5];
```

这里，`A` 被看作一个包含 5 个元素的数组，其中每个元素本身又是一个包含 3 个整数的数组。

##### **内存布局 (行优先顺序)**

多维数组的元素在内存中按照“**行优先 (row-major)**”的顺序排列。这意味着，第 0 行的所有元素会完整地存放在一起，后面跟着第 1 行的所有元素，以此类推。

对于 `int A[5][3]`（假设 `int` 为 4 字节），其内存布局如下 (对应原文图 3-36)：

| 元素 | 地址 |
| :--- | :--- |
| `A[0][0]` | `x_A` |
| `A[0][1]` | `x_A + 4` |
| `A[0][2]` | `x_A + 8` |
| `A[1][0]` | `x_A + 12`|
| `A[1][1]` | `x_A + 16`|
| `A[1][2]` | `x_A + 20`|
| ... | ... |
| `A[4][2]` | `x_A + 56`|

##### **地址计算**

通常来说，对于一个声明为 `T D[R][C]` 的数组，其数组元素 `D[i][j]` 的内存地址为：

```
&D[i][j] = x_D + L * (C * i + j)
```

其中：

  * `x_D` 是数组的起始地址。
  * `L` 是数据类型 `T` 的大小（字节）。
  * `R` 是行数，`C` 是列数。
  * `i` 是行索引，`j` 是列索引。

##### **汇编代码示例**

假设 `int A[5][3]` 的起始地址 `x_A` 在 `%rdi` 中，行索引 `i` 在 `%rsi` 中，列索引 `j` 在 `%rdx` 中。要将数组元素 `A[i][j]` 复制到寄存器 `%eax` 中，汇编代码如下：

```s
// A in %rdi, i in %rsi, j in %rdx
    leaq    (%rsi, %rsi, 2), %rax  // %rax = i + 2*i = 3*i
    leaq    (%rdi, %rax, 4), %rax  // %rax = x_A + (3*i) * 4 = x_A + 12*i
    movl    (%rax, %rdx, 4), %eax  // %eax = M[ %rax + j * 4 ] 
                                   //      = M[ (x_A + 12*i) + 4*j ]
```

这段代码巧妙地使用了 `leaq` 指令和 x86-64 的伸缩变址寻址模式，分步计算出了 `A[i][j]` 的最终地址 `x_A + 12*i + 4*j`，并从该地址读取了数据。


#### **3.8.4 定长数组**

C 语言编译器能够对操作**定长**多维数组的代码进行高度优化。下面我们来看一个例子。

假设我们定义一个 16x16 的整型数组类型：

```c
#define N 16
typedef int fix_matrix[N][N];
```

> **编码好习惯**: 当程序要用一个常数作为数组维度时，最好通过 `#define` 声明将这个常数与一个名字联系起来。这样，如果需要修改这个值，只需简单地修改 `#define` 声明即可。

-----

##### **矩阵乘法元素计算的优化**

下面的代码计算矩阵 A 和 B 乘积的 `(i, k)` 元素，即 A 的第 `i` 行和 B 的第 `k` 列的内积。

**图 3-37：原始和优化过的代码**

**a) 原始的 C 代码**
这是一个标准的、使用数组索引的 `for` 循环。

```c
/* Compute i,k of fixed matrix product */
int fix_prod_ele(fix_matrix A, fix_matrix B, long i, long k) {
    long j;
    int result = 0;

    for (j = 0; j < N; j++)
        result += A[i][j] * B[j][k];
    
    return result;
}
```

**b) 优化过的 C 代码 (模拟编译器行为)**
编译器会自动执行一系列优化，其逻辑等价于下面的 C 代码。

```c
/* Compute i,k of fixed matrix product - Optimized version */
int fix_prod_ele_opt(fix_matrix A, fix_matrix B, long i, long k) {
    // 指向 A 的第 i 行的第一个元素
    int *Aptr = &A[i][0];
    // 指向 B 的第 k 列的第一个元素
    int *Bptr = &B[0][k];
    // 指向 B 的第 k 列的最后一个元素之后的位置，用作循环终止条件
    int *Bend = &B[N][k];
    int result = 0;

    do {
        result += *Aptr * *Bptr; // 将下一个乘积加到 sum
        Aptr++;                 // Aptr 移动到行中的下一个元素
        Bptr += N;              // Bptr 移动到下一行的同一列元素
    } while (Bptr != Bend);

    return result;
}
```

**关键优化点**:

  * 编译器消除了整数索引变量 `j`。
  * 所有的数组引用都被转换成了**指针间接引用**。
  * `Aptr++` 移动 4 个字节，在行中横向移动。
  * `Bptr += N` 移动 `16 * 4 = 64` 个字节，在列中纵向移动（相当于跳到下一行的同一列）。
  * 通过一个结束指针 `Bend` 来控制循环，而不是每次都进行索引比较。

**c) 生成的汇编代码**
下面是 GCC 为原始函数 `fix_prod_ele` 生成的实际汇编代码，其逻辑与优化后的 C 代码版本完全对应。

```s
// A in %rdi, B in %rsi, i in %rdx, k in %rcx
fix_prod_ele:
    salq    $6, %rdx                  // %rdx = i * 64 (计算 A 第 i 行的字节偏移量)
    addq    %rdx, %rdi                // %rdi = &A[i][0] (Aptr)
    leaq    (%rsi, %rcx, 4), %rcx     // %rcx = &B[0][k] (Bptr)
    leaq    1024(%rcx), %rsi          // %rsi = &B[0][k] + 1024 = &B[16][k] (Bend)
    movl    $0, %eax                  // result = 0 (%eax)
.L7:                                  // loop:
    movl    (%rdi), %edx              // %edx = *Aptr
    imull   (%rcx), %edx              // %edx *= *Bptr
    addl    %edx, %eax                // result += ...
    addq    $4, %rdi                  // Aptr++
    addq    $64, %rcx                 // Bptr += 16
    cmpq    %rsi, %rcx                // Compare Bptr : Bend
    jne     .L7                       // If !=, goto loop
    rep; ret
```

**寄存器映射**:

  * **`%eax`**: `result`
  * **`%rdi`**: `Aptr`
  * **`%rcx`**: `Bptr`
  * **`%rsi`**: `Bend`

#### **3.8.5 变长数组**

历史上，C 语言只支持大小在编译时就能确定的多维数组。ISO C99 引入了**变长数组 (Variable-Length Array, VLA)** 的功能，允许数组的维度是表达式，在数组被分配的时候才计算出来。

例如，我们可以写一个如下的函数，其中 `n` 是在运行时才确定的维度：

```c
int var_ele(long n, int A[n][n], long i, long j) {
    return A[i][j];
}
```

> **注意**: 维度参数 `n` 必须在数组参数 `A[n][n]` 之前声明。

##### **VLA 的地址计算**

GCC 为 `var_ele` 函数产生的代码如下所示：

```s
// n in %rdi, A in %rsi, i in %rdx, j in %rcx
var_ele:
    imulq   %rdx, %rdi          // 计算 n * i
    leaq    (%rsi, %rdi, 4), %rax // 计算 x_A + 4 * (n * i) (第i行的起始地址)
    movl    (%rax, %rcx, 4), %eax // 读取 M[ (x_A + 4*n*i) + 4*j ]
    ret
```

这段代码计算元素 `A[i][j]` 的地址为 `x_A + 4 * (n * i + j)`。

这与定长数组的地址计算类似，但有一个关键区别：由于 `n` 是一个变量，编译器**必须使用乘法指令 (`imulq`)** 来计算 `n * i`。而对于定长数组，编译器可以用一系列更快的移位和加法指令来代替乘法。在一些处理器中，乘法会招致严重的性能处罚。

-----

##### **循环中的 VLA 优化**

当在循环中引用变长数组时，编译器常常可以利用访问模式的规律性来优化索引的计算，避免在循环中重复执行昂贵的乘法。

**图 3-38：计算变长数组的矩阵乘积元素**

**a) 原始的 C 代码**

```c
/* Compute i,k of variable matrix product */
int var_prod_ele(long n, int A[n][n], int B[n][n], long i, long k) {
    long j;
    int result = 0;
    for (j = 0; j < n; j++)
        result += A[i][j] * B[j][k];
    return result;
}
```

**b) 优化后的 C 代码 (模拟编译器行为)**
编译器可以识别出访问 `A` 的第 `i` 行是连续的，而访问 `B` 的第 `k` 列是以 `n` 个元素的固定步长进行的。其优化逻辑等价于下面的 C 代码：

```c
/* Optimized version */
int var_prod_ele_opt(long n, int A[n][n], int B[n][n], long i, long k) {
    int *Arow = A[i];             // 获取 A 第 i 行的起始指针
    int *Bptr = &B[0][k];         // 获取 B 第 k 列的起始指针
    int result = 0;
    long j;
    for (j = 0; j < n; j++) {
        result += Arow[j] * *Bptr;
        Bptr += n;                // Bptr 指针移动 n 个元素，即跳到下一行的同一列
    }
    return result;
}
```

**`var_prod_ele` 的循环部分的汇编代码**:

```s
// Registers: n in %rdi, Arow in %rsi, Bptr in %rcx
//            4*n in %r9, result in %eax, j in %edx
.L24:                             // loop:
    movl    (%rsi, %rdx, 4), %r8d //   读取 Arow[j]
    imull   (%rcx), %r8d          //   乘以 *Bptr
    addl    %r8d, %eax            //   加到 result
    addq    $1, %rdx              //   j++
    addq    %r9, %rcx             //   Bptr += n (in bytes)
    cmpq    %rdi, %rdx            //   比较 j:n
    jne     .L24                  //   If !=, goto loop
```

可以看到，如果允许使用优化，GCC 能够识别出程序访问多维数组元素的**步长 (stride)**。它会在循环开始前计算出这个步长（例如 `4*n`），然后在循环内部使用开销较小的**加法**来更新指针，从而避免了在循环中重复执行乘法。这些优化都能显著提高程序的性能。

