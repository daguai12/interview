好的，这是根据您提供的文本内容，保留原始结构和标题整理的结果。

### **3.4 访问信息**
一个 x86-64 的中央处理单元 (CPU) 包含一组 16 个存储 64 位值的**通用目的寄存器**。这些寄存器用来存储整数数据和指针。

#### **整数寄存器**
图 3-2 展示了这 16 个寄存器。它们的名字都以 `%r` 开头。指令可以对这些寄存器的低位部分进行不同大小的操作（字节、字、双字、四字）。

| 64位(四字)    | 32位(双字) | 16位(字)  | 8位(字节)  | 主要用途/角色 |
| :--------- | :------ | :------ | :------ | :------ |
| **`%rax`** | `%eax`  | `%ax`   | `%al`   | 返回值     |
| **`%rbx`** | `%ebx`  | `%bx`   | `%bl`   | 被调用者保存  |
| **`%rcx`** | `%ecx`  | `%cx`   | `%cl`   | 第 4 个参数 |
| **`%rdx`** | `%edx`  | `%dx`   | `%dl`   | 第 3 个参数 |
| **`%rsi`** | `%esi`  | `%si`   | `%sil`  | 第 2 个参数 |
| **`%rdi`** | `%edi`  | `%di`   | `%dil`  | 第 1 个参数 |
| **`%rsp`** | `%esp`  | `%sp`   | `%spl`  | **栈指针** |
| **`%rbp`** | `%ebp`  | `%bp`   | `%bpl`  | 被调用者保存  |
| **`%r8`**  | `%r8d`  | `%r8w`  | `%r8b`  | 第 5 个参数 |
| **`%r9`**  | `%r9d`  | `%r9w`  | `%r9b`  | 第 6 个参数 |
| **`%r10`** | `%r10d` | `%r10w` | `%r10b` | 调用者保存   |
| **`%r11`** | `%r11d` | `%r11w` | `%r11b` | 调用者保存   |
| **`%r12`** | `%r12d` | `%r12w` | `%r12b` | 被调用者保存  |
| **`%r13`** | `%r13d` | `%r13w` | `%r13b` | 被调用者保存  |
| **`%r14`** | `%r14d` | `%r14w` | `%r14b` | 被调用者保存  |
| **`%r15`** | `%r15d` | `%r15w` | `%r15b` | 被调用者保存  |

**重要规则**:
当指令生成一个小于 8 字节的结果并写入寄存器时：
* 生成 **1 字节**和 **2 字节**数字的指令会保持寄存器中**剩下的字节不变**。
* 生成 **4 字节**数字的指令会把该寄存器的**高位 4 个字节置为 0**。

---
#### **3.4.1 操作数指示符**
大多数指令有一个或多个**操作数 (operand)**，用于指示执行操作要使用的源数据值，以及放置结果的目标位置。操作数分为三种类型：

1.  **立即数 (Immediate)**:
    * 表示常数值。
    * 在 ATT 格式的汇编代码中，书写方式是 `$` 后面跟一个 C 表示法的整数，例如 `$-577` 或 `$0x1F`。

2.  **寄存器 (Register)**:
    * 表示某个寄存器的内容。
    * 例如 `%rax` 表示寄存器 `rax` 的内容。

3.  **内存引用 (Memory Reference)**:
    * 根据计算出的**有效地址 (effective address)** 访问某个内存位置。
    * 它有多种**寻址模式**，允许不同形式的内存引用。

##### **内存寻址模式**
最常用的形式是 `Imm(rb, ri, s)`。一个内存引用由四个部分组成：一个立即数偏移 `Imm`，一个基址寄存器 `rb`，一个变址寄存器 `ri`，和一个比例因子 `s` (s 必须是 1, 2, 4, 或 8)。

有效地址被计算为： `Imm + R[rb] + R[ri] * s`

下表总结了各种寻址模式。

**图 3-3：操作数格式**

| 类型  | 格式                 | 操作数值                         | 名称         |
| :-- | :----------------- | :--------------------------- | :--------- |
| 立即数 | `$Imm`             | `Imm`                        | 立即数寻址      |
| 寄存器 | `%ra`              | `R[ra]`                      | 寄存器寻址      |
| 存储器 | `Imm`              | `M[Imm]`                     | 绝对寻址       |
| 存储器 | `(%ra)`            | `M[R[ra]]`                   | 间接寻址       |
| 存储器 | `Imm(%rb)`         | `M[Imm + R[rb]]`             | (基址+偏移量)寻址 |
| 存储器 | `(%rb, %ri)`       | `M[R[rb] + R[ri]]`           | 变址寻址       |
| 存储器 | `Imm(%rb, %ri)`    | `M[Imm + R[rb] + R[ri]]`     | 变址寻址       |
| 存储器 | `(, %ri, s)`       | `M[R[ri] * s]`               | 比例变址寻址     |
| 存储器 | `Imm(, %ri, s)`    | `M[Imm + R[ri] * s]`         | 比例变址寻址     |
| 存储器 | `(%rb, %ri, s)`    | `M[R[rb] + R[ri] * s]`       | 比例变址寻址     |
| 存储器 | `Imm(%rb, %ri, s)` | `M[Imm + R[rb] + R[ri] * s]` | 比例变址寻址     |
[[示例解读]]

#### **3.4.2 数据传送指令**

最频繁使用的指令是**数据传送指令**。由于操作数的通用性，一条简单的 `MOV` 指令就能完成许多机器需要多条不同指令才能完成的功能。

##### **MOV 类指令**

`MOV` 类指令把数据从源位置复制到目的位置，不做任何变化。它由四条指令组成：`movb` (1字节), `movw` (2字节), `movl` (4字节), `movq` (8字节)。

**图 3-4：简单的数据传送指令**

| 指令 | 效果 | 描述 |
| :--- | :--- | :--- |
| `movb` S, D | `D <- S` | 传送字节 |
| `movw` S, D | `D <- S` | 传送字 (2字节) |
| `movl` S, D | `D <- S` | 传送双字 (4字节) |
| `movq` S, D | `D <- S` | 传送四字 (8字节) |
| `movabsq` I, R | `R <- I` | 传送绝对的四字 (64位立即数) |

  * **操作数**: 源操作数可以是立即数、寄存器或内存地址。目的操作数可以是寄存器或内存地址。
  * **限制**: x86-64 的一条重要限制是，传送指令的**两个操作数不能都指向内存位置**。将一个值从内存复制到另一个内存位置需要两条指令（先加载到寄存器，再从寄存器存储到内存）。
  * **`movl` 的特殊规则**: 当 `movl` 指令以寄存器作为目的时，它会把该寄存器的**高位 4 字节设置为 0**。这是 x86-64 的一个惯例。
  * **`movabsq`**: 常规的 `movq` 指令只能接收 32 位的立即数（然后符号扩展到64位）。`movabsq` 指令则可以接收任意 64 位立即数值作为源操作数，但其目的操作数必须是寄存器。

**示例**:

```s
movl $0x4050, %eax     # 立即数 -> 寄存器
movw %bp, %sp         # 寄存器 -> 寄存器
movb (%rdi,%rcx), %al # 内存   -> 寄存器
movb $-17, (%rsp)      # 立即数 -> 内存
movq %rax, -12(%rbp)  # 寄存器 -> 内存
```

-----

##### **MOVZ 类指令 (零扩展)**

`MOVZ` 类指令用于将一个较小的源值复制到一个较大的目的寄存器，并将目的寄存器中剩余的高位字节**用 0 填充**（零扩展）。指令名字的最后两个字符分别代表源和目的的大小。

**图 3-5：零扩展数据传送指令**

| 指令            | 效果                   | 描述           |
| :------------ | :------------------- | :----------- |
| `movzbw` S, R | `R <- ZeroExtend(S)` | 将零扩展的字节传送到字  |
| `movzbl` S, R | `R <- ZeroExtend(S)` | 将零扩展的字节传送到双字 |
| `movzwl` S, R | `R <- ZeroExtend(S)` | 将零扩展的字传送到双字  |
| `movzbq` S, R | `R <- ZeroExtend(S)` | 将零扩展的字节传送到四字 |
| `movzwq` S, R | `R <- ZeroExtend(S)` | 将零扩展的字传送到四字  |

> **注意**: 没有 `movzlq` 指令。这是因为 `movl` 指令在以寄存器为目的时，会自动将目的寄存器的高 4 字节清零，已经达到了零扩展的效果。

[[示例解读]]

-----

##### **MOVS 类指令 (符号扩展)**

`MOVS` 类指令也用于将一个较小的源值复制到一个较大的目的寄存器，但它是通过**符号扩展**来填充高位字节，即用源操作数的最高位（符号位）进行复制填充。

**图 3-6：符号扩展数据传送指令**

| 指令            | 效果                         | 描述                    |
| :------------ | :------------------------- | :-------------------- |
| `movsbw` S, R | `R <- SignExtend(S)`       | 将符号扩展的字节传送到字          |
| `movsbl` S, R | `R <- SignExtend(S)`       | 将符号扩展的字节传送到双字         |
| `movswl` S, R | `R <- SignExtend(S)`       | 将符号扩展的字传送到双字          |
| `movsbq` S, R | `R <- SignExtend(S)`       | 将符号扩展的字节传送到四字         |
| `movswq` S, R | `R <- SignExtend(S)`       | 将符号扩展的字传送到四字          |
| `movslq` S, R | `R <- SignExtend(S)`       | 将符号扩展的双字传送到四字         |
| `cltq`        | `%rax <- SignExtend(%eax)` | 把 `%eax` 符号扩展到 `%rax` |

  * **`cltq`**: 这条指令没有操作数，它专门用于将 `%eax` (32位) 的值符号扩展到 `%rax` (64位)，其效果与 `movslq %eax, %rax` 完全一致，但编码更紧凑。

[[示例解读]]

-----

#### **示例：理解数据传送如何改变目的寄存器**

下面这段代码序列很好地说明了不同指令对目的寄存器高位字节的影响：

```s
movabsq $0x0011223344556677, %rax  # %rax = 0011223344556677
movb    $-1, %al                    # %rax = 00112233445566FF  (只修改低1字节)
movw    $-1, %ax                    # %rax = 001122334455FFFF  (只修改低2字节)
movl    $-1, %eax                   # %rax = 00000000FFFFFFFF  (修改低4字节，高4字节清零！)
movq    $-1, %rax                   # %rax = FFFFFFFFFFFFFFFF  (修改整个8字节)
```


#### **3.4.3 数据传送示例**

作为一个使用数据传送指令的代码示例，我们来看一下下面的数据交换函数 `exchange`。

**图 3-7：`exchange` 函数的 C 语言和汇编代码**

a) C 语言代码

```c
long exchange(long *xp, long y)
{
    long x = *xp;
    *xp = y;
    return x;
}
```

b) 汇编代码 (带注释)

```s
// xp in %rdi, y in %rsi
exchange:
    movq    (%rdi), %rax    // Get x at xp. Set as return value.
    movq    %rsi, (%rdi)    // Store y at xp.
    ret                     // Return.
```

当 `exchange` 函数开始执行时，参数指针 `xp` 和参数 `y` 分别存储在寄存器 `%rdi` 和 `%rsi` 中。

  * **第 2 行 (`movq (%rdi), %rax`)**: 从内存中读出 `x`。`(%rdi)` 表示“使用寄存器 `%rdi` 中的地址作为内存地址”，这实现了 C 程序中的指针解引用操作 `*xp`。读出的值被存放到寄存器 `%rax` 中，该寄存器按照惯例用于存放函数返回值。
  * **第 3 行 (`movq %rsi, (%rdi)`)**: 将 `y` 的值（存放在 `%rsi` 中）写入到由 `xp` 指向的内存位置，这实现了 C 程序中的操作 `*xp = y`。

关于这段汇编代码有两点值得注意：

1.  C 语言中所谓的”**指针**“其实就是**地址**。间接引用指针就是将该指针（地址）放在一个寄存器中，然后在内存引用中使用这个寄存器。
2.  像 `x` 这样的**局部变量**通常是保存在**寄存器**中（本例中是 `%rax`），而不是内存中。访问寄存器比访问内存要快得多。

-----

##### **C 语言指针回顾**

函数 `exchange` 是一个关于 C 语言中指针使用的很好说明。

  * **`long x = *xp;`**: 这一句是**指针的间接引用 (pointer dereferencing)**。它表示我们将读取存储在 `xp` 所指向内存位置中的值，并将它存放到局部变量 `x` 中。
  * **`*xp = y;`**: 这一句也是指针的间接引用，但它表示一个**写操作**，因为它在赋值语句的左边。它将参数 `y` 的值写入到 `xp` 所指向的内存位置。

下面是调用 `exchange` 的一个实际例子：

```c
long a = 4;
long b = exchange(&a, 3);
printf("a = %ld, b = %ld\n", a, b);
```

这段代码会打印出：

```
a = 3, b = 4
```

  * **`&a`**: C 操作符 `&`（称为“取址”操作符）创建了一个指向变量 `a` 所在位置的指针。
  * **`exchange(&a, 3)`**: 我们将 `a` 的地址和值 `3` 传递给 `exchange` 函数。函数内部将 `a` 的原始值 `4` 读取出来作为返回值，然后用 `3` 覆盖了存储在 `a` 中的值。
  * **结果**: 调用返回后，`a` 的值变成了 `3`，而函数返回的原始值 `4` 被赋给了 `b`。这清晰地展示了如何通过传递指针，让一个函数能够修改存在于其调用者作用域中的数据。

#### **3.4.4 压入和弹出栈数据**

`push` 和 `pop` 是两个重要的数据传送操作，用于在**程序栈 (program stack)** 中存入和取出数据。栈在处理过程（函数）调用中起到至关重要的作用。

##### **栈的基本概念**

  * **结构**: 栈是一种“**后进先出 (Last-In, First-Out, LIFO)**”的数据结构。
  * **操作**:
      * `push` (压栈/入栈): 向栈中添加数据。
      * `pop` (弹栈/出栈): 从栈中移除数据，弹出的值永远是最近被压入且仍然在栈中的值。
  * **x86-64 中的实现**:
      * 程序栈存放在内存中的某个区域。
      * 栈向**低地址方向**增长（向下增长）。
      * **栈顶 (stack top)** 元素的地址是所有栈中元素地址中**最低**的。
      * **栈指针寄存器 `%rsp`** 保存着栈顶元素的地址。

##### **入栈和出栈指令**

`pushq` 指令的功能是把数据压入到栈上，而 `popq` 指令是弹出数据。

**图 3-8：入栈和出栈指令**

| 指令        | 效果                             | 描述            |
| :-------- | :----------------------------- | :------------ |
| `pushq` S | `R[%rsp] -= 8; M[R[%rsp]] = S` | 将四字 (8字节) 压入栈 |
| `popq` D  | `D = M[R[%rsp]]; R[%rsp] += 8` | 将四字 (8字节) 弹出栈 |

**`pushq` 操作详解**
将一个四字（8字节）值压入栈中，包含两个步骤：

1.  首先要将栈指针 `%rsp` **减 8**。
2.  然后将值写入到新的栈顶地址。

因此，指令 `pushq %rbp` 的行为等价于下面两条指令：

```s
subq $8, %rsp      # Decrement stack pointer
movq %rbp, (%rsp)  # Store %rbp on stack
```

**`popq` 操作详解**
弹出一个四字的操作与入栈相反，也包含两个步骤：

1.  从栈顶位置（`%rsp` 指向的地址）读出数据。
2.  然后将栈指针 `%rsp` **加 8**。

因此，指令 `popq %rax` 等价于下面两条指令：

```s
movq (%rsp), %rax   # Read %rax from stack
addq $8, %rsp     # Increment stack pointer
```

-----

#### **栈操作图解**

下图（对应原文图 3-9）说明了栈操作的全过程。
![[Pasted image 20250925222013.png]]

1.  **初始状态**:

      * 假设 `%rax` 寄存器的值是 `0x123`，栈指针 `%rsp` 的值是 `0x108`。此时栈顶位于地址 `0x108`。

2.  **执行 `pushq %rax` 后**:

      * 栈指针 `%rsp` **减 8**，变为 `0x100`。
      * `%rax` 的值 `0x123` 被存放到内存地址 `0x100` 处。此时新的栈顶位于地址 `0x100`。

3.  **执行 `popq %rdx` 后**:

      * 从当前栈顶（地址 `0x100`）读出值 `0x123`，并写入到 `%rdx` 寄存器中。
      * 栈指针 `%rsp` **加 8**，恢复为 `0x108`。

> **注意**: 在 `pop` 操作之后，值 `0x123` 仍然会保留在内存位置 `0x100` 中，直到它被后续的操作（例如另一次 `push`）所覆盖。但由于 `%rsp` 已经指向了 `0x108`，所以地址 `0x100` 已不属于当前栈的有效范围。

因为栈本身就是内存的一部分，所以程序也可以用标准的内存寻址方法访问栈内的任意位置。例如，`movq 8(%rsp), %rdx` 会将栈顶下面的第二个四字从栈中复制到寄存器 `%rdx`。

[[示例解读]]



# 补充

### `popq` 指令目的操作数详细规则

`popq` 指令从栈顶弹出一个 64 位（四字）的值，并将其传送到一个**目的操作数 (Destination Operand)**。这个目的操作数必须是一个**可写入的、大小为 64 位的存储位置**。

下表详细列出了不同类型的操作数作为 `popq` 目的地的合法性、语法示例及背后的原因。

| 目标操作数类型                                       | 是否为合法目标?               | 语法示例                                                  | 详细说明与原因                                                                                                                                              |
| :-------------------------------------------- | :--------------------- | :---------------------------------------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------- |
| **64位通用寄存器**<br>(General-Purpose Register)    | ✅ **是**                | `popq %rax`<br>`popq %rbx`<br>`popq %r15`             | **这是 `popq` 最主要、最常见的用途。**<br>通用寄存器就是被设计用来存放和操作数据的。`popq` 通常用于恢复在函数调用前被保存到栈上的寄存器值。                                                                    |
| **内存地址**<br>(Memory Address)                  | ✅ **是**                | `popq my_variable`<br>`popq (%rax)`<br>`popq 8(%rbp)` | **完全合法，但不如弹出到寄存器常见。**<br>这会将栈顶的值直接写入内存中的指定位置，而无需通过一个中间寄存器。它在功能上等价于 `movq (%rsp), D` 之后 `addq $8, %rsp`。                                              |
| **栈指针寄存器**<br>(Stack Pointer Register)        | ✅ **是**<br>(但为特殊高级用法)  | `popq %rsp`                                           | **这是一条合法但操作独特的指令。**<br>它会先从栈顶读取一个值，然后用这个值**覆盖** `%rsp` 自身，最后再将**新的** `%rsp` 加 8。这是一种快速拆除当前栈帧并恢复到旧栈指针的强大技巧，通常在函数返回时由编译器生成。                            |
| **指令指针寄存器**<br>(Instruction Pointer Register) | ❌ **否**                | `popq %rip`<br>(非法指令)                                 | **绝对禁止。这是架构设计的核心规则。**<br>直接修改程序执行流（即 `%rip`）是一个特殊操作。为此，CPU 提供了专门的指令 `ret`，其唯一作用就是从栈顶弹出一个地址并载入 `%rip` 中。将数据传送 (`pop`) 与控制流 (`ret`) 分开，是保证程序结构化和安全的基础。 |
| **立即数/常量**<br>(Immediate/Constant)            | ❌ **否**                | `popq $0x100`<br>(非法指令)                               | **逻辑上不成立。**<br>目的操作数必须是一个**存储位置**（L-value），而立即数是一个**值**（R-value）。你不能将一个值“存入”另一个值中。就如同在 C 语言中，`100 = x;` 是错误的。                                        |
| **段寄存器**<br>(Segment Registers)               | ❌ **否**<br>(在 64 位模式下) | `popq %cs`<br>`popq %ds`<br>(非法指令)                    | **在 x86-64 模式下，这些寄存器的加载方式受到严格限制。**<br>段寄存器的作用被大大简化，并且不能通过 `popq` 这样的通用指令来修改。修改它们需要使用特定的指令（如远跳转 `ljmp` 来修改 `%cs`）。                                    |
| **其他特殊寄存器**<br>(e.g., Control Registers)      | ❌ **否**                | `popq %cr0`<br>(非法指令)                                 | **这些是特权寄存器。**<br>控制寄存器（`%cr0`, `%cr3` 等）决定了 CPU 的核心工作模式（如是否开启分页、保护模式等）。修改它们是高度敏感的操作，只能在内核态下通过特定的 `mov` 指令完成，以保护操作系统免受用户程序的干扰。                        |

-----

### 核心要点总结

简单来说，判断一个目标是否合法，可以记住以下两点：

1.  **它必须是一个可写入的存储位置**：这排除了立即数（常量）。
2.  **它必须是为“通用数据”设计的存储位置**：这排除了那些控制 CPU 行为的特殊寄存器（如 `%rip`、`%cs`、`%cr0` 等），因为修改它们需要使用专门的、更安全的指令。

希望这个更详细的版本能帮助您彻底理解 `popq` 的使用规则。