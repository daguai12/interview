好的，这是根据您提供的文本内容，保留原始结构和标题整理的结果。

### **3.7 过程**

过程（在 C 语言中称为函数）是软件中一种很重要的抽象。它提供了一种封装代码的方式，用一组指定的参数和一个可选的返回值实现了某种功能。

要提供对过程的机器级支持，必须要处理许多不同的属性。假设过程 P 调用过程 Q，Q 执行后返回到 P，这个过程涉及以下机制：

1.  **传递控制 (Transferring Control)**:

      * **调用时**: 程序计数器 (PC) 必须被设置为 Q 的代码的起始地址。
      * **返回时**: 程序计数器必须被设置为 P 中调用 Q 之后的那条指令的地址。

2.  **传递数据 (Passing Data)**:

      * P 必须能够向 Q 提供一个或多个参数。
      * Q 必须能够向 P 返回一个值。

3.  **分配和释放内存 (Allocating and Deallocating Memory)**:

      * Q 在开始时可能需要为它的局部变量分配空间。
      * Q 在返回前，必须释放这些存储空间。

x86-64 的过程实现包括一组特殊的指令和一些对机器资源（寄存器和程序内存）使用的约定规则。

-----

#### **3.7.1 运行时栈**

C 语言过程调用机制的一个关键特性是使用了**栈 (stack)** 这种数据结构，它提供了“后进先出 (LIFO)”的内存管理原则。

当过程 P 调用 Q 时，控制和数据信息被添加到栈顶；当 Q 返回时，这些信息会从栈中释放。在 x86-64 中，栈向**低地址方向**增长，而栈指针寄存器 **`%rsp`** 始终指向栈顶元素。

##### **栈帧 (Stack Frame)**

当一个 x86-64 过程需要的存储空间超出寄存器能够存放的大小时，它就会在栈上分配空间。这个为单个过程分配的栈区域被称为该过程的**栈帧 (stack frame)**。

**通用栈帧结构 (对应原文图 3-25)**

![[Pasted image 20250925224239.png]]
  * **结构**: 当前正在执行的过程的帧总是在栈顶。当过程 P 调用过程 Q 时，会发生以下事情：
    1.  P 将**返回地址**（即 Q 返回后 P 应该继续执行的指令地址）压入栈中。这个返回地址被看作是 P 的栈帧的一部分。
    2.  Q 的代码会扩展当前栈的边界（即将 `%rsp` 的值减小），为自己的栈帧分配所需的空间。
  * **栈帧内容**:
      * **参数**: 如果一个函数需要传递超过 6 个整数/指针参数，那么多余的参数（第 7 个及以后）会通过调用者的栈帧来传递。
      * **返回地址**: 由 `call` 指令压入栈中。
      * **被保存的寄存器**: 如果 Q 需要使用某些由 P “委托保管”的寄存器，它必须先把这些寄存器的值保存在自己的栈帧里。
      * **局部变量**: Q 的局部变量，如果不能完全放在寄存器中，就会保存在栈帧里。
      * **参数构造区**: 如果 Q 准备调用另一个函数 R，它会把传递给 R 的参数（第 7 个及以后）放在自己栈帧的这个区域。

> **优化**: 为了提高效率，x86-64 的过程只分配自己所需要的栈帧部分。许多函数甚至根本不需要栈帧。当一个函数所有的局部变量都可以保存在寄存器中，并且该函数不会调用任何其他函数（这种函数被称为**叶子过程 (leaf procedure)**）时，就可以不创建栈帧。



#### **3.7.2 转移控制**

将控制从函数 P 转移到函数 Q，以及从 Q 返回，是通过 `call` 和 `ret` 指令来实现的。

  * **`call Q`**:

    1.  将**返回地址 A** 压入栈中。这个地址是紧跟在 `call` 指令后面的那条指令的地址。
    2.  将程序计数器 (PC) 设置为 Q 的起始地址。

  * **`ret`**:

    1.  从栈中弹出地址 A。
    2.  将程序计数器 (PC) 设置为 A。

`call` 指令的目标可以是**直接的**（一个标号）或**间接的**（`*` 后面跟一个操作数，表示从寄存器或内存中读取目标地址）。

-----

##### **简单调用示例 (图 3-26)**

我们来看 `main` 函数调用 `multstore` 函数的过程。

```s
//... in main ...
400563: callq 400540 <multstore>
400568: mov     ...               // <-- This is the return address

//... in multstore ...
40054d: retq
```

**执行流程**:

1.  **执行 `call` 之前**: 假设栈指针 `%rsp` 指向地址 `0x7fffffffe848`。程序计数器指向 `0x400563`。

2.  **`call` 执行之后**:

      * `call` 指令将返回地址 `0x400568` 压入栈中。
      * 栈指针 `%rsp` 减 8，变为 `0x7fffffffe840`。现在栈顶存放的是返回地址。
      * 程序计数器跳转到 `multstore` 的起始地址 `0x400540`。

3.  **`ret` 执行之后**:

      * `multstore` 函数执行到 `ret` 指令。
      * `ret` 指令从栈顶弹出返回地址 `0x400568`。
      * 栈指针 `%rsp` 加 8，恢复为 `0x7fffffffe848`。
      * 程序计数器被设置为 `0x400568`，`main` 函数从调用 `multstore` 之后的地方继续执行。

-----

##### **嵌套调用示例 (图 3-27)**

`call`/`ret` 机制和栈的“后进先出”特性完美配合，可以正确处理嵌套的函数调用。下面是一个 `main` 调用 `top`，`top` 再调用 `leaf` 的例子。

**a) 示例反汇编代码**

```s
// Disassembly of leaf(long y)
// y in %rdi
0000000000400540 <leaf>:
400540:   lea    0x2(%rdi),%rax     // L1: y+2
400544:   retq                      // L2: Return

// Disassembly of top(long x)
// x in %rdi
0000000000400545 <top>:
400545:   sub    $0x5,%rdi          // T1: x-5
400549:   callq  400540 <leaf>      // T2: Call leaf(x-5)
40054e:   add    %rax,%rax          // T3: Double result
400551:   retq                      // T4: Return

// Call to top from function main
40055b:   callq  400545 <top>       // M1: Call top(100)
400560:   mov    %rax,%rdx          // M2: Resume
```

**b) 示例代码的执行过程**
下表详细描述了 `main` 调用 `top(100)`，`top` 继而调用 `leaf(95)` 的完整过程。`leaf` 返回 97，`top` 将其加倍后返回 194。

| 标号 | PC | 指令 | `%rdi` | `%rax` | `%rsp` | \*%rsp (栈顶内容) | 描述 |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- |:--- |
| M1 |`0x40055b`| `callq` | 100 | - | `0x7fffffffe820`| - | 调用 `top(100)` |
| T1 |`0x400545`| `sub` | 100 | - | `0x7fffffffe818`| `0x400560`| 进入 `top` |
| T2 |`0x400549`| `callq` | 95 | - | `0x7fffffffe818`| `0x400560`| 调用 `leaf(95)` |
| L1 |`0x400540`| `lea` | 95 | - | `0x7fffffffe810`| `0x40054e`| 进入 `leaf` |
| L2 |`0x400544`| `retq` | 95 | 97 | `0x7fffffffe810`| `0x40054e`| 从 `leaf` 返回 97 |
| T3 |`0x40054e`| `add` | 95 | 97 | `0x7fffffffe818`| `0x400560`| 继续 `top` |
| T4 |`0x400551`| `retq` | 95 | 194 | `0x7fffffffe818`| `0x400560`| 从 `top` 返回 194 |
| M2 |`0x400560`| `mov` | 95 | 194 | `0x7fffffffe820`| - | 继续 `main` |

这个过程清晰地展示了运行时栈在管理过程调用和返回时所起的关键作用。每次 `call` 都将返回地址压入栈顶，而每次 `ret` 都从栈顶弹出正确的返回地址，确保程序总能回到正确的位置。


好的，这是根据您提供的文本内容，保留原始结构和标题整理的结果。

#### **3.7.3 数据传送**

除了转移控制，过程调用还包括传递数据（作为参数）和返回一个值。在 x86-64 中，大部分过程间的数据传送是通过**寄存器**实现的。

##### **参数传递**

  * **前 6 个参数**: x86-64 中，可以通过寄存器最多传递 **6 个**整型参数（例如整数和指针）。寄存器的使用是有特殊顺序的，会根据参数在参数列表中的顺序为它们分配寄存器。

    **图 3-28：传递函数参数的寄存器**
    | 参数序号 | **64位** (`long`, `char*`) | **32位** (`int`) | **16位** (`short`) | **8位** (`char`) |
    | :--- | :--- | :--- | :--- | :--- |
    | **1** | `%rdi` | `%edi` | `%di` | `%dil` |
    | **2** | `%rsi` | `%esi` | `%si` | `%sil` |
    | **3** | `%rdx` | `%edx` | `%dx` | `%dl` |
    | **4** | `%rcx` | `%ecx` | `%cx` | `%cl` |
    | **5** | `%r8` | `%r8d` | `%r8w` | `%r8b` |
    | **6** | `%r9` | `%r9d` | `%r9w` | `%r9b` |

  * **超出 6 个的参数**: 如果一个函数有大于 6 个整型参数，超出的部分（第 7 个、第 8 个，以此类推）就要通过**栈**来传递。调用者需要在执行 `call` 指令之前，将这些参数压入自己的栈帧中。

  * **返回值**: 函数的返回值通常通过寄存器 **`%rax`** 来传递。

##### **多参数示例**

图 3-29 展示了一个有 8 个不同类型参数的函数示例，清晰地说明了寄存器和栈是如何协同工作的。

**图 3-29：有多个不同类型参数的函数示例**

**a) C 代码**

```c
void proc(long a1, int a2, short a3, char a4,
          long *a1p, int *a2p, short *a3p, char *a4p)
{
    *a1p += a1;
    *a2p += a2;
    *a3p += a3;
    *a4p += a4;
}
```

**b) 生成的汇编代码**

```s
// 参数传递位置如下:
// a1 in %rdi, a1p in %rsi, a2 in %edx, a2p in %rcx,
// a3 in %r8w, a3p in %r9, a4 at 8(%rsp), a4p at 16(%rsp)
proc:
    movq    16(%rsp), %rax      // 从栈中取出 a4p
    addq    %rdi, (%rsi)        // *a1p += a1 (64位加法)
    addl    %edx, (%rcx)        // *a2p += a2 (32位加法)
    addw    %r8w, (%r9)         // *a3p += a3 (16位加法)
    movl    8(%rsp), %edx       // 从栈中取出 a4
    addb    %dl, (%rax)         // *a4p += a4 (8位加法)
    ret
```

**调用时的栈状态 (对应原文图 3-30)**

![[Pasted image 20250925223903.png]]
当 `main` 函数调用 `proc` 时，在 `call` 指令执行后，栈的状态如下：

  * 栈顶 (`%rsp` 指向的位置) 存放的是**返回地址**。
  * 参数 7 (`a4`) 位于栈上的 `8(%rsp)` 位置。
  * 参数 8 (`a4p`) 位于栈上的 `16(%rsp)` 位置。


#### **3.7.4 栈上的局部存储**

在前面的例子中，大多数过程都不需要超出寄存器大小的本地存储区域。不过，在某些情况下，局部数据必须存放在内存中，常见的情况包括：

  * 寄存器不足以存放所有的本地数据。
  * 对一个局部变量使用了地址运算符 `&`，因此必须为它产生一个内存地址。
  * 某些局部变量是数组或结构体，必须通过数组或结构引用来访问。

一般来说，过程通过**减小栈指针 (`%rsp`)** 在栈上为这些数据分配空间。这块分配的区域是该过程**栈帧 (stack frame)** 的一部分。

##### **示例 1：传递局部变量地址**

下面的 `caller` 函数由于对局部变量 `arg1` 和 `arg2` 使用了取址运算符 `&`，因此必须为它们在栈上分配空间。

**图 3-31：过程定义和调用的示例**

a) C 代码

```c
long swap_add(long *xp, long *yp)
{
    long x = *xp;
    long y = *yp;
    *xp = y;
    *yp = x;
    return x + y;
}

long caller()
{
    long arg1 = 534;
    long arg2 = 1057;
    long sum = swap_add(&arg1, &arg2);
    long diff = arg1 - arg2;
    return sum * diff;
}
```

b) `caller` 函数生成的汇编代码

```s
caller:
    subq    $16, %rsp         // 为栈帧分配 16 字节
    movq    $534, (%rsp)      // 在栈上存储 arg1 (位于 %rsp+0)
    movq    $1057, 8(%rsp)    // 在栈上存储 arg2 (位于 %rsp+8)
    leaq    8(%rsp), %rsi     // 计算 &arg2 作为第二个参数
    movq    %rsp, %rdi        // 计算 &arg1 作为第一个参数
    call    swap_add          // 调用 swap_add(&arg1, &arg2)
    movq    (%rsp), %rdx      // 获取 arg1 (此时值已交换为 1057)
    subq    8(%rsp), %rdx     // 计算 diff = arg1 - arg2
    imulq   %rdx, %rax        // 计算 sum * diff
    addq    $16, %rsp         // 释放栈帧
    ret
```

-----

##### **示例 2：为局部变量和传出参数分配空间**

`call_proc` 函数是一个更复杂的例子，它既有自己的局部变量需要存放在栈上，又要调用一个需要 8 个参数的函数 `proc`（其中第 7 和第 8 个参数需要通过栈传递）。

**图 3-32：调用多参数函数的代码示例**

a) C 代码

```c
// proc 的原型在图 3-29 中定义
void proc(long, long*, int, int*, short, short*, char, char*);

long call_proc()
{
    long  x1 = 1; int   x2 = 2;
    short x3 = 3; char  x4 = 4;
    proc(x1, &x1, x2, &x2, x3, &x3, x4, &x4);
    return (x1 + x2) * (x3 - x4);
}
```

b) `call_proc` 函数生成的汇编代码

```s
call_proc:
    subq    $32, %rsp          // 为栈帧分配 32 字节
    movq    $1, 24(%rsp)       // 在栈上存储 x1
    movl    $2, 20(%rsp)       // 在栈上存储 x2
    movw    $3, 18(%rsp)       // 在栈上存储 x3
    movb    $4, 17(%rsp)       // 在栈上存储 x4
    
    // 准备传递给 proc 的参数
    leaq    17(%rsp), %rax     // 计算 &x4
    movq    %rax, 8(%rsp)      // 将 &x4 作为第 8 个参数存入栈中
    movq    $4, (%rsp)         // 将 4 作为第 7 个参数存入栈中
    leaq    18(%rsp), %r9      // 将 &x3 作为第 6 个参数 (寄存器)
    movl    $3, %r8d           // 将 3 作为第 5 个参数 (寄存器)
    leaq    20(%rsp), %rcx     // 将 &x2 作为第 4 个参数 (寄存器)
    movl    $2, %edx           // 将 2 作为第 3 个参数 (寄存器)
    leaq    24(%rsp), %rsi     // 将 &x1 作为第 2 个参数 (寄存器)
    movl    $1, %edi           // 将 1 作为第 1 个参数 (寄存器)
    
    call    proc               // 调用 proc

    // 从 proc 返回后，计算返回值
    movslq  20(%rsp), %rdx     // 获取 x2
    addq    24(%rsp), %rdx     // 计算 x1 + x2
    movswl  18(%rsp), %eax     // 获取 x3
    movsbl  17(%rsp), %ecx     // 获取 x4
    subl    %ecx, %eax         // 计算 x3 - x4
    cltq                       // 将 (x3-x4) 符号扩展到 %rax
    imulq   %rdx, %rax         // 计算 (x1+x2) * (x3-x4)
    
    addq    $32, %rsp          // 释放栈帧
    ret
```

**`call_proc` 的栈帧布局 (对应原文图 3-33)**
`call_proc` 函数分配的 32 字节栈帧的布局如下：
![[Pasted image 20250925224040.png]]


#### **3.7.5 寄存器中的局部存储空间**

寄存器组是唯一被所有过程共享的资源。虽然在给定时刻只有一个过程是活动的，我们仍然必须确保当一个过程（调用者）调用另一个过程（被调用者）时，被调用者不会覆盖调用者稍后会使用的寄存器值。

为此，x86-64 采用了一组统一的寄存器使用惯例，所有的过程（包括程序库）都必须遵循。该惯例将 16 个通用寄存器划分为两类。

##### **被调用者保存寄存器 (Callee-Saved Registers)**

  * **寄存器**: `%rbx`, `%rbp`, `%r12`, `%r13`, `%r14`, `%r15`。
  * **规则**: 当过程 P 调用过程 Q 时，Q **必须**保存这些寄存器的值，保证它们的值在 Q 返回到 P 时与 Q 被调用时是一样的。
  * **实现**: 如果 Q 需要使用这些寄存器，它必须先把寄存器的原始值压入栈中，在使用完毕后，在返回前再从栈中弹出旧值以恢复它们。如果 Q 不使用这些寄存器，则无需任何操作。
  * **对调用者的意义**: P 可以安全地将一个值存储在这些寄存器中，然后调用 Q，并且确信在 Q 返回后，这个值仍然保持不变。

##### **调用者保存寄存器 (Caller-Saved Registers)**

  * **寄存器**: 所有其他的寄存器（除了栈指针 `%rsp`），包括 `%rax`, `%rdi`, `%rsi`, `%rdx`, `%rcx`, `%r8`-%r11\`。
  * **规则**: 被调用者 Q 可以**随意修改**这些寄存器，而无需保存它们之前的值。
  * **对调用者的意义**: 如果 P 在调用 Q **之前**，在这些寄存器中存有某个它在 Q 返回**之后**还想继续使用的值，那么 P **自己**（调用者）有责任在调用 Q 之前保存好这个数据（例如，把它压入栈中）。

-----

##### **示例**

图 3-34 中的代码展示了被调用者保存寄存器的使用。函数 `P` 两次调用函数 `Q`。它必须在第一次调用 `Q(y)` 的过程中保存 `x` 的值，并在第二次调用 `Q(x)` 的过程中保存第一次调用的结果 `Q(y)`。

**图 3-34：展示被调用者保存寄存器使用的代码**

**a) 调用函数 (C 代码)**

```c
long P(long x, long y)
{
    long u = Q(y);
    long v = Q(x);
    return u + v;
}
```

**b) 调用函数生成的汇编代码**

```s
// x in %rdi, y in %rsi
P:
    pushq   %rbp              // 保存 %rbp
    pushq   %rbx              // 保存 %rbx
    subq    $8, %rsp          // 对齐栈帧

    movq    %rdi, %rbp        // 将 x 保存到被调用者保存寄存器 %rbp
    movq    %rsi, %rdi        // 将 y 移动到第一个参数寄存器
    call    Q                 // 调用 Q(y)，结果在 %rax

    movq    %rax, %rbx        // 将 Q(y) 的结果保存到被调用者保存寄存器 %rbx
    movq    %rbp, %rdi        // 从 %rbp 恢复 x，作为第二个调用的参数
    call    Q                 // 调用 Q(x)，结果在 %rax

    addq    %rbx, %rax        // 将 Q(x) 的结果与保存的 Q(y) 的结果相加
    
    addq    $8, %rsp          // 释放栈帧
    popq    %rbx              // 恢复 %rbx
    popq    %rbp              // 恢复 %rbp
    ret
```

**代码解读**:

  * 在函数 `P` 的开头，它将两个它计划使用的被调用者保存寄存器 `%rbp` 和 `%rbx` 的原始值压入栈中。
  * 在第一次调用 `Q` 之前，它将 `x` 的值从 `%rdi` 移入 `%rbp` 中进行“保管”。
  * 在第二次调用 `Q` 之前，它将第一次调用的结果从 `%rax` 移入 `%rbx` 中进行“保管”。
  * 在函数 `P` 的结尾，它从栈中以相反的顺序弹出值，恢复了 `%rbx` 和 `%rbp` 的原始状态，然后才返回。

#### **3.7.6 递归过程**

前面已经描述的寄存器和栈的使用惯例，使得 x86-64 过程能够**递归地 (recursively)** 调用它们自身。

其核心在于，每个过程调用在栈中都有它自己的**私有空间**（即栈帧）。因此，一个函数的多个未完成的调用，其各自的局部变量和状态信息（如返回地址、保存的寄存器值）**不会相互影响**。栈的“后进先出”原则很自然地提供了适当的策略：当过程被调用时分配局部存储，当返回时释放存储。

##### **示例：递归阶乘**

图 3-35 给出了一个递归的阶乘函数的 C 代码和它生成的汇编代码，清晰地展示了这一机制。

**图 3-35：递归的阶乘程序的代码**

**a) C 代码**

```c
long rfact(long n)
{
    long result;
    if (n <= 1)
        result = 1;
    else
        result = n * rfact(n-1);
    return result;
}
```

**b) 生成的汇编代码**

```s
// n in %rdi
rfact:
    pushq   %rbx                  // 保存被调用者保存寄存器 %rbx
    movq    %rdi, %rbx            // 将 n 保存到 %rbx 中
    
    movl    $1, %eax              // 准备好返回值 result = 1 (用于基本情况)
    cmpq    $1, %rdi              // 比较 n:1
    jle     .L35                  // 如果 n <= 1, 跳转到 done
    
    leaq    -1(%rdi), %rdi        // 计算 n-1 作为递归调用的参数
    call    rfact                 // 递归调用 rfact(n-1)
    imulq   %rbx, %rax            // 返回后，将结果 (%rax) 乘以保存的 n (%rbx)
    
.L35:                           // done:
    popq    %rbx                  // 恢复 %rbx
    ret                         // 返回
```

**代码解读**:

  * **关键步骤**: 在进行递归调用 `call rfact` 之前，程序必须保存好当前这层调用的参数 `n` 的值。
  * **为何使用 `%rbx`**: `call` 指令可能会修改**调用者保存寄存器**（如 `%rdi`），但它必须保证**被调用者保存寄存器**（如 `%rbx`）的值不变。因此，代码在第 3 行将 `n` 的值从 `%rdi` 复制到了 `%rbx` 中。
  * **递归返回**: 当递归调用 `rfact(n-1)` 返回时（第 9 行），我们可以保证两件事：
    1.  该次调用的结果（即 `(n-1)!`）会保存在寄存器 `%rax` 中。
    2.  当前这层调用的参数 `n` 的值仍然安全地保存在寄存器 `%rbx` 中。
  * **最终计算**: 第 10 行的 `imulq %rbx, %rax` 指令将这两个值相乘，就得到了期望的结果 `n * (n-1)!`。

从这个例子我们可以看到，递归调用一个函数本身与调用其他函数在机器层面上的处理方式是一样的。栈规则为每一次函数调用都提供了其自己私有的状态信息存储空间，完美地支持了递归。
