### **3.2 程序编码**

假设一个 C 程序，有两个文件 `p1.c` 和 `p2.c`。我们用 Unix 命令行编译这些代码：

```bash
linux> gcc -Og -o p p1.c p2.c
```

`gcc` 命令调用了一整套的程序，将源代码转化成可执行代码。这个过程分为四个阶段：

1.  **预处理 (Preprocessing)**: 预处理器 (cpp) 扩展源代码，插入所有用 `#include` 命令指定的文件，并扩展所有用 `#define` 声明的宏。
2.  **编译 (Compilation)**: 编译器 (ccl) 产生两个源文件的汇编代码，名为 `p1.s` 和 `p2.s`。
3.  **汇编 (Assembly)**: 汇编器 (as) 将汇编代码转化成二进制**目标代码 (object code)** 文件 `p1.o` 和 `p2.o`。目标代码是机器代码的一种形式，但还没有填入全局值的最终地址。
4.  **链接 (Linking)**: 链接器 (ld) 将两个目标代码文件与实现库函数（例如 `printf`）的代码合并，并产生最终的**可执行代码 (executable code)** 文件 `p`。

-----

#### **3.2.1 机器级代码**

对于机器级编程来说，其中两种抽象尤为重要：

1.  **指令集架构 (Instruction Set Architecture, ISA)**: 它定义了机器级程序的格式和行为，包括处理器状态、指令格式以及每条指令对状态的影响。它描述了一个抽象的模型，仿佛每条指令都是按顺序执行的。
2.  **虚拟地址 (Virtual Addresses)**: 机器级程序使用的内存地址是虚拟地址，它提供了一个看上去是超大字节数组的内存模型。

C 语言和机器代码之间存在巨大差异，一些对 C 程序员隐藏的处理器状态在机器代码中都是可见的：

  * **程序计数器 (%rip)**: 给出将要执行的下一条指令在内存中的地址。
  * **整数寄存器文件**: 包含 16 个命名的位置，分别存储 64 位的值，可用于存储地址（指针）或整数数据。
  * **条件码寄存器**: 保存着最近执行的算术或逻辑指令的状态信息，用于实现 `if`, `while` 等条件变化。
  * **向量寄存器**: 可以存放一个或多个整数或浮点数值。

此外，C 语言中的数组、结构体等在机器代码中仅表现为一组连续的字节。汇编代码甚至不区分有符号或无符号整数，也不区分指针和整数。

-----

#### **3.2.2 代码示例**

假设我们有一个 C 代码文件 `mstore.c`:

```c
long mult2(long, long);

void multstore(long x, long y, long *dest) {
    long t = mult2(x, y);
    *dest = t;
}
```

  * **生成汇编代码**:

    ```bash
    linux> gcc -Og -S mstore.c
    ```

    这会产生一个汇编文件 `mstore.s`，其中包含 `multstore` 函数的定义：

    ```s
    multstore:
        pushq   %rbx
        movq    %rdx, %rbx
        call    mult2
        movq    %rax, (%rbx)
        popq    %rbx
        ret
    ```

  * **生成目标代码**:

    ```bash
    linux> gcc -Og -c mstore.c
    ```

    这会产生一个二进制的目标代码文件 `mstore.o`。其中 `multstore` 函数对应的 14 字节序列的十六进制表示为：
    `53 48 89 d3 e8 00 00 00 00 48 89 03 5b c3`

  * **查看目标代码 (反汇编)**:
    我们可以使用 `objdump` 程序来查看机器代码文件的内容：

    ```bash
    linux> objdump -d mstore.o
    ```

    结果如下：

    ```
    0000000000000000 <multstore>:
       0:   53                      push   %rbx
       1:   48 89 d3                mov    %rdx,%rbx
       4:   e8 00 00 00 00          callq  9 <multstore+0x9>
       9:   48 89 03                mov    %rax,(%rbx)
       c:   5b                      pop    %rbx
       d:   c3                      retq
    ```

    值得注意的特性：

      * x86-64 的指令长度从 1 到 15 个字节不等。
      * 反汇编器仅根据字节序列来确定汇编代码，它不需要访问源代码。

  * **生成可执行文件**:
    要生成可执行文件，我们需要一个包含 `main` 函数的文件，并将其与 `mstore.o` 链接起来。假设我们有 `main.c`，则：

    ```bash
    linux> gcc -Og -o prog main.c mstore.c
    ```

    现在我们反汇编可执行文件 `prog`：

    ```bash
    linux> objdump -d prog
    ```

    反汇编器会抽取出 `multstore` 的代码序列：

    ```
    0000000000400540 <multstore>:
      400540:   53                      push   %rbx
      400541:   48 89 d3                mov    %rdx,%rbx
      400544:   e8 42 00 00 00          callq  40058b <mult2>
      400549:   48 89 03                mov    %rax,(%rbx)
      40054c:   5b                      pop    %rbx
      40054d:   c3                      retq
    ```

    与之前的反汇编结果相比，主要区别是：

    1.  **地址不同**: 链接器将代码的地址移到了一个新的地址范围。
    2.  **调用地址被填充**: 链接器填上了 `callq` 指令需要调用的函数 `mult2` 的实际地址。

-----

#### **3.2.3 关于格式的注解**

GCC 产生的汇编代码包含很多以 `.` 开头的**伪指令**，它们用于指导汇编器和链接器工作，我们通常可以忽略。为了更清晰地说明，本书使用一种带注释的格式。

##### **ATT 与 Intel 汇编代码格式**

GCC 和其他 GNU 工具默认使用 **ATT 格式**的汇编。而 Microsoft 和 Intel 的文档则使用 **Intel 格式**。两者在多个方面有所不同：

  * **大小后缀**: ATT 使用后缀（如 `movq`），Intel 代码则省略（`mov`）。
  * **寄存器前缀**: ATT 使用 `％` 符号（如 `%rbx`），Intel 代码则没有（`rbx`）。
  * **内存描述**: ATT 使用 `(%rbx)`，Intel 则使用 `QWORD PTR [rbx]` 这样的形式。
  * **操作数顺序**: 在带有多个操作数的指令情况下，**操作数顺序是相反的**。
      * ATT 格式: `movq %rax, %rbx`  (源 -\> 目标)
      * Intel 格式: `mov rbx, rax` (目标 -\> 源)
        这一点在转换时非常容易令人困惑。