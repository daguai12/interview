好的，这是根据您提供的文本内容，保留原始结构和标题整理的结果。

### **3.9 异质的数据结构**

C 语言提供了两种将不同类型的对象组合到一起创建数据类型的机制：**结构 (structure)**，用关键字 `struct` 来声明；以及**联合 (union)**，用关键字 `union` 来声明。

-----

#### **3.9.1 结构**

C 语言的 `struct` 声明创建一个数据类型，将可能不同类型的对象聚合到一个对象中。

  * **内存布局**: 结构的所有组成部分都存放在内存中一段**连续的**区域内。
  * **指针**: 指向结构的指针就是结构第一个字节的地址。
  * **字段访问**: 编译器维护关于每个结构类型的信息，指示每个字段的字节偏移。它以这些偏移作为内存引用指令中的位移，从而产生对结构元素的引用。

##### **`struct` 作为对象**

`struct` 允许程序员在一个数据结构中保存关于某个实体的多种信息，并用名字来引用这些信息。

**示例 `struct`**:

```c
struct rect {
    long llx;           // 左下角 X 坐标
    long lly;           // 左下角 Y 坐标
    unsigned long width;  // 宽度
    unsigned long height; // 高度
    unsigned int color;   // 颜色编码
};
```

**指针访问**:
在 C 语言中，将指向结构的指针从一个地方传递到另一个地方，而不是复制它们，这是很常见的。

```c
// 计算面积的函数
long area(struct rect *rp) {
    // 表达式 (*rp).width 间接引用指针并选取 width 字段
    return (*rp).width * (*rp).height;
}
```

间接引用和字段选取结合起来使用非常常见，以至于 C 语言提供了一种替代的表示法 `->`。即 `rp->width` 等价于表达式 `(*rp).width`。

##### **结构体的内存布局**

考虑下面这样的结构声明：

```c
struct rec {
    int i;
    int j;
    int a[2];
    int *p;
};
```

这个结构包含 2 个 4 字节 `int`、一个由 2 个 4 字节 `int` 组成的数组和一个 8 字节整型指针，总共是 24 个字节。其内存布局如下：

| 偏移 (Bytes) | 0-3 | 4-7 | 8-11   | 12-15  | 16-23 |
| :--------- | :-- | :-- | :----- | :----- | :---- |
| **内容**     | `i` | `j` | `a[0]` | `a[1]` | `p`   |

可以看到，数组 `a` 是嵌入到这个结构中的。

##### **汇编代码中的字段访问**

为了访问结构的字段，编译器产生的代码要将结构的地址加上适当的偏移。假设 `struct rec *` 类型的变量 `r` 存放在寄存器 `%rdi` 中。

**示例 1**: `r->j = r->i;`

```s
// r in %rdi
    movl    (%rdi), %eax    // 获取 r->i (偏移量为 0)
    movl    %eax, 4(%rdi)   // 将其存入 r->j (偏移量为 4)
```

**示例 2**: `&(r->a[i])` (获取结构体内嵌数组元素的地址)
假设索引 `i` 存放在 `%rsi` 中。

```s
// r in %rdi, i in %rsi
    leaq    8(%rdi, %rsi, 4), %rax // 设置 %rax = &r->a[i]
```

  * **计算**: `r 的地址(%rdi) + a 的偏移量(8) + i(%rsi) * int 的大小(4)`

**示例 3**: `r->p = &r->a[r->i + r->j];`

```s
// r in %rdi
    movl    4(%rdi), %eax       // 获取 r->j
    addl    (%rdi), %eax        // 计算 r->i + r->j
    cltq                        // 将结果(32位)符号扩展到 %rax (64位)
    leaq    8(%rdi, %rax, 4), %rax  // 计算 &r->a[...] 的地址
    movq    %rax, 16(%rdi)      // 将计算出的地址存入 r->p (偏移量为 16)
```

综上所述，结构的各个字段的选取完全是在**编译时**处理的。机器代码不包含关于字段声明或字段名字的任何信息，只处理地址和偏移量。


#### **3.9.2 联合 (Union)**

**联合**提供了一种能够规避 C 语言类型系统的方式，允许以多种类型来引用一个对象。联合声明的语法与结构一样，但语义相差很大：它们是用不同的字段来引用**相同的内存块**。

##### **内存布局与大小**

  * **`struct`**: 结构中的每个字段都存放在内存中**不同的、连续的**位置。结构的总大小至少是其所有字段大小的总和（加上可能的填充字节）。
  * **`union`**: 联合中的所有字段都**共享同一块内存**，它们的起始地址是相同的。联合的总大小等于其**最大字段**的大小。

**示例**:

| 类型          | 字段  | 偏移量   | 字段大小 | 结构/联合总大小 |
| :---------- | :-- | :---- | :--- | :------- |
| `struct S3` | `c` | 0     | 1    | 24       |
|             | `i` | 4     | 8    |          |
|             | `v` | 16    | 8    |          |
| `union U3`  | `c` | **0** | 1    | 16       |
|             | `i` | **0** | 8    |          |
|             | `v` | **0** | 8    |          |

-----

##### **联合的用途**

联合虽然会绕过 C 语言的类型安全检查，但在某些场景下非常有用。

**1. 节省空间 (与互斥字段)**
当我们知道一个数据结构中的两个不同字段的使用是**互斥**的（即不可能同时使用），那么将这两个字段声明为联合的一部分，会减小分配空间的总量。

  * **场景**: 实现一个二叉树，其中叶子节点有数据，而内部节点有指向孩子的指针。
  * **朴素的 `struct` 实现**:
    ```c
    // 每个节点都为指针和数据分配了空间，造成浪费
    struct node_s {
        struct node_s *left;  // 8 bytes
        struct node_s *right; // 8 bytes
        double data[2];       // 16 bytes
    }; // Total: 32 bytes
    ```
  * **使用 `union` 的实现**:
    ```c
    union node_u {
        struct {
            union node_u *left;
            union node_u *right;
        } internal;
        double data[2];
    }; // Total: 16 bytes
    ```
  * **标记联合 (Tagged Union)**:
    上述 `union` 实现虽然节省了空间，但我们无法判断一个节点到底是叶子还是内部节点。通常的解决方法是引入一个“标签”字段，与联合一起封装在一个结构中：
    ```c
    typedef enum { N_LEAF, N_INTERNAL } nodetype_t;

    struct node_t {
        nodetype_t type; // 标签字段
        union {
            struct {
                struct node_t *left;
                struct node_t *right;
            } internal;
            double data[2];
        } info;
    };
    ```
    这样，我们就可以通过检查 `type` 字段来安全地访问 `info` 联合中正确的成员。

**2. 访问不同数据类型的位模式**
联合可以用来访问一个数据类型的原始**位模式 (bit pattern)**，而不是其数值。

  * **示例 1**: 获取 `double` 的位表示

    ```c
    unsigned long double2bits(double d) {
        union {
            double d;
            unsigned long u;
        } temp;
        
        temp.d = d;       // 将 double 值存入联合
        return temp.u;    // 作为一个 unsigned long 读出其位模式
    };
    ```

    这里返回的 `u` 的值与 `d` 的数值没有任何关系（除了 d=0.0 的情况），但 `u` 的 64 个位与 `d` 的 IEEE 754 浮点数表示的 64 个位是完全相同的。

  * **示例 2**: 通过位模式构造 `double`

    ```c
    double uu2double(unsigned word0, unsigned word1) {
        union {
            double d;
            unsigned u[2];
        } temp;
        
        temp.u[0] = word0;
        temp.u[1] = word1;
        return temp.d;
    }
    ```

    > **字节序问题**: 这种位操作**高度依赖于字节序**。在小端法机器上，`word0` 会成为 `d` 的低 4 个字节；而在大端法机器上，`word0` 则会成为 `d` 的高 4 个字节。

#### **3.9.3 数据对齐**

许多计算机系统对基本数据类型的合法地址做出了限制，要求某种类型对象的地址必须是某个值 K（通常是 2, 4, 或 8）的倍数。这种**对齐 (alignment)** 限制简化了处理器和内存系统之间接口的硬件设计，并能显著提高内存系统的性能。

  * **x86-64 的情况**: 无论数据是否对齐，x86-64 硬件都能正确工作。不过，Intel 仍然强烈建议对齐数据以获得最佳性能。
  * **对齐原则**: 任何 `K` 字节的基本对象的地址必须是 `K` 的倍数。

| 类型 (`K` 字节)                   | 对齐要求 (地址是 K 的倍数) |
| :---------------------------- | :--------------- |
| `char` (1)                    | 1                |
| `short` (2)                   | 2                |
| `int`, `float` (4)            | 4                |
| `long`, `double`, `char*` (8) | 8                |

-----

##### **结构体中的对齐**

对于包含 `struct` 的代码，编译器可能需要在字段的分配中**插入间隙 (padding)**，以保证每个结构元素都满足它的对齐要求。

**1. 结构体内部的填充**
考虑下面的结构声明：

```c
struct S1 {
    int i;    // 4 字节
    char c;   // 1 字节
    int j;    // 4 字节
};
```

为了保证字段 `j` 满足 4 字节对齐的要求，编译器不能将它紧跟在字段 `c` 后面。它必须在字段 `c` 和 `j` 之间插入一个 **3 字节的间隙**。

**内存布局**:
因此，字段 `j` 的偏移量为 8，而整个结构的大小也从 9 字节增加到了 **12 字节**。

**2. 结构体末尾的填充**
编译器的另一个要求是，**结构体的总大小**必须是其内部**最大基本类型元素大小**的整数倍。这样做是为了确保在创建**结构体数组**时，数组中的每一个元素都能满足其对齐要求。

考虑下面这个结构声明：

```c
struct S2 {
    int i;    // 4 字节
    int j;    // 4 字节
    char c;   // 1 字节
};
```

这个结构体中最大的元素是 `int`（4字节），所以整个结构体的大小必须是 4 的倍数。如果只分配 9 个字节，那么当创建数组 `struct S2 d[4]` 时，第二个元素 `d[1]` 的地址将是 `&d[0] + 9`，这个地址将不再是 4 的倍数，从而违反了对齐规则。

为了解决这个问题，编译器会在结构 `S2` 的末尾添加 **3 个字节的填充**。

**内存布局**:
这样，结构体的总大小就变成了 **12 字节**（4的倍数），确保了数组中的每个元素都能正确对齐。

-----

##### **强制对齐的情况**

对于大多数 x86-64 指令来说，保持数据对齐是为了提高效率，不遵守也不会导致程序出错。

但有一个重要的例外：用于实现多媒体操作的 **SSE 指令**。这些指令对 16 字节数据块进行操作，在 SSE 单元和内存之间传送数据的指令**要求**内存地址必须是 **16 的倍数**。任何试图以不满足对齐要求的地址来访问内存都会导致**异常**，默认行为是程序终止。

这个要求有两个重要后果：

1.  任何内存分配函数 (`malloc`, `calloc` 等) 生成的块的起始地址都**必须**是 16 的倍数。
2.  大多数函数的**栈帧边界**也**必须**是 16 字节的倍数。