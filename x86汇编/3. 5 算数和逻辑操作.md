### **3.5 算术和逻辑操作**

图 3-10 列出了 x86-64 的一些整数和逻辑操作。这些操作被分为四组：加载有效地址、一元操作、二元操作和移位。

**图 3-10：整数算术操作**
*注意：下表中“效果”列的操作数顺序（源 -\> 目标）与 ATT 格式汇编代码中的（源, 目标）相反。*

| 指令类别                            | 效果             | 描述         |     |
| :------------------------------ | :------------- | :--------- | --- |
| **`leaq`** S, D                 | `D <- &S`      | **加载有效地址** |     |
|                                 |                |            |     |
| **`INC`** D                     | `D <- D + 1`   | 加 1        |     |
| **`DEC`** D                     | `D <- D - 1`   | 减 1        |     |
| **`NEG`** D                     | `D <- -D`      | 取负 (二进制补码) |     |
| **`NOT`** D                     | `D <- ~D`      | 取补 (位求反)   |     |
|                                 |                |            |     |
| **`ADD`** S, D                  | `D <- D + S`   | 加          |     |
| **`SUB`** S, D                  | `D <- D - S`   | 减          |     |
| **`IMUL`** S, D                 | `D <- D * S`   | 乘          |     |
| **`XOR`** S, D                  | `D <- D ^ S`   | 异或         |     |
| **`OR`** S, D                   | `D <- D`       | 或          |     |
| **`AND`** S, D                  | `D <- D & S`   | 与          |     |
|                                 |                |            |     |
| **`SAL`** k, D / **`SHL`** k, D | `D <- D << k`  | 左移         |     |
| **`SAR`** k, D                  | `D <- D >>A k` | 算术右移       |     |
| **`SHR`** k, D                  | `D <- D >>L k` | 逻辑右移       |     |

-----

#### **3.5.1 加载有效地址 (Load Effective Address)**

加载有效地址指令 **`leaq`** 实际上是 `movq` 指令的一种变形。

  * **核心机制**: `leaq` 的指令形式是**从内存读数据到寄存器**，但它**根本就没有引用内存**。它只是计算出源操作数所指定的有效地址，然后将这个计算出的**地址值**写入到目的寄存器中。

  * **主要用途**:

    1.  为后面的内存引用产生指针。
    2.  简洁地描述普通的算术操作。

  * **算术操作示例**:
    如果寄存器 `%rdx` 的值为 `x`，那么指令 `leaq 7(%rdx, %rdx, 4), %rax` 的作用是：

    1.  计算有效地址：`7 + R[%rdx] + R[%rdx] * 4`
    2.  即 `7 + x + 4*x`，结果为 `5x + 7`
    3.  将计算结果 `5x + 7` 存入寄存器 `%rax`。
        整个过程没有访问内存。

##### **代码示例**

编译器经常利用 `leaq` 来执行加法和有限形式的乘法。考虑以下 C 程序：

```c
// C 语言代码
long scale(long x, long y, long z) {
    long t = x + 4 * y + 12 * z;
    return t;
}
```

编译后，该函数的算术运算可以完全由三条 `leaq` 指令实现：

```s
// x in %rdi, y in %rsi, z in %rdx
scale:
    leaq    (%rdi, %rsi, 4), %rax    // %rax = x + 4*y
    leaq    (%rdx, %rdx, 2), %rdx    // %rdx = z + 2*z = 3*z
    leaq    (%rax, %rdx, 4), %rax    // %rax = %rax + 4*%rdx = (x + 4*y) + 4*(3*z)
    ret
```

这个例子清晰地展示了 `leaq` 在编译简单的算术表达式时是如何被巧妙利用的。

[[示例解读2]]

#### **3.5.2 一元和二元操作**

##### **一元操作**
第二组中的操作是**一元操作 (unary operations)**，它们只有一个操作数，这个操作数既是**源**又是**目的**。这个操作数可以是一个寄存器，也可以是一个内存位置。
* **示例**: `incq (%rsp)`
    * 这条指令会使栈顶的 8 字节元素加 1。它首先从内存中读取栈顶的值，将其加 1，然后再将结果写回内存中的同一位置。
* **类比**: 这种语法让人想起 C 语言中的自增 (`++`) 和自减 (`--`) 运算符。

##### **二元操作**
第三组是**二元操作 (binary operations)**，它们有两个操作数。其中，第二个操作数既是源又是目的。
* **语法**: `指令 源操作数, 目的操作数`  ( `instruction Source, Destination` )
* **效果**: `目的操作数 = 目的操作数 op 源操作数` ( `Destination = Destination op Source` )
* **类比**: 这种语法让人想起 C 语言中的赋值运算符，例如 `x -= y`。
* **重要提示**: 源操作数是**第一个**，目的操作数是**第二个**。对于不可交换的操作（如减法），这可能看起来不直观。
    * **示例**: `subq %rax, %rdx`
    * **含义**: `R[%rdx] = R[%rdx] - R[%rax]`。
    * **记忆技巧**: 可以将它解读为 “从 `%rdx` 中减去 `%rax`”。

* **操作数类型**:
    * 第一个操作数（源）可以是立即数、寄存器或是内存位置。
    * 第二个操作数（目的）可以是寄存器或是内存位置。
* **内存目的操作**: 当第二个操作数为内存地址时，处理器必须先从内存读出值，执行操作，再把结果写回内存。

[[示例解读2]]

#### **3.5.3 移位操作**

最后一组是移位操作。这类指令的第一个操作数是**移位量**，第二个操作数是要被移位的数（同时也是目的操作数）。

##### **移位量**

移位量可以通过两种方式指定：

1.  一个**立即数**。
2.  放在单字节寄存器 **`%cl`** 中。（对于可变移位量，指令集只允许使用 `%cl` 这一个特定的寄存器作为操作数。）

> **有效移位量**:
> 当使用 `%cl` 寄存器指定移位量时，实际的移位位数是由 `%cl` 的**低 `m` 位**决定的，其中 `2^m = w` (w 是要操作的数据的位数)。例如：
>
>   * `salb` (操作 8 位数据, w=8, m=3): 只看 `%cl` 的低 3 位，所以最大移位 7 位。
>   * `sall` (操作 32 位数据, w=32, m=5): 只看 `%cl` 的低 5 位，所以最大移位 31 位。
>   * `salq` (操作 64 位数据, w=64, m=6): 只看 `%cl` 的低 6 位，所以最大移位 63 位。

##### **移位指令类型**

  * **左移 (`SAL` 和 `SHL`)**:

      * `SAL` (Shift Arithmetic Left) 和 `SHL` (Shift Logical Left) 是两条名字不同但**效果完全相同**的指令。
      * 它们都执行**逻辑左移**，即把位向左移动，然后在右边填上 0。

  * **右移 (`SAR` 和 `SHR`)**:

      * **`SAR`** (Shift **Arithmetic** Right): 执行**算术右移**。它在左边填充的是**符号位**（即原始数据的最高位）。这保留了有符号数的正负性质。
      * **`SHR`** (Shift **Logical** Right): 执行**逻辑右移**。它在左边**总是填充 0**。

**示例**:
假设 8 位寄存器 `%al` 的值为 `10100100` (一个负数)

```s
sarb $1, %al   ; 算术右移 1 位 -> %al = 11010010 (左边用符号位 1 填充)

# 重新假设 %al 的值为 10100100
shrb $1, %al   ; 逻辑右移 1 位 -> %al = 01010010 (左边用 0 填充)
```

移位操作的目的操作数可以是一个寄存器或是一个内存位置。

[[示例解读2]]

#### **3.5.4 讨论**

我们看到，图 3-10 中列出的大多数指令，既可以用于无符号运算，也可以用于补码（有符号）运算。只有**右移**操作要求区分有符号数 (`SAR`) 和无符号数 (`SHR`)。这个特性是补码成为实现有符号整数运算的一种优秀方法的原因之一。

下图给出了一个执行算术操作的函数示例，以及它的汇编代码。

**图 3-11：算术运算函数的 C 语言和汇编代码**

a) C 语言代码

```c
long arith(long x, long y, long z)
{
    long t1 = x ^ y; // 原文此处为 x - y，根据汇编代码应为 x ^ y
    long t2 = z * 48;
    long t3 = t1 & 0x0F0F0F0F;
    long t4 = t2 - t3;
    return t4;
}
```

b) 汇编代码

```s
// x in %rdi, y in %rsi, z in %rdx
arith:
    xorq    %rsi, %rdi        // t1 = x ^ y (结果存入 %rdi)
    leaq    (%rdx, %rdx, 2), %rax // %rax = z + 2*z = 3*z
    salq    $4, %rax          // %rax = %rax << 4  => 16 * (3*z) = 48*z. t2 = 48*z
    andq    $252645135, %rdi  // t3 = t1 & 0x0F0F0F0F (252645135 的十六进制是 0F0F0F0F)
    subq    %rdi, %rax        // %rax = %rax - %rdi  => t4 = t2 - t3
    ret                       // 返回 %rax 中的结果
```

> **原文注**: 原文 C 代码中第一行为 `long t1 = x - y;`，但这与生成的汇编代码第一行 `xorq` (异或) 不符。根据汇编代码的行为，C 代码应为 `long t1 = x ^ y;`。


#### **3.5.5 特殊的算术操作**

x86-64 指令集提供了一些特殊指令，用于支持产生 128 位乘积的乘法以及 128 位除法。

**图 3-12：特殊的算术操作**

| 指令        | 效果                                                                   | 描述     |
| :-------- | :------------------------------------------------------------------- | :----- |
| `imulq` S | `R[%rdx]:R[%rax] <- S * R[%rax]`                                     | 有符号全乘法 |
| `mulq` S  | `R[%rdx]:R[%rax] <- S * R[%rax]`                                     | 无符号全乘法 |
| `clto`    | `R[%rdx]:R[%rax] <- SignExtend(R[%rax])`                             | 转换为八字  |
| `idivq` S | `R[%rax] <- R[%rdx]:R[%rax] / S`<br>`R[%rdx] <- R[%rdx]:R[%rax] % S` | 有符号除法  |
| `divq` S  | `R[%rax] <- R[%rdx]:R[%rax] / S`<br>`R[%rdx] <- R[%rdx]:R[%rax] % S` | 无符号除法  |

##### **128位乘法**

x86-64 提供了两条“单操作数”乘法指令来计算两个 64 位值的全 128 位乘积：`mulq` (无符号) 和 `imulq` (有符号)。

  * **机制**: 这两条指令都要求一个操作数必须在寄存器 `%rax` 中，另一个作为指令的源操作数。乘积的结果会存放在 `%rdx` (高 64 位) 和 `%rax` (低 64 位) 两个寄存器中。

**示例 C 代码 (使用 GCC 扩展)**:

```c
#include <inttypes.h>

// 使用 GCC 的 __int128 类型
typedef unsigned __int128 uint128_t;

void store_uprod(uint128_t *dest, uint64_t x, uint64_t y) {
    *dest = x * (uint128_t) y;
}
```

**生成的汇编代码**:

```s
// dest in %rdi, x in %rsi, y in %rdx
store_uprod:
    movq    %rsi, %rax      // 将 x 复制到被乘数寄存器 %rax
    mulq    %rdx            // 乘以 y (%rdx)
    movq    %rax, (%rdi)    // 将乘积的低 8 字节存入 dest
    movq    %rdx, 8(%rdi)   // 将乘积的高 8 字节存入 dest+8
    ret
```

##### **128位除法**

`idivq` (有符号) 和 `divq` (无符号) 指令将 `%rdx` (高64位) 和 `%rax` (低64位) 拼接成的 128 位数作为被除数，指令的源操作数作为除数。

  * **商**存储在 `%rax` 中。
  * **余数**存储在 `%rdx` 中。

对于大多数 64 位除法应用来说，被除数也常常是一个 64 位的值。在这种情况下，需要将 64 位的被除数扩展到 128 位：

  * **有符号除法**: 将 64 位被除数放入 `%rax`，然后使用 **`cqto`** 指令将其符号位扩展到 `%rdx` 的所有位。
  * **无符号除法**: 将 64 位被除数放入 `%rax`，然后将 `%rdx` **手动置为 0**。

**示例 C 代码 (有符号除法)**:

```c
void remdiv(long x, long y, long *qp, long *rp) {
    long q = x/y;
    long r = x%y;
    *qp = q;
*rp = r;
}
```

**生成的汇编代码**:

```s
// x in %rdi, y in %rsi, qp in %rdx, rp in %rcx
remdiv:
    movq    %rdx, %r8         // 备份 qp 的地址，因为 %rdx 将被用作余数
    movq    %rdi, %rax        // 将被除数 x 移入 %rax
    cqto                      // 将 %rax 符号扩展到 %rdx, 形成 128 位被除数
    idivq   %rsi              // 除以 y (%rsi)
    movq    %rax, (%r8)       // 将商 (%rax) 存入 qp
    movq    %rdx, (%rcx)      // 将余数 (%rdx) 存入 rp
    ret
```

-----