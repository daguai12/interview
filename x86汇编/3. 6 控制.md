### **3.6 控制**

C 语言中的条件语句、循环和分支等结构，要求根据数据测试的结果来决定操作的执行顺序。机器代码通过**跳转 (jump)** 指令来实现这种有条件的控制流。跳转指令可以改变机器代码指令的默认执行顺序，将控制权传递到程序的某个其他部分。

---
#### **3.6.1 条件码**

除了整数寄存器，CPU 还维护着一组单个位的**条件码 (condition code)** 寄存器，它们描述了最近的算术或逻辑操作的属性。条件分支指令会检测这些寄存器来决定是否进行跳转。

最常用的条件码有：
* **`CF` (Carry Flag - 进位标志)**: 最近的操作使最高位产生了进位。可用来检查**无符号**操作的溢出。
* **`ZF` (Zero Flag - 零标志)**: 最近的操作得出的结果为 0。
* **`SF` (Sign Flag - 符号标志)**: 最近的操作得到的结果为负数（即最高位为 1）。
* **`OF` (Overflow Flag - 溢出标志)**: 最近的操作导致一个**补码（有符号）溢出**——正溢出或负溢出。

例如，假设我们用一条 `ADD` 指令完成 `t = a + b`，那么条件码会根据以下情况设置：
* **`CF`**: `(unsigned) t < (unsigned) a` (发生了无符号溢出)
* **`ZF`**: `t == 0`
* **`SF`**: `t < 0` (结果为负)
* **`OF`**: `(a<0 == b<0) && (t<0 != a<0)` (两个负数相加得正，或两个正数相加得负，即有符号溢出)

> **注意**: `leaq` 指令不改变任何条件码。除了 `leaq` 之外，之前列出的所有算术和逻辑指令都会设置条件码。

##### **`CMP` 和 `TEST` 指令**

有两类指令，它们只设置条件码而不改变任何其他寄存器。

**图 3-13：比较和测试指令**

| 指令            | 基于        | 描述  |
| :------------ | :-------- | :-- |
| `CMP` S1, S2  | `S2 - S1` | 比较  |
| `TEST` S1, S2 | `S1 & S2` | 测试  |

* **`CMP` 指令**:
    * 行为与 `SUB` 指令类似，它根据两个操作数之差 `S2 - S1` 来设置条件码。
    * 但它**不会**更新目的寄存器 `S2` 的值，只是简单地丢弃计算结果。
    * 例如，如果 `S1 == S2`，那么差为 0，`ZF` (零标志) 会被置为 1。

* **`TEST` 指令**:
    * 行为与 `AND` 指令类似，它根据两个操作数的**按位与**结果来设置条件码。
    * 它也**不会**更新目的寄存器的值。
    * **典型用法**:
        1.  `testq %rax, %rax`: 用来检查 `%rax` 的值。如果结果为 0，则 `ZF` 置 1；如果结果为负，则 `SF` 置 1。
        2.  使用一个操作数作为**掩码**，来指示需要测试另一个操作数中的哪些位。
		3.  CF 和 OF会一直**清0**

[[示例解读3]]

#### **3.6.2 访问条件码**

条件码通常不会被直接读取，常用的使用方法有三种：

1.  根据条件码的某种组合，将一个字节设置为 0 或者 1。
2.  条件跳转到程序的某个其他的部分。
3.  有条件地传送数据。

本节主要讨论第一种情况，它由 `SET` 指令类实现。

##### **`SET` 指令**

`SET` 指令类根据条件码的某种组合，将一个目标字节设置为 0 或者 1。这些指令名字的不同后缀指明了它们所考虑的条件，**而不是操作数大小**。例如，`setl` 表示“小于时设置 (set if less)”，而不是“设置长字 (set long)”。

一条 `SET` 指令的目的操作数是低位单字节寄存器（如 `%al`）或一个单字节的内存位置。为了得到一个 32 位或 64 位的结果，通常必须对这个字节进行零扩展。

一个计算 C 表达式 `a < b` 的典型指令序列如下所示（假设 a 和 b 都是 `long` 类型）：

```s
// a in %rdi, b in %rsi
    cmpq    %rsi, %rdi      // 比较 a 和 b (计算 a - b)
    setl    %al             // 如果 a < b (有符号比较)，则设置 %al 为 1, 否则为 0
    movzbl  %al, %eax       // 将 %al (1字节) 零扩展到 %eax (4字节)，同时 %rax 的高4字节被清零
```

下表列出了 `SET` 指令的完整集合。

**图 3-14：`SET` 指令**

| 指令        | 同义名      | 效果                    | 描述              |                 |
| :-------- | :------- | :-------------------- | :-------------- | --------------- |
| `sete` D  | `setz`   | `D <- ZF`             | 相等 / 零          |                 |
| `setne` D | `setnz`  | `D <- ~ZF`            | 不等 / 非零         |                 |
| `sets` D  |          | `D <- SF`             | 负数              |                 |
| `setns` D |          | `D <- ~SF`            | 非负数             |                 |
| `setg` D  | `setnle` | `D <- ~(SF^OF) & ~ZF` | 大于 (有符号 \>)     |                 |
| `setge` D | `setnl`  | `D <- ~(SF^OF)`       | 大于等于 (有符号 \>=)  |                 |
| `setl` D  | `setnge` | `D <- SF^OF`          | 小于 (有符号 \<)     |                 |
| `setle` D | `setng`  | `D <- (SF^OF)         | ZF`             | 小于等于 (有符号 \<=)  |
| `seta` D  | `setnbe` | `D <- ~CF & ~ZF`      | 超过 (无符号 \>)     |                 |
| `setae` D | `setnb`  | `D <- ~CF`            | 超过或相等 (无符号 \>=) |                 |
| `setb` D  | `setnae` | `D <- CF`             | 低于 (无符号 \<)     |                 |
| `setbe` D | `setna`  | `D <- CF              | ZF`             | 低于或相等 (无符号 \<=) |

##### **条件码组合的逻辑**

`SET` 指令的判断逻辑基于 `CMP S1, S2` (计算 `S2 - S1`) 指令设置的条件码：

  * **相等比较 (`sete`)**: 基于**零标志位 (ZF)**。如果 `S2 - S1 = 0`，则 `ZF` 被置位。
  * **有符号比较 (`setl`, `setg`, etc.)**: 基于**符号标志位 (SF)** 和**溢出标志位 (OF)** 的组合。例如，对于 `setl` (小于)，当且仅当 `SF ^ OF` (符号位和溢出位的异或) 为 1 时，才判定为“小于”。
  * **无符号比较 (`setb`, `seta`, etc.)**: 基于**进位标志位 (CF)** 和**零标志位 (ZF)** 的组合。例如，对于 `setb` (低于)，当 `CMP` 操作产生一个进位（借位）时，`CF` 会被置位，表示无符号数 `S2 < S1`。

**案例**

好的，我们来为这段C语言代码生成对应的x86-64汇编指令。这是一个绝佳的例子，因为它完美地展示了我们刚刚讨论过的 `CMP` -\> `SET` -\> `MOVZ` 这个经典的三步模式。

 **C 语言代码**

```c
// 假设 a 和 b 是 64 位有符号整数 (long)
long a = 100;
long b = 50;
bool result = (a > b); 
```

**汇编实现**

在真实的程序中，`a` 和 `b` 的值会作为函数参数传入，或者从内存中加载。根据标准的x86-64调用约定（System V AMD64 ABI），函数的前两个整数/指针参数分别通过 `%rdi` 和 `%rsi` 寄存器传递。函数的返回值则通过 `%rax` 寄存器返回。

因此，我们可以将上述代码看作一个函数的核心逻辑：

```c
bool is_a_greater_than_b(long a, long b) {  // a 在 %rdi, b 在 %rsi
    return a > b;
}
```

下面是这个函数对应的汇编代码：

```s
# 假设 a 的值 100 在 %rdi 寄存器中
# 假设 b 的值 50 在 %rsi 寄存器中

is_a_greater_than_b:
    # 第 1 步: 提问 - 使用 CMP 比较 a 和 b
    # cmpq S1, S2 计算的是 S2 - S1
    # 为了计算 a - b, 我们使用 cmpq %rsi, %rdi
    cmpq    %rsi, %rdi              # 计算 %rdi - %rsi (即 a - b), 并设置条件码

    # 第 2 步: 回答 - 使用 SET 根据条件码设置一个字节
    # 我们需要判断 "大于" (Greater), 所以使用 setg
    # 目的操作数通常是 %al (rax 的低 8 位)
    setg    %al                     # 如果 a > b (ZF=0 且 SF=OF), 则将 %al 设置为 1, 否则设置为 0

    # 第 3 步: 格式化 - 将单字节的布尔值转换为标准的函数返回值
    # bool 类型的 true 在 C 中是 1。函数返回值应存放在 %rax 中。
    # 为了确保 %rax 的高位是干净的 0, 我们使用 movzbl
    movzbl  %al, %eax               # 将 %al (1字节) 零扩展到 %eax (4字节)。
                                    # 这会将 %eax 设置为 0x00000000 或 0x00000001,
                                    # 并且根据x86-64规则，%rax 的高32位也会被自动清零。

    ret                             # 函数返回，返回值在 %rax 中
```

**逐行讲解**

1.  `cmpq %rsi, %rdi`

      * **作用**：执行比较。它从 `%rdi` (a) 中减去 `%rsi` (b) 的值，即 `100 - 50`。
      * **结果**：计算结果是 `50`。CPU根据这个结果设置内部的标志位：`ZF=0` (因为结果不是0)，`SF=0` (因为结果是正数)，`OF=0` (没有溢出)。
      * **注意**：这一步**不修改** `%rdi` 或 `%rsi` 的内容，只改变标志位。

2.  `setg %al`

      * **作用**：根据标志位生成布尔结果。`g` 代表 "Greater" (有符号大于)。
      * **逻辑**：它检查的条件是 `(ZF == 0) && (SF == OF)`。
      * **判断**：根据上一步设置的标志位，`(0 == 0) && (0 == 0)` 的结果为**真**。
      * **结果**：因为条件为真，`setg` 指令将它的目的操作数——单字节寄存器 `%al`——设置为 `1`。

3.  `movzbl %al, %eax`

      * **作用**：将结果格式化为标准的整数 `1`。
      * **逻辑**：`movzbl` (Move Zero-Extend Byte to Long) 读取 `%al` 中的 `1`，并将其放入 `%eax`，同时用 `0` 填充 `%eax` 的高 24 位。
      * **结果**：`%eax` 的值变为 `0x00000001`。由于任何对 32 位寄存器 `%eax` 的写入都会自动清零其对应的 64 位寄存器 `%rax` 的高 32 位，因此 `%rax` 的值现在就是 `1`。
      * 这是一个非常标准和健壮的做法，确保了返回值的干净。

4.  `ret`

      * **作用**：函数返回。调用者（caller）会从 `%rax` 寄存器中读取返回值，得到 `1`，这在 C 语言中就代表 `true`。

这三条核心指令 `cmpq`, `setg`, `movzbl` 共同构成了一个高效、标准的模式，用于在汇编层面实现高级语言中的比较和布尔逻辑。
[[示例解读3]]

-----

#### **3.6.3 跳转指令**

正常情况下，指令是按照它们在程序中出现的顺序一条一条地执行。**跳转 (jump)** 指令会改变这种顺序执行的控制流，导致执行切换到程序中一个全新的位置。在汇编代码中，这些跳转的目的地通常用一个**标号 (label)** 指明。

例如：

```s
    movq $0, %rax
    jmp  .L1            // 跳转到标号 .L1
    movq (%rax), %rdx   // 这条指令会被跳过，不会执行
.L1:
    popq %rdx           // 程序从这里继续执行
```

`jmp` 指令是**无条件跳转**。除此之外，还有很多**有条件跳转**指令，它们会根据条件码的状态来决定是否进行跳转。

##### **跳转指令的类型**

  * **直接跳转 (Direct Jump)**:
    跳转的目标地址是作为指令的一部分编码的。在汇编中，这表现为跳转到一个标号（如 `jmp .L1`）。

  * **间接跳转 (Indirect Jump)**:
    跳转的目标地址是从寄存器或内存位置中读出的。其写法是 `*` 后面跟一个操作数指示符。

      * 示例 1: `jmp *%rax` (用寄存器 `%rax` 中的值作为跳转目标地址)
      * 示例 2: `jmp *(%rax)` (从内存中读出跳转目标地址，该内存的地址存放在 `%rax` 中)

> **注意**: **条件跳转**指令只能是**直接跳转**。

##### **跳转指令表**

下表（对应原文图 3-15）列举了不同的跳转指令。这些指令的条件与上一节的 `SET` 指令是相匹配的。

| 指令          | 同义名     | 跳转条件             | 描述             |
| :---------- | :------ | :--------------- | :------------- |
| `jmp Label` |         | `1`              | 直接跳转           |
| `jmp *Op`   |         | `1`              | 间接跳转           |
|             |         |                  | **有符号比较**      |
| `je Label`  | `jz`    | `ZF`             | 相等 / 零         |
| `jne Label` | `jnz`   | `~ZF`            | 不等 / 非零        |
| `js Label`  |         | `SF`             | 负数             |
| `jns Label` |         | `~SF`            | 非负数            |
| `jg Label`  | `jnle`  | `~(SF^OF) & ~ZF` | 大于 (\>)        |
| `jge Label` | `jnl`   | `~(SF^OF)`       | 大于等于 (\>=)     |
| `jl Label`  | `jnge`  | `SF^OF`          | 小于 (\<)        |
| `jle Label` | `jng`   | `(SF^OF) \| ZF`  | 小于等于 (\<=)     |
|             |         |                  | **无符号比较**      |
| `ja Label`  | `jnbe`  | `~CF & ~ZF`      | 超过 (above, \>) |
| `jae Label` | `jnb`   | `~CF`            | 超过或相等 (\>=)    |
| `jb Label`  | `jnae`  | `CF`             | 低于 (below, \<) |
| `jbe Label` | `setna` | `CF \| ZF`       | 低于或相等 (\<=)    |

[[示例解读3]]

#### **3.6.4 跳转指令的编码**

在汇编代码中，跳转目标用符号标号书写。汇编器和链接器负责将这些标号转换为目标指令的实际地址。跳转指令主要有两种编码方式：

1.  **PC 相对的 (PC-relative)**: 这是最常用的方式。指令中存储的不是目标的绝对地址，而是**目标地址**与**跳转指令之后那条指令的地址**之间的**差值（偏移量）**。
2.  **绝对地址**: 指令中直接用 4 个字节编码目标的完整地址。

##### **PC 相对寻址示例**

我们来看一段汇编代码及其反汇编后的字节编码：

**原始汇编代码**:

```s
movq    %rdi, %rax
jmp     .L2
.L3:
sarq    %rax
.L2:
testq   %rax, %rax
jg      .L3
rep; ret
```

**反汇编后的目标代码 (`.o` 文件)**:

```
       0:   48 89 f8                mov    %rdi,%rax
       3:   eb 03                   jmp    8 <loop+0x8>
       5:   48 d1 f8                sar    %rax
       8:   48 85 c0                test   %rax,%rax
       b:   7f f8                   jg     5 <loop+0x5>
       d:   f3 c3                   repz retq
```

**编码解析**:

  * **前向跳转 (第 2 行)**:

      * 跳转指令 `jmp` 位于地址 `0x3`，它之后的指令位于地址 `0x5`。
      * 跳转的目标是地址 `0x8`。
      * 字节编码是 `eb 03`。其中 `03` 就是偏移量。
      * **计算**: `下一条指令的地址 + 偏移量 = 目标地址` -\> `0x5 + 0x3 = 0x8`。计算正确。

  * **后向跳转 (第 5 行)**:

      * 跳转指令 `jg` 位于地址 `0xb`，它之后的指令位于地址 `0xd`。
      * 跳转的目标是地址 `0x5`。
      * 字节编码是 `7f f8`。其中 `f8` 是 `-8` 的补码表示。
      * **计算**: `0xd + (-8) = 0x5`。计算正确。

**PC 相对寻址的优点**:

1.  **编码简洁**: 偏移量通常只需要 1 或 2 个字节，比绝对地址更短。
2.  **位置无关**: 因为目标地址是相对的，所以这段代码可以被加载到内存中的任何位置，而**无需修改跳转指令的编码**，这使得代码的重定位变得非常简单。

-----

##### **关于 `rep; ret` 的注解**

在上面的反汇编代码中，我们看到了 `repz retq` 指令。`rep` 指令通常用于重复的字符串操作，但在这里的用途很特别。

这是 AMD 处理器的一个**性能优化**建议。处理器有分支预测逻辑，但当 `ret` 指令成为一个条件跳转的目标时（如此例中 `jg` 不跳转就会执行 `ret`），某些处理器的分支预测可能会失败。

`rep` 指令在这里被用作一个事实上的**空操作 (no-op)**。通过让条件跳转的目标指向 `rep` 而不是直接指向 `ret`，可以帮助处理器正确地预测返回地址，从而提高性能。当您在阅读汇编代码时看到紧跟在 `ret` 之前的 `rep` 或 `repz` 时，可以放心地忽略它。

[[示例解读3]]
#### **3.6.5 用条件控制来实现条件分支**

将 C 语言中的条件表达式和语句（如 `if-else`）翻译成机器代码，最常用的方式是结合使用**有条件跳转**和**无条件跳转**。

##### **示例：`if-else` 语句的编译**

我们通过一个计算两数之差绝对值的函数 `absdiff_se` 来观察编译器是如何工作的。

**图 3-16：条件语句的编译**

**a) 原始的 C 语言代码**

```c
long lt_cnt = 0;
long ge_cnt = 0;

long absdiff_se(long x, long y)
{
    long result;
    if (x < y) {
        lt_cnt++;
        result = y - x;
    } else {
        ge_cnt++;
        result = x - y;
    }
    return result;
}
```

**b) 与之等价的 `goto` 版本**
下面的 C 代码使用 `goto` 语句来精确模拟汇编代码的控制流。虽然 `goto` 通常被认为是不好的编程风格，但它能帮助我们理解机器代码的逻辑。

```c
long gotodiff_se(long x, long y)
{
    long result;
    if (x >= y)         // 测试 if 条件的 *相反* 条件
        goto x_ge_y;    // 如果相反条件为真，则跳转到 else 部分
    
    // "then" 块
    lt_cnt++;
    result = y - x;
    return result;

x_ge_y: // "else" 块的标号
    ge_cnt++;
    result = x - y;
    return result;
}
```

**c) 产生的汇编代码**

```s
// x in %rdi, y in %rsi
absdiff_se:
    cmpq    %rsi, %rdi      // 比较 x:y (计算 x - y)
    jge     .L2             // 如果 x >= y (jge)，则跳转到 .L2 标号
    
    // "then" 块 (x < y)
    addq    $1, lt_cnt(%rip)
    movq    %rsi, %rax
    subq    %rdi, %rax
    ret

.L2:                        // "else" 块 (x >= y) 的标号，对应 goto 版本的 x_ge_y
    addq    $1, ge_cnt(%rip)
    movq    %rdi, %rax
    subq    %rsi, %rax
    ret
```

可以看到，汇编代码的控制流与 `goto` 版本的 C 代码非常相似。它首先比较两个操作数，如果条件 `x >= y` 成立，就直接跳转到处理 `else` 逻辑的代码块。

-----

##### **`if-else` 语句的通用编译模式**

对于 C 语言中通用的 `if-else` 语句形式：

```c
if (test-expr)
    then-statement
else
    else-statement
```

汇编实现通常会采用下面这种“goto 代码”的逻辑模式：

```c
    t = test-expr;
    if (!t)             // 测试 test-expr 的 *相反* 条件
        goto false;     // 如果相反条件为真，跳转到 else 部分
    
    then-statement      // 否则，顺序执行 then 部分
    goto done;          // 执行完后，无条件跳转到末尾，跳过 else 部分

false:
    else-statement      // else 部分的代码

done:
    // ... 继续执行
```

也就是说，编译器会为 `then` 块和 `else` 块分别产生代码，然后插入条件和无条件跳转，以保证在任何情况下都只执行正确的代码块。

#### **3.6.6 用条件传送来实现条件分支**

实现条件操作的传统方法是通过使用**控制的条件转移**（即条件跳转）。当条件满足时，程序沿着一条执行路径执行；不满足时，走另一条路径。这种机制在现代处理器上可能会因为**分支预测错误**而变得非常低效。

一种替代的策略是使用**数据的条件转移**。这种方法会计算一个条件操作的**两种结果**，然后再根据条件是否满足，从中选取一个正确的结果。如果可行，这种策略可以用一条简单的**条件传送指令**来实现，它更符合现代处理器的性能特性。

##### **示例：`if-else` 与条件传送**

我们来看一个不带副作用的 `absdiff` 函数。

**图 3-17：使用条件赋值的条件语句编译**

**a) 原始的 C 语言代码**

```c
long absdiff(long x, long y)
{
    long result;
    if (x < y)
        result = y - x;
    else
        result = x - y;
    return result;
}
```

**b) 使用条件赋值的 C 语言实现 (模拟汇编)**

```c
long cmovdiff(long x, long y)
{
    long rval = y - x; // "then" 表达式的结果
    long eval = x - y; // "else" 表达式的结果
    long ntest = x >= y;
    
    // 如果 ntest 为真，则将 eval 赋值给 rval
    if (ntest) rval = eval; 
    
    return rval;
}
```

**c) 产生的汇编代码**

```s
// x in %rdi, y in %rsi
absdiff:
    movq    %rsi, %rax      // rax = y
    subq    %rdi, %rax      // rax = y - x (这是 rval)
    movq    %rdi, %rdx      // rdx = x
    subq    %rsi, %rdx      // rdx = x - y (这是 eval)
    cmpq    %rsi, %rdi      // 比较 x:y
    cmovge  %rdx, %rax      // 如果 x >= y (ge)，则 rval = eval (即 %rax = %rdx)
    ret                     // 返回 rval (%rax)
```

可以看到，汇编代码计算了 `if` 和 `else` 两种情况的结果，然后使用一条 `cmovge`（大于或等于时条件传送）指令，根据比较结果选择正确的值放入返回寄存器 `%rax`，全程**没有发生跳转**。

-----

##### **流水线与分支预测错误代价**

现代处理器通过**流水线 (pipelining)** 来获得高性能，即重叠连续指令的执行步骤。但当机器遇到**条件跳转**时，只有当分支条件求值完成之后，才能决定接下来该执行哪条指令，这会打断流水线。

为了解决这个问题，处理器采用非常精密的**分支预测逻辑**来猜测跳转指令是否会执行。

  * **预测正确**: 流水线继续充满指令，性能很高。
  * **预测错误**: 处理器必须丢掉它在错误路径上已做的所有工作，然后重新用正确位置的指令去填充流水线。这样一个错误预测会招致很严重的性能惩罚（通常浪费 15-30 个时钟周期）。

对于不可预测的分支（例如，随机数据），分支预测错误率约为 50%，这会导致程序性能严重下降。而使用条件传送的代码，由于没有跳转，其执行时间是恒定的，不受数据模式的影响，从而避免了这种性能惩罚。

-----

##### **条件传送指令 (`CMOV`)**

图 3-18 列举了 x86-64 上可用的条件传送指令。每条指令都有两个操作数：源 `S`（寄存器或内存）和目的 `R`（必须是寄存器）。只有在指定的条件码满足时，源值才会被复制到目的寄存器中。

**图 3-18：条件传送指令**

| 指令 | 同义名 | 传送条件 | 描述 |
| :--- | :--- | :--- | :--- |
|`cmove` S,R | `cmovz` | `ZF` | 相等 / 零 |
|`cmovne` S,R| `cmovnz`| `~ZF` | 不等 / 非零 |
|`cmovs` S,R | | `SF` | 负数 |
|`cmovns` S,R| | `~SF` | 非负数 |
|... | ... | ... | (与 `SET` 和 `JUMP` 指令的条件相同) |

-----

#### **条件传送的局限性**

不是所有的条件表达式都可以用条件传送来编译。

  * **核心原则**: 使用条件传送时，`if` 和 `else` 两个分支的表达式**都会被求值**。

这就带来了两个重要的局限性：

1.  **不能有副作用或潜在错误**:

      * 如果任一分支表达式有副作用（例如 `lt_cnt++`），或者可能产生错误（例如解引用一个可能为空的指针），那么就不能使用条件传送。
      * **示例**:
        ```c
        long cread(long *xp) {
            return (xp ? *xp : 0); // 如果 xp 为 NULL，*xp 会导致段错误
        }
        ```
        如果用条件传送编译，`*xp` 这个操作**总会被执行**，即使 `xp` 是 `NULL`，从而导致程序崩溃。因此，这种情况必须用条件跳转来编译。

2.  **计算开销权衡**:

      * 如果 `if` 或 `else` 分支的计算量非常大，而分支预测的成功率又很高，那么总是计算两个分支的代价，可能比偶尔一次分支预测错误的代价还要高。
      * 编译器会根据一些启发式规则（通常是当两个分支的计算都很简单时）来决定是否使用条件传送。

### **3.6.7 循环**

C 语言提供了多种循环结构，即 `do-while`、`while` 和 `for`。汇编中没有相应的指令，但可以用条件测试和跳转组合起来实现循环的效果。GCC 主要基于两种基本的循环模式来生成代码。

-----

#### **1. do-while 循环**

`do-while` 语句的通用形式如下：

```c
do
    body-statement
while (test-expr);
```

它的效果是重复执行 `body-statement`，然后对 `test-expr` 求值，如果结果为非零，就继续循环。`body-statement` 至少会执行一次。

这种通用形式可以被翻译成如下所示的 `goto` 语句：

```c
loop:
    body-statement
    t = test-expr;
    if (t)
        goto loop;
```

**示例：`do-while` 版本的阶乘函数**

**图 3-19：阶乘程序的 `do-while` 版本**

a) C 代码

```c
long fact_do(long n)
{
    long result = 1;
    do {
        result *= n;
        n = n - 1;
    } while (n > 1);
    return result;
}
```

b) 等价的 `goto` 版本

```c
long fact_do_goto(long n)
{
    long result = 1;
loop:
    result *= n;
    n = n - 1;
    if (n > 1)
        goto loop;
    return result;
}
```

c) 对应的汇编代码

```s
// n in %rdi
fact_do:
    movl    $1, %eax        // Set result = 1
.L2:                        // loop:
    imulq   %rdi, %rax      //   Compute result *= n
    subq    $1, %rdi        //   Decrement n
    cmpq    $1, %rdi        //   Compare n : 1
    jg      .L2             //   If >, goto loop
    rep; ret                // Return
```

汇编代码的结构与 `goto` 版本几乎完全一致。

#### **2. while 循环**

`while` 语句的通用形式如下：

```c
while (test-expr)
    body-statement
```

它与 `do-while` 的不同之处在于，在第一次执行循环体之前，就会对测试条件求值。GCC 在代码生成中使用两种方法来翻译 `while` 循环。

##### **方法一：跳转到中间 (Jump to Middle)**

这种方法执行一个无条件跳转，跳到循环结尾处的测试，以此来执行初始测试。

```c
// goto 代码模板
    goto test;
loop:
    body-statement
test:
    t = test-expr;
    if (t)
        goto loop;
```

**示例：`while` 版本的阶乘函数 (`-Og` 优化等级)**

**图 3-20：使用跳转到中间翻译方法的 `while` 循环**
a) C 代码

```c
long fact_while(long n)
{
    long result = 1;
    while (n > 1) {
        result *= n;
        n = n - 1;
    }
    return result;
}
```

c) 对应的汇编代码

```s
// n in %rdi
fact_while:
    movl    $1, %eax        // Set result = 1
    jmp     .L5             // Goto test
.L6:                        // loop:
    imulq   %rdi, %rax      //   Compute result *= n
    subq    $1, %rdi        //   Decrement n
.L5:                        // test:
    cmpq    $1, %rdi        //   Compare n : 1
    jg      .L6             //   If >, goto loop
    rep; ret                // Return
```

##### **方法二：Guarded-do**

这种方法首先用一个条件分支，如果初始条件不成立就跳过整个循环，否则就进入一个标准的 `do-while` 结构。当使用较高优化等级（如 `-O1`）编译时，GCC 会采用这种策略。

```c
// goto 代码模板
    t = test-expr;
    if (!t)
        goto done;
loop:
    body-statement
    t = test-expr;
    if (t)
        goto loop;
done:
```

**示例：`while` 版本的阶乘函数 (`-O1` 优化等级)**

**图 3-21：使用 `guarded-do` 翻译方法的 `while` 循环**
c) 对应的汇编代码

```s
// n in %rdi
fact_while:
    cmpq    $1, %rdi        // Compare n : 1
    jle     .L7             // If <=, goto done
    movl    $1, %eax        // Set result = 1
.L6:                        // loop:
    imulq   %rdi, %rax      //   Compute result *= n
    subq    $1, %rdi        //   Decrement n
    cmpq    $1, %rdi        //   Compare n : 1
    jne     .L6             //   If !=, goto loop
    rep; ret                // Return
.L7:                        // done:
    movl    $1, %eax        //   Compute result = 1
    ret                     // Return
```

-----

#### **3. for 循环**

`for` 循环的通用形式如下：

```c
for (init-expr; test-expr; update-expr)
    body-statement
```

这个循环的行为与下面这段使用 `while` 循环的代码的行为一样：

```c
init-expr;
while (test-expr) {
    body-statement
    update-expr;
}
```

因此，GCC 为 `for` 循环产生的代码就是 `while` 循环的两种翻译方法之一，具体取决于优化等级。



#### **3.6.8 switch 语句**

`switch`（开关）语句可以根据一个整数索引值进行**多重分支 (multi-way branching)**。在处理具有多种可能结果的测试时，这种语句不仅能提高 C 代码的可读性，而且可以通过使用一种名为**跳转表 (jump table)** 的数据结构使得实现更加高效。

跳转表是一个数组，表项 `i` 是一个代码段的地址，这个代码段实现了当开关索引值等于 `i` 时程序应该采取的动作。程序代码用开关索引值来执行一个跳转表内的数组引用，从而确定跳转指令的目标。

和使用一组很长的 `if-else` 语句相比，使用跳转表的优点是**执行 `switch` 语句的时间与开关情况的数量无关**。GCC 会根据开关情况的数量和值的稀疏程度来决定是否使用跳转表（通常在情况数量较多且值的范围跨度较小时使用）。

##### **`switch` 语句示例与翻译**

**图 3-22**

**a) C 语言 `switch` 语句示例**
这个例子包含了一些有趣的特征：不连续的 case 值、多个标号对应同一代码块、以及 case 的“落入 (fall through)”。

```c
void switch_eg(long x, long n, long *dest)
{
    long val = x;
    switch (n) {
        case 100:
            val *= 13;
            break;
        case 102:
            val += 10;
            /* Fall through */
        case 103:
            val += 11;
            break;
        case 104:
        case 106:
            val *= val;
            break;
        default:
            val = 0;
    }
    *dest = val;
}
```

**b) 翻译到扩展的 C 语言 (模拟汇编逻辑)**
下面的代码使用了 GCC 的扩展（计算 `goto` 和 `&&` 取标号地址运算符）来模拟编译器如何使用跳转表。

```c
void switch_eg_impl(long x, long n, long *dest)
{
    // 跳转表，一个包含7个代码指针的数组
    static void *jt[7] = {
        &&loc_A, &&loc_def, &&loc_B, &&loc_C,
        &&loc_D, &&loc_def, &&loc_D
    };

    // 将 n 的值范围移到 0-6
    unsigned long index = n - 100;
    long val;

    if (index > 6)      // 范围检查，超出则跳到 default
        goto loc_def;

    goto *jt[index];    // 使用计算出的 index 执行多路分支

loc_A:  /* Case 100 */
    val = x * 13;
    goto done;
loc_B:  /* Case 102 */
    x = x + 10;
    /* Fall through */
loc_C:  /* Case 103 */
    val = x + 11;
    goto done;
loc_D:  /* Cases 104, 106 */
    val = x * x;
    goto done;
loc_def:/* Default case */
    val = 0;
done:
    *dest = val;
}
```

##### **产生的汇编代码**

**图 3-23：`switch` 语句示例的汇编代码**

```s
// x in %rdi, n in %rsi, dest in %rdx
switch_eg:
    subq    $100, %rsi          // 计算 index = n - 100
    cmpq    $6, %rsi            // 比较 index: 6
    ja      .L8                 // 如果 > (无符号比较), 跳转到 default (loc_def)
    jmp     *.L4(,%rsi,8)       // 跳转到跳转表 jt[index]

.L3:    // loc_A (Case 100)
    leaq    (%rdi,%rdi,2), %rax
    leaq    (%rdi,%rax,4), %rdi // val = 13*x
    jmp     .L2

.L5:    // loc_B (Case 102)
    addq    $10, %rdi
    // (此处无 jmp, 直接落入 .L6)

.L6:    // loc_C (Case 103)
    addq    $11, %rdi           // val = x + 11
    jmp     .L2

.L7:    // loc_D (Cases 104, 106)
    imulq   %rdi, %rdi          // val = x * x
    jmp     .L2

.L8:    // loc_def (Default case)
    movl    $0, %edi            // val = 0

.L2:    // done:
    movq    %rdi, (%rdx)        // *dest = val
    ret
```

##### **汇编中的跳转表**

汇编代码中的跳转表用以下声明表示：

```s
    .section .rodata     // 只读数据段
    .align 8
.L4:                     // 跳转表的起始地址
    .quad .L3            // index 0 (case 100) -> loc_A
    .quad .L8            // index 1 (case 101) -> loc_def
    .quad .L5            // index 2 (case 102) -> loc_B
    .quad .L6            // index 3 (case 103) -> loc_C
    .quad .L7            // index 4 (case 104) -> loc_D
    .quad .L8            // index 5 (case 105) -> loc_def
    .quad .L7            // index 6 (case 106) -> loc_D
```

  * **`.quad`** 伪指令声明了一个 8 字节的值（一个地址）。
  * **间接跳转**: 汇编代码第 5 行的 `jmp *.L4(,%rsi,8)` 是执行 `switch` 的关键。它以 `.L4` 为基地址，`%rsi` (index) 为索引，`8` 为比例因子（因为每个地址是8字节），从跳转表中取出目标地址，然后跳转过去。
  * **处理方式**:
      * **重复情况** (case 104, 106): 简单地让表项 4 和 6 指向同一个代码标号 (`.L7`)。
      * **缺失情况** (case 101, 105): 让表项 1 和 5 指向 `default` 的代码标号 (`.L8`)。
      * **落入情况** (case 102 fall through to 103): 对应于标号 `.L5` 的代码块结尾处**没有** `jmp` 指令，因此执行会自然地“落”到下一个代码块 `.L6`。


# 案例

```asm
switch.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 <switch_eg>:
   0:	f3 0f 1e fa          	endbr64 
   4:	48 83 ee 64          	sub    $0x64,%rsi
   8:	48 83 fe 06          	cmp    $0x6,%rsi
   c:	77 2d                	ja     3b <switch_eg+0x3b>
   e:	48 8d 0d 00 00 00 00 	lea    0x0(%rip),%rcx        # 15 <switch_eg+0x15>
  15:	48 63 04 b1          	movslq (%rcx,%rsi,4),%rax
  19:	48 01 c8             	add    %rcx,%rax
  1c:	3e ff e0             	notrack jmp *%rax
  1f:	48 8d 04 7f          	lea    (%rdi,%rdi,2),%rax
  23:	48 8d 3c 87          	lea    (%rdi,%rax,4),%rdi
  27:	eb 08                	jmp    31 <switch_eg+0x31>
  29:	48 83 c7 0a          	add    $0xa,%rdi
  2d:	48 83 c7 0b          	add    $0xb,%rdi
  31:	48 89 3a             	mov    %rdi,(%rdx)
  34:	c3                   	ret    
  35:	48 0f af ff          	imul   %rdi,%rdi
  39:	eb f6                	jmp    31 <switch_eg+0x31>
  3b:	bf 00 00 00 00       	mov    $0x0,%edi
  40:	eb ef                	jmp    31 <switch_eg+0x31>

```
-----

### 整体结构分析

教科书的示例使用了一个简单、直接的跳转表，里面存放着**绝对地址**。而您的编译器生成的代码使用了一个更巧妙的跳转表，里面存放的是**相对偏移量 (offsets)**，并且在运行时动态计算出最终要跳转的绝对地址。

我们一步步来看它是如何工作的。

```s
// x in %rdi, n in %rsi, dest in %rdx
0000000000000000 <switch_eg>:
    0:  f3 0f 1e fa          endbr64 
```

  * **`endbr64`**: 这是现代 Linux 系统中的一项安全特性，叫做 **CET (Control-Flow Enforcement Technology)** 的一部分。它用来防止某些类型的代码注入攻击。在分析程序逻辑时，您可以把它看作一个“安全检查点”，可以暂时忽略它。

<!-- end list -->

```s
    4:  48 83 ee 64          sub    $0x64,%rsi
    8:  48 83 fe 06          cmp    $0x6,%rsi
    c:  77 2d                ja     3b <switch_eg+0x3b>
```

  * **`sub $0x64,%rsi`**: `0x64` 就是十进制的 100。这行代码计算 `index = n - 100`。**这与教科书版本完全相同**。
  * **`cmp $0x6,%rsi`**: 比较 `index` 和 `6`。**这也和教科书版本相同**。
  * **`ja 3b <switch_eg+0x3b>`**: `ja` (Jump if Above) 是无符号大于跳转。如果 `index > 6`，就跳转到地址 `0x3b`，也就是 `default` 分支。**这也和教科书版本相同**。

到目前为止，逻辑完全一致。**真正的区别从下一行开始**。

-----

### 核心：基于 RIP 的相对寻址跳转表

```s
    e:  48 8d 0d 00 00 00 00 lea    0x0(%rip),%rcx        # 15 <switch_eg+0x15>
```

  * **`lea 0x0(%rip),%rcx`**: 这是整个实现中最关键、最核心的一步。
      * `%rip` 是**指令指针寄存器**，它总是指向**下一条**将要执行的指令的地址。此时，下一条指令的地址是 `0x15`。
      * `lea` (加载有效地址) 指令会计算 `0x0(%rip)` 这个地址，也就是 `0 + 0x15`，结果是 `0x15`。
      * 然后它将这个计算出的地址 `0x15` 存入 `%rcx` 寄存器。
      * **重要**: 这里的 `0x0` 是一个占位符。因为这是在链接之前的目标文件 (`.o` 文件)，链接器之后会把这个 `0x0` 替换成**跳转表相对于当前位置的实际偏移**。但在这个例子中，编译器非常聪明地把跳转表数据紧凑地放在了代码中间，我们稍后会看到。**现在，我们只需要知道 `%rcx` 保存了跳转表的基地址**。

<!-- end list -->

```s
   15:  48 63 04 b1             movslq (%rcx,%rsi,4),%rax
```

  * **`movslq (%rcx,%rsi,4),%rax`**: 这就是查表操作。
      * `(%rcx, %rsi, 4)`: 这是一个内存寻址。
          * `%rcx`: 跳转表的基地址。
          * `%rsi`: 索引 `index`。
          * `4`: 比例因子。这告诉我们一个惊人的事实：这张跳转表里的每个条目只占 **4 个字节** (`.long`)，而不是教科书里的 8 字节 (`.quad`)！这意味着表里存的不是完整的 64 位地址，而是 32 位的**偏移量**。
      * `movslq`: 这条指令从计算出的地址读取一个 4 字节的**有符号**长整数 (`l`)，然后将其**符号扩展**成一个 64 位的四字 (`q`)，并存入 `%rax`。
      * **现在 `%rax` 中存放的是从跳转表中读出的、相对于表基地址的偏移量**。

<!-- end list -->

```s
   19:  48 01 c8                add    %rcx,%rax
```

  * **`add %rcx,%rax`**: 计算最终的目标地址。
      * `%rax = %rcx + %rax`
      * 翻译过来就是：**`最终跳转地址 = 跳转表基地址 + 从表中查到的偏移量`**。

<!-- end list -->

```s
   1c:  3e ff e0                notrack jmp *%rax
```

  * **`notrack jmp *%rax`**: **执行间接跳转**。CPU 现在会跳转到我们刚刚在 `%rax` 中精心计算出的最终地址。`notrack` 是一个给CPU分支预测器的提示，可以忽略。

-----

### 代码块解析 (与教科书版本对比)

您的编译器也为各个 `case` 生成了对应的代码块，只是布局和一些指令选择略有不同。

  * **Case 100 (地址 `1f`):**

    ```s
       1f:	48 8d 04 7f          lea    (%rdi,%rdi,2),%rax  // rax = x + 2*x = 3x
       23:	48 8d 3c 87          lea    (%rdi,%rax,4),%rdi  // rdi = x + rax*4 = x + (3x)*4 = 13x
       27:	eb 08                jmp    31 <switch_eg+0x31>
    ```

    这里编译器使用了两条 `lea` 指令来实现 `val *= 13`，这是一个非常经典的乘法优化。

  * **Case 102 & 103 (地址 `29`):**

    ```s
       29:	48 83 c7 0a          add    $0xa,%rdi           // val += 10 (case 102)
       2d:	48 83 c7 0b          add    $0xb,%rdi           // val += 11 (case 103)
    ```

    编译器把 `case 102` 和 `case 103` 的代码块紧挨着放在了一起。从 `case 102` 跳转过来后，执行完 `add $0xa,%rdi`，会**自然地落入 (fall through)** 下一行 `add $0xb,%rdi`，完美实现了 C 代码的逻辑。

  * **Case 104 & 106 (地址 `35`):**

    ```s
       35:	48 0f af ff          imul   %rdi,%rdi           // val *= val
       39:	eb f6                jmp    31 <switch_eg+0x31>
    ```

    这部分逻辑很直接。

  * **Default (地址 `3b`):**

    ```s
       3b:	bf 00 00 00 00       mov    $0x0,%edi           // val = 0
       40:	eb ef                jmp    31 <switch_eg+0x31>
    ```

    这里将 0 移入 `%edi` (`%rdi`的低32位)，利用了32位操作会清零64位寄存器高位的特性。

  * **Done (地址 `31`):**

    ```s
       31:	48 89 3a             mov    %rdi,(%rdx)         // *dest = val
       34:	c3                   ret
    ```

    所有分支最终都会汇集到这里，将结果存入内存并返回。

### 总结

您生成的汇编代码和教科书版本相比，主要的不同点在于**跳转表的实现策略**：

| 特性 | 教科书版本 | 您的编译器版本 (现代 GCC/Clang) |
| :--- | :--- | :--- |
| **跳转表内容** | 8 字节的**绝对地址** | 4 字节的**相对偏移量** |
| **表的位置** | 通常在 `.rodata` 数据段 | 可能被优化到 `.text` 代码段中，紧跟在跳转指令之后 |
| **地址计算** | 直接查表 `jmp *table(,%index,8)` | 动态计算 `地址 = 表基址 + 表中偏移` |
| **代码特性** | 简单易懂，但代码与数据分离 | 代码更紧凑，**与位置无关 (PIC)**，更适合动态链接库和现代操作系统 |

您的编译器选择了更现代、更优化的 PIC 方案。虽然初看起来更复杂，但它背后的逻辑（基址 + 偏移量）是现代汇编中非常普遍的模式。您通过这次对比，看到了一个从“教学模型”到“工业级实现”的精彩演进。