### **3.6 控制**

C 语言中的条件语句、循环和分支等结构，要求根据数据测试的结果来决定操作的执行顺序。机器代码通过**跳转 (jump)** 指令来实现这种有条件的控制流。跳转指令可以改变机器代码指令的默认执行顺序，将控制权传递到程序的某个其他部分。

---
#### **3.6.1 条件码**

除了整数寄存器，CPU 还维护着一组单个位的**条件码 (condition code)** 寄存器，它们描述了最近的算术或逻辑操作的属性。条件分支指令会检测这些寄存器来决定是否进行跳转。

最常用的条件码有：
* **`CF` (Carry Flag - 进位标志)**: 最近的操作使最高位产生了进位。可用来检查**无符号**操作的溢出。
* **`ZF` (Zero Flag - 零标志)**: 最近的操作得出的结果为 0。
* **`SF` (Sign Flag - 符号标志)**: 最近的操作得到的结果为负数（即最高位为 1）。
* **`OF` (Overflow Flag - 溢出标志)**: 最近的操作导致一个**补码（有符号）溢出**——正溢出或负溢出。

例如，假设我们用一条 `ADD` 指令完成 `t = a + b`，那么条件码会根据以下情况设置：
* **`CF`**: `(unsigned) t < (unsigned) a` (发生了无符号溢出)
* **`ZF`**: `t == 0`
* **`SF`**: `t < 0` (结果为负)
* **`OF`**: `(a<0 == b<0) && (t<0 != a<0)` (两个负数相加得正，或两个正数相加得负，即有符号溢出)

> **注意**: `leaq` 指令不改变任何条件码。除了 `leaq` 之外，之前列出的所有算术和逻辑指令都会设置条件码。

##### **`CMP` 和 `TEST` 指令**

有两类指令，它们只设置条件码而不改变任何其他寄存器。

**图 3-13：比较和测试指令**

| 指令            | 基于        | 描述  |
| :------------ | :-------- | :-- |
| `CMP` S1, S2  | `S2 - S1` | 比较  |
| `TEST` S1, S2 | `S1 & S2` | 测试  |

* **`CMP` 指令**:
    * 行为与 `SUB` 指令类似，它根据两个操作数之差 `S2 - S1` 来设置条件码。
    * 但它**不会**更新目的寄存器 `S2` 的值，只是简单地丢弃计算结果。
    * 例如，如果 `S1 == S2`，那么差为 0，`ZF` (零标志) 会被置为 1。

* **`TEST` 指令**:
    * 行为与 `AND` 指令类似，它根据两个操作数的**按位与**结果来设置条件码。
    * 它也**不会**更新目的寄存器的值。
    * **典型用法**:
        1.  `testq %rax, %rax`: 用来检查 `%rax` 的值。如果结果为 0，则 `ZF` 置 1；如果结果为负，则 `SF` 置 1。
        2.  使用一个操作数作为**掩码**，来指示需要测试另一个操作数中的哪些位。

[[示例解读3]]

#### **3.6.2 访问条件码**

条件码通常不会被直接读取，常用的使用方法有三种：

1.  根据条件码的某种组合，将一个字节设置为 0 或者 1。
2.  条件跳转到程序的某个其他的部分。
3.  有条件地传送数据。

本节主要讨论第一种情况，它由 `SET` 指令类实现。

##### **`SET` 指令**

`SET` 指令类根据条件码的某种组合，将一个目标字节设置为 0 或者 1。这些指令名字的不同后缀指明了它们所考虑的条件，**而不是操作数大小**。例如，`setl` 表示“小于时设置 (set if less)”，而不是“设置长字 (set long)”。

一条 `SET` 指令的目的操作数是低位单字节寄存器（如 `%al`）或一个单字节的内存位置。为了得到一个 32 位或 64 位的结果，通常必须对这个字节进行零扩展。

一个计算 C 表达式 `a < b` 的典型指令序列如下所示（假设 a 和 b 都是 `long` 类型）：

```s
// a in %rdi, b in %rsi
    cmpq    %rsi, %rdi      // 比较 a 和 b (计算 a - b)
    setl    %al             // 如果 a < b (有符号比较)，则设置 %al 为 1, 否则为 0
    movzbl  %al, %eax       // 将 %al (1字节) 零扩展到 %eax (4字节)，同时 %rax 的高4字节被清零
```

下表列出了 `SET` 指令的完整集合。

**图 3-14：`SET` 指令**

| 指令        | 同义名      | 效果                    | 描述              |                 |
| :-------- | :------- | :-------------------- | :-------------- | --------------- |
| `sete` D  | `setz`   | `D <- ZF`             | 相等 / 零          |                 |
| `setne` D | `setnz`  | `D <- ~ZF`            | 不等 / 非零         |                 |
| `sets` D  |          | `D <- SF`             | 负数              |                 |
| `setns` D |          | `D <- ~SF`            | 非负数             |                 |
| `setg` D  | `setnle` | `D <- ~(SF^OF) & ~ZF` | 大于 (有符号 \>)     |                 |
| `setge` D | `setnl`  | `D <- ~(SF^OF)`       | 大于等于 (有符号 \>=)  |                 |
| `setl` D  | `setnge` | `D <- SF^OF`          | 小于 (有符号 \<)     |                 |
| `setle` D | `setng`  | `D <- (SF^OF)         | ZF`             | 小于等于 (有符号 \<=)  |
| `seta` D  | `setnbe` | `D <- ~CF & ~ZF`      | 超过 (无符号 \>)     |                 |
| `setae` D | `setnb`  | `D <- ~CF`            | 超过或相等 (无符号 \>=) |                 |
| `setb` D  | `setnae` | `D <- CF`             | 低于 (无符号 \<)     |                 |
| `setbe` D | `setna`  | `D <- CF              | ZF`             | 低于或相等 (无符号 \<=) |

##### **条件码组合的逻辑**

`SET` 指令的判断逻辑基于 `CMP S1, S2` (计算 `S2 - S1`) 指令设置的条件码：

  * **相等比较 (`sete`)**: 基于**零标志位 (ZF)**。如果 `S2 - S1 = 0`，则 `ZF` 被置位。
  * **有符号比较 (`setl`, `setg`, etc.)**: 基于**符号标志位 (SF)** 和**溢出标志位 (OF)** 的组合。例如，对于 `setl` (小于)，当且仅当 `SF ^ OF` (符号位和溢出位的异或) 为 1 时，才判定为“小于”。
  * **无符号比较 (`setb`, `seta`, etc.)**: 基于**进位标志位 (CF)** 和**零标志位 (ZF)** 的组合。例如，对于 `setb` (低于)，当 `CMP` 操作产生一个进位（借位）时，`CF` 会被置位，表示无符号数 `S2 < S1`。

-----

#### **3.6.3 跳转指令**

正常情况下，指令是按照它们在程序中出现的顺序一条一条地执行。**跳转 (jump)** 指令会改变这种顺序执行的控制流，导致执行切换到程序中一个全新的位置。在汇编代码中，这些跳转的目的地通常用一个**标号 (label)** 指明。

例如：

```s
    movq $0, %rax
    jmp  .L1            // 跳转到标号 .L1
    movq (%rax), %rdx   // 这条指令会被跳过，不会执行
.L1:
    popq %rdx           // 程序从这里继续执行
```

`jmp` 指令是**无条件跳转**。除此之外，还有很多**有条件跳转**指令，它们会根据条件码的状态来决定是否进行跳转。

##### **跳转指令的类型**

  * **直接跳转 (Direct Jump)**:
    跳转的目标地址是作为指令的一部分编码的。在汇编中，这表现为跳转到一个标号（如 `jmp .L1`）。

  * **间接跳转 (Indirect Jump)**:
    跳转的目标地址是从寄存器或内存位置中读出的。其写法是 `*` 后面跟一个操作数指示符。

      * 示例 1: `jmp *%rax` (用寄存器 `%rax` 中的值作为跳转目标地址)
      * 示例 2: `jmp *(%rax)` (从内存中读出跳转目标地址，该内存的地址存放在 `%rax` 中)

> **注意**: **条件跳转**指令只能是**直接跳转**。

##### **跳转指令表**

下表（对应原文图 3-15）列举了不同的跳转指令。这些指令的条件与上一节的 `SET` 指令是相匹配的。

| 指令          | 同义名     | 跳转条件             | 描述             |
| :---------- | :------ | :--------------- | :------------- |
| `jmp Label` |         | `1`              | 直接跳转           |
| `jmp *Op`   |         | `1`              | 间接跳转           |
|             |         |                  | **有符号比较**      |
| `je Label`  | `jz`    | `ZF`             | 相等 / 零         |
| `jne Label` | `jnz`   | `~ZF`            | 不等 / 非零        |
| `js Label`  |         | `SF`             | 负数             |
| `jns Label` |         | `~SF`            | 非负数            |
| `jg Label`  | `jnle`  | `~(SF^OF) & ~ZF` | 大于 (\>)        |
| `jge Label` | `jnl`   | `~(SF^OF)`       | 大于等于 (\>=)     |
| `jl Label`  | `jnge`  | `SF^OF`          | 小于 (\<)        |
| `jle Label` | `jng`   | `(SF^OF) \| ZF`  | 小于等于 (\<=)     |
|             |         |                  | **无符号比较**      |
| `ja Label`  | `jnbe`  | `~CF & ~ZF`      | 超过 (above, \>) |
| `jae Label` | `jnb`   | `~CF`            | 超过或相等 (\>=)    |
| `jb Label`  | `jnae`  | `CF`             | 低于 (below, \<) |
| `jbe Label` | `setna` | `CF \| ZF`       | 低于或相等 (\<=)    |

#### **3.6.4 跳转指令的编码**

在汇编代码中，跳转目标用符号标号书写。汇编器和链接器负责将这些标号转换为目标指令的实际地址。跳转指令主要有两种编码方式：

1.  **PC 相对的 (PC-relative)**: 这是最常用的方式。指令中存储的不是目标的绝对地址，而是**目标地址**与**跳转指令之后那条指令的地址**之间的**差值（偏移量）**。
2.  **绝对地址**: 指令中直接用 4 个字节编码目标的完整地址。

##### **PC 相对寻址示例**

我们来看一段汇编代码及其反汇编后的字节编码：

**原始汇编代码**:

```s
movq    %rdi, %rax
jmp     .L2
.L3:
sarq    %rax
.L2:
testq   %rax, %rax
jg      .L3
rep; ret
```

**反汇编后的目标代码 (`.o` 文件)**:

```
       0:   48 89 f8                mov    %rdi,%rax
       3:   eb 03                   jmp    8 <loop+0x8>
       5:   48 d1 f8                sar    %rax
       8:   48 85 c0                test   %rax,%rax
       b:   7f f8                   jg     5 <loop+0x5>
       d:   f3 c3                   repz retq
```

**编码解析**:

  * **前向跳转 (第 2 行)**:

      * 跳转指令 `jmp` 位于地址 `0x3`，它之后的指令位于地址 `0x5`。
      * 跳转的目标是地址 `0x8`。
      * 字节编码是 `eb 03`。其中 `03` 就是偏移量。
      * **计算**: `下一条指令的地址 + 偏移量 = 目标地址` -\> `0x5 + 0x3 = 0x8`。计算正确。

  * **后向跳转 (第 5 行)**:

      * 跳转指令 `jg` 位于地址 `0xb`，它之后的指令位于地址 `0xd`。
      * 跳转的目标是地址 `0x5`。
      * 字节编码是 `7f f8`。其中 `f8` 是 `-8` 的补码表示。
      * **计算**: `0xd + (-8) = 0x5`。计算正确。

**PC 相对寻址的优点**:

1.  **编码简洁**: 偏移量通常只需要 1 或 2 个字节，比绝对地址更短。
2.  **位置无关**: 因为目标地址是相对的，所以这段代码可以被加载到内存中的任何位置，而**无需修改跳转指令的编码**，这使得代码的重定位变得非常简单。

-----

##### **关于 `rep; ret` 的注解**

在上面的反汇编代码中，我们看到了 `repz retq` 指令。`rep` 指令通常用于重复的字符串操作，但在这里的用途很特别。

这是 AMD 处理器的一个**性能优化**建议。处理器有分支预测逻辑，但当 `ret` 指令成为一个条件跳转的目标时（如此例中 `jg` 不跳转就会执行 `ret`），某些处理器的分支预测可能会失败。

`rep` 指令在这里被用作一个事实上的**空操作 (no-op)**。通过让条件跳转的目标指向 `rep` 而不是直接指向 `ret`，可以帮助处理器正确地预测返回地址，从而提高性能。当您在阅读汇编代码时看到紧跟在 `ret` 之前的 `rep` 或 `repz` 时，可以放心地忽略它。


#### **3.6.5 用条件控制来实现条件分支**

将 C 语言中的条件表达式和语句（如 `if-else`）翻译成机器代码，最常用的方式是结合使用**有条件跳转**和**无条件跳转**。

##### **示例：`if-else` 语句的编译**

我们通过一个计算两数之差绝对值的函数 `absdiff_se` 来观察编译器是如何工作的。

**图 3-16：条件语句的编译**

**a) 原始的 C 语言代码**

```c
long lt_cnt = 0;
long ge_cnt = 0;

long absdiff_se(long x, long y)
{
    long result;
    if (x < y) {
        lt_cnt++;
        result = y - x;
    } else {
        ge_cnt++;
        result = x - y;
    }
    return result;
}
```

**b) 与之等价的 `goto` 版本**
下面的 C 代码使用 `goto` 语句来精确模拟汇编代码的控制流。虽然 `goto` 通常被认为是不好的编程风格，但它能帮助我们理解机器代码的逻辑。

```c
long gotodiff_se(long x, long y)
{
    long result;
    if (x >= y)         // 测试 if 条件的 *相反* 条件
        goto x_ge_y;    // 如果相反条件为真，则跳转到 else 部分
    
    // "then" 块
    lt_cnt++;
    result = y - x;
    return result;

x_ge_y: // "else" 块的标号
    ge_cnt++;
    result = x - y;
    return result;
}
```

**c) 产生的汇编代码**

```s
// x in %rdi, y in %rsi
absdiff_se:
    cmpq    %rsi, %rdi      // 比较 x:y (计算 x - y)
    jge     .L2             // 如果 x >= y (jge)，则跳转到 .L2 标号
    
    // "then" 块 (x < y)
    addq    $1, lt_cnt(%rip)
    movq    %rsi, %rax
    subq    %rdi, %rax
    ret

.L2:                        // "else" 块 (x >= y) 的标号，对应 goto 版本的 x_ge_y
    addq    $1, ge_cnt(%rip)
    movq    %rdi, %rax
    subq    %rsi, %rax
    ret
```

可以看到，汇编代码的控制流与 `goto` 版本的 C 代码非常相似。它首先比较两个操作数，如果条件 `x >= y` 成立，就直接跳转到处理 `else` 逻辑的代码块。

-----

##### **`if-else` 语句的通用编译模式**

对于 C 语言中通用的 `if-else` 语句形式：

```c
if (test-expr)
    then-statement
else
    else-statement
```

汇编实现通常会采用下面这种“goto 代码”的逻辑模式：

```c
    t = test-expr;
    if (!t)             // 测试 test-expr 的 *相反* 条件
        goto false;     // 如果相反条件为真，跳转到 else 部分
    
    then-statement      // 否则，顺序执行 then 部分
    goto done;          // 执行完后，无条件跳转到末尾，跳过 else 部分

false:
    else-statement      // else 部分的代码

done:
    // ... 继续执行
```

也就是说，编译器会为 `then` 块和 `else` 块分别产生代码，然后插入条件和无条件跳转，以保证在任何情况下都只执行正确的代码块。

#### **3.6.6 用条件传送来实现条件分支**

实现条件操作的传统方法是通过使用**控制的条件转移**（即条件跳转）。当条件满足时，程序沿着一条执行路径执行；不满足时，走另一条路径。这种机制在现代处理器上可能会因为**分支预测错误**而变得非常低效。

一种替代的策略是使用**数据的条件转移**。这种方法会计算一个条件操作的**两种结果**，然后再根据条件是否满足，从中选取一个正确的结果。如果可行，这种策略可以用一条简单的**条件传送指令**来实现，它更符合现代处理器的性能特性。

##### **示例：`if-else` 与条件传送**

我们来看一个不带副作用的 `absdiff` 函数。

**图 3-17：使用条件赋值的条件语句编译**

**a) 原始的 C 语言代码**

```c
long absdiff(long x, long y)
{
    long result;
    if (x < y)
        result = y - x;
    else
        result = x - y;
    return result;
}
```

**b) 使用条件赋值的 C 语言实现 (模拟汇编)**

```c
long cmovdiff(long x, long y)
{
    long rval = y - x; // "then" 表达式的结果
    long eval = x - y; // "else" 表达式的结果
    long ntest = x >= y;
    
    // 如果 ntest 为真，则将 eval 赋值给 rval
    if (ntest) rval = eval; 
    
    return rval;
}
```

**c) 产生的汇编代码**

```s
// x in %rdi, y in %rsi
absdiff:
    movq    %rsi, %rax      // rax = y
    subq    %rdi, %rax      // rax = y - x (这是 rval)
    movq    %rdi, %rdx      // rdx = x
    subq    %rsi, %rdx      // rdx = x - y (这是 eval)
    cmpq    %rsi, %rdi      // 比较 x:y
    cmovge  %rdx, %rax      // 如果 x >= y (ge)，则 rval = eval (即 %rax = %rdx)
    ret                     // 返回 rval (%rax)
```

可以看到，汇编代码计算了 `if` 和 `else` 两种情况的结果，然后使用一条 `cmovge`（大于或等于时条件传送）指令，根据比较结果选择正确的值放入返回寄存器 `%rax`，全程**没有发生跳转**。

-----

##### **流水线与分支预测错误代价**

现代处理器通过**流水线 (pipelining)** 来获得高性能，即重叠连续指令的执行步骤。但当机器遇到**条件跳转**时，只有当分支条件求值完成之后，才能决定接下来该执行哪条指令，这会打断流水线。

为了解决这个问题，处理器采用非常精密的**分支预测逻辑**来猜测跳转指令是否会执行。

  * **预测正确**: 流水线继续充满指令，性能很高。
  * **预测错误**: 处理器必须丢掉它在错误路径上已做的所有工作，然后重新用正确位置的指令去填充流水线。这样一个错误预测会招致很严重的性能惩罚（通常浪费 15-30 个时钟周期）。

对于不可预测的分支（例如，随机数据），分支预测错误率约为 50%，这会导致程序性能严重下降。而使用条件传送的代码，由于没有跳转，其执行时间是恒定的，不受数据模式的影响，从而避免了这种性能惩罚。

-----

##### **条件传送指令 (`CMOV`)**

图 3-18 列举了 x86-64 上可用的条件传送指令。每条指令都有两个操作数：源 `S`（寄存器或内存）和目的 `R`（必须是寄存器）。只有在指定的条件码满足时，源值才会被复制到目的寄存器中。

**图 3-18：条件传送指令**

| 指令 | 同义名 | 传送条件 | 描述 |
| :--- | :--- | :--- | :--- |
|`cmove` S,R | `cmovz` | `ZF` | 相等 / 零 |
|`cmovne` S,R| `cmovnz`| `~ZF` | 不等 / 非零 |
|`cmovs` S,R | | `SF` | 负数 |
|`cmovns` S,R| | `~SF` | 非负数 |
|... | ... | ... | (与 `SET` 和 `JUMP` 指令的条件相同) |

-----

#### **条件传送的局限性**

不是所有的条件表达式都可以用条件传送来编译。

  * **核心原则**: 使用条件传送时，`if` 和 `else` 两个分支的表达式**都会被求值**。

这就带来了两个重要的局限性：

1.  **不能有副作用或潜在错误**:

      * 如果任一分支表达式有副作用（例如 `lt_cnt++`），或者可能产生错误（例如解引用一个可能为空的指针），那么就不能使用条件传送。
      * **示例**:
        ```c
        long cread(long *xp) {
            return (xp ? *xp : 0); // 如果 xp 为 NULL，*xp 会导致段错误
        }
        ```
        如果用条件传送编译，`*xp` 这个操作**总会被执行**，即使 `xp` 是 `NULL`，从而导致程序崩溃。因此，这种情况必须用条件跳转来编译。

2.  **计算开销权衡**:

      * 如果 `if` 或 `else` 分支的计算量非常大，而分支预测的成功率又很高，那么总是计算两个分支的代价，可能比偶尔一次分支预测错误的代价还要高。
      * 编译器会根据一些启发式规则（通常是当两个分支的计算都很简单时）来决定是否使用条件传送。

### **3.6.7 循环**

C 语言提供了多种循环结构，即 `do-while`、`while` 和 `for`。汇编中没有相应的指令，但可以用条件测试和跳转组合起来实现循环的效果。GCC 主要基于两种基本的循环模式来生成代码。

-----

#### **1. do-while 循环**

`do-while` 语句的通用形式如下：

```c
do
    body-statement
while (test-expr);
```

它的效果是重复执行 `body-statement`，然后对 `test-expr` 求值，如果结果为非零，就继续循环。`body-statement` 至少会执行一次。

这种通用形式可以被翻译成如下所示的 `goto` 语句：

```c
loop:
    body-statement
    t = test-expr;
    if (t)
        goto loop;
```

**示例：`do-while` 版本的阶乘函数**

**图 3-19：阶乘程序的 `do-while` 版本**

a) C 代码

```c
long fact_do(long n)
{
    long result = 1;
    do {
        result *= n;
        n = n - 1;
    } while (n > 1);
    return result;
}
```

b) 等价的 `goto` 版本

```c
long fact_do_goto(long n)
{
    long result = 1;
loop:
    result *= n;
    n = n - 1;
    if (n > 1)
        goto loop;
    return result;
}
```

c) 对应的汇编代码

```s
// n in %rdi
fact_do:
    movl    $1, %eax        // Set result = 1
.L2:                        // loop:
    imulq   %rdi, %rax      //   Compute result *= n
    subq    $1, %rdi        //   Decrement n
    cmpq    $1, %rdi        //   Compare n : 1
    jg      .L2             //   If >, goto loop
    rep; ret                // Return
```

汇编代码的结构与 `goto` 版本几乎完全一致。

**练习题 3.23**
已知 C 代码如下：

```c
long dw_loop(long x) {
    long y = x*x;
    long *p = &x;
    long n = 2*x;
    do {
        x += y;
        (*p)++;
        n--;
    } while (n > 0);
    return x;
}
```

GCC 产生的汇编代码如下：

```s
// x initially in %rdi
dw_loop:
    movq    %rdi, %rax
    movq    %rdi, %rcx
    imulq   %rdi, %rcx
    leaq    (%rdi, %rdi), %rdx
.L2:
    leaq    1(%rcx,%rax), %rax
    subq    $1, %rdx
    testq   %rdx, %rdx
    jg      .L2
    rep; ret
```

A. 哪些寄存器用来存放程序值 x、y 和 n?
B. 编译器如何消除对指针变量 p 和表达式 `(*p)++` 隐含的指针间接引用的需求？
C. 对汇编代码添加一些注释，描述程序的操作。

-----

#### **2. while 循环**

`while` 语句的通用形式如下：

```c
while (test-expr)
    body-statement
```

它与 `do-while` 的不同之处在于，在第一次执行循环体之前，就会对测试条件求值。GCC 在代码生成中使用两种方法来翻译 `while` 循环。

##### **方法一：跳转到中间 (Jump to Middle)**

这种方法执行一个无条件跳转，跳到循环结尾处的测试，以此来执行初始测试。

```c
// goto 代码模板
    goto test;
loop:
    body-statement
test:
    t = test-expr;
    if (t)
        goto loop;
```

**示例：`while` 版本的阶乘函数 (`-Og` 优化等级)**

**图 3-20：使用跳转到中间翻译方法的 `while` 循环**
a) C 代码

```c
long fact_while(long n)
{
    long result = 1;
    while (n > 1) {
        result *= n;
        n = n - 1;
    }
    return result;
}
```

c) 对应的汇编代码

```s
// n in %rdi
fact_while:
    movl    $1, %eax        // Set result = 1
    jmp     .L5             // Goto test
.L6:                        // loop:
    imulq   %rdi, %rax      //   Compute result *= n
    subq    $1, %rdi        //   Decrement n
.L5:                        // test:
    cmpq    $1, %rdi        //   Compare n : 1
    jg      .L6             //   If >, goto loop
    rep; ret                // Return
```

##### **方法二：Guarded-do**

这种方法首先用一个条件分支，如果初始条件不成立就跳过整个循环，否则就进入一个标准的 `do-while` 结构。当使用较高优化等级（如 `-O1`）编译时，GCC 会采用这种策略。

```c
// goto 代码模板
    t = test-expr;
    if (!t)
        goto done;
loop:
    body-statement
    t = test-expr;
    if (t)
        goto loop;
done:
```

**示例：`while` 版本的阶乘函数 (`-O1` 优化等级)**

**图 3-21：使用 `guarded-do` 翻译方法的 `while` 循环**
c) 对应的汇编代码

```s
// n in %rdi
fact_while:
    cmpq    $1, %rdi        // Compare n : 1
    jle     .L7             // If <=, goto done
    movl    $1, %eax        // Set result = 1
.L6:                        // loop:
    imulq   %rdi, %rax      //   Compute result *= n
    subq    $1, %rdi        //   Decrement n
    cmpq    $1, %rdi        //   Compare n : 1
    jne     .L6             //   If !=, goto loop
    rep; ret                // Return
.L7:                        // done:
    movl    $1, %eax        //   Compute result = 1
    ret                     // Return
```

-----

#### **3. for 循环**

`for` 循环的通用形式如下：

```c
for (init-expr; test-expr; update-expr)
    body-statement
```

这个循环的行为与下面这段使用 `while` 循环的代码的行为一样：

```c
init-expr;
while (test-expr) {
    body-statement
    update-expr;
}
```

因此，GCC 为 `for` 循环产生的代码就是 `while` 循环的两种翻译方法之一，具体取决于优化等级。



#### **3.6.8 switch 语句**

`switch`（开关）语句可以根据一个整数索引值进行**多重分支 (multi-way branching)**。在处理具有多种可能结果的测试时，这种语句不仅能提高 C 代码的可读性，而且可以通过使用一种名为**跳转表 (jump table)** 的数据结构使得实现更加高效。

跳转表是一个数组，表项 `i` 是一个代码段的地址，这个代码段实现了当开关索引值等于 `i` 时程序应该采取的动作。程序代码用开关索引值来执行一个跳转表内的数组引用，从而确定跳转指令的目标。

和使用一组很长的 `if-else` 语句相比，使用跳转表的优点是**执行 `switch` 语句的时间与开关情况的数量无关**。GCC 会根据开关情况的数量和值的稀疏程度来决定是否使用跳转表（通常在情况数量较多且值的范围跨度较小时使用）。

##### **`switch` 语句示例与翻译**

**图 3-22**

**a) C 语言 `switch` 语句示例**
这个例子包含了一些有趣的特征：不连续的 case 值、多个标号对应同一代码块、以及 case 的“落入 (fall through)”。

```c
void switch_eg(long x, long n, long *dest)
{
    long val = x;
    switch (n) {
        case 100:
            val *= 13;
            break;
        case 102:
            val += 10;
            /* Fall through */
        case 103:
            val += 11;
            break;
        case 104:
        case 106:
            val *= val;
            break;
        default:
            val = 0;
    }
    *dest = val;
}
```

**b) 翻译到扩展的 C 语言 (模拟汇编逻辑)**
下面的代码使用了 GCC 的扩展（计算 `goto` 和 `&&` 取标号地址运算符）来模拟编译器如何使用跳转表。

```c
void switch_eg_impl(long x, long n, long *dest)
{
    // 跳转表，一个包含7个代码指针的数组
    static void *jt[7] = {
        &&loc_A, &&loc_def, &&loc_B, &&loc_C,
        &&loc_D, &&loc_def, &&loc_D
    };

    // 将 n 的值范围移到 0-6
    unsigned long index = n - 100;
    long val;

    if (index > 6)      // 范围检查，超出则跳到 default
        goto loc_def;

    goto *jt[index];    // 使用计算出的 index 执行多路分支

loc_A:  /* Case 100 */
    val = x * 13;
    goto done;
loc_B:  /* Case 102 */
    x = x + 10;
    /* Fall through */
loc_C:  /* Case 103 */
    val = x + 11;
    goto done;
loc_D:  /* Cases 104, 106 */
    val = x * x;
    goto done;
loc_def:/* Default case */
    val = 0;
done:
    *dest = val;
}
```

##### **产生的汇编代码**

**图 3-23：`switch` 语句示例的汇编代码**

```s
// x in %rdi, n in %rsi, dest in %rdx
switch_eg:
    subq    $100, %rsi          // 计算 index = n - 100
    cmpq    $6, %rsi            // 比较 index: 6
    ja      .L8                 // 如果 > (无符号比较), 跳转到 default (loc_def)
    jmp     *.L4(,%rsi,8)       // 跳转到跳转表 jt[index]

.L3:    // loc_A (Case 100)
    leaq    (%rdi,%rdi,2), %rax
    leaq    (%rdi,%rax,4), %rdi // val = 13*x
    jmp     .L2

.L5:    // loc_B (Case 102)
    addq    $10, %rdi
    // (此处无 jmp, 直接落入 .L6)

.L6:    // loc_C (Case 103)
    addq    $11, %rdi           // val = x + 11
    jmp     .L2

.L7:    // loc_D (Cases 104, 106)
    imulq   %rdi, %rdi          // val = x * x
    jmp     .L2

.L8:    // loc_def (Default case)
    movl    $0, %edi            // val = 0

.L2:    // done:
    movq    %rdi, (%rdx)        // *dest = val
    ret
```

##### **汇编中的跳转表**

汇编代码中的跳转表用以下声明表示：

```s
    .section .rodata     // 只读数据段
    .align 8
.L4:                     // 跳转表的起始地址
    .quad .L3            // index 0 (case 100) -> loc_A
    .quad .L8            // index 1 (case 101) -> loc_def
    .quad .L5            // index 2 (case 102) -> loc_B
    .quad .L6            // index 3 (case 103) -> loc_C
    .quad .L7            // index 4 (case 104) -> loc_D
    .quad .L8            // index 5 (case 105) -> loc_def
    .quad .L7            // index 6 (case 106) -> loc_D
```

  * **`.quad`** 伪指令声明了一个 8 字节的值（一个地址）。
  * **间接跳转**: 汇编代码第 5 行的 `jmp *.L4(,%rsi,8)` 是执行 `switch` 的关键。它以 `.L4` 为基地址，`%rsi` (index) 为索引，`8` 为比例因子（因为每个地址是8字节），从跳转表中取出目标地址，然后跳转过去。
  * **处理方式**:
      * **重复情况** (case 104, 106): 简单地让表项 4 和 6 指向同一个代码标号 (`.L7`)。
      * **缺失情况** (case 101, 105): 让表项 1 和 5 指向 `default` 的代码标号 (`.L8`)。
      * **落入情况** (case 102 fall through to 103): 对应于标号 `.L5` 的代码块结尾处**没有** `jmp` 指令，因此执行会自然地“落”到下一个代码块 `.L6`。