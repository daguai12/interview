
### 程序内存区域分布图

为了更清晰地理解，一个典型的程序内存布局如下：

```
+-----------------------+  <- 高地址
| 命令行参数/环境变量   |
+-----------------------+
|         栈 (Stack)    |
|  <-- 生长方向(向下)   |
+-----------------------+
|                       |
|         ...           |  (空闲区域)
|                       |
+-----------------------+
|   <-- 生长方向(向上)    |
|         堆 (Heap)     |
+-----------------------+
|      BSS 段           | (未初始化的全局/静态变量)
+-----------------------+
|      Data 段          | (已初始化的全局/静态变量)
+-----------------------+
|      Text 段          | (代码)
+-----------------------+  <- 低地址
```

### 堆与栈的详细对比

| 特性       | 栈 (Stack)                                                  | 堆 (Heap)                                              |
| :------- | :--------------------------------------------------------- | :---------------------------------------------------- |
| **管理方式** | **自动管理**。由编译器和操作系统自动分配和释放。                                 | **手动管理**。由程序员通过 `new/delete` 或 `malloc/free` 来申请和释放。  |
| **生命周期** | **短暂且作用域化**。与函数调用绑定，函数执行结束，栈上的局部变量立刻被销毁。                   | **持久**。从 `new` 开始，直到程序员手动 `delete` 或程序结束，其生命周期与作用域无关。 |
| **分配效率** | **极高**。本质上只是移动栈顶指针（SP 寄存器），有专门的CPU指令支持。                    | **较低**。需要在空闲内存链表/树中查找合适的内存块，可能涉及复杂的算法，并需要记录分配信息。      |
| **大小限制** | **小且固定**。通常为几MB（Linux下可用 `ulimit -s` 查看/设置），过大或无限递归会导致栈溢出。 | **大且灵活**。受限于虚拟内存大小，在32位系统下可达2-3GB，64位系统下则非常巨大。        |
| **内存区域** | **连续的内存空间**。                                               | **不连续的内存块**。通过链表等结构组织，频繁申请和释放容易产生碎片。                  |
| **碎片问题** | **无碎片**。后进先出的模式决定了其内存块的分配和回收是有序的，不会产生空洞。                   | **有碎片**。频繁的申请和释放不同大小的内存块，会导致大量不连续的小块空闲内存，即外部碎片。       |
| **生长方向** | **向低地址方向生长**（向下）。                                          | **向高地址方向生长**（向上）。                                     |
| **存储内容** | 局部变量、函数参数、返回地址、函数调用上下文等。                                   | 程序运行时动态创建的对象和数据，例如大型数组、类的实例等。                         |

### 常见问题

  * **栈相关问题**：

      * **栈溢出 (Stack Overflow)**：最常见的问题。原因通常是：
        1.  函数递归调用层次太深，没有正确的终止条件。
        2.  在栈上定义了过于庞大的局部变量（如 `int arr[1000000];`）。

  * **堆相关问题**：

      * **内存泄漏 (Memory Leak)**：忘记 `delete` / `free` 已经申请的内存，导致该内存无法被再次使用。
      * **野指针 (Wild Pointer)** / **悬垂指针 (Dangling Pointer)**：内存已经被释放，但指针变量仍然指向那块“垃圾”内存地址，此时再通过该指针访问内存是极其危险的。
      * **重复释放 (Double Free)**：对同一块内存执行了两次或多次 `delete` / `free`。

### 总结

选择使用堆还是栈，是基于数据**生命周期**和**大小**的权衡：

  * 对于生命周期短暂、大小可预知且不大的数据（如函数内的局部变量），编译器会自动将其放在**栈**上，以获得最高的效率和安全性。
  * 对于生命周期需要跨越多个函数作用域、或者大小在运行时才能确定、或者体积非常庞大的数据，则需要程序员手动在**堆**上申请，并承担起正确管理它的责任。