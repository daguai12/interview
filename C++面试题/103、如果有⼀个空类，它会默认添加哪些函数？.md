您好，您列出的这四个函数非常准确！这确实是 C++98/03 时代，当我们谈论一个空类时，编译器会为其\*\*隐式声明（implicitly-declare）\*\*的“四大金刚”。

在**现代C++（C++11及以后）中，随着移动语义（Move Semantics）的引入，这个列表扩展到了六个**特殊成员函数。

下面，我们来详细解析这套“豪华套餐”。

-----

### C++11及以后，空类默认生成的六个特殊成员函数

当您定义一个空类时：

```cpp
class Empty {};
```

只要您**没有**手动声明**任何**一个构造函数、析构函数或赋值运算符，编译器就会在需要时，像下面这样为您隐式地声明和定义所有六个特殊成员函数：

#### 1\. 默认构造函数 (Default Constructor)

  * **签名**：`Empty();`
  * **作用**：创建一个处于默认状态的对象。
  * **何时调用**：`Empty e1;` 或 `new Empty();`
  * **默认行为**：函数体为空。如果类有成员变量，会调用成员变量的默认构造函数。

#### 2\. 析构函数 (Destructor)

  * **签名**：`~Empty();`
  * **作用**：在对象生命周期结束时，执行清理工作。
  * **何时调用**：当对象离开作用域，或被 `delete` 时。
  * **默认行为**：函数体为空。如果类有成员变量，会以声明顺序的逆序调用成员变量的析构函数。

#### 3\. 拷贝构造函数 (Copy Constructor)

  * **签名**：`Empty(const Empty&);`
  * **作用**：从一个已存在的同类型对象（左值）来创建一个新的对象。
  * **何时调用**：`Empty e2 = e1;` 或 `Empty e2(e1);`
  * **默认行为**：对类的每个成员执行“成员逐一拷贝（memberwise copy）”。对于空类，此函数体为空。

#### 4\. 拷贝赋值运算符 (Copy Assignment Operator)

  * **签名**：`Empty& operator=(const Empty&);`
  * **作用**：将一个已存在的同类型对象（左值）的值，赋给另一个已存在的对象。
  * **何时调用**：`e2 = e1;`
  * **默认行为**：对类的每个成员执行“成员逐一赋值（memberwise assignment）”。对于空类，此函数体为空。

-----

#### 5\. 移动构造函数 (Move Constructor) - (C++11 新增)

  * **签名**：`Empty(Empty&&);`
  * **作用**：从一个临时对象或将亡值（右值）“窃取”其资源来创建一个新对象，避免昂贵的拷贝。
  * **何时调用**：`Empty e3 = Empty();` 或 `Empty e4 = std::move(e1);`
  * **默认行为**：对类的每个成员执行“成员逐一移动（memberwise move）”。对于空类，此函数体为空。

#### 6\. 移动赋值运算符 (Move Assignment Operator) - (C++11 新增)

  * **签名**：`Empty& operator=(Empty&&);`
  * **作用**：将一个临时对象或将亡值（右值）的值，“窃取”并赋给一个已存在的对象。
  * **何时调用**：`e1 = Empty();`
  * **默认行为**：对类的每个成员执行“成员逐一移动赋值（memberwise move assignment）”。对于空类，此函数体为空。

-----

### “零之法则” (The Rule of Zero)

这个概念对于理解何时会生成这些函数至关重要。

  * **规则**：如果你**没有**为你的类显式声明**任何**一个上述的特殊成员函数，那么编译器就会在需要时，为你生成全部六个。
  * **反之**：一旦你**手动**声明了它们中的**任何一个**（例如，你只写了一个析构函数 `~MyClass() {}`），编译器的行为就会改变，**可能会阻止**其他某些函数的自动生成（特别是移动构造和移动赋值）。
  * **推论**：这就引出了“**五之法则（The Rule of Five）**”——如果你手动管理了资源，需要自己编写析构函数、拷贝构造或拷贝赋值中的任何一个，那么你很可能需要同时考虑并实现所有五个（析构+拷贝+移动）函数，以确保行为的正确和一致性。

### 代码示例验证

```cpp
#include <iostream>

class Empty {
    // 编译器会在这里隐式地声明和定义六个特殊成员函数
};

int main() {
    std::cout << "1. 默认构造: Empty e1;" << std::endl;
    Empty e1;

    std::cout << "\n2. 拷贝构造: Empty e2 = e1;" << std::endl;
    Empty e2 = e1;

    std::cout << "\n3. 拷贝赋值: e1 = e2;" << std::endl;
    e1 = e2;

    std::cout << "\n4. 移动构造: Empty e3 = Empty();" << std::endl;
    Empty e3 = Empty(); // Empty() 是一个临时对象（右值）

    std::cout << "\n5. 移动赋值: e1 = std::move(e2);" << std::endl;
    e1 = std::move(e2); // std::move 将 e2 转换为右值

    std::cout << "\nProgram finished. Destructors will be called." << std::endl;
}
```

这段代码可以成功编译和运行，证明了即使 `Empty` 类在代码中是空的，这六种生命周期管理的操作也都已经由编译器为我们准备好了。

### 一个额外的问题：`sizeof(Empty)` 是多少？

一个空类的大小**不是0**，而是**1**。

C++标准规定，任何两个不同的对象都必须拥有不同的内存地址。为了满足这个要求，编译器会为空类（或空基类）的对象分配至少**1字节**的空间，以作为其在内存中的唯一“占位符”。