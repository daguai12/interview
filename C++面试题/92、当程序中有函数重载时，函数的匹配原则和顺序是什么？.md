您好，您对函数重载匹配原则的总结——**名字查找、确定候选函数、寻找最佳匹配**——非常准确和专业！这正是 C++ 标准中规定的函数重载解析（Overload Resolution）的核心三部曲。

这是一个在编译时由编译器严格执行的、高度确定性的过程。下面，我们来详细展开这三个步骤，看看编译器是如何思考并最终做出选择的。

-----

### 函数重载解析的三部曲

假设编译器遇到一个函数调用，例如 `func(42, 3.14);`。

#### 步骤一：名字查找 (Name Lookup)

**目标**：在当前作用域中，找到所有名为 `func` 的声明。

  * 编译器会从函数调用的地方开始，向外层作用域（例如类作用域、命名空间作用域、全局作用域）逐层搜索，直到找到至少一个名为 `func` 的声明为止。
  * 一旦在某个作用域中找到了匹配的名称，**查找就会停止**。外层作用域中任何同名的函数都会被\*\*“隐藏”（Hide）**，不再被考虑。这是**名称隐藏（Name Hiding）\*\*规则。
  * 这个阶段只关心**函数的名字**，不关心参数列表或返回类型。

**比喻**：就像在一个大公司里找一个叫“张伟”的人。你先在你自己的办公室找，如果找到了，你就不会再去隔壁办公室或整栋楼里找其他的“张伟”了。

#### 步骤二：确定候选函数 (Candidate Function Set)

**目标**：从第一步找到的所有同名函数中，筛选出“可能可以被调用”的函数，形成一个**候选函数集**。

  * 编译器会检查第一步找到的每个 `func` 函数，看它的声明是否满足以下条件：

    1.  **参数数量正确**：函数声明的参数个数，与本次调用提供的实参个数相匹配（或者能够通过默认参数匹配）。
    2.  **参数类型可转换**：对于每一个实参，都存在一种**隐式转换序列**，可以将其转换为对应形参的类型。

  * 如果一个函数不满足这两个条件，它就会被从候选函数集中剔除。

**示例**：

```cpp
void func(int i);
void func(const std::string& s);
void func(int i, int j);

// 调用
func("hello");
```

1.  **名字查找**：找到了以上三个名为 `func` 的函数。
2.  **确定候选**：
      * `func(int i)`：无法将 `"hello"` (类型是 `const char*`) 隐式转换为 `int`，**被剔除**。
      * `func(const std::string& s)`：存在从 `const char*` 到 `std::string` 的转换（通过 `std::string` 的构造函数），**成为候选函数**。
      * `func(int i, int j)`：参数数量不匹配（调用是1个，需要2个），**被剔除**。

<!-- end list -->

  * **最终结果**：候选函数集中只有一个函数 `func(const std::string& s)`。

#### 步骤三：寻找最佳匹配 (Best Viable Function)

**目标**：如果候选函数集中有多个函数，编译器需要按照一个严格的\*\*“匹配质量”排行榜\*\*，从所有候选函数中，找出一个**唯一的、最佳的**匹配。

这个“匹配质量”主要取决于从**实参类型**到**形参类型**所需的**转换成本**。成本越低，排名越高。

**转换成本排名（从高到低，成本从低到高）：**

1.  **精确匹配 (Exact Match)**：**最高优先级**。

      * 类型完全相同。
      * 仅有无伤大雅的“平凡转换”，如：
          * `T` -\> `const T` 或 `T&`
          * 数组 -\> 指针
          * 函数名 -\> 函数指针

2.  **类型提升 (Promotion)**

      * 一些“无损”的、非常自然的整数和浮点数提升。
      * 例如：`char`, `short` -\> `int`；`float` -\> `double`。

3.  **标准转换 (Standard Conversion)**

      * 其他所有内置的、可能会“有损”的类型转换。
      * 例如：`int` -\> `double` (无损), `double` -\> `int` (有损), `int` -\> `long`, 派生类指针 -\> 基类指针。

4.  **用户自定义转换 (User-defined Conversion)**

      * 通过**转换构造函数**（`MyClass(int)`) 或**类型转换运算符**（`operator int()`) 进行的转换。

5.  **省略号匹配 (Ellipsis Conversion)**

      * 匹配可变参数列表 `...`。这是**最低优先级**的匹配。

**选择规则：**

  * 编译器会为每个候选函数的每个参数都评定一个“转换等级”。
  * 如果有一个候选函数，它在**至少一个参数**上的匹配等级**优于**所有其他候选函数，并且在**所有其他参数**上的匹配等级**不差于**其他候选函数，那么这个函数就是唯一的**最佳匹配**。
  * **歧义（Ambiguity）**：如果经过评比，找出了**两个或更多**同样“优秀”的候选函数（没有一个能明确胜出），编译器就会放弃选择，并报告一个“**调用不明确（call is ambiguous）**”的编译错误。

**示例：**

```cpp
void process(long l);      // (A)
void process(double d);    // (B)

process(10); // 10 的类型是 int
```

  * **分析**：
      * `int` -\> `long` (用于匹配A)：属于**标准转换**。
      * `int` -\> `double` (用于匹配B)：也属于**标准转换**。
  * **结果**：`process(long)` 和 `process(double)` 的匹配质量**完全相同**。编译器无法做出唯一选择，因此这是一个**歧义调用**，会导致编译失败。

-----

### 总结

函数重载的匹配过程是一个严谨的三步筛选：

1.  **名字查找**：在作用域中“广撒网”，找出所有同名函数。
2.  **确定候选**：根据参数数量和可转换性，“精筛选”，得到一份候选名单。
3.  **寻找最佳匹配**：对候选名单进行“择优录取”，根据转换成本的高低，选出唯一的获胜者。如果没有唯一的获胜者，则视为歧义。

这个过程保证了C++的函数调用是高度确定和类型安全的，编译器绝不会替你做“模糊”的决定。