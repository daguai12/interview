### 1\. 共同的出发点

首先，我们之所以不总是使用最简单的**值传递（Pass-by-Value）**，而选择指针或引用，其根本原因正如您所说，主要有两点：

1.  **需要修改调用方的数据**：值传递是单向的副本传递，无法修改原始数据。
2.  **希望避免昂贵的拷贝**：对于大型对象（如 `std::string`, `std::vector` 或大型结构体/类），值传递会创建一个完整的副本，开销巨大。指针和引用都只传递地址信息，效率极高。

既然指针和引用都能满足这两个核心需求，我们该如何选择呢？

-----

### 2\. 决策的核心：参数是否“可选”？

在现代C++中，选择指针还是引用的**最关键**的考量点是：这个参数**是否允许为空（optional/nullable）**？

  * **指针 (Pointer)**：可以是一个**空指针 (`nullptr`)**。这给了它一种额外的表达能力，即“**这里可能没有对象**”。
  * **引用 (Reference)**：**必须**绑定到一个**已存在的、有效的对象**。它在设计上就是非空的。

基于这一点，我们可以得出一套清晰的决策流程。

-----

### 3\. C++参数传递最佳实践指南

#### 情况一：函数不需要修改实参（只读/Input-Only）

这是最常见的情况。

  * **如果对象很小且复制成本低**（例如 `int`, `double`, `char`, 指针本身）：

      * **选择：按值传递 (Pass-by-Value)**
      * **原因**：最简单、最安全、最易于理解。代码清晰地表明函数在操作一个独立的副本。

    <!-- end list -->

    ```cpp
    void print_id(int user_id);
    ```

  * **如果对象是C风格数组**：

      * **选择：按指针传递 (Pass-by-Pointer to `const`)**
      * **原因**：这是处理C风格数组的唯一方式，因为数组会“退化”为指针。`const` 保证了数组内容不会被修改。

    <!-- end list -->

    ```cpp
    void print_array(const int* arr, size_t size);
    ```

  * **如果对象较大或复制成本高**（例如 `std::string`, `std::vector`, 大型类/结构体）：

      * **选择：按常量引用传递 (Pass-by-`const`-Reference)**
      * **原因**：这是**现代C++的黄金标准**。它兼具了**引用传递的高效率**（避免拷贝）和**值传递的安全性**（`const` 确保原始对象不被修改）。

    <!-- end list -->

    ```cpp
    void print_report(const std::string& report_content);
    ```

#### 情况二：函数需要修改实参（读写/Output）

这是指针和引用正面交锋的场景。

  * **如果这个可修改的参数是“可选的”**（即调用者可以合法地传入一个“空”状态，表示不需要这个功能）：

      * **选择：按指针传递 (Pass-by-Pointer)**
      * **原因**：`nullptr` 是表达“不存在”或“可选”的唯一标准方式。函数内部必须在使用前进行**空指针检查**。

    <!-- end list -->

    ```cpp
    // 一个函数，尝试查找一个值，如果找到了就通过指针返回，如果没找到就算了
    bool find_value(int id, int* out_value) {
        if (/* 找到了 */) {
            if (out_value) { // 检查调用者是否真的需要返回值
                *out_value = 42;
            }
            return true;
        }
        return false;
    }

    // 调用
    int result;
    find_value(101, &result); // 我需要返回值
    find_value(102, nullptr); // 我只是想检查它存不存在，不需要返回值
    ```

  * **如果这个可修改的参数是“必需的”**（即函数必须操作在一个有效的对象上）：

      * **选择：按引用传递 (Pass-by-Reference)**
      * **原因**：这是一种\*\*“契约式编程”**。通过使用引用，函数签名本身就在声明：“调用我，必须提供一个有效的对象”。这免去了函数内部的空指针检查，使代码更简洁，意图也更明确。这是**现代C++的首选\*\*。

    <!-- end list -->

    ```cpp
    void normalize_vector(std::vector<double>& data) {
        // 无需检查 data 是否为空，因为它是一个引用，保证有效
        for (auto& val : data) {
            // ... 修改 val ...
        }
    }
    ```

### 总结表格

| 意图              | 对象大小/类型    | 最佳选择       | 示例                               |
| :-------------- | :--------- | :--------- | :------------------------------- |
| **只读 (Input)**  | 小 / 复制成本低  | **值传递**    | `void func(int);`                |
|                 | 大 / 复制成本高  | **常量引用传递** | `void func(const std::string&);` |
|                 | C风格数组      | **常量指针传递** | `void func(const int*);`         |
| **修改 (Output)** | 参数是**可选**的 | **指针传递**   | `bool func(int* out_val);`       |
|                 | 参数是**必需**的 | **引用传递**   | `void func(std::string&);`       |

**结论**：在现代C++中，应**优先使用引用**。

  * 当你需要向函数传递大型只读数据时，使用**常量引用（`const T&`）**。
  * 当你需要让函数修改你的数据且该数据是必需的时，使用**引用（`T&`）**。
  * 只有当你需要表示“**可选**”或“**不存在**”的语义，或者需要与C语言API交互时，才选择使用**指针（`T*`）**。