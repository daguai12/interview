
### 核心思想与关系

  * **重载 (Overloading)**：**“水平”关系**。像是在同一个房间里，放了几个名字相同但功能（参数）不同的工具。
  * **重写 (Overriding)**：**“垂直”关系**。像是儿子对父亲传下来的一门手艺（虚函数）进行了改进和升级。这是**运行时多态**的基石。
  * **隐藏 (Hiding)**：**“垂直”关系**。像是儿子新开了一家店，店名和父亲的一样，导致顾客（编译器）只看得到儿子的店，而“隐藏”了父亲的店。这是**编译时**的名称解析规则。

-----

### 1\. 重载 (Overload)

**定义**：在**同一个作用域**（例如，同一个类或同一个命名空间）中，定义多个同名函数，但它们的**参数列表必须不同**（参数的个数、类型或顺序不同）。

  * **与返回值无关**：不能只有返回值不同。
  * **与`virtual`无关**：无论函数是否为虚函数，都可以构成重载。

**作用**：为了方便用户，提供功能相似但接受不同参数的多个函数接口。

**示例**：

```cpp
class Printer {
public:
    void print(int i) { /* ... */ }
    void print(double d) { /* ... */ }
    void print(const std::string& s) { /* ... */ }
};

Printer p;
p.print(10);       // 调用 print(int)
p.print(3.14);     // 调用 print(double)
p.print("hello");  // 调用 print(const std::string&)
```

**决策时机**：**编译时**。编译器根据你调用函数时提供的实参类型，来决定具体执行哪一个重载版本。

-----

### 2\. 重写 (Override) / 覆盖

**定义**：在派生类中，重新实现基类中**同名的虚函数**。这是实现多态行为的关键。

**严格的匹配规则**：

1.  必须发生在**基类和派生类**之间。
2.  基类中的函数必须是**虚函数 (`virtual`)**。
3.  函数名、参数列表、`const`修饰符必须**完全相同**。
4.  返回值类型必须**兼容**（相同，或者是协变返回类型，即返回派生类指针/引用）。

**作用**：允许通过基类指针或引用，调用到派生类中具体实现的版本，从而实现动态绑定和多态。

**现代C++最佳实践**：在重写的函数后加上 `override` 关键字。这会强制编译器检查该函数是否真的满足重写的所有条件，如果不是，就会在编译时报错，避免了因手误导致的“静默错误”（本想重写却变成了隐藏）。

**示例**：

```cpp
class Animal {
public:
    virtual void speak() const { std::cout << "Animal speaks" << std::endl; }
    virtual ~Animal() {}
};

class Dog : public Animal {
public:
    void speak() const override { // 使用 override 确保是重写
        std::cout << "Dog barks: Woof!" << std::endl;
    }
};

Animal* p = new Dog();
p->speak(); // 运行时动态绑定，调用的是 Dog::speak()
delete p;
```

**决策时机**：**运行时**。当通过基类指针或引用调用虚函数时，系统会根据指针实际指向的**对象类型**，通过虚函数表（vtable）来决定调用哪个版本。

-----

### 3\. 隐藏 (Hiding) / 名称隐藏

**定义**：在派生类中定义了一个与基类**同名**的函数（或成员变量），从而导致基类的同名实体在派生类的作用域中被\*\*“隐藏”或“遮蔽”\*\*。

一旦发生隐藏，当通过派生类对象或指针调用该名字的函数时，编译器将**只在派生类的作用域中查找**，不再去基类中查找。

**发生隐藏的两种主要情况：**

1.  **参数列表不同**：无论基类函数是否为 `virtual`，只要派生类定义了同名函数但参数列表不同，基类的所有同名函数（包括所有重载版本）都会被隐藏。

    ```cpp
    class Base {
    public:
        void func(int i) { /* ... */ }
        void func(double d) { /* ... */ }
    };

    class Derived : public Base {
    public:
        void func(const std::string& s) { /* ... */ } // 隐藏了 Base::func(int) 和 Base::func(double)
    };

    Derived d;
    d.func("hello"); // OK
    // d.func(10);      // 编译错误！编译器在 Derived 中找到了 func，就不会再去 Base 中找
    d.Base::func(10);  // OK，必须使用作用域解析运算符显式调用
    ```

    **解决方法**：在派生类中使用 `using Base::func;` 声明，可以将基类中被隐藏的同名函数引入到派生类的作用域中，使它们也参与重载解析。

2.  **参数列表相同，但基类函数不是 `virtual`**：这种情况下，派生类的函数会隐藏基类的函数，它们之间只是普通的同名函数，没有多态关系。

    ```cpp
    class Base {
    public:
        void func(int i) { /* ... */ } // 非虚函数
    };

    class Derived : public Base {
    public:
        void func(int i) { /* ... */ } // 隐藏 Base::func(int)
    };

    Base* p = new Derived();
    p->func(10); // 调用的是 Base::func(10)，因为 func 不是虚函数，静态绑定
    ```

**决策时机**：**编译时**。隐藏是基于静态类型和名称解析规则的。

### 总结表格

| 特性         | 重载 (Overload)      | 重写 (Override)       | 隐藏 (Hiding)     |
| :--------- | :----------------- | :------------------ | :-------------- |
| **作用域**    | **同一作用域** (如类内)    | **父子类之间**           | **父子类之间**       |
| **函数签名**   | 函数名相同，**参数列表必须不同** | 函数名、参数列表**必须相同**    | 函数名相同，参数列表可同可不同 |
| **基类函数要求** | 无要求                | **必须是 `virtual`**   | 无要求             |
| **决策时机**   | **编译时**            | **运行时** (通过基类指针/引用) | **编译时**         |
| **关系**     | 水平关系               | 垂直关系 (多态)           | 垂直关系 (名称遮蔽)     |

您的补充示例非常完美地展示了重写和隐藏在通过基类指针调用时的关键区别，清晰地证明了**重写（虚函数）是动态绑定，而隐藏（非虚函数）是静态绑定**。