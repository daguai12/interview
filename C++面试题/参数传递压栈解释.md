这是一个非常棒的问题，它触及了函数调用约定（Calling Convention）的核心。

答案是：**参数是由调用者（caller）准备并放置的，但它们最终成为被调用者（callee）栈帧的一部分。**

我们可以把这个过程分解来看，这样会更清晰：

### 经典的、完全通过栈传递参数的情况

在一些较老的或者特定的调用约定中，所有参数都通过栈来传递。这个过程像一个交接仪式：

1.  **第一步 (在调用者函数内完成)**：
    在执行 `call` 指令跳转到被调用函数**之前**，**调用者**有责任将所有要传递的参数，按照约定的顺序（通常是从右到左）压入自己的栈顶。

2.  **第二步 (跳转)**：
    调用者执行 `call` 指令，这个指令会自动将**返回地址**（即 `call` 指令的下一条指令的地址）压入栈中，然后跳转到被调用函数的代码。

3.  **第三步 (在被调用者函数内完成)**：
    被调用函数开始执行。它的“函数序言（prologue）”代码会建立自己的栈帧。这个栈帧的起始位置就在刚刚压入的返回地址之下。

因此，当被调用者的栈帧建立完成后，从内存布局上看，那些由调用者提前压入栈的参数，正好位于被调用者栈帧的**最顶部**（高地址处），紧邻着返回地址。被调用函数会通过自己的基址指针（`EBP`/`RBP`）加上一个正向偏移量来访问这些参数。

**所以，虽然动作是调用者做的，但结果是这些参数成为了被调用者栈帧的一部分，归被调用者使用。**

### 现代高效的调用约定 (例如x86-64)

为了提升效率，现代的64位系统调用约定做了很大的优化，因为访问寄存器的速度远快于访问内存（栈）。

* **前几个参数通过寄存器传递**：
    通常，前 4 到 6 个简单类型（如整数、指针）的参数不再通过栈传递，而是直接放入**CPU寄存器**中。
    * 例如，在 Linux (System V AMD64 ABI) 中，前六个整数/指针参数依次通过 `RDI`, `RSI`, `RDX`, `RCX`, `R8`, `R9` 寄存器传递。
    * 在 64位 Windows (x64 aalling convention) 中，前四个参数通过 `RCX`, `RDX`, `R8`, `R9` 传递。

* **超出寄存器数量的参数才通过栈传递**：
    只有当参数数量超过了约定的寄存器数量时，多出来的参数才会像经典情况一样，由调用者压入栈中。

### 总结

| 方式 | 谁准备？ | 放在哪里？ | 谁的栈帧？ |
| :--- | :--- | :--- | :--- |
| **经典方式(全用栈)** | **调用者** (Caller) | 调用者将参数压入栈顶 | **被调用者** (Callee) 的栈帧 |
| **现代方式(寄存器+栈)** | **调用者** (Caller) | 前几个参数放入**寄存器**，其余的压入栈顶 | 其余的参数成为**被调用者** (Callee) 的栈帧 |

**结论**：无论是哪种方式，传递参数的“准备工作”总是由**调用者**完成的。对于那些需要通过栈传递的参数，它们在内存布局上被视为**被调用者**栈帧的组成部分。