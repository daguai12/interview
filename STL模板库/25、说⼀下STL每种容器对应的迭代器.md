### 1. 迭代器类别回顾

首先，我们回顾一下迭代器类别的“能力等级”金字塔，从最强到最弱：
1.  **随机访问迭代器 (Random Access Iterator)**：`++`, `--`, `+n`, `-n`, `[]` 等所有操作。
2.  **双向迭代器 (Bidirectional Iterator)**：`++`, `--`。
3.  **前向迭代器 (Forward Iterator)**：`++`。
4.  **输入/输出迭代器**：更弱的单向迭代器。

一个容器提供的迭代器类别，完全取决于其**底层数据结构**能否高效地支持这些操作。

---

### 2. 各容器的迭代器类别详解

#### a) 随机访问迭代器 (Random Access Iterators)

这是能力最强的迭代器，支持 O(1) 复杂度的任意位置跳转。

* **`std::vector`**
* **`std::deque`**
* **`std::array`** (C++11)
* (以及C风格的原生指针 `T*`)

**原因**：这些容器的底层都依赖于**连续或分段连续的内存块（数组）**。这使得通过简单的数学计算（`基地址 + 索引 * 元素大小`）就能以 O(1) 的效率定位到任何一个元素，从而支持 `+`, `-`, `[]` 等操作。

#### b) 双向迭代器 (Bidirectional Iterators)

支持向前（`++`）和向后（`--`）移动，但不支持 O(1) 的跳跃。

* **`std::list`**
    * **原因**：其底层是**双向链表**。每个节点都存有指向前一个（`prev`）和后一个（`next`）节点的指针，因此 `++` 和 `--` 操作都非常高效（O(1)）。但要访问第n个元素，必须从头或尾一步步走过去。

* **`std::map` / `std::multimap`**
* **`std::set` / `std::multiset`**
    * **原因**：其底层是**红黑树**（一种自平衡二叉搜索树）。树的节点通常存有指向父节点、左子节点和右子节点的指针。通过这些指针，可以高效地找到中序遍历下的前一个和后一个元素，从而支持 `++` 和 `--`。

#### c) 前向迭代器 (Forward Iterators)

只支持向前移动（`++`）。

* **`std::forward_list` (C++11)**
    * **原因**：其底层是**单向链表**。每个节点只存有指向下一个（`next`）节点的指针，没有办法高效地找到前一个元素，因此不支持 `--`。

* **`std::unordered_set` / `std::unordered_map` / `..._multiset` / `..._multimap`**
    * **您的总结非常接近，但这里有一个微妙的细节**：
    * **C++标准要求**：无序容器的迭代器**至少**要满足**前向迭代器**的要求。因为其底层哈希表的链表（用于解决冲突）是单向的就足够实现所有基本功能。
    * **主流实现**：在实践中，大多数现代标准库实现（如 GCC 的 libstdc++ 和 Clang 的 libc++）为了方便，其内部的链表节点实际上是**双向**的，因此它们为无序容器提供了**双向迭代器**。然而，**MSVC** 的实现则只提供**前向迭代器**。
    * **结论**：为了代码的可移植性，我们应该**只假定**无序容器的迭代器是**前向迭代器**，不要在代码中对其使用 `--` 操作，即使在你当前的编译器上它可能碰巧能够工作。

#### d) 不提供迭代器 (No Iterators)

* **`std::stack`**
* **`std::queue`**
* **`std::priority_queue`**

**原因**：这三者是**容器适配器 (Container Adaptors)**，而不是真正的容器。它们的设计目的就是提供一个**受限的、特定的接口**（如LIFO或FIFO）。如果它们暴露了迭代器，就允许用户绕过这个受限接口去访问甚至修改容器中间的元素，这完全违背了它们的设计初衷。

---

### 总结表格

| 迭代器类别                    | 核心能力              | 对应容器                                     |
| :----------------------- | :---------------- | :--------------------------------------- |
| **随机访问 (Random Access)** | `it + n`, `it[n]` | `vector`, `deque`, `array`, `string`     |
| **双向 (Bidirectional)**   | `it--`            | `list`, `map`, `set`                     |
| **前向 (Forward)**         | `it++`            | `forward_list`, **`unordered_`系列（标准保证）** |
| **(无迭代器)**               | -                 | `stack`, `queue`, `priority_queue`       |

**核心 takeaway**：一个容器支持何种迭代器，完全由其底层数据结构的性质决定。这个迭代器类别，又进一步决定了哪些STL算法可以高效地（或根本上）应用于这个容器。