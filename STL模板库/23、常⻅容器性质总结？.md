### C++ STL 容器的分类

C++标准库容器主要可以分为三大类：**序列式容器**、**关联式容器**和**容器适配器**。

### 1. 序列式容器 (Sequence Containers)

**核心特点**：元素在容器中的位置与其插入的时机和位置有关，呈**线性排列**。

* **`std::vector`**
    * **底层结构**：动态数组。内存**连续**。
    * **优点**：支持快速**随机访问**（`[]`和`.at()`，O(1)）。尾部插入/删除效率高（摊销O(1)）。
    * **缺点**：在序列**中间或头部**插入/删除元素效率低（O(n)），因为需要移动大量元素。
    * **适用场景**：**默认首选的序列容器**。需要高频随机访问，且主要在尾部操作数据。

* **`std::list`**
    * **底层结构**：**双向链表**。内存**不连续**。
    * **优点**：在序列**任意位置**插入/删除元素效率极高（O(1)）。迭代器非常稳定，不会因其他位置的增删而失效。
    * **缺点**：不支持随机访问，访问某个元素必须遍历（O(n)）。每个元素有额外的指针开销。
    * **适用场景**：需要对序列进行大量、频繁的非头尾位置的插入和删除操作。

* **`std::deque` (双端队列)**
    * **底层结构**：分段的连续数组（一个中控器管理多个缓冲区）。
    * **优点**：支持快速随机访问（O(1)，但常数时间比`vector`稍慢）。在**序列的头部和尾部**插入/删除都非常高效（O(1)）。
    * **缺点**：在序列**中间**插入/删除效率低（O(n)）。内存布局比`vector`复杂。
    * **适用场景**：需要一个类似队列、能在头尾两端高效操作的数据结构。

* **`std::array` (C++11)**
    * **底层结构**：固定大小的数组。内存**连续**。
    * **优点**：与C风格数组性能相同，但提供了更安全、更现代的容器接口（如迭代器、`.size()`）。大小在编译时确定，通常分配在栈上。
    * **缺点**：大小不可变。
    * **适用场景**：替换C风格的定长数组。

---

### 2. 关联式容器 (Associative Containers)

**核心特点**：元素根据其**键（Key）**自动排序。分为“键-值”对的 `map` 和只有“键”的 `set`。

#### a) 有序关联容器（基于红黑树）

* **`std::map`** / **`std::multimap`**
    * **底层结构**：**红黑树**。
    * **特点**：存储 `key-value` 对，元素按 `key` **自动排序**。`map` 的 `key` 唯一，`multimap` 允许 `key` 重复。
    * **性能**：插入、删除、查找操作的时间复杂度都是 **O(log n)**。
    * **适用场景**：需要一个按键排序的字典，或需要进行范围查找。

* **`std::set`** / **`std::multiset`**
    * **底层结构**：**红黑树**。
    * **特点**：只存储 `key`（值就是键），元素**自动排序**。`set` 的 `key` 唯一，`multiset` 允许 `key` 重复。
    * **性能**：插入、删除、查找操作的时间复杂度都是 **O(log n)**。
    * **适用场景**：需要一个有序的、不允许/允许重复的元素集合，并快速判断元素是否存在。

#### b) 无序关联容器 (C++11)（基于哈希表）

* **`std::unordered_map`** / **`std::unordered_multimap`**
    * **底层结构**：**哈希表**。
    * **特点**：存储 `key-value` 对，元素**无序**。
    * **性能**：平均情况下的插入、删除、查找操作时间复杂度为 **O(1)**，最坏情况为 O(n)。
    * **适用场景**：追求极致的查找性能，且不关心元素顺序的字典。（**现代C++字典的首选**）

* **`std::unordered_set`** / **`std::unordered_multiset`**
    * **底层结构**：**哈希表**。
    * **特点**：只存储 `key`，元素**无序**。
    * **性能**：平均情况下的插入、删除、查找操作时间复杂度为 **O(1)**。
    * **适用场景**：追求极致的判断元素是否存在性能，且不关心顺序。

---

### 3. 容器适配器 (Container Adaptors)

正如您所指出的，它们**不是真正的容器**，而是对现有序列容器的**接口进行封装**，以提供特定的行为模式。

* **`std::stack`** (栈)
    * **行为**：后进先出 (LIFO - Last-In, First-Out)。
    * **接口**：`push()`, `pop()`, `top()`。
    * **默认底层容器**：`std::deque`。

* **`std::queue`** (队列)
    * **行为**：先进先出 (FIFO - First-In, First-Out)。
    * **接口**：`push()`, `pop()`, `front()`, `back()`。
    * **默认底层容器**：`std::deque`。

* **`std::priority_queue`** (优先队列)
    * **行为**：保证 `top()` 永远是队列中优先级最高的元素。
    * **接口**：`push()`, `pop()`, `top()`。
    * **默认底层容器**：`std::vector`，并以**堆（Heap）**的数据结构进行管理。

**为什么 `stack` 和 `queue` 不默认使用 `vector`？**
`queue` 需要高效的 `pop_front()` 操作，而 `vector` 的头部删除是 O(n) 的，效率极低。`deque` 则为 `pop_front()` 和 `push_back()` 都提供了 O(1) 的支持。`stack` 只需 `push_back()` 和 `pop_back()`，虽然 `vector` 也能满足，但为了统一和泛用性，标准库也选择了 `deque` 作为其默认底层实现。