### 1. 为什么需要扩容？—— 维持 O(1) 平均性能

首先，我们要明白 `unordered_map` 的核心承诺是提供**平均时间复杂度为 O(1) 的插入、删除和查找**。

这个承诺的基石，是让哈希冲突（即多个不同的键哈希到同一个“桶”）尽可能少，从而保证每个桶后面挂载的链表都非常短。

* **负载因子 (Load Factor)**：这是一个关键指标，用于衡量哈希表的“拥挤”程度。
  `负载因子 = 已存储的元素总数 / 桶的总数`

* **触发时机**：`unordered_map` 内部有一个**最大负载因子** (`max_load_factor()`)，默认值通常是 **1.0**。当一次插入操作**将要导致**负载因子**超过**这个最大值时，就会在插入新元素**之前**触发一次扩容。

**一个生动的比喻：**
* **哈希表**：就像一个**停车场**。
* **桶 (Buckets)**：是停车场里一排排的**停车位**。
* **元素 (Nodes)**：是停在车位里的**汽车**。
* **哈希冲突**：多个车主都想停在同一个车位，只好在车位后面排起队（**链表**）。
* **负载因子**：是“**停车场占用率**”。
* **扩容 (Rehashing)**：当停车场占用率太高（超过100%），导致排队的汽车太多，找车变得很慢时，管理员决定**关闭旧停车场，启用一个旁边新建的、更大的停车场**，并指挥所有车辆重新停到新停车场里去。

---

### 2. 扩容（Rehashing）时发生了什么？

“扩容”在哈希表的世界里，有一个更精确的名字，叫做**“重哈希（Rehashing）”**，因为它不仅仅是扩大空间，更重要的是要**为所有元素重新计算位置**。

这个过程通常包含以下几个步骤：

1.  **申请新空间**：
    * 容器会在堆上申请一块**全新的、更大的内存**，用于创建一个新的“桶数组”。
    * 新桶数组的大小通常是**原大小两倍左右的一个质数**。使用质数有助于让哈希值在取模后更均匀地分布，进一步减少冲突。

2.  **遍历所有旧元素**：
    * 容器会从头到尾，**遍历旧桶数组中的每一个桶**，以及桶后面链表上的**每一个元素**。

3.  **为每个元素重新计算哈希索引**：
    * 这是“重哈希”的核心。对于每一个旧元素，容器会重新计算它在新表中的位置。
    * 新索引 = `hash(key) % 新的桶数量`
    * 因为“分母”（桶数量）变了，所以一个元素在旧表和新表中的位置通常是**不同**的。

4.  **将元素放入新表**：
    * 根据计算出的新索引，将元素插入到新桶数组对应位置的链表中。

5.  **释放旧空间**：
    * 当所有元素都迁移到新表之后，旧的桶数组和其内部结构会被**完全释放**。

---

### 3. 扩容的后果

#### a) 性能开销
* 重哈希是一个**非常昂贵**的操作，其时间复杂度为 **O(n)**，其中 `n` 是容器中元素的数量。
* 在执行重哈希时，程序可能会出现一次**可观的、瞬时的性能抖动或卡顿**。

#### b) 迭代器、指针和引用的失效
* 因为重哈希会**重新分配所有内存**，并**移动每一个元素**到新的位置，所以：
* **在重哈希之后，所有指向该容器元素的原有迭代器、指针和引用，将全部失效！**
* 继续使用这些失效的迭代器将导致**未定义行为**。

### 4. 如何控制扩容行为？

STL 提供了 `reserve()` 成员函数，让程序员可以主动管理扩容，避免在关键时刻发生意料之外的性能卡顿。

`my_map.reserve(n);`

这个函数会请求容器**一次性地将桶数量调整到至少能容纳 `n` 个元素而不会触发重哈希**的程度。

**适用场景**：
如果你能预知你将要向 `unordered_map` 中插入大量的元素（例如，从文件中读取100万条记录），最佳实践是：

1.  先创建一个空的 `unordered_map`。
2.  调用 `my_map.reserve(1000000);`，进行一次性的、可预期的重哈希。
3.  然后在一个循环中，执行100万次 `insert` 或 `emplace`。这些插入操作将非常快，因为它们不会再触发任何重哈希。

这比让 `unordered_map` 在插入过程中自动进行多次（例如 1, 2, 4, 8... -> ~20次）零散的重哈希，性能要高得多。