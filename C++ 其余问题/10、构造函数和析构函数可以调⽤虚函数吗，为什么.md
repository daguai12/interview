### 明确的答案

首先，我们来明确结论：

1.  **构造函数**：**可以**调用虚函数，但**不推荐**这样做。
2.  **析构函数**：**可以**调用虚函数，但同样**不推荐**这样做。

关键在于，在这两种特殊的成员函数中调用虚函数时，**动态绑定（Dynamic Binding）机制会失效**，调用会被解析为对**当前正在执行构造/析构的类**中所定义的版本的**静态调用**。

-----

### 1\. 为什么会这样？—— 对象生命周期中的“身份”变化

要理解这个行为，我们需要把对象的构造和析构过程看作是一个\*\*“身份”动态变化\*\*的过程。

**一个生动的比喻：盖楼与拆楼**

  * **基类 `Building`**：定义了建筑的“地基和框架”。
  * **派生类 `Skyscraper`**：在 `Building` 的基础上，增加了“玻璃幕墙和顶层天线”。
  * **虚函数 `clean()`**：`Building::clean()` 负责打扫框架，`Skyscraper::clean()` 负责擦玻璃。

#### a) 构造过程 (自底向上：`Building` -\> `Skyscraper`)

1.  **地基施工阶段**：当 `Skyscraper` 对象开始构造时，首先会调用其基类 `Building` 的构造函数。在这个阶段，对象在内存中还只是一个\*\*“半成品”**，只有地基和框架。派生类的“玻璃幕墙”成员此时还**不存在或未初始化\*\*。
2.  **“身份”是基类**：在 `Building` 构造函数执行期间，对象的类型被**视作 `Building`**。它的虚函数表指针（`vptr`）指向的是 `Building` 的虚函数表。
3.  **调用虚函数**：此时，如果在 `Building` 的构造函数中调用虚函数 `clean()`，因为对象的“身份”还是 `Building`，所以调用的必然是 `Building::clean()`（打扫框架）。**C++ 语言规定这样做是为了安全**，因为它杜绝了在派生类成员还未初始化时，就去调用派生类版本的虚函数（总不能在地基没打好时就去擦一块还不存在的玻璃吧！）。
4.  **派生类施工**：基类构造完成后，才开始执行派生类 `Skyscraper` 的构造函数，安装玻璃幕墙。此时，对象的 `vptr` 才被**更新为指向 `Skyscraper` 的虚函数表**，对象的“身份”才正式变为 `Skyscraper`。

#### b) 析构过程 (自顶向下：`Skyscraper` -\> `Building`)

1.  **外墙拆除阶段**：当 `Skyscraper` 对象被销毁时，首先会调用**派生类 `Skyscraper` 的析构函数**。在这个阶段，对象的“身份”还是 `Skyscraper`，`vptr` 指向 `Skyscraper` 的虚函数表。
2.  **派生类成员销毁**：`Skyscraper` 的析构函数执行完毕后，其“玻璃幕墙”成员被销毁。
3.  **“身份”退化为基类**：接下来，程序开始执行**基类 `Building` 的析构函数**。在进入基类析构函数的那一刻，对象就已经**不再是**一个 `Skyscraper` 了，它的“身份”**退化**回了 `Building`。其 `vptr` 也会被重置为指向 `Building` 的虚函数表。
4.  **调用虚函数**：此时，如果在 `Building` 的析构函数中调用虚函数 `clean()`，因为对象的“身份”已经退化为 `Building`，所以调用的必然是 `Building::clean()`（打扫框架）。**调用一个已经被销毁的派生类版本的虚函数是毫无意义且极其危险的**。

-----

### 2\. 代码示例

下面的代码清晰地展示了这一行为：

```cpp
#include <iostream>

class Base {
public:
    Base() {
        std::cout << "Base constructor starts. Calling virtual log()... ";
        log(); // 静态绑定到 Base::log()
    }

    virtual void log() const {
        std::cout << "Log from Base" << std::endl;
    }

    virtual ~Base() {
        std::cout << "Base destructor starts. Calling virtual log()... ";
        log(); // 静态绑定到 Base::log()
    }
};

class Derived : public Base {
public:
    Derived() {
        std::cout << "Derived constructor starts." << std::endl;
    }

    void log() const override {
        std::cout << "Log from Derived" << std::endl;
    }
    
    ~Derived() {
        std::cout << "Derived destructor starts." << std::endl;
    }
};


int main() {
    Derived d;
    return 0;
}
```

**输出结果：**

```
Base constructor starts. Calling virtual log()... Log from Base
Derived constructor starts.
Derived destructor starts.
Base destructor starts. Calling virtual log()... Log from Base
```

**分析**：

  * 在 `Base` 的构造函数中调用 `log()` 时，输出的是 `Log from Base`，而不是 `Log from Derived`。
  * 在 `Base` 的析构函数中调用 `log()` 时，输出的**同样是** `Log from Base`。
  * 这完美地证明了，在构造和析构期间，虚函数调用被解析为了对**当前正在执行构造/析构的类**的版本的调用。

### 3\. 总结与实践建议

  * **可以调用吗？**：**可以**，语法上允许。
  * **发生什么？**：**动态绑定机制失效**，发生静态绑定，调用的是当前类中定义的版本。
  * **为什么？**：为了保证**类型安全**。C++通过在构造/析构期间改变对象的“动态类型”，防止了对**未初始化**或**已销毁**的派生类成员的访问。
  * **最佳实践**：**强烈建议不要在构造函数和析构函数中调用虚函数。**
      * 因为这种行为违反了虚函数通常给人的“调用到最终派生类版本”的直觉，容易导致混淆和逻辑错误。
      * 如果你需要在对象完全构造后，根据其动态类型执行某些初始化逻辑，更好的设计模式是**两阶段构造（Two-Phase Construction）**，即提供一个独立的、`public` 的（可以是 `virtual` 的）`init()` 方法，在对象被完全构造**之后**再调用它。