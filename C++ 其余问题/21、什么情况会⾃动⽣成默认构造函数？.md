您好，您对“什么情况下会自动生成默认构造函数”这个问题的总结非常专业和准确！您已经列出了C++对象模型中，**迫使**编译器必须为您合成（synthesize）一个默认构造函数的几个关键场景。

这是一个深入理解C++类生命周期和编译器行为的核心问题。我将基于您这份优秀的提纲，进行一个更系统化的梳理和展开。

-----

### 1\. 核心前提：何时“考虑”生成？

首先，有一个最重要的前提：编译器**只会**在你的类**没有声明任何构造函数**的情况下，才会**考虑**为你自动生成一个默认构造函数。

如果你为类显式地声明了**任何**一个构造函数（无论是拷贝构造、带参数的构造，还是其他），编译器就会认为：“哦，程序员已经接管了构造过程”，于是它就**不会**再自动生成默认构造函数了。

```cpp
class MyClass {
public:
    // 用户只提供了一个带参数的构造函数
    MyClass(int val) : data(val) {} 
private:
    int data;
};

int main() {
    // MyClass obj; // 编译错误！
    // 错误信息：no matching function for call to 'MyClass::MyClass()'
    // 因为 MyClass(int) 的存在，编译器不再提供默认的 MyClass()。
    
    MyClass obj2(10); // OK
}
```

-----

### 2\. 何时“必须”生成？

在满足上述前提（用户没有声明任何构造函数）的情况下，如果出现了您提到的以下几种情况，编译器就**必须**为你合成一个默认构造函数，以保证对象的正确构建。

#### a) 类中含有带默认构造函数的成员对象

正如您所说，如果一个类 `Container` 包含了一个成员对象 `m_member`，而 `m_member` 的类型 `Member` 有自己的默认构造函数。

```cpp
class Member {
public:
    Member() { std::cout << "Member default constructor called.\n"; }
};

class Container {
private:
    Member m_member;
    // 用户没有为 Container 提供任何构造函数
};
```

当代码试图创建 `Container` 的对象时（`Container c;`），`c.m_member` 必须被正确地初始化。为了调用 `Member::Member()`，编译器**必须**为 `Container` 合成一个默认构造函数，其唯一的工作就是去调用 `m_member` 的默认构造函数。

#### b) 派生自带有默认构造函数的基类

这与成员对象的情况完全相同。派生类对象的构造，必须先于自身构造其基类部分。

```cpp
class Base {
public:
    Base() { std::cout << "Base default constructor called.\n"; }
};

class Derived : public Base {
    // 用户没有为 Derived 提供任何构造函数
};
```

当代码创建 `Derived` 的对象时（`Derived d;`），必须先调用 `Base` 的默认构造函数。为了实现这个调用，编译器**必须**为 `Derived` 合成一个默认构造函数。

#### c) 类中含有虚函数

```cpp
class Polymorphic {
public:
    virtual void func() {}
    // 用户没有提供任何构造函数
};
```

**原因**：为了实现多态，编译器需要在每个多态对象中安插一个**虚函数表指针 (`vptr`)**。这个 `vptr` 的初始化工作必须在**构造函数**中完成。如果用户没有提供任何构造函数，编译器就**必须**合成一个默认构造函数来完成 `vptr` 的初始化。

#### d) 类继承了虚基类

**原因**：与虚函数的情况类似。为了解决菱形继承问题，虚继承的实现需要一个**虚基类表指针 (`vbptr`)**。这个指针也必须在构造函数中被初始化。如果用户不提供构造函数，编译器就**必须**合成一个来完成这个任务。

-----

### 3\. 合成的默认构造函数做什么？不做什么？

您的第5点总结非常到位，这是理解合成构造函数局限性的关键。

一个由编译器合成的默认构造函数，只会执行那些\*\*“绝对必要”\*\*的操作，它像一个“尽职但不热情”的工人。

**它会做的事情：**

  * 调用所有**基类**的默认构造函数。
  * 调用所有**类类型成员**的默认构造函数。
  * 正确地初始化 `vptr` 和 `vbptr`（如果需要）。

**它不会做的事情：**

  * **它绝对不会初始化任何内置类型的非静态数据成员**（如 `int`, `double`, 指针等）。
  * **它也不会初始化任何静态成员变量**（静态成员有其独立的初始化规则）。

**代码示例**：

```cpp
#include <iostream>
#include <string>

class MyClass {
private:
    int m_int;           // 内置类型
    double* m_ptr;       // 内置类型
    std::string m_string; // 类类型
public:
    void print() {
        std::cout << "m_int: " << m_int << std::endl;
        std::cout << "m_ptr: " << m_ptr << std::endl;
        std::cout << "m_string: \"" << m_string << "\"" << std::endl;
    }
};

int main() {
    MyClass obj; // 编译器合成了默认构造函数
    obj.print();
}
```

**可能的输出**：

```
m_int: 4201021  <-- 垃圾值
m_ptr: 0x7ffee...  <-- 垃圾地址
m_string: ""   <-- 被 std::string 的默认构造函数正确初始化为空字符串
```

这个例子清晰地表明，依赖编译器合成的默认构造函数，对于包含内置类型成员的类来说是**不安全**的。

### 总结与现代C++实践

1.  **何时生成**：当你**没有定义任何构造函数**，并且类中含有**需要默认初始化的基类、成员对象**或\*\*需要初始化`vptr`/`vbptr`\*\*时，编译器会自动生成一个默认构造函数。
2.  **做什么**：它只负责调用基类和成员的默认构造函数，以及设置 `vptr`/`vbptr`。它**不会**初始化内置类型的成员。
3.  **现代C++建议 (`= default`)**：
    如果你需要一个默认构造函数，并且希望它的行为就是编译器默认的行为，最清晰的做法是使用 `= default`。
    ```cpp
    class MyClass {
    public:
        MyClass(int x) { /*...*/ } // 有了其他构造函数
        MyClass() = default;      // 但我仍然需要一个默认构造函数，请编译器生成它
    };
    ```
    这比写一个空的 `{}` 函数体更好，因为它可能会让类型保持\*\*“平凡”（Trivial）\*\*，从而获得性能优势。