## EventLoopçš„å®šä¹‰
EventLoopæ˜¯äº‹ä»¶å¾ªç¯.
## EventLoopçš„ä½œç”¨
- é€šè¿‡è°ƒç”¨ `Polleræ¨¡å—` æ¥ç›‘å¬å’Œåˆ†å‘äº‹ä»¶

åœ¨Muduoä¸­ï¼Œæ¯ä¸ª `EventLoop` é€šå¸¸å¯¹åº”ä¸€ä¸ªçº¿ç¨‹ï¼Œ**å®ç°äº†"ä¸€ä¸ªçº¿ç¨‹å¯¹åº”ä¸€ä¸ªloop**çš„æ¨¡å‹ã€‚

**æ ¸å¿ƒèŒè´£**

1. **IOå¤ç”¨**
	-  é€šè¿‡ `epoll_wait()` ç­‰å¾…æ–‡ä»¶æè¿°ç¬¦çš„ IO äº‹ä»¶å‘ç”Ÿã€‚
	- äº‹ä»¶å‘ç”Ÿä»¥åï¼Œè°ƒç”¨ `Channel` ä¸­çš„å›è°ƒå‡½æ•°ã€‚
	

## æˆå‘˜å˜é‡è¯¦è§£
```c++
using ChannelList = std::vector<Channel*>;

std::atomic_bool looping_; /*atomic*/
std::atomic_bool quit_;

const pid_t threadId_;

Timestamp pollReturnTime_;
std::unique_ptr<Poller> poller_;

int wakeupFd_;
std::unique_ptr<Channel> wakeupChannel_;

ChannelList activeChannels_;

std::atomic_bool callingPendingFunctors_; 
std::vector<Functor> pendingFunctors_; 
std::mutex mutex_;

```

- `looping_:` æ ‡ç¤ºæ˜¯å¦å¤„äºäº‹ä»¶å¾ªç¯ä¸­
- `quit_:` è¡¨ç¤ºæ˜¯å¦é€€å‡ºäº‹ä»¶å¾ªç¯
- `threadId_`:
- `pollReturnTime_`
- `poller_:` å°è£… `epoll` æ“ä½œçš„ç±»
- `wakeupFd:` 
- `wakeupChannel_`
- `activeChannels_`
- `callingPendingFunctors_:` åˆ¤æ–­æ˜¯å¦æ­£åœ¨æ‰§è¡Œå›è°ƒå‡½æ•°
- `pendingFunctors_`

## æˆå‘˜å‡½æ•°è¯¦è§£
### 1. createEventfd()

```c++
int createEventfd()
{
    int evtfd = ::eventfd(0, EFD_NONBLOCK | EFD_CLOEXEC);
    if (evtfd < 0)
    {
        LOG_FATAL("eventfd error:%d \n", errno);
    }
    return evtfd;
}
```

è¿™ä¸ªå‡½æ•°çš„ä½œç”¨æ˜¯ï¼š

> **åˆ›å»ºä¸€ä¸ª `eventfd` æ–‡ä»¶æè¿°ç¬¦**ï¼Œç”¨äº**çº¿ç¨‹é—´å”¤é†’ï¼ˆevent notificationï¼‰æœºåˆ¶**ï¼Œç„¶åè¿”å›å®ƒã€‚

* `eventfd` æ˜¯ Linux æä¾›çš„è½»é‡çº§**äº‹ä»¶é€šçŸ¥æœºåˆ¶**
* å¸¸ç”¨äº**å¤šçº¿ç¨‹æˆ–å¤šè¿›ç¨‹ä¹‹é—´çš„äº‹ä»¶å”¤é†’**
* åœ¨ Muduo é‡Œç”¨æ¥**å”¤é†’ EventLoop æ‰€åœ¨çº¿ç¨‹**ï¼Œæ¯”å¦‚åœ¨ `queueInLoop()` é‡Œï¼Œå¦‚æœå…¶ä»–çº¿ç¨‹è¦å¾€ `EventLoop` çº¿ç¨‹æ‰”ä»»åŠ¡ï¼Œå°±ç”¨ `eventfd` æ¥å”¤é†’ `poll()` æˆ– `epoll_wait()` é˜»å¡ä¸­çš„ EventLoopã€‚

>`eventfd()`ä»‹ç»

- write() ç»™è¿™ä¸ª fd å†™å…¥å€¼ï¼Œcounter += å†™å…¥å€¼
- read() ä»è¿™ä¸ª fd è¯»å–å€¼ï¼Œcounter â†’ 0ï¼Œå¹¶è¿”å›ä¹‹å‰çš„å€¼
- æ”¯æŒ EFD_NONBLOCK éé˜»å¡
- epoll å¯ä»¥ç›‘æ§è¿™ä¸ª fd çš„å¯è¯»äº‹ä»¶


### 2. wakeup() å’Œ handleRead()
è¿™ä¿©å‡½æ•°é…å¥—ç”¨æ¥å®ç°ï¼š

> **é€šè¿‡ eventfd å”¤é†’æ­£åœ¨ epoll\_wait çš„ EventLoop æ‰€åœ¨çº¿ç¨‹**

* `wakeup()`ï¼š**åˆ«çš„çº¿ç¨‹æˆ–è‡ªå·±è°ƒç”¨ï¼Œå‘ `eventfd` å†™æ•°æ®ï¼Œè§¦å‘å¯è¯»äº‹ä»¶**
* `handleRead()`ï¼š**EventLoop çº¿ç¨‹è‡ªå·±è°ƒç”¨ï¼Œè¯»å– eventfdï¼ŒæŠŠäº‹ä»¶æ¸…æ‰**


eventfd æ˜¯ä¸€ä¸ª 64 ä½æ— ç¬¦å·æ•´æ•°ï¼š

* `write()` å¢åŠ è¿™ä¸ªå€¼
* `read()` è¿”å›å½“å‰å€¼å¹¶æ¸…é›¶
* `epoll` å¯ä»¥ç›‘è§† eventfdï¼Œ**åªè¦è¿™ä¸ªå€¼ä¸ä¸º 0 å°±æ˜¯å¯è¯»**

**æ³¨æ„ï¼ševentfd çš„ read/write éƒ½æ˜¯ 8 å­—èŠ‚ï¼ˆuint64\_tï¼‰**


#### ğŸ”µ `wakeup()`

```cpp
void EventLoop::wakeup()
{
    uint64_t one = 1;
    ssize_t n = write(wakeupFd_, &one, sizeof one);
    if (n != sizeof one)
    {
        LOG_ERROR("EventLoop::wakeup() writes %lu bytes instead of 8 \n", n);
    }
}
```

#### ğŸ‘‰ ä½œç”¨ï¼š

**å‘ `wakeupFd_` å†™å…¥ 1ï¼Œè§¦å‘ epoll ä¸­æ³¨å†Œçš„ wakeupFd çš„å¯è¯»äº‹ä»¶ï¼Œä»è€Œå”¤é†’æ­£åœ¨ `epoll_wait()` çš„ EventLoop çº¿ç¨‹ã€‚**

#### ğŸ‘‰ ä¸ºä»€ä¹ˆå†™ `uint64_t one = 1`ï¼Ÿ

eventfd è§„å®šï¼šæ¯æ¬¡ `read/write` éƒ½æ˜¯ 8 å­—èŠ‚ï¼ˆ64 ä½æ— ç¬¦å·æ•´æ•°ï¼‰

#### ğŸ‘‰ ä¸ºä»€ä¹ˆè¦å”¤é†’ï¼Ÿ

å› ä¸ºåˆ«çš„çº¿ç¨‹è°ƒç”¨äº† `queueInLoop()` å¾€ `EventLoop` æ‰”äº†å›è°ƒå‡½æ•°ï¼Œå¾—é€šçŸ¥ EventLoop é†’ä¸€é†’ï¼Œæ‰§è¡Œ `doPendingFunctors()`

#### ğŸ‘‰ ä¸ºä»€ä¹ˆè¦åˆ¤æ–­ `n != sizeof one`ï¼Ÿ

é˜²æ­¢å†™å¤±è´¥æˆ–è€…å†™äº†ä¸æ»¡ 8 å­—èŠ‚ã€‚æŒ‰ç†è¯´ä¸ä¼šå‡ºé—®é¢˜ï¼Œä½†è¿™æ˜¯é˜²å¾¡æ€§ç¼–ç¨‹ã€‚

---

#### ğŸ”µ `handleRead()`

```cpp
void EventLoop::handleRead()
{
  uint64_t one = 1;
  ssize_t n = read(wakeupFd_, &one, sizeof one);
  if (n != sizeof one)
  {
    LOG_ERROR("EventLoop::handleRead() reads %lu bytes instead of 8", n);
  }
}
```

#### ğŸ‘‰ ä½œç”¨ï¼š

**æŠŠ wakeupFd ä¸­çš„æ•°æ®è¯»å‡ºæ¥ï¼Œé¿å… eventfd çš„ counter å€¼ç´¯ç§¯ï¼Œé˜²æ­¢ epoll é‡å¤è§¦å‘å¯è¯»äº‹ä»¶ã€‚**

#### ğŸ‘‰ ä¸ºä»€ä¹ˆè¯»å‡ºæ¥ï¼Ÿ

å¦‚æœä¸è¯»ï¼Œeventfd çš„ counter ä¼šç´¯ç§¯ä¸æ¸…é›¶ï¼Œ`epoll_wait` ä¹‹åæ¯æ¬¡éƒ½æ£€æµ‹åˆ°å¯è¯»ï¼Œä¸åœå”¤é†’ï¼Œé€ æˆç©ºè½¬ã€‚

#### ğŸ‘‰ ä¸ºä»€ä¹ˆä¸€æ ·åˆ¤æ–­ `n != sizeof one`ï¼Ÿ

è¿˜æ˜¯é˜²å¾¡æ€§ç¼–ç¨‹ï¼Œç¡®ä¿ read æ“ä½œæ­£ç¡®å®Œæˆã€‚

#### ğŸ“Œ ç»“åˆ epoll çš„å·¥ä½œæµç¨‹å›¾

### ğŸ“Š æµç¨‹ï¼š

```text
å…¶ä»–çº¿ç¨‹ï¼š
queueInLoop(cb) 
â†’ æ£€æŸ¥çº¿ç¨‹ï¼Œä¸æ˜¯æœ¬çº¿ç¨‹ æˆ–è€… æœ¬çº¿ç¨‹æ­£åœ¨ doPendingFunctors
â†’ wakeup()
â†’ write(wakeupFd_)

EventLoop çº¿ç¨‹ï¼š
epoll_wait()
â†’ wakeupFd_ å¯è¯»
â†’ è°ƒç”¨ handleRead()
â†’ doPendingFunctors()
```

* `EventLoop::loop()` é‡Œçš„ `epoll_wait` ç›‘å¬äº† wakeupFd\_
* `wakeup()` å†™ wakeupFd\_
* epoll æ£€æµ‹åˆ° wakeupFd\_ å¯è¯»ï¼Œå”¤é†’
* æ‰§è¡Œ `handleRead()` æŠŠ eventfd çš„å€¼æ¸…ç©º
* ç„¶åæ‰§è¡Œ `doPendingFunctors()` å¤„ç†é˜Ÿåˆ—é‡Œçš„ä»»åŠ¡

#### ğŸ“Œ ä¸ºä»€ä¹ˆä¸ç›´æ¥ç”¨ä¿¡å·ã€pipeï¼Ÿ

| æ–¹æ¡ˆ        | ä¼˜ç‚¹                  | ç¼ºç‚¹           |
| :-------- | :------------------ | :----------- |
| `eventfd` | é«˜æ•ˆã€å• fdã€å†…æ ¸å®ç°è½»é‡ã€ç®€å•å®‰å…¨ | åªæ”¯æŒ 64 ä½æ•´æ•°è¯»å†™ |
| `pipe`    | é€šç”¨ï¼Œæ”¯æŒä»»æ„æ•°æ®ä¼ é€’         | ä¸¤ä¸ª fdï¼Œæ•ˆç‡ç•¥ä½   |
| ä¿¡å· signal | å¤æ‚ã€ä¿¡å·å¯é æ€§å·®           | æ˜“ä¸¢å¤±ã€è°ƒåº¦å¼€é”€å¤§    |
|           |                     |              |
### 3. queueInLoop()

```c++
void EventLoop::queueInLoop(Functor cb)
{
    {
        std::unique_lock<std::mutex> lock(mutex_);
        pendingFunctors_.emplace_back(cb);
    }

    // å”¤é†’ç›¸åº”çš„ï¼Œéœ€è¦æ‰§è¡Œä¸Šé¢å›è°ƒæ“ä½œçš„loopçš„çº¿ç¨‹äº†
    // || callingPendingFunctors_çš„æ„æ€æ˜¯ï¼šå½“å‰loopæ­£åœ¨æ‰§è¡Œå›è°ƒï¼Œä½†æ˜¯loopåˆæœ‰äº†æ–°çš„å›è°ƒ
    if (!isInLoopThread() || callingPendingFunctors_) 
    {
        wakeup(); // å”¤é†’loopæ‰€åœ¨çº¿ç¨‹
    }
}

```

#### ğŸ“Œ æ€»ä½“ä½œç”¨

**æŠŠæŸä¸ªå›è°ƒå‡½æ•°ï¼ˆFunctorï¼‰æ”¾å…¥ `EventLoop` çš„å›è°ƒé˜Ÿåˆ— `pendingFunctors_` ä¸­ï¼Œå¦‚æœéœ€è¦å°±å”¤é†’ `EventLoop` çº¿ç¨‹å»æ‰§è¡Œå®ƒã€‚**

è¿™ä¸ªæ–¹æ³•çš„å…¸å‹åº”ç”¨åœºæ™¯ï¼š

* å…¶ä»–çº¿ç¨‹å‘ `EventLoop` çº¿ç¨‹å‘é€ä»»åŠ¡ï¼ˆå›è°ƒï¼‰
* è‡ªå·±çº¿ç¨‹åœ¨å›è°ƒä¸­ç»§ç»­è¿½åŠ å›è°ƒ


#### ğŸ“Œ å‡½æ•°é€è¡Œè¯¦ç»†è§£æ

```cpp
{
    std::unique_lock<std::mutex> lock(mutex_);
    pendingFunctors_.emplace_back(cb);
}
```

#### ğŸ“Œ ä½œç”¨ï¼š

* åŠ é”ä¿æŠ¤ `pendingFunctors_` é˜Ÿåˆ—ï¼Œé˜²æ­¢å¤šä¸ªçº¿ç¨‹åŒæ—¶è®¿é—®
* æŠŠä¼ è¿›æ¥çš„å›è°ƒ `cb` åŠ å…¥ `pendingFunctors_`

#### ğŸ“Œ ä¸ºä»€ä¹ˆè¦åŠ é”ï¼Ÿ

* `EventLoop` çš„ `doPendingFunctors()` å’Œå…¶ä»–çº¿ç¨‹çš„ `queueInLoop()` éƒ½ä¼šè®¿é—® `pendingFunctors_`
* éœ€è¦ç”¨ mutex ä¿è¯çº¿ç¨‹å®‰å…¨


```cpp
if (!isInLoopThread() || callingPendingFunctors_) 
```

#### ğŸ“Œ ä½œç”¨ï¼š

åˆ¤æ–­æ˜¯å¦éœ€è¦å”¤é†’ `EventLoop` æ‰€åœ¨çº¿ç¨‹ã€‚

#### ğŸ“Œ è¿™ä¿©æ¡ä»¶ä»€ä¹ˆæ„æ€ï¼Ÿ

##### â‘  `!isInLoopThread()`

* å¦‚æœ **å½“å‰çº¿ç¨‹ä¸æ˜¯ EventLoop æ‰€åœ¨çº¿ç¨‹**
  â†’ è¯´æ˜æ˜¯**å…¶ä»–çº¿ç¨‹**è°ƒç”¨ `queueInLoop()`ï¼Œè€Œ `EventLoop` çº¿ç¨‹å¯èƒ½æ­£åœ¨ `epoll_wait()` ç¡çœ ï¼Œéœ€è¦å”¤é†’å®ƒã€‚

##### â‘¡ `callingPendingFunctors_`

* è¡¨ç¤º**å½“å‰ EventLoop æ­£åœ¨æ‰§è¡Œ `doPendingFunctors()` å›è°ƒ**
* å¦‚æœæ­¤æ—¶åˆæœ‰æ–°çš„å›è°ƒåŠ å…¥ï¼Œå°±å¿…é¡»å”¤é†’ä¸€æ¬¡ï¼Œä¿è¯æ–°å›è°ƒèƒ½è¢«åŠæ—¶æ‰§è¡Œï¼Œè€Œä¸æ˜¯ç­‰ä¸‹ä¸€æ¬¡ `epoll_wait()` å”¤é†’ã€‚

### ğŸ“Œ ä¸ºä»€ä¹ˆè¦è¿™ä¸ªæ¡ä»¶ï¼Ÿ

å¦‚æœ\*\*å½“å‰çº¿ç¨‹æ˜¯ EventLoop çº¿ç¨‹ï¼Œä½†å®ƒæ­£å¤„åœ¨ `doPendingFunctors()` ä¸­ï¼Œ\*\*è€Œä½ åˆè°ƒç”¨ `queueInLoop()` åŠ äº†æ–°å›è°ƒï¼Œä¸å”¤é†’çš„è¯è¿™æ¬¡ `doPendingFunctors()` å¯èƒ½å°±ç»“æŸäº†ï¼Œå¯¼è‡´æ–°å›è°ƒä¸èƒ½åŠæ—¶æ‰§è¡Œã€‚

#### ğŸ‘‰ å”¤é†’ä¸€ä¸‹ï¼Œä¿è¯ï¼š

* **å½“å‰ doPendingFunctors æ‰§è¡Œå®Œ**
* **epoll\_wait ä¼šç«‹å³è¿”å›**
* **EventLoop ä¼šå†æ¬¡è¿›å…¥ `doPendingFunctors()`**

```cpp
wakeup(); // å”¤é†’loopæ‰€åœ¨çº¿ç¨‹
```

### ğŸ“Œ ä½œç”¨ï¼š

* å¦‚æœæ»¡è¶³ä¸Šé¢æ¡ä»¶ï¼Œå°±å”¤é†’ EventLoop æ‰€åœ¨çº¿ç¨‹
* åŸç†ï¼š`write()` å¾€ `eventfd` å†™å…¥æ•°æ®ï¼Œè§¦å‘ `epoll` çš„å¯è¯»äº‹ä»¶ï¼Œ`EventLoop` è¢«å”¤é†’


### ğŸ“Œ ä¸ºä»€ä¹ˆä¸ç›´æ¥ `runInLoop()`ï¼Ÿ

`runInLoop(cb)` é€šå¸¸æ˜¯ï¼š

* å¦‚æœæœ¬çº¿ç¨‹æ˜¯ `EventLoop` çº¿ç¨‹ï¼Œå°±**ç›´æ¥æ‰§è¡Œ cb**
* å¦åˆ™è°ƒç”¨ `queueInLoop(cb)`

`queueInLoop()` å°±æ˜¯**å¼‚æ­¥çº¿ç¨‹å®‰å…¨ç‰ˆ**ï¼Œé€‚åˆå…¶ä»–çº¿ç¨‹è°ƒã€‚

### 4.pendingFunctors_()
#### ğŸ“Œ å‡½æ•°ä½œç”¨

ğŸ‘‰ **æŠŠ pendingFunctors\_ é˜Ÿåˆ—é‡Œçš„ä»»åŠ¡æ‹¿å‡ºæ¥ï¼Œä¾æ¬¡æ‰§è¡Œå®ƒä»¬**

è¿™äº› `Functor` å¾€å¾€æ˜¯å…¶ä»–çº¿ç¨‹é€šè¿‡ `queueInLoop()` æ‰”è¿‡æ¥çš„â€œå¾…æ‰§è¡Œä»»åŠ¡â€ã€‚

---

#### ğŸ“Œ æ¯è¡Œç»†èŠ‚

```cpp
std::vector<Functor> functors;
```

å®šä¹‰ä¸€ä¸ª**å±€éƒ¨çš„ vector**ï¼Œç”¨æ¥ä¸´æ—¶ä¿å­˜å³å°†è¦æ‰§è¡Œçš„ Functor å›è°ƒã€‚

```cpp
callingPendingFunctors_ = true;
```

è®¾ç½®çŠ¶æ€ï¼š
ğŸ‘‰ å‘Šè¯‰ `EventLoop` å½“å‰æ­£åœ¨æ‰§è¡Œ pending çš„ Functor å›è°ƒã€‚
**é˜²æ­¢å…¶ä»–çº¿ç¨‹åœ¨è¿™ä¸ªè¿‡ç¨‹ä¸­åšå†²çªæ“ä½œ**ã€‚

```cpp
{
    std::unique_lock<std::mutex> lock(mutex_);
    functors.swap(pendingFunctors_);
}
```

### âœ… å¹²äº†å•¥ï¼Ÿ

1. **ä¸Šé”**ï¼šä¿è¯æ“ä½œ `pendingFunctors_` çš„çº¿ç¨‹å®‰å…¨
2. **äº¤æ¢æ•°æ®**ï¼š

   * `functors.swap(pendingFunctors_)`
     ğŸ‘‰ æŠŠ `pendingFunctors_` é‡Œçš„æ‰€æœ‰å›è°ƒï¼Œä¸€æ¬¡æ€§äº¤æ¢åˆ°å±€éƒ¨ `functors` é‡Œ
     ğŸ‘‰ **pendingFunctors\_ æ¸…ç©ºäº†**ï¼Œå±€éƒ¨ functors æ¥ç®¡ä»»åŠ¡
3. **é‡Šæ”¾é”**ï¼ˆå‡ºäº†ä½œç”¨åŸŸï¼‰

#### âœ… ä¸ºä»€ä¹ˆè¦ swapï¼Ÿ

* é¿å… holding é”çš„æ—¶é—´è¿‡é•¿ï¼ğŸ”¥
  å¦‚æœç›´æ¥åœ¨é”ä¿æŠ¤ä¸‹éå† `pendingFunctors_`ï¼Œå¦‚æœæŸä¸ªå›è°ƒè€—æ—¶ï¼Œåˆ«çš„çº¿ç¨‹è°ƒç”¨ `queueInLoop()` æ—¶å°±é˜»å¡åœ¨é”ä¸Šäº†
  â†’ **å½±å“æ€§èƒ½ã€å¯èƒ½æ­»é”**

---

```cpp
for (const Functor &functor : functors)
{
    functor();
}
```

#### âœ… å¹²äº†å•¥ï¼Ÿ

* éå† functors é‡Œçš„æ‰€æœ‰å›è°ƒï¼Œé€ä¸ªæ‰§è¡Œ

```cpp
callingPendingFunctors_ = false;
```

æ¢å¤çŠ¶æ€ï¼Œè¡¨ç¤ºæ‰§è¡Œå®Œæ¯•ã€‚


#### ğŸ“Œ æ€»ç»“ä¸€å¥ï¼š

* **å®‰å…¨é«˜æ•ˆåœ°å–å‡ºæ‰€æœ‰ pendingFunctors\_**
* **åœ¨æ— é”çŠ¶æ€ä¸‹æ‰§è¡Œå›è°ƒ**
* **é¿å…é˜»å¡ queueInLoop() çš„çº¿ç¨‹**
* **ä¿è¯çº¿ç¨‹å®‰å…¨å’Œé«˜æ€§èƒ½**


#### ğŸ“Œ æ€»ç»“äº®ç‚¹ï¼š

âœ… **é”ç²’åº¦å°**
âœ… **æ‰§è¡Œå›è°ƒä¸é˜»å¡ queueInLoop()**
âœ… **å®‰å…¨é˜²æ­¢ç«æ€**
âœ… **çŠ¶æ€å˜é‡ callingPendingFunctors\_ é˜²æ­¢é€’å½’å†²çª**


### 5. runInLoop()

#### ğŸ“Œ ä½œç”¨ï¼š

ğŸ‘‰ **åˆ¤æ–­å½“å‰è°ƒç”¨çº¿ç¨‹æ˜¯å¦æ˜¯ EventLoop æ‰€åœ¨çº¿ç¨‹**

* æ˜¯çš„è¯ï¼šç›´æ¥æ‰§è¡Œå›è°ƒ
* ä¸æ˜¯çš„è¯ï¼šé€šè¿‡ `queueInLoop()` å°†å›è°ƒåŠ å…¥ pendingFunctors\_ï¼Œç„¶åå”¤é†’ EventLoop çº¿ç¨‹æ‰§è¡Œ

**ç›®çš„**ï¼šç¡®ä¿æ‰€æœ‰å’Œ IO ç›¸å…³çš„æ“ä½œéƒ½åœ¨ EventLoop æ‰€å±çº¿ç¨‹ä¸­å®Œæˆï¼Œä¿è¯çº¿ç¨‹å®‰å…¨ã€‚

---

#### ğŸ“Œ é€è¡Œè¯¦ç»†è§£è¯»ï¼š

```cpp
if (isInLoopThread())
```

ğŸ‘‰ åˆ¤æ–­å½“å‰çº¿ç¨‹æ˜¯å¦æ˜¯ EventLoop åˆ›å»ºæ—¶æ‰€å±çš„çº¿ç¨‹ã€‚
**æ€ä¹ˆåˆ¤æ–­å‘¢ï¼Ÿ**
`isInLoopThread()` å°±æ˜¯å¯¹æ¯” `threadId_` å’Œ `CurrentThread::tid()`ã€‚
ï¼ˆ`EventLoop` æ„é€ çš„æ—¶å€™è®°å½•äº†è‡ªå·±åœ¨å“ªä¸ªçº¿ç¨‹ï¼‰

#### âœ… æ˜¯ EventLoop æ‰€åœ¨çº¿ç¨‹

```cpp
cb();
```

ğŸ‘‰ å¦‚æœå½“å‰çº¿ç¨‹å°±æ˜¯ EventLoop æ‰€åœ¨çº¿ç¨‹ï¼Œ**ç›´æ¥æ‰§è¡Œ Functor**ã€‚

å› ä¸ºï¼š

* è¿™æ˜¯çº¿ç¨‹å®‰å…¨çš„
* ä¹Ÿé¿å…äº†å¤šä½™çš„ wakeupã€é˜Ÿåˆ—æ“ä½œ

#### âœ… ä¸æ˜¯ EventLoop æ‰€åœ¨çº¿ç¨‹

```cpp
queueInLoop(cb);
```

ğŸ‘‰ å¦‚æœæ˜¯**åˆ«çš„çº¿ç¨‹**è°ƒç”¨äº† `runInLoop()`ï¼Œå°±è°ƒç”¨ `queueInLoop(cb)`ï¼š

* å°† `cb` åŠ å…¥ `pendingFunctors_`
* å¹¶è°ƒç”¨ `wakeup()`ï¼Œå”¤é†’ EventLoop æ‰€åœ¨çº¿ç¨‹
* æœ€å EventLoop åœ¨ `doPendingFunctors()` ä¸­ç»Ÿä¸€å¤„ç†è¿™äº›å›è°ƒ

#### ğŸ“Œ åœºæ™¯ä¸¾ä¾‹ï¼š

å‡è®¾ï¼š

* `main thread` æ˜¯ EventLoop æ‰€åœ¨çº¿ç¨‹
* `worker thread` æƒ³è¦è®© EventLoop æ‰§è¡Œä¸ªä»»åŠ¡
  å°±ç›´æ¥ `loop->runInLoop(cb)`

å¦‚æœæ­¤æ—¶æ˜¯ main thread è°ƒç”¨ï¼Œcb ç›´æ¥æ‰§è¡Œ
å¦‚æœæ˜¯ worker thread è°ƒç”¨ï¼Œcb è¢« queue åˆ° pendingFunctors\_ï¼Œç„¶åå”¤é†’ main thread æ‰§è¡Œ

#### ğŸ“Œ ä¸ºä»€ä¹ˆè¦è¿™æ ·è®¾è®¡ï¼Ÿ

ğŸ‘‰ **ä¿è¯çº¿ç¨‹å®‰å…¨ï¼Œæ‰€æœ‰ IO å’Œå›è°ƒéƒ½åœ¨ EventLoop æ‰€å±çº¿ç¨‹æ‰§è¡Œ**
ğŸ‘‰ **æ”¯æŒè·¨çº¿ç¨‹ä»»åŠ¡æ´¾å‘**

#### ğŸ“Œ æ€»ç»“ä¸€å¥è¯ï¼š

* **runInLoop** æ˜¯ä¸ªæ™ºèƒ½è°ƒåº¦å™¨
* **åŒçº¿ç¨‹ç«‹å³æ‰§è¡Œ**ï¼Œ**å¼‚çº¿ç¨‹ä¸¢é˜Ÿåˆ—å”¤é†’æ‰§è¡Œ**


### 6.quit()
## ğŸ“Œ ä½œç”¨ï¼š

ğŸ‘‰ å®‰å…¨ã€ä¼˜é›…åœ°**è®© EventLoop é€€å‡ºå¾ªç¯**ã€‚

**æ³¨æ„ï¼šEventLoop ä¸€èˆ¬æ˜¯ä¸ªæ­»å¾ªç¯ `while (!quit_) { ... }`**ï¼Œè¦é€€å‡ºå°±å¾—æ”¹æ‰è¿™ä¸ªæ¡ä»¶ï¼Œä½†åŒæ—¶è¦ä¿è¯ï¼š

* ä¸ç®¡æ˜¯**åŒçº¿ç¨‹**è¿˜æ˜¯**å…¶ä»–çº¿ç¨‹è°ƒç”¨ quit()**ï¼Œéƒ½èƒ½æ­£ç¡®è®© EventLoop åŠæ—¶é€€å‡ºã€‚

---

## ğŸ“Œ é€è¡Œè§£è¯»ï¼š

```cpp
quit_ = true;
```

ğŸ‘‰ å°† `quit_` ç½®ä¸º `true`ã€‚
EventLoop ä¸­çš„ä¸»å¾ªç¯é€šå¸¸æ˜¯ï¼š

```cpp
while (!quit_)
{
    poller_->poll();
    doPendingFunctors();
}
```

**ç½® true ä¹‹åï¼Œä¸‹æ¬¡å¾ªç¯åˆ¤æ–­ç›´æ¥é€€å‡º**

---

### âœ… å¦‚æœè°ƒç”¨ quit() çš„çº¿ç¨‹ **ä¸æ˜¯ EventLoop æ‰€å±çº¿ç¨‹**

```cpp
if (!isInLoopThread())
{
    wakeup();
}
```

ğŸ‘‰ åˆ¤æ–­å½“å‰è°ƒç”¨ quit() çš„çº¿ç¨‹æ˜¯å¦æ˜¯ EventLoop æ‰€åœ¨çº¿ç¨‹ã€‚

* **å¦‚æœæ˜¯**ï¼šä¸ç”¨å”¤é†’ï¼Œåæ­£é©¬ä¸Š EventLoop çš„ poll() æˆ– epoll\_wait() ä¼šè¶…æ—¶æˆ–è€…æ£€æµ‹åˆ° quit\_
* **å¦‚æœä¸æ˜¯**ï¼šé‚£å½“å‰ EventLoop å¯èƒ½æ­£åœ¨ `epoll_wait()` é˜»å¡ä¸­
  å°±éœ€è¦é€šè¿‡ `wakeup()` å”¤é†’ EventLoop æ‰€åœ¨çº¿ç¨‹ï¼Œä½¿å®ƒä» `epoll_wait()` ä¸­è¿”å›ï¼Œç»§ç»­æ‰§è¡Œï¼Œæ£€æµ‹åˆ° quit\_ï¼Œé€€å‡ºå¾ªç¯ã€‚

---

## ğŸ“Œ ä¸ºä»€ä¹ˆè¦å”¤é†’ï¼Ÿ

ğŸ‘‰ EventLoop çš„äº‹ä»¶å¾ªç¯æ ¸å¿ƒæ˜¯ç±»ä¼¼è¿™æ ·çš„ï¼š

```cpp
while (!quit_)
{
    activeChannels.clear();
    poller_->poll(timeout, &activeChannels);
    handleEvents();
    doPendingFunctors();
}
```

å¦‚æœ**åˆ«çš„çº¿ç¨‹è°ƒç”¨äº† quit()**ï¼ŒEventLoop æ‰€åœ¨çº¿ç¨‹å¯èƒ½æ­£åœ¨é˜»å¡ç­‰äº‹ä»¶ï¼Œæ²¡åŠæ³•åŠæ—¶é€€å‡ºã€‚
è¿™æ—¶å€™å°±é  `wakeup()` å¾€ `eventfd` å†™ä¸ªå€¼ï¼Œè§¦å‘å¯è¯»äº‹ä»¶ï¼Œå”¤é†’ `epoll_wait()`ï¼Œè¿™æ ·å¾ªç¯ç»§ç»­ï¼Œæ£€æµ‹åˆ° `quit_`ï¼Œå°±èƒ½å®‰å…¨é€€å‡ºäº†ã€‚

---

## ğŸ“Œ æ€»ç»“ï¼š

| ä½œç”¨                 | è¡Œä¸º                         |
| :----------------- | :------------------------- |
| è®¾ç½®é€€å‡ºæ ‡å¿—             | `quit_ = true`             |
| é EventLoop æ‰€å±çº¿ç¨‹è°ƒç”¨ | `wakeup()` å”¤é†’ EventLoop çº¿ç¨‹ |
| åŒ EventLoop çº¿ç¨‹è°ƒç”¨   | ä¸ç”¨å”¤é†’ï¼Œç›´æ¥é€€å‡º                  |

---

## ğŸ“Œ å›¾ç¤ºï¼š

```text
å…¶ä»–çº¿ç¨‹è°ƒç”¨ quit()
      |
      v
  quit_ = true
      |
æ˜¯å¦æ˜¯ EventLoop çº¿ç¨‹ï¼Ÿ
      |
  +---+---+
  |       |
æ˜¯        å¦
  |        |
ç»§ç»­å¾ªç¯   wakeup()
æ£€æµ‹ quit_  
é€€å‡º
```

---

## ğŸ“Œ æ ¸å¿ƒç›®çš„ï¼š

ğŸ‘‰ **çº¿ç¨‹å®‰å…¨åœ°å”¤é†’ EventLoop å¹¶è®©å®ƒé€€å‡ºå¾ªç¯**

---

è¦ä¸è¦æˆ‘æŠŠ EventLoop æ•´ä¸ªå¾ªç¯+å”¤é†’+é€€å‡ºçš„**å®Œæ•´æµç¨‹å›¾**ç”»ä¸€ç‰ˆç»™ä½ ï¼Ÿä¼šæ›´æ¸…æ¥šè¿™ä¸ªæœºåˆ¶æ˜¯æ€ä¹ˆæ— é”å®‰å…¨è°ƒåº¦å’Œä¼˜é›…å…³é—­çš„âš¡ï¸âœ¨
