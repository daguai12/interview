# æœåŠ¡å™¨å¯åŠ¨æ‰€æ¶‰åŠçš„æ¨¡å—è°ƒç”¨å…³ç³»å›¾


![[Pasted image 20250527165435.png]]
# ä»threadPool_->start()åˆ°Thread::start()æ‰€ç»å†çš„è¿‡ç¨‹

## TcpServer::Start()
```cpp
void TcpServer::start(){
	threadPool_->start(threadInitCallback_); 
	...
}
```

åœ¨å‡½æ•°`start()`ä¸­ï¼Œ`threadPool_`æˆå‘˜å˜é‡è°ƒç”¨`start(threadInitCallback_)`æ–¹æ³•,æ¥å¯åŠ¨çº¿ç¨‹æ± ã€‚

## EventLoopThreadPool::start()
```cpp
void EventLoopThreadPool::start(const ThreadInitCallback& cb)
{
    started_ = true;
    for (int i = 0; i < numThreads_; ++i)
    {
        char buf[name_.size() + 32];
        snprintf(buf, sizeof buf, "%s%d",name_.c_str(),i);
        EventLoopThread *t = new EventLoopThread(cb,buf);
        threads_.push_back(std::unique_ptr<EventLoopThread>(t));
        loops_.push_back(t->startLoop());
    }

    // æ•´ä¸ªæœåŠ¡ç«¯åªæœ‰ä¸€ä¸ªçº¿ç¨‹ï¼Œè¿è¡Œç€baseloop
    if (numThreads_ == 0 && cb)
    {
        cb(baseLoop_);
    }
}
```

è¿™ä¸ªå‡½æ•°ç”¨äº**å¯åŠ¨çº¿ç¨‹æ± ä¸­çš„æ‰€æœ‰çº¿ç¨‹**ï¼Œå¹¶ä¸”ä¸ºæ¯ä¸ªçº¿ç¨‹åˆ›å»ºä¸€ä¸ª `EventLoop` å®ä¾‹ã€‚

* æ¯ä¸ª `EventLoop` éƒ½åœ¨ç‹¬ç«‹çš„çº¿ç¨‹ä¸­è¿è¡Œï¼Œç›‘å¬å’Œå¤„ç† IO äº‹ä»¶ã€‚
* å¦‚æœæ²¡æœ‰å¼€å¯å¤šçº¿ç¨‹ï¼ˆ`numThreads_ == 0`ï¼‰ï¼Œå°±ç›´æ¥åœ¨ä¸»çº¿ç¨‹ï¼ˆbaseloopï¼‰é‡Œè¿è¡Œå›è°ƒã€‚

### å‡½æ•°é€å¥å‰–æï¼š

```cpp
void EventLoopThreadPool::start(const ThreadInitCallback& cb)
```

* `start`ï¼šå¯åŠ¨çº¿ç¨‹æ± ï¼Œåˆ›å»ºå¹¶å¯åŠ¨çº¿ç¨‹ã€‚
* `cb`ï¼šå¯é€‰çš„çº¿ç¨‹åˆå§‹åŒ–å›è°ƒï¼Œåœ¨æ¯ä¸ªæ–°çº¿ç¨‹çš„ `EventLoop` å¯åŠ¨å‰è°ƒç”¨ã€‚

### å¯åŠ¨æ ‡å¿—

```cpp
started_ = true;
```

* æ ‡è®°çº¿ç¨‹æ± å·²å¯åŠ¨ï¼Œé¿å…é‡å¤å¯åŠ¨ã€‚


### å¯åŠ¨ `numThreads_` ä¸ªçº¿ç¨‹

```cpp
for (int i = 0; i < numThreads_; ++i)
```

å¾ªç¯åˆ›å»º `numThreads_` ä¸ª `EventLoopThread`ã€‚


### è®¾ç½®çº¿ç¨‹å

```cpp
char buf[name_.size() + 32];
snprintf(buf, sizeof buf, "%s%d", name_.c_str(), i);
```

* ç»™æ¯ä¸ªçº¿ç¨‹ç”Ÿæˆå”¯ä¸€çš„åå­—ï¼Œæ¯”å¦‚ `IOThread0`, `IOThread1`ï¼Œä¾¿äºè°ƒè¯•å’Œæ—¥å¿—ã€‚


### åˆ›å»ºå¹¶ä¿å­˜çº¿ç¨‹å¯¹è±¡

```cpp
EventLoopThread *t = new EventLoopThread(cb, buf);
threads_.push_back(std::unique_ptr<EventLoopThread>(t));
```

* new å‡ºä¸€ä¸ª `EventLoopThread`ï¼Œä¼ å…¥åˆå§‹åŒ–å›è°ƒå’Œçº¿ç¨‹åã€‚
* ç”¨ `unique_ptr` ç®¡ç†ï¼Œé˜²æ­¢å†…å­˜æ³„æ¼ã€‚


### å¯åŠ¨çº¿ç¨‹ï¼Œè·å–å­çº¿ç¨‹ä¸­çš„ EventLoop

```cpp
loops_.push_back(t->startLoop());
```

* `startLoop()` ä¼šï¼š

  1. å¯åŠ¨æ–°çº¿ç¨‹ã€‚
  2. åœ¨æ–°çº¿ç¨‹ä¸­åˆ›å»ºä¸€ä¸ª `EventLoop`ã€‚
  3. é€šçŸ¥ä¸»çº¿ç¨‹è¿”å›è¿™ä¸ª `EventLoop*`ã€‚
* ä¿å­˜è¿™ä¸ª `EventLoop*` åˆ° `loops_` å®¹å™¨ï¼Œä¾¿äºåç»­åœ¨ `TcpServer` ä¸­åˆ†å‘è¿æ¥ï¼ˆè½®è¯¢è°ƒåº¦ IO äº‹ä»¶æ—¶ç”¨ï¼‰ã€‚


### å•çº¿ç¨‹æ¨¡å¼ä¸‹æ‰§è¡Œå›è°ƒ

```cpp
if (numThreads_ == 0 && cb)
{
    cb(baseLoop_);
}
```

* å¦‚æœæ²¡è®¾ç½®å¤šçº¿ç¨‹ï¼Œç›´æ¥å¯¹ä¸»çº¿ç¨‹ï¼ˆ`baseLoop_`ï¼‰æ‰§è¡Œåˆå§‹åŒ–å›è°ƒã€‚



### ä¸ºä»€ä¹ˆè¿™ä¹ˆè®¾è®¡ï¼Ÿ

* **ä¸»çº¿ç¨‹ baseLoop\_**ï¼šç›‘å¬ acceptã€åˆ†å‘æ–°è¿æ¥ã€‚
* **å­çº¿ç¨‹æ± ä¸­çš„ EventLoop**ï¼šç›‘å¬è¿æ¥ä¸Šçš„ IO äº‹ä»¶ï¼ˆè¯»å†™ã€å…³é—­ç­‰ï¼‰ã€‚
* ä¿è¯ä¸€ä¸ªçº¿ç¨‹ä¸€ä¸ª EventLoopï¼Œä¸€ä¸ª EventLoop åªåœ¨è‡ªå·±çº¿ç¨‹é‡Œè¿è¡Œï¼Œ**é¿å…é”**ï¼Œç®€åŒ–å¹¶å‘æ¨¡å‹ã€‚

## EventLoopThread::startLoop()  

```cpp
EventLoop* EventLoopThread::startLoop()
{
    thread_.start();

    EventLoop *loop = nullptr;
    {
        std::unique_lock<std::mutex> lock(mutex_);
        while ( loop_ == nullptr )
        {
            cond_.wait(lock);
        }
        loop = loop_;
    }
    return loop;
}
```


### å‡½æ•°ä½œç”¨ï¼š

ğŸ‘‰ å¯åŠ¨ `EventLoopThread` çº¿ç¨‹ï¼Œå¹¶ç­‰å¾…çº¿ç¨‹å†…åˆå§‹åŒ–å¥½ `EventLoop`ï¼Œç„¶åå®‰å…¨åœ°è¿”å›è¿™ä¸ª `EventLoop*` æŒ‡é’ˆç»™ä¸»çº¿ç¨‹ã€‚



### 1ï¸âƒ£ å¯åŠ¨çº¿ç¨‹

```cpp
thread_.start();
```

* `thread_` æ˜¯ `muduo::Thread` ç±»å‹ï¼ˆå°è£…äº† `pthread_create`ï¼‰ã€‚
* è°ƒç”¨ `start()` ä¼šæ–°å»ºä¸€ä¸ªçº¿ç¨‹ï¼Œçº¿ç¨‹æ‰§è¡Œ `EventLoopThread::threadFunc()`ï¼Œ**åœ¨é‚£ä¸ªçº¿ç¨‹é‡Œä¼šåˆ›å»º EventLoop å®ä¾‹**ã€‚
* âš ï¸ è¿™æ—¶å€™ï¼Œå­çº¿ç¨‹åˆšå¯åŠ¨ï¼ŒEventLoop è¿˜æ²¡åˆå§‹åŒ–å¥½ã€‚

---

### 2ï¸âƒ£ ä¸»çº¿ç¨‹å£°æ˜ä¸€ä¸ª `loop` ä¸´æ—¶å˜é‡

```cpp
EventLoop *loop = nullptr;
```

---

### 3ï¸âƒ£ åŠ é”ç­‰å¾…

```cpp
{
    std::unique_lock<std::mutex> lock(mutex_);
```

* ä¿è¯è®¿é—® `loop_` æ˜¯çº¿ç¨‹å®‰å…¨çš„ã€‚

---

### 4ï¸âƒ£ ç­‰å¾…å­çº¿ç¨‹ä¿¡å·

```cpp
while (loop_ == nullptr)
{
    cond_.wait(lock);
}
```

* å¦‚æœ `loop_` è¿˜æ²¡åˆå§‹åŒ–ï¼ˆæ­¤æ—¶å­çº¿ç¨‹é‡Œçš„ EventLoop å¯èƒ½è¿˜æ²¡ new å‡ºæ¥ï¼‰
* **ä¸»çº¿ç¨‹é˜»å¡åœ¨è¿™é‡Œï¼Œç­‰å­çº¿ç¨‹é€šè¿‡ `cond_.notify_one()` é€šçŸ¥å®ƒã€‚**


### 5ï¸âƒ£ æ‹¿åˆ° loop\_ï¼Œé€€å‡ºä¸´ç•ŒåŒº

```cpp
loop = loop_;
```

* å­çº¿ç¨‹åœ¨æ‰§è¡Œ `threadFunc()` æ—¶ï¼Œåˆ›å»º EventLoop å®ä¾‹ï¼Œå¹¶èµ‹å€¼ç»™ `loop_`ï¼Œç„¶åå”¤é†’è¿™ä¸ª condã€‚
* æ‹¿åˆ° EventLoop æŒ‡é’ˆï¼Œé€€å‡ºé”ä¿æŠ¤èŒƒå›´ã€‚


### 6ï¸âƒ£ è¿”å› EventLoop\*

```cpp
return loop;
```


### ğŸ“Œ ä¸ºä»€ä¹ˆè¦è¿™æ ·è®¾è®¡ï¼Ÿ

* **è·¨çº¿ç¨‹é€šä¿¡**ï¼š

  * ä¸»çº¿ç¨‹éœ€è¦æ‹¿åˆ°å­çº¿ç¨‹é‡Œé‚£ä¸ª `EventLoop*`ï¼Œä½† EventLoop å¿…é¡»åœ¨å­çº¿ç¨‹ä¸­åˆ›å»ºï¼Œç”Ÿå‘½å‘¨æœŸç”±å­çº¿ç¨‹æ§åˆ¶ã€‚
  * é€šè¿‡ `mutex_` + `cond_` åšåŒæ­¥ï¼Œé¿å…ä¸»çº¿ç¨‹åœ¨å­çº¿ç¨‹ EventLoop æ²¡å»ºå¥½æ—¶å°±å–å€¼ï¼Œäº§ç”Ÿç©ºæŒ‡é’ˆæˆ–ç«æ€ã€‚

* **åŒæ­¥é˜»å¡ç­‰å¾…**ï¼š

  * ä¿è¯ `startLoop()` è¿”å›æ—¶ï¼Œå­çº¿ç¨‹çš„ `EventLoop` å·²ç»å‡†å¤‡å¥½ï¼Œ**å¯ä»¥ç«‹å³åŠ å…¥ loop åˆ—è¡¨ï¼ŒæŠ•å…¥ä½¿ç”¨ã€‚**


## Thread::start()

###  ä½œç”¨æ¦‚è¿°ï¼š

è¿™ä¸ªå‡½æ•°ä¼šï¼š

1. æ ‡è®°çº¿ç¨‹å·²å¯åŠ¨
2. åˆ›å»ºä¸€ä¸ªæ–°çº¿ç¨‹ï¼Œè¿è¡Œ `func_()`ï¼ˆç”¨æˆ·è®¾ç½®çš„çº¿ç¨‹å‡½æ•°ï¼‰
3. ç”¨ `sem_t` ä¿¡å·é‡åŒæ­¥ï¼Œ**ä¸»çº¿ç¨‹ç­‰å¾…å­çº¿ç¨‹è·å–è‡ªå·±çš„ tid å¹¶ä¸ŠæŠ¥ï¼Œå†ç»§ç»­æ‰§è¡Œ**



### 1ï¸âƒ£ è®¾ç½®çº¿ç¨‹å·²å¯åŠ¨

```cpp
started_ = true;
```

* æ ‡è®°è¿™ä¸ª `Thread` å®ä¾‹çš„çº¿ç¨‹å·²ç»å¯åŠ¨ï¼Œé¿å…é‡å¤è°ƒç”¨ã€‚


### 2ï¸âƒ£ åˆå§‹åŒ–ä¿¡å·é‡

```cpp
sem_t sem;
sem_init(&sem, false, 0);
```

* `sem` æ˜¯ä¸€ä¸ª POSIX ä¿¡å·é‡ï¼Œå€¼åˆå§‹åŒ–ä¸º 0ã€‚
* ç¬¬äºŒä¸ªå‚æ•° `false` è¡¨ç¤ºæ˜¯çº¿ç¨‹é—´åŒæ­¥ï¼ˆè€Œéè¿›ç¨‹é—´ï¼‰ã€‚


### 3ï¸âƒ£ åˆ›å»ºæ–°çº¿ç¨‹

```cpp
thread_ = std::shared_ptr<std::thread>(new std::thread([&](){
```

* æ–°å»ºä¸€ä¸ª `std::thread`ï¼Œçº¿ç¨‹æ‰§è¡Œçš„ lambda æ•è· `sem`ã€`this` ä¹‹ç±»çš„å±€éƒ¨å˜é‡ã€‚


### 4ï¸âƒ£ å­çº¿ç¨‹è·å–è‡ªèº« tid

```cpp
tid_ = CurrentThread::tid();
```

* `CurrentThread::tid()` è·å–å½“å‰çº¿ç¨‹çš„çº¿ç¨‹IDã€‚
* ç„¶åæŠŠè¿™ä¸ª tid å­˜åˆ° `Thread` å¯¹è±¡çš„ `tid_` æˆå‘˜é‡Œï¼Œä¾›ä¸»çº¿ç¨‹æŸ¥çœ‹ã€‚


### 5ï¸âƒ£ é€šçŸ¥ä¸»çº¿ç¨‹

```cpp
sem_post(&sem);
```

* å­çº¿ç¨‹æ‰§è¡Œåˆ°è¿™ä¸€æ­¥æ—¶ï¼Œè¯´æ˜å®ƒå·²ç»è·å–åˆ°äº†è‡ªå·±çš„ tidã€‚
* `sem_post()` æŠŠä¿¡å·é‡ +1ï¼Œå”¤é†’ä¸»çº¿ç¨‹ã€‚


### 6ï¸âƒ£ å­çº¿ç¨‹æ­£å¼å¼€å§‹å¹²æ´»

```cpp
func_();
```

* æ‰§è¡Œç”¨æˆ·è®¾å®šçš„çº¿ç¨‹å‡½æ•°ï¼Œæ¯”å¦‚ `EventLoopThread::threadFunc()`ã€‚


### 7ï¸âƒ£ ä¸»çº¿ç¨‹é˜»å¡ç­‰å¾…

```cpp
sem_wait(&sem);
```

* ä¸»çº¿ç¨‹é˜»å¡åœ¨è¿™é‡Œï¼Œç›´åˆ°å­çº¿ç¨‹è°ƒç”¨ `sem_post()`ã€‚
* ç¡®ä¿ä¸»çº¿ç¨‹åœ¨**ç»§ç»­å¾€ä¸‹æ‰§è¡Œä¹‹å‰ï¼Œå­çº¿ç¨‹çš„ tid\_ å·²ç»èµ‹å€¼å®Œæ¯•**ã€‚





# ä» loop_->runInLoopåˆ°å¯ä»¥ç›‘å¬ç”¨æˆ·è¿æ¥æ‰€ç»å†çš„è¿‡ç¨‹


## å…ˆçœ‹ `Acceptor::listen()` æºç 

```cpp
void Acceptor::listen()
{
    listenning_ = true;
    acceptSocket_.listen();   // è°ƒç”¨ Socket å°è£…çš„ listen() ç³»ç»Ÿè°ƒç”¨
    acceptChannel_.enableReading();  // è®© acceptChannel å…³æ³¨è¯»äº‹ä»¶ï¼ˆæ–°è¿æ¥åˆ°æ¥ï¼‰
}
```



###  â‘  `acceptSocket_.listen()`

ğŸ‘‰ æŸ¥çœ‹ `Socket` ç±»çš„ `listen()`

```cpp
void Socket::listen()
{
    ::listen(sockfd_, SOMAXCONN);
}
```

* è°ƒç”¨ Linux ç³»ç»Ÿè°ƒç”¨ `listen()`
* `SOMAXCONN` æ˜¯ backlog é˜Ÿåˆ—æœ€å¤§é•¿åº¦
* **è®©å†…æ ¸ç›‘å¬ listenFd çš„å¯è¿æ¥é˜Ÿåˆ—**

âœ”ï¸ åˆ°è¿™é‡Œï¼Œå†…æ ¸å°±èƒ½æ¥æ”¶å®¢æˆ·ç«¯è¿æ¥äº†ã€‚


### ğŸ“¦ â‘¡ `acceptChannel_.enableReading()`

ğŸ‘‰ æŸ¥çœ‹ `Channel` ç±»çš„ `enableReading()`

```cpp
void Channel::enableReading()
{
    events_ |= kReadEvent; // kReadEvent = EPOLLIN
    update();
}
```

* è®¾ç½®ç›‘å¬äº‹ä»¶ `EPOLLIN`
* è°ƒç”¨ `update()` å°†è¯¥ Channel åŠ å…¥ `EventLoop` çš„ `epoll`


### ğŸ“¦ â‘¢ `Channel::update()`

ğŸ‘‰ çœ‹ `Channel::update()`

```cpp
void Channel::update()
{
    loop_->updateChannel(this);
}
```

* é€šçŸ¥ `EventLoop`ï¼ŒæŠŠå½“å‰ `Channel` æ·»åŠ è¿› `epoll`


### ğŸ“¦ â‘£ `EventLoop::updateChannel()`

ğŸ‘‰ çœ‹ `EventLoop` çš„ `updateChannel()`

```cpp
void EventLoop::updateChannel(Channel* channel)
{
    poller_->updateChannel(channel);
}
```

* `poller_` å°±æ˜¯ epoll çš„å°è£… `EpollPoller`
* æŠŠ `Channel` æ³¨å†Œåˆ° epoll çš„å…³æ³¨åˆ—è¡¨


### ğŸ“¦ â‘¤ `Poller::updateChannel()` â†’ `EpollPoller::updateChannel()`

ğŸ‘‰ çœ‹ `EpollPoller` çš„ `updateChannel()`

```cpp
void EpollPoller::updateChannel(Channel* channel)
{
    struct epoll_event event;
    event.events = channel->events();
    event.data.ptr = channel;
    int fd = channel->fd();

    if (channel is new)
        ::epoll_ctl(epollfd_, EPOLL_CTL_ADD, fd, &event);
    else
        ::epoll_ctl(epollfd_, EPOLL_CTL_MOD, fd, &event);
}
```

* é€šè¿‡ `epoll_ctl` æ³¨å†Œæˆ–ä¿®æ”¹ç›‘å¬
* å…³æ³¨ `listenFd` ä¸Šçš„ `EPOLLIN` äº‹ä»¶ï¼ˆè¡¨ç¤ºæœ‰æ–°è¿æ¥åˆ°æ¥ï¼‰


## ğŸ“Œ ğŸ“Š å®Œæ•´è°ƒç”¨é“¾æ•´ç†æˆå›¾

```
Acceptor::listen()
  â”œâ”€â”€ Socket::listen()            // å†…æ ¸ç›‘å¬ listenFd
  â””â”€â”€ Channel::enableReading()    // å…³æ³¨ EPOLLIN äº‹ä»¶
        â””â”€â”€ Channel::update()
              â””â”€â”€ EventLoop::updateChannel()
                    â””â”€â”€ EpollPoller::updateChannel()
                          â””â”€â”€ epoll_ctl(ADD / MOD)
```


## ğŸ“Œ ğŸ“– æ•´ä½“ä½œç”¨æ€»ç»“

ğŸ‘‰ `Acceptor::listen()` å®Œæˆä¸¤ä¸ªæ ¸å¿ƒä»»åŠ¡ï¼š

* **è®©å†…æ ¸ç›‘å¬ listenFd**ï¼Œå‡†å¤‡æ¥å—å®¢æˆ·ç«¯è¿æ¥
* **æŠŠ listenFd æ³¨å†Œåˆ° epoll**ï¼Œå…³æ³¨ `EPOLLIN` äº‹ä»¶ï¼ˆæ–°è¿æ¥åˆ°æ¥ï¼‰

å½“æœ‰æ–°è¿æ¥æ—¶ï¼Œepoll å°±ä¼šè¿”å›è¿™ä¸ª `listenFd`ï¼Œç„¶åè§¦å‘ Acceptor æ³¨å†Œçš„ `handleRead()` å›è°ƒï¼Œè¿›å…¥**è¿æ¥å»ºç«‹æµç¨‹**ã€‚


