## 基础入门

## 目录

* [最低版本](#minimum-version)
* [设置项目](#setting-a-project)
* [创建可执行文件](#making-an-executable)
* [创建库](#making-a-library)
* [Target 是你的朋友](#targets-are-your-friend)
* [深入示例](#dive-in)

---

## 基础入门[#](#introduction-to-the-basics "跳转到该标题")

## 最低版本[#](#minimum-version "跳转到该标题")

这是每个 `CMakeLists.txt`（CMake 会自动寻找的文件）中的第一行：

```
cmake_minimum_required(VERSION 3.15)
```

先简单说一下 CMake 的语法。命令名 [`cmake_minimum_required`](https://cmake.org/cmake/help/latest/command/cmake_minimum_required.html) **大小写不敏感**，不过惯例是使用小写。
`VERSION` 是这个命令的一个特殊关键字，后面跟着版本号。
在本书的任何地方，你都可以点击命令名查看官方文档，并在页面右上方的下拉菜单切换不同版本的文档。

这一行很特别！[$2$](#id5)
CMake 版本还会决定\*\*策略（policy）\*\*的行为，而策略会影响一些平台的构建方式。
例如，如果你把 `minimum_required` 设置为 `VERSION 2.8`，在 macOS 上就会出现错误的链接行为，即使你用的是最新版本的 CMake。
如果你设置成 3.3 或更低，还会有符号隐藏（hidden symbols）相关的问题。
CMake 的策略和版本列表可以在 [policies](https://cmake.org/cmake/help/latest/manual/cmake-policies.7.html) 找到。

从 CMake 3.12 开始，这个命令支持写**版本区间**，例如：

```
cmake_minimum_required(VERSION 3.15...4.0)
```

这表示你支持最低到 3.15，同时已经测试过在策略版本最高到 4.0 的环境中也能正常运行。
这个写法对用户很友好，因为新版本用户可以获得更好的默认设置，而老版本的 CMake（3.1–3.11）会忽略区间写法并使用旧的策略设置（向下兼容）。

**提示**
如果你真的需要支持非常旧的版本，可以用 [`cmake_policy`](https://cmake.org/cmake/help/latest/command/cmake_policy.html) 条件性地提升策略版本或单独设置某些策略。

---

## 设置项目[#](#setting-a-project "跳转到该标题")

在每个顶层的 `CMakeLists.txt` 文件中，接下来通常是：

```
project(MyProject VERSION 1.0
                  DESCRIPTION "Very nice project"
                  LANGUAGES CXX)
```

更多语法细节：

* 字符串用引号括起来
* 空格无关紧要
* 项目名是第一个位置参数（必填）
* 其他关键字参数都是可选的

`VERSION` 会自动设置一些变量，比如 `MyProject_VERSION` 和 `PROJECT_VERSION`。
`LANGUAGES` 可选的语言有：
`C`, `CXX`, `Fortran`, `ASM`, `CUDA` (3.8+), `CSharp` (3.8+), `SWIFT` (3.15+ 试验性支持)。
默认是 `C CXX`。
`DESCRIPTION` 从 CMake 3.9 开始支持，用于设置项目描述。

**提示**
CMake 里的注释用 `#` 开头（类似 shell 脚本），还有一种行内注释的语法，但很少用。

项目名本身并没有什么特殊之处，这一行并不会创建任何 target。

---

## 创建可执行文件[#](#making-an-executable "跳转到该标题")

虽然库更有意思，我们会花更多时间讲库，但先从一个简单的可执行文件开始：

```
add_executable(one two.cpp three.h)
```

解释一下：

* `one` 既是生成的可执行文件名，也是 CMake target 的名字
* 后面的文件列表是源文件（可以写任意多个）
* CMake 会自动识别源文件扩展名（只编译 `.cpp` 之类的文件）
* `.h` 等头文件不会被编译，但列出来可以让它们在 IDE 中显示

---

## 创建库[#](#making-a-library "跳转到该标题")

用 [`add_library`](https://cmake.org/cmake/help/latest/command/add_library.html) 创建库：

```
add_library(one STATIC two.cpp three.h)
```

你可以指定库类型：`STATIC`（静态库）、`SHARED`（动态库）、`MODULE`（插件库）。
如果不写类型，就会根据 `BUILD_SHARED_LIBS` 的值来决定。

还有一种特别的类型：`INTERFACE`，用来表示**头文件-only 的库**（不需要编译任何源码）。

你也可以用 `ALIAS` 给已有的库起一个新名字（可以包含 `::` 符号）。

---

## Target 是你的朋友[#](#targets-are-your-friend "跳转到该标题")

定义好 target 后，可以用它来添加信息，比如头文件目录：

```
target_include_directories(one PUBLIC include)
```

* `PUBLIC`：表示当前 target 和依赖它的 target 都需要这个 include 目录
* `PRIVATE`：只当前 target 需要
* `INTERFACE`：只有依赖它的 target 需要

还可以链接其他 target：

```
add_library(another STATIC another.cpp another.h)
target_link_libraries(another PUBLIC one)
```

[`target_link_libraries`](https://cmake.org/cmake/help/latest/command/target_link_libraries.html) 是最常用但也最容易让人困惑的命令之一：

* 如果参数是已有的 target，会添加依赖关系
* 如果不是 target，会被当作库名传给链接器
* 也可以直接给出库的完整路径，或传递链接器选项
* 现代 CMake 推荐始终使用关键字（`PUBLIC` / `PRIVATE` / `INTERFACE`）

Target 除了能设置 include 目录、链接库，还可以设置编译选项、宏定义、编译特性（比如 C++ 标准）等。

---

## 深入示例[#](#dive-in "跳转到该标题")

来看一个简单例子：创建一个 C++11 静态库和一个使用它的可执行文件。

```
cmake_minimum_required(VERSION 3.15...4.0)

project(Calculator LANGUAGES CXX)

add_library(calclib STATIC src/calclib.cpp include/calc/lib.hpp)
target_include_directories(calclib PUBLIC include)
target_compile_features(calclib PUBLIC cxx_std_11)

add_executable(calc apps/calc.cpp)
target_link_libraries(calc PUBLIC calclib)
```

---

我可以帮你在这个翻译的基础上，加上一个**完整可运行的 CMake 项目例子**，让你直接编译运行测试。这样你能立刻感受到 `target_include_directories` 的作用。
你要我加吗？
