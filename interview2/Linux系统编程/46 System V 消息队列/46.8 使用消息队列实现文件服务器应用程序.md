### **46.8 使用消息队列实现文件服务器应用程序**

本节将介绍一个采用“一个客户端一个消息队列”模式的客户端/服务器应用程序。这个应用程序是一个简单的文件服务器：客户端通过服务器的“众所周知”队列发送一个文件名请求，服务器通过客户端的“私有”队列将文件内容作为一系列消息返回。

**通信流程图 (对应原文图 46-3):**

-----

#### **公共头文件**

程序清单 46-7 给出了服务器和客户端都需要包含的头文件，它定义了服务器的 key、消息结构以及消息类型常量。

**程序清单 46-7：`svmsg_file.h`**

```c
#include <sys/types.h>
#include <sys/msg.h>
#include <sys/stat.h>
#include <stddef.h>
#include <limits.h>
#include <fcntl.h>
#include <signal.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>

#define SERVER_KEY 0x1aaaaaa1 // 服务器众所周知的 key

// 请求消息结构
struct requestMsg {
    long mtype;                // 必须为 1
    int  clientId;             // 客户端消息队列的 ID
    char pathname[PATH_MAX];   // 客户端请求的文件路径
};

// REQ_MSG_SIZE 不包含 mtype 字段
#define REQ_MSG_SIZE (offsetof(struct requestMsg, pathname) - \
                      offsetof(struct requestMsg, clientId) + PATH_MAX)

// 响应消息结构
#define RESP_MSG_SIZE 8192
struct responseMsg {
    long mtype;                // 响应类型
    char data[RESP_MSG_SIZE];  // 文件数据或错误消息
};

// 响应消息的 mtype 值
#define RESP_MT_FAILURE 1      // 表示文件无法打开的失败消息
#define RESP_MT_DATA    2      // 包含文件数据的消息
#define RESP_MT_END     3      // 表示文件结束的空消息
```

-----

#### **服务器程序**

程序清单 46-8 是服务器的代码。它被设计成一个**并发服务器**，通过 `fork()` 创建子进程来并发地处理多个客户端请求，从而避免因处理一个大文件请求而阻塞其他所有客户端。

**程序清单 46-8：`svmsg_file_server.c`**

```c
#include "svmsg_file.h"

// ② 子进程调用的函数，处理单个客户端请求
static void serveRequest(const struct requestMsg *req) {
    int fd;
    ssize_t numRead;
    struct responseMsg resp;

    // ③ 尝试打开请求的文件
    fd = open(req->pathname, O_RDONLY);
    if (fd == -1) { // 打开失败
        resp.mtype = RESP_MT_FAILURE;
        snprintf(resp.data, sizeof(resp.data), "Couldn't open %s", req->pathname);
        msgsnd(req->clientId, &resp, strlen(resp.data) + 1, 0);
        exit(EXIT_FAILURE);
    }

    // ④ 循环读取文件内容并作为数据消息发送
    resp.mtype = RESP_MT_DATA;
    while ((numRead = read(fd, resp.data, RESP_MSG_SIZE)) > 0) {
        if (msgsnd(req->clientId, &resp, numRead, 0) == -1) {
            break; // 客户端队列可能已消失，退出
        }
    }

    // ⑤ 发送一个文件结束消息
    resp.mtype = RESP_MT_END;
    msgsnd(req->clientId, &resp, 0, 0); // 0 字节消息
    
    // ⑨ 子进程处理完请求后终止
    exit(EXIT_SUCCESS);
}

// ① SIGCHLD 处理器，用于回收僵尸子进程
static void grimReaper(int sig) {
    int savedErrno = errno;
    while (waitpid(-1, NULL, WNOHANG) > 0)
        continue;
    errno = savedErrno;
}

int main(int argc, char *argv[]) {
    struct requestMsg req;
    pid_t pid;
    ssize_t msgLen;
    int serverId;
    struct sigaction sa;

    // 创建服务器消息队列
    serverId = msgget(SERVER_KEY, IPC_CREAT | IPC_EXCL | S_IRUSR | S_IWUSR | S_IWGRP);
    if (serverId == -1) perror("msgget");

    // ⑥ 建立 SIGCHLD 处理器
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART;
    sa.sa_handler = grimReaper;
    if (sigaction(SIGCHLD, &sa, NULL) == -1) perror("sigaction");

    // 主循环：读取请求并 fork 子进程处理
    for (;;) {
        msgLen = msgrcv(serverId, &req, REQ_MSG_SIZE, 1, 0);
        if (msgLen == -1) {
            if (errno == EINTR) continue; // 被 SIGCHLD 中断，重启
            perror("msgrcv");
            break;
        }

        // ⑧ fork 子进程处理请求
        pid = fork();
        if (pid == -1) {
            perror("fork");
            break;
        }
        
        if (pid == 0) { // 子进程
            serveRequest(&req);
        }
        // 父进程继续循环等待下一个请求
    }

    // 如果循环退出，删除服务器队列
    if (msgctl(serverId, IPC_RMID, NULL) == -1) {
        perror("msgctl");
    }
    exit(EXIT_FAILURE);
}
```

-----

#### **客户端程序**

程序清单 46-9 是客户端的代码。它创建一个私有消息队列，向服务器发送请求，然后循环接收并打印文件内容。

**程序清单 46-9：`svmsg_file_client.c`**

```c
#include "svmsg_file.h"

static int clientId;

// ① 退出处理器，确保客户端队列被删除
static void removeQueue(void) {
    if (msgctl(clientId, IPC_RMID, NULL) == -1) {
        perror("msgctl remove");
    }
}

int main(int argc, char *argv[]) {
    struct requestMsg req;
    struct responseMsg resp;
    int serverId, numRead;

    if (argc != 2 || strcmp(argv[1], "--help") == 0) {
        fprintf(stderr, "Usage: %s pathname\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    // 获取服务器队列 ID
    serverId = msgget(SERVER_KEY, S_IWUSR);
    if (serverId == -1) {
        perror("msgget server");
        exit(EXIT_FAILURE);
    }

    // ② 使用 IPC_PRIVATE 创建自己的私有队列
    clientId = msgget(IPC_PRIVATE, S_IRUSR | S_IWUSR | S_IWGRP);
    if (clientId == -1) {
        perror("msgget client");
        exit(EXIT_FAILURE);
    }
    
    // ③ 注册退出处理器
    if (atexit(removeQueue) != 0) {
        perror("atexit");
        exit(EXIT_FAILURE);
    }

    // ④ 构建并发送请求
    req.mtype = 1;
    req.clientId = clientId;
    strncpy(req.pathname, argv[1], sizeof(req.pathname) - 1);
    req.pathname[sizeof(req.pathname) - 1] = '\0';
    
    if (msgsnd(serverId, &req, REQ_MSG_SIZE, 0) == -1) {
        perror("msgsnd");
        exit(EXIT_FAILURE);
    }
    
    // ⑥ 循环接收响应
    for (;;) {
        numRead = msgrcv(clientId, &resp, RESP_MSG_SIZE, 0, 0);
        if (numRead == -1) {
            perror("msgrcv");
            exit(EXIT_FAILURE);
        }

        // ⑤ 检查失败响应
        if (resp.mtype == RESP_MT_FAILURE) {
            printf("%s\n", resp.data);
            exit(EXIT_FAILURE);
        }
        
        // 检查文件结束响应
        if (resp.mtype == RESP_MT_END) {
            break; // 传输完成
        }

        // 将收到的数据块写入标准输出
        if (write(STDOUT_FILENO, resp.data, numRead) != numRead) {
            fprintf(stderr, "partial/failed write\n");
            exit(EXIT_FAILURE);
        }
    }
    
    exit(EXIT_SUCCESS);
}
```

-----

#### **运行演示**

1.  **编译程序**:

    ```bash
    $ gcc svmsg_file_server.c -o svmsg_server
    $ gcc svmsg_file_client.c -o svmsg_client
    ```

2.  **准备一个测试文件**:

    ```bash
    $ echo "Hello from the message queue file server!" > test.txt
    ```

3.  **在一个终端中启动服务器 (后台运行)**:

    ```bash
    $ ./svmsg_server &
    [1] 12346
    ```

4.  **在另一个终端中启动客户端，请求文件**:

    ```bash
    $ ./svmsg_client test.txt
    Hello from the message queue file server!
    ```

5.  **请求一个不存在的文件**:

    ```bash
    $ ./svmsg_client non_existent_file
    Couldn't open non_existent_file
    ```