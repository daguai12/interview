### **46.4 消息队列关联数据结构**

每个 System V 消息队列都有一个关联的 `msqid_ds` 数据结构，它在内核中维护着该队列的状态信息。其形式如下：

```c
#include <sys/msg.h>

struct msqid_ds {
    struct ipc_perm msg_perm;     /* Ownership and permissions */
    time_t          msg_stime;    /* Time of last msgsnd() */
    time_t          msg_rtime;    /* Time of last msgrcv() */
    time_t          msg_ctime;    /* Time of last change */
    unsigned long   __msg_cbytes; /* Current number of bytes in queue (Linux-specific) */
    msgqnum_t       msg_qnum;     /* Current number of messages in queue */
    msglen_t        msg_qbytes;   /* Maximum number of bytes in queue */
    pid_t           msg_lspid;    /* PID of last msgsnd() */
    pid_t           msg_lrpid;    /* PID of last msgrcv() */
};
```

应用程序可以通过 `msgctl()` 的 `IPC_STAT` 操作来获取这个数据结构的副本，并通过 `IPC_SET` 操作来修改其中的部分字段。

#### **字段详解**

  * **`msg_perm`**:
    一个 `ipc_perm` 子结构，包含了队列的所有权（`uid`, `gid`）和权限（`mode`）信息。这些字段可以通过 `IPC_SET` 来更新。

  * **`msg_stime`**:
    上一次成功调用 `msgsnd()` 的时间。

  * **`msg_rtime`**:
    上一次成功调用 `msgrcv()` 的时间。

  * **`msg_ctime`**:
    队列被创建或成功执行 `IPC_SET` 操作的时间。

  * **`__msg_cbytes`**:
    当前队列中所有消息的 `mtext` 字段包含的字节数总和。`msgsnd()` 和 `msgrcv()` 调用都会相应地更新这个字段。

  * **`msg_qnum`**:
    当前队列中的消息总数。`msgsnd()` 调用会递增这个值，`msgrcv()` 调用会递减这个值。

  * **`msg_qbytes`**:
    定义了消息队列中所有消息的 `mtext` 字段的字节总数的**上限**。

      * 队列被创建时，该字段被初始化为系统默认值 `MSGMNB`。
      * 特权进程（`CAP_SYS_RESOURCE`）可以使用 `IPC_SET` 操作修改这个上限值。
      * 管理员可以通过修改 `/proc/sys/kernel/msgmnb` 文件来改变系统默认的 `msg_qbytes` 上限。

  * **`msg_lspid`**:
    上一次成功调用 `msgsnd()` 的进程的 PID。

  * **`msg_lrpid`**:
    上一次成功调用 `msgrcv()` 的进程的PID。

-----

#### **程序示例**

程序清单 46-5 演示了如何使用 `IPC_STAT` 和 `IPC_SET` 操作来获取并修改一个消息队列的 `msg_qbytes` 设置。

**程序清单 46-5：修改一个 System V 消息队列的 `msg_qbytes` 设置**

```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/msg.h>

int main(int argc, char *argv[]) {
    struct msqid_ds ds;
    int msqid;

    if (argc != 3 || strcmp(argv[1], "--help") == 0) {
        fprintf(stderr, "Usage: %s msqid max-bytes\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    msqid = atoi(argv[1]);

    // 1. 获取当前的消息队列数据结构
    if (msgctl(msqid, IPC_STAT, &ds) == -1) {
        perror("msgctl IPC_STAT");
        exit(EXIT_FAILURE);
    }
    printf("Current msg_qbytes value is %ld\n", (long) ds.msg_qbytes);

    // 2. 修改 msg_qbytes 字段
    ds.msg_qbytes = atoi(argv[2]);

    // 3. 将修改后的数据结构设置回内核
    // 注意: 修改此值通常需要特权 (CAP_SYS_RESOURCE)
    if (msgctl(msqid, IPC_SET, &ds) == -1) {
        perror("msgctl IPC_SET");
        exit(EXIT_FAILURE);
    }

    printf("Successfully set msg_qbytes to %ld\n", (long) ds.msg_qbytes);
    
    exit(EXIT_SUCCESS);
}
```

##### **编译和运行演示**

1.  **编译程序**:
    ```bash
    gcc msg_change_qbytes.c -o msg_change_qbytes
    ```
2.  **先创建一个消息队列 (使用上一节的 `msgget_demo` 程序)**:
    ```bash
    $ ./msgget_demo -c -k 0x12345 0666
    Message Queue ID = 0
    ```
3.  **以 `root` 权限运行程序来修改队列的字节上限**:
    ```bash
    $ sudo ./msg_change_qbytes 0 2048
    Current msg_qbytes value is 16384  <-- 系统的默认值
    Successfully set msg_qbytes to 2048
    ```
4.  **使用 `ipcs` 命令验证**:
    ```bash
    $ ipcs -q -i 0

    Message Queue msqid=0
    ...
    cbytes=0, qnum=0, qbytes=2048  <-- 上限已被成功修改
    ...
    ```