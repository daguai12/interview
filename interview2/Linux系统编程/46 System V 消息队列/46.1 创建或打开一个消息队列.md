### **46.1 创建或打开一个消息队列**
`msgget()` 系统调用用于创建一个新消息队列，或取得一个既有消息队列的标识符。
```c
#include <sys/msg.h>
int msgget(key_t key, int msgflg);
```
* **`key`**: 一个键，用于在系统中唯一地标识一个消息队列。通常使用 `ftok()` 生成或指定为 `IPC_PRIVATE`（见 45.2 节）。
* **`msgflg`**: 一个位掩码，由**权限位**和**控制标志**组成。
	* **权限位**: 低 9 位用于指定新消息队列的权限（例如 `0600`）。
	* **控制标志**: 可以在 `msgflg` 中“或”上以下一个或多个标志来控制 `msgget()` 的操作：
		* **`IPC_CREAT`**: 如果与指定的 `key` 对应的消息队列**不存在**，则创建一个新队列。
		* **`IPC_EXCL`**: 必须与 `IPC_CREAT` 一同使用。如果与指定的 `key` 对应的队列**已经存在**，那么 `msgget()` 调用就会失败，并将 `errno` 置为 `EEXIST`。
**工作流程**:
`msgget()` 首先会在系统中搜索与 `key` 对应的消息队列。
1.  如果找到了一个匹配的队列，就返回该队列的标识符（除非同时指定了 `IPC_CREAT` 和 `IPC_EXCL`）。
2.  如果没有找到匹配的队列，并且在 `msgflg` 中指定了 `IPC_CREAT`，那么就会创建一个新队列并返回其标识符。
3.  如果没有找到匹配的队列，并且**没有**指定 `IPC_CREAT`，则调用失败。
-----
#### **程序示例**
程序清单 46-1 为 `msgget()` 系统调用提供了一个命令行接口，允许通过命令行参数来指定 `key` 和 `msgflg` 的所有组合。
**程序清单 46-1：使用 `msgget()`**
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/msg.h>
#include <errno.h>
#include <unistd.h>
static void usageError(const char *progName, const char *msg) {
	if (msg != NULL)
		fprintf(stderr, "%s", msg);
	fprintf(stderr, "Usage: %s [-cx] {-f pathname | -k key | -p} [octal-perms]\n", progName);
	fprintf(stderr, "    -c           Use IPC_CREAT flag\n");
	fprintf(stderr, "    -x           Use IPC_EXCL flag\n");
	fprintf(stderr, "    -f pathname  Generate key using ftok()\n");
	fprintf(stderr, "    -k key       Use 'key' as key (in hex)\n");
	fprintf(stderr, "    -p           Use IPC_PRIVATE key\n");
	exit(EXIT_FAILURE);
}
int main(int argc, char *argv[]) {
	int numKeyFlags;
	int flags, opt;
	key_t key;
	int msqid;
		// 初始化标志和权限
	flags = 0;
	numKeyFlags = 0;
	// 解析命令行选项
	while ((opt = getopt(argc, argv, "cf:k:px")) != -1) {
		switch (opt) {
		case 'c':
			flags |= IPC_CREAT;
			break;
		case 'f':
			key = ftok(optarg, 1);
			if (key == -1) {
				perror("ftok");
				exit(EXIT_FAILURE);
			}
			numKeyFlags++;
			break;
		case 'k':
			if (sscanf(optarg, "%x", &key) != 1)
				usageError(argv[0], "Hex argument required for -k\n");
			numKeyFlags++;
			break;
		case 'p':
			key = IPC_PRIVATE;
			numKeyFlags++;
			break;
		case 'x':
			flags |= IPC_EXCL;
			break;
		default:
			usageError(argv[0], NULL);
		}
	}
	// 确保只指定了一种 key 的生成方式
	if (numKeyFlags != 1)
		usageError(argv[0], "Exactly one of -f, -k, or -p must be specified\n");
	// 如果提供了权限参数，则添加到 flags 中
	if (optind < argc) {
		if (sscanf(argv[optind], "%o", &flags) != 1)
			usageError(argv[0], "Invalid octal perms\n");
	}
	// 调用 msgget()
	msqid = msgget(key, flags);
	if (msqid == -1) {
		perror("msgget");
		exit(EXIT_FAILURE);
	}
	printf("Message Queue ID = %d\n", msqid);
		exit(EXIT_SUCCESS);
}
```
这个程序本身不产生复杂的输出，它是一个工具，用于从命令行直接调用 `msgget()` 来创建或打开消息队列，并打印出返回的队列标识符。它的用法将在后续章节的客户端/服务器示例中得到演示。