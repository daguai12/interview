好的，这是根据您提供的文本内容，保留原始结构和标题整理的结果。

### **46.2 交换消息**

`msgsnd()` 和 `msgrcv()` 系统调用用于在消息队列上执行 I/O 操作（即发送和接收消息）。

这两个系统调用的第一个参数都是消息队列标识符 `msqid`。第二个参数 `msgp` 是一个指向由程序员自定义的、用于存放消息内容的结构体的指针。

#### **消息结构**

尽管 `msgp` 参数的类型是 `void *`，允许传递任意结构的指针，但所有消息结构都必须遵循一个通用的形式：**第一个字段必须是消息类型**。

其常规形式如下：

```c
struct mymsg {
    long mtype;       /* message type (必须是 long 类型) */
    char mtext[...];  /* message data (消息正文) */
};
```

  * **`mtype` (消息类型)**:

      * 必须是结构体的**第一个字段**，且其类型必须是 `long`。
      * 内核使用这个字段来区分不同类型的消息，并允许接收进程根据类型来选择性地接收消息。

  * **`mtext` (消息正文/负载)**:

      * 消息的剩余部分是由程序员定义的结构，其长度和内容可以是任意的，不一定是一个字符数组。
      * `mtext` 字段的长度可以为零。当所需传递的信息仅通过消息类型就能表示时，这种做法非常有用。

#### **46.2.1 发送消息**

`msgsnd()` 系统调用向一个消息队列写入（发送）一条消息。

```c
#include <sys/msg.h>

int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);
```

  * **`msqid`**: 目标消息队列的标识符。
  * **`msgp`**: 指向要发送的消息结构体的指针。该结构体的第一个字段 `mtype` 必须被设为一个**大于 0** 的值。
  * **`msgsz`**: 要发送的消息**正文**的字节数（即 `mtext` 字段的大小），**不包括** `mtype` 字段的长度。
  * **`msgflg`**: 一个位掩码，用于控制 `msgsnd()` 的操作。目前只定义了一个标记：
      * **`IPC_NOWAIT`**: 执行**非阻塞**发送。

**发送行为**:

  * **阻塞 (默认)**: 如果消息队列已满（因达到字节数或消息数限制），`msgsnd()` 调用会**阻塞**，直到队列中有足够的空间来存放这条消息。
  * **非阻塞 (`IPC_NOWAIT`)**: 如果消息队列已满，`msgsnd()` 会立即失败并返回 `EAGAIN` 错误。
  * **原子性**: 与 `write()` 不同，`msgsnd()` 不存在“部分写入”的概念。消息要么被完整地发送，要么完全不发送。成功的 `msgsnd()` 调用返回 0。
  * **信号中断**: 如果一个阻塞的 `msgsnd()` 调用被信号处理器中断，它**总是**会失败并返回 `EINTR` 错误（即使信号处理器设置了 `SA_RESTART` 标志）。
  * **权限**: 向消息队列写入消息要求调用进程在该队列上拥有**写权限**。

-----

#### **程序示例**

程序清单 46-2 为 `msgsnd()` 系统调用提供了一个命令行接口。它直接接收消息队列的**标识符**作为参数，而不是 `key`。

**程序清单 46-2：使用 `msgsnd()` 发送一条消息**

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/msg.h>
#include <errno.h>
#include <unistd.h>

#define MAX_MTEXT 1024

// 自定义消息结构
struct mbuf {
    long mtype;
    char mtext[MAX_MTEXT];
};

static void usageError(const char *progName, const char *msg) {
    if (msg != NULL)
        fprintf(stderr, "%s", msg);
    fprintf(stderr, "Usage: %s [-n] msqid msg-type [msg-text]\n", progName);
    fprintf(stderr, "    -n           Use IPC_NOWAIT flag\n");
    exit(EXIT_FAILURE);
}

int main(int argc, char *argv[]) {
    int msqid, flags, msgLen;
    struct mbuf msg;
    int opt;

    flags = 0;
    while ((opt = getopt(argc, argv, "n")) != -1) {
        if (opt == 'n') {
            flags |= IPC_NOWAIT;
        }
    }

    if (argc < optind + 2 || argc > optind + 3) {
        usageError(argv[0], NULL);
    }
    
    msqid = atoi(argv[optind]);
    msg.mtype = atoi(argv[optind + 1]);
    
    if (msg.mtype == 0) {
        usageError(argv[0], "msg-type must be > 0\n");
    }

    if (argc > optind + 2) { // 提供了消息文本
        msgLen = strlen(argv[optind + 2]) + 1; // +1 for '\0'
        if (msgLen > MAX_MTEXT) {
            fprintf(stderr, "msg-text too long (max: %d characters)\n", MAX_MTEXT);
            exit(EXIT_FAILURE);
        }
        memcpy(msg.mtext, argv[optind + 2], msgLen);
    } else { // 没有消息文本
        msgLen = 0;
    }
    
    // 发送消息
    if (msgsnd(msqid, &msg, msgLen, flags) == -1) {
        perror("msgsnd");
        exit(EXIT_FAILURE);
    }
    
    printf("Message sent.\n");
    exit(EXIT_SUCCESS);
}
```

这个程序是一个命令行工具，用于向一个已存在的消息队列发送消息。它的用法将在下一节的客户端/服务器示例中得到演示。