### **46.7 使用消息队列实现客户端-服务器应用程序**

在客户端-服务器应用程序设计中使用 System V 消息队列的方式有很多种，本节将介绍其中两种。

1.  在服务器和所有客户端之间使用**单个**消息队列进行双向消息交换。
2.  服务器和各个客户端使用**多个**消息队列：服务器用一个队列接收请求，然后为每个客户端使用其私有队列发送响应。

至于选择何种方法，依赖于应用程序的需求。

-----

#### **方法一：服务器和客户端使用一个消息队列**

当服务器与客户端之间交换的消息大小较小时，使用单个消息队列是合适的，但需要特别注意以下几点。

##### **消息寻址**

由于多个进程可能会同时从同一个队列中读取消息，因此必须使用消息的**类型 (`mtype`)** 字段来让各个进程只选择那些发送给自己的消息。一种实现方法是：

  * **客户端 -\> 服务器**: 所有客户端向服务器发送请求时，都使用一个固定的、众所周知的消息类型，例如 `mtype = 1`。（使用 `1` 是安全的，因为 `init` 进程的 PID 是 1，没有客户端进程的 PID 会是 1）。
  * **服务器 -\> 客户端**: 服务器在发送响应给特定客户端时，使用该**客户端的进程 ID** 作为消息类型（`mtype = client_pid`）。客户端需要将自己的 PID 作为请求消息的一部分发送给服务器。

**通信流程图 (对应原文图 46-2):**
![[Pasted image 20250916083854.png]]

##### **缺点**

1.  **死锁风险**: 消息队列的容量是有限的。多个并发的客户端可能会用请求消息填满队列，导致服务器在尝试写入响应时被阻塞。一旦服务器被阻塞，它就无法再处理新的请求，从而导致整个系统死锁。
2.  **恶意客户端问题**: 一个行为不良或恶意的客户端可能在发送请求后，从不读取服务器的响应。这将导致队列中充满了未被读取的“垃圾”消息，最终同样会耗尽队列容量并导致死锁。

-----

#### **方法二：一个客户端使用一个消息队列**

当需要交换的消息较大，或者为了避免单队列模型带来的问题时，为每个客户端使用一个单独的消息队列是更健壮的方法。这种设计通常如下：

  * 服务器创建一个众所周知的**请求队列**。
  * 每个客户端在需要通信时，创建一个属于自己的、私有的**响应队列**。

##### **实现要点**

  * 每个客户端必须创建自己的消息队列（通常使用 `IPC_PRIVATE` 键）。
  * 客户端需要将自己队列的**标识符 (msqid)** 告知服务器，这通常通过将标识符作为请求消息的一部分，发送到服务器的请求队列来完成。

##### **缺点**

1.  **队列数量限制 (`MSGMNI`)**: 系统对消息队列的总数是有限制的。如果同时运行的客户端数量非常庞大，可能会达到这个上限。
2.  **客户端队列可能消失**: 服务器应该能健壮地处理客户端的响应队列不再存在的情况（例如，客户端在收到响应前崩溃并删除了它的队列）。

下一节将会对“为每个客户端使用一个队列”这种更优的方法进行深入介绍和代码实现。