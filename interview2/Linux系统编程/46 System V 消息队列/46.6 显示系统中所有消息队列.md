### **46.6 显示系统中所有消息队列**

在 45.7 节中介绍了通过 `/proc/sysvipc` 目录中的文件来获取系统中所有 IPC 对象列表的方法。本节将介绍获取相同信息的第二种 Linux 特有方法：通过一组特定的 `ctl` 调用。`ipcs` 命令正是使用了这些操作。

#### **Linux 特有的 ctl 操作**

要使用这些常量，必须在程序开头定义 `_GNU_SOURCE` 特性测试宏。

  * **`MSG_INFO`**, **`SEM_INFO`**, **`SHM_INFO`**:

      * **作用**: 获取关于某类 IPC 资源的**全局信息**。
      * **返回值**: `msgctl()` 的函数结果将返回内核中用于表示该类对象的内部数组的**最大下标 (maximum index)**。同时，`buf` 参数会填充一个包含资源消耗信息的结构体（如 `msginfo`）。

  * **`MSG_STAT`**, **`SEM_STAT`**, **`SHM_STAT`**:

      * **作用**: 获取单个 IPC 对象的关联数据结构，与 `IPC_STAT` 类似但有两点不同。
      * **区别 1 (输入)**: `ctl` 调用的第一个参数不是 IPC **标识符**，而是内核内部数组的**下标 (index)**。
      * **区别 2 (返回)**: 如果操作成功，`ctl` 调用的函数结果会返回与该下标对应的 IPC **标识符 (identifier)**。

#### **遍历所有消息队列的算法**

按照下面的步骤可以列出系统上所有的消息队列：

1.  使用 `msgctl()` 的 `MSG_INFO` 操作找到消息队列内核数组的最大下标 `maxind`。
2.  执行一个从 `0` 到 `maxind` 的循环，对每一个下标值 `j` 都执行一个 `msgctl()` 的 `MSG_STAT` 操作。
3.  在循环过程中，忽略因该下标对应的数组元素为空而发生的 `EINVAL` 错误，以及因权限不足而发生的 `EACCES` 错误。

-----

#### **程序示例**

程序清单 46-6 按照上面的步骤实现了对系统中所有消息队列的遍历和信息显示，功能类似于 `ipcs -q`。

**程序清单 46-6：显示系统上所有 System V 消息队列**

```c
#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <sys/msg.h>
#include <errno.h>

int main(int argc, char *argv[]) {
    int maxind, msqid;
    struct msqid_ds ds;
    struct msginfo msginfo;

    // 1. 获取内核消息队列数组的最大下标
    maxind = msgctl(0, MSG_INFO, (struct msqid_ds *) &msginfo);
    if (maxind == -1) {
        perror("msgctl MSG_INFO");
        exit(EXIT_FAILURE);
    }
 printf("maxind: %d\n\n", maxind);
    printf("        id       key      mode       uid      gid\n");

    // 2. 循环遍历所有可能的下标
    for (int j = 0; j <= maxind; j++) {
        // 3. 根据下标获取消息队列的标识符，并填充 ds 结构
        msqid = msgctl(j, MSG_STAT, &ds);
        if (msqid == -1) {
            // 如果是 EINVAL 或 EACCES，说明该下标的队列不存在或无权访问，属正常情况
            if (errno == EINVAL || errno == EACCES) {
                continue; // 继续下一个
            }
            // 其他错误则需要报告
            perror("msgctl MSG_STAT"); 
            break; 
        }

        // 打印获取到的消息队列信息
        printf("%10d  0x%08lx %10o %10d %10d\n", msqid,
               (unsigned long) ds.msg_perm.__key,
               (unsigned int) ds.msg_perm.mode,
               (int) ds.msg_perm.uid, (int) ds.msg_perm.gid);
    }

    exit(EXIT_SUCCESS);
}
```

##### **编译和运行演示**

1.  **编译程序**: `gcc list_msg_queues.c -o list_msg_queues`
2.  **先创建一些消息队列 (使用 `msgget_demo` 程序)**:
    ```bash
    $ ./msgget_demo -c -k 0x111111 0666
    Message Queue ID = 0
    $ ./msgget_demo -c -k 0x222222 0600
    Message Queue ID = 1
    ```
3.  **运行程序列出所有队列**:
    ```bash
    $ ./list_msg_queues
    maxind: 1

            id       key      mode       uid      gid
             0  0x00111111       0666      1000      1000
             1  0x00222222       0600      1000      1000
    ```

这个程序成功地遍历并打印出了系统上存在的所有消息队列的信息，而无需预先知道它们的标识符。