### **37.5 使用 syslog 记录消息和错误**

在编写 daemon 时碰到的一个核心问题是如何处理日志和错误消息。由于 daemon 在后台运行且没有控制终端，它无法像普通程序那样将消息直接输出到屏幕上。虽然可以写入特定的日志文件，但这会给系统管理员带来管理和监控多个分散日志文件的困难。

**`syslog`** 工具就是为了解决这个问题而设计的，它提供了一个**集中式的日志记录工具**，系统中的所有应用程序都可以使用它来记录日志消息。

#### **37.5.1 概述**

![[Pasted image 20250912113251.png]]


`syslog` 工具有两个主要组件：`syslogd` 守护进程和 `syslog(3)` 库函数。

##### **工作流程概览**

1.  **应用程序**通过调用 `syslog()` 库函数来生成一条日志消息。
2.  `syslog()` 函数将这条消息格式化，并通过一个 UNIX domain socket (`/dev/log`) 发送出去。
3.  **`syslogd` 守护进程**持续监听 `/dev/log` socket。
4.  当 `syslogd` 收到消息后，它会检查消息的**类型 (facility)** 和**严重等级 (level)**。
5.  `syslogd` 根据其配置文件 `/etc/syslog.conf` 中的规则，决定将这条消息路由到一个或多个**目的地**。

##### **`syslogd` 守护进程**

`syslogd` 是系统的日志中心。

  * **消息来源**:
      * **本地**: 通过 UNIX domain socket `/dev/log` 接收。
      * **远程**: 通过 Internet domain socket (UDP 端口 514) 接收来自网络上其他主机的日志消息。
  * **消息属性**: 每条消息都包含两个重要属性：
      * **Facility (设备/类型)**: 指定了产生消息的程序类型（例如，内核、邮件服务、cron 作业等）。
      * **Level (级别/严重程度)**: 指定了消息的严重性（例如，调试、信息、警告、错误、紧急）。
  * **消息目的地**: 根据 `/etc/syslog.conf` 的配置，消息可以被发送到：
      * 磁盘文件 (如 `/var/log/messages`)。
      * 终端或虚拟控制台。
      * 所有已登录用户的屏幕。
      * 另一个系统上的 `syslogd` 守护进程（这对于集中日志管理和提高安全性非常有用）。

##### **`syslog(3)` 库函数**

  * **作用**: 这是供应用程序使用的标准接口。
  * **功能**: 任意进程都可以调用 `syslog(3)` 函数，它会构建一条标准格式的日志消息，并将其写入 `/dev/log` socket，以供 `syslogd` 读取和处理。

##### **内核日志**

内核产生的日志消息（通过 `printk()` 函数生成）由另一个名为 **`klogd`** 的守护进程收集。`klogd` 从内核日志缓冲区（可通过 `/proc/kmsg` 访问）读取消息，然后也通过 `syslog(3)` 函数将这些消息转发到 `/dev/log`，最终由 `syslogd` 统一处理。

> **`syslog(2)` 与 `syslog(3)` 的区别**:
>
>   * `syslog(3)` 是本节讨论的、用于向 `syslogd` 发送日志消息的**库函数**。
>   * `syslog(2)` 是一个用于控制内核日志环形缓冲区的**系统调用**，其 glibc 封装函数名为 `klogctl()`。两者名称相同，但功能完全不同。



#### **37.5.2 syslog API**

syslog API 主要由以下三个函数构成：

  * **`openlog()`**: (可选) 建立到日志工具的连接并设置默认值。
  * **`syslog()`**: 记录一条日志消息。
  * **`closelog()`**: (可选) 关闭与日志工具的连接。

这些函数都不会返回状态值，因为日志服务被假定为总是可用的。

##### **建立连接：`openlog()`**

`openlog()` 函数为后续的 `syslog()` 调用设置默认值。

```c
#include <syslog.h>

void openlog(const char *ident, int log_options, int facility);
```

  * **`ident`**: 一个字符串，通常是程序名，它会被添加到每条日志消息的开头。
  * **`log_options`**: 一个位掩码，由以下一个或多个常量进行“或”运算组成：
      * `LOG_CONS`: 当向 `syslogd` 发送消息发生错误时，将消息直接写入系统控制台 (`/dev/console`)。
      * `LOG_NDELAY`: 立即打开到 `/dev/log` 的连接。默认是延迟到首次调用 `syslog()` 时才打开。
      * `LOG_PERROR`: 除了将消息发送到 `syslogd`，也将其写入**标准错误 (stderr)**。
      * `LOG_PID`: 在每条消息中都包含调用进程的 PID。
  * **`facility`**: 指定后续 `syslog()` 调用使用的默认消息类型。其可选值如下表所示。

**表 37-1：`openlog()` 的 `facility` 值**
| 值 | 描述 (消息来源) |
| :--- | :--- |
| `LOG_AUTH` | 安全和验证消息 |
| `LOG_AUTHPRIV` | 私有的安全和验证消息 |
| `LOG_CRON` | 来自 `cron` 和 `at` 守护进程的消息 |
| `LOG_DAEMON` | 来自其他系统守护进程的消息 |
| `LOG_FTP` | 来自 FTP 守护进程的消息 |
| `LOG_KERN` | 内核消息（用户进程无法生成） |
| `LOG_LOCAL0` ... `LOG_LOCAL7` | 保留给本地使用 |
| `LOG_LPR` | 来自打印系统的消息 |
| `LOG_MAIL` | 来自邮件系统的消息 |
| `LOG_NEWS` | 与网络新闻相关的消息 |
| `LOG_SYSLOG` | 来自 `syslogd` 自身的消息 |
| `LOG_USER` | **(默认值)** 用户进程生成的消息 |
| `LOG_UUCP` | 来自 UUCP 系统的消息 |

##### **记录消息：`syslog()`**

`syslog()` 函数用于写入一条日志消息。

```c
#include <syslog.h>

void syslog(int priority, const char *format, ...);
```

  * **`priority`**: 是 `facility` 值和 `level` 值的“或”(`|`)运算结果。
      * **`facility`**: 消息的类型，可使用上表中的值。如果省略（即 facility 部分为 0），则使用 `openlog()` 中设置的默认值。
      * **`level`**: 消息的严重等级，其取值如下表所示。
  * **`format`, ...**: 与 `printf()` 类似，是一个格式化字符串和相应的参数列表。
      * 不需要包含换行符 `\n`。
      * 可以包含 `**%m**` 序列，它会被自动替换为与当前 `errno` 值对应的错误字符串（即 `strerror(errno)`）。

**表 37-2：`syslog()` 的 `level` 值 (严重性从高到低)**
| 值 | 描述 |
| :--- | :--- |
|`LOG_EMERG`| 紧急情况（系统不可用）|
|`LOG_ALERT`| 需要立即处理的情况 |
|`LOG_CRIT`| 关键情况（如硬件错误）|
|`LOG_ERR`| 常规错误 |
|`LOG_WARNING`| 警告 |
|`LOG_NOTICE`| 普通但需要注意的情况 |
|`LOG_INFO`| 情报性消息 |
|`LOG_DEBUG`| 调试消息 |

**用法示例**:

```c
openlog("my_app", LOG_PID | LOG_CONS, LOG_LOCAL0);
syslog(LOG_INFO, "Application started.");
syslog(LOG_USER | LOG_ERR, "An error occurred: %m"); // 覆盖默认 facility
```

> **安全警告：格式化字符串攻击**
> **永远不要**将用户提供的字符串直接作为 `syslog()` 的第一个参数。
>
> ```c
> // 错误！有漏洞！
> syslog(LOG_INFO, user_input_string);
> ```

> // 正确！
> syslog(LOG\_INFO, "%s", user\_input\_string);
>
> ```
> 
> 否则，如果用户输入的字符串中包含 `%s`, `%x` 等格式化字符，可能会导致程序崩溃或信息泄露。
> ```

##### **关闭连接：`closelog()`**

```c
#include <syslog.h>

void closelog(void);
```

当完成日志记录之后，可以调用 `closelog()` 来释放分配给 `/dev/log` socket 的文件描述符。由于 daemon 通常会持续记录日志，因此一般会省略对 `closelog()` 的调用。

##### **过滤消息：`setlogmask()`**

`setlogmask()` 函数设置一个进程级的掩码，用于过滤由 `syslog()` 写入的消息。只有 `level` 在当前掩码设置中的消息才会被发送。

```c
#include <syslog.h>

int setlogmask(int mask);
```

  * `LOG_MASK(level)` 宏可以将一个 `level` 值转换成适合的位。
  * `LOG_UPTO(level)` 宏可以创建一个包含指定级别及以上所有级别的掩码。

例如，要丢弃除 `LOG_ERR` 及以上优先级之外的所有消息，可以这样写：

```c
// 方法一：使用 LOG_MASK
setlogmask(LOG_MASK(LOG_EMERG) | LOG_MASK(LOG_ALERT) |
           LOG_MASK(LOG_CRIT) | LOG_MASK(LOG_ERR));

// 方法二：使用 LOG_UPTO (更简洁)
setlogmask(LOG_UPTO(LOG_ERR));
```


#### **37.5.3 /etc/syslog.conf 文件**

`/etc/syslog.conf` 配置文件控制 `syslogd` 守护进程的操作。这个文件由一系列规则和注释（以 `#` 字符开头）构成。

##### **规则语法**

每条规则都由两部分组成，中间用空白字符隔开：

```
selector    action
```

  * **`selector` (选择器)**: 由 `facility.level` 组合而成，用于选择需要应用此规则的消息。
  * **`action` (动作)**: 指定与选择器匹配的消息将被发送到何处（目的地）。

-----

##### **规则示例与解析**

下面是一些示例规则：

1.  **将所有错误及更严重的消息发送到控制台**

    ```
    *.err        /dev/tty10
    ```

      * **选择器 (`*.err`)**:
          * `facility`: `*` (通配符)，表示**所有**类型的程序。
          * `level`: `err`，表示 `LOG_ERR` 等级以及**所有比它更严重**的等级（如 `LOG_CRIT`, `LOG_ALERT`, `LOG_EMERG`）。
      * **动作 (`/dev/tty10`)**: 将消息写入到 `/dev/tty10` 这个控制台设备。

2.  **将认证相关的通知发送给所有已登录的 root 用户**

    ```
    auth.notice  *
    ```

      * **选择器 (`auth.notice`)**: 匹配来自验证工具（`LOG_AUTH`）的、严重等级为 `notice` 及以上的所有消息。
      * **动作 (`*`)**: `*` (通配符)，表示将消息广播给**所有**已登录的用户。这条规则可以让登录的 `root` 用户立即看到失败的 `su` 尝试等安全事件。

3.  **记录除邮件和新闻外的所有消息，并使用异步写入**

    ```
    *.debug;mail.none;news.none   -/var/log/messages
    ```

      * **选择器 (`*.debug;mail.none;news.none`)**:
          * 这是一个由分号分隔的**多重选择器**。
          * `*.debug`: `debug` 是最低的严重等级，所以这个选择器匹配**所有来源的所有消息**。
          * `mail.none;news.none`: `none` 是一个特殊的 `level`，表示**排除**。这两个选择器排除了所有来自邮件系统 (`mail`) 和新闻系统 (`news`) 的消息。
      * **动作 (`-/var/log/messages`)**:
          * 将最终匹配的消息写入 `/var/log/messages` 文件。
          * 文件名前面的**连接符 (`-`)** 表示**无需**每次都将写入同步到磁盘。这可以提高写入性能，但代价是在系统崩溃时可能会丢失最后几条日志数据。

-----

##### **应用配置变更**

每次修改 `/etc/syslog.conf` 文件之后，都需要通知 `syslogd` 守护进程重新加载配置文件。这通常通过向它发送 `SIGHUP` 信号来完成：

```bash
# killall -HUP syslogd
```