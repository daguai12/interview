### **37.4 使用 SIGHUP 重新初始化一个 daemon**

由于守护进程（daemon）需要长时间持续运行，因此在设计上需要解决一些问题：

1.  **更新配置**: 如何在不重启 daemon 的情况下，让它加载新的配置文件并修改其操作参数？
2.  **日志文件轮转 (Log Rotation)**: 如何处理会无限增长的日志文件？如果只是简单地重命名或删除日志文件，daemon 由于仍然持有对该文件的打开描述符，会继续向旧文件（即使它已被删除且无文件名）写入数据。

解决这两个问题的标准方案是：**让 daemon 为 `SIGHUP` 信号建立一个处理器**，并在收到这个信号时执行重新初始化的操作。

之所以选择 `SIGHUP`，是因为它原本是用于通知进程其控制终端已断开连接的信号。而一个正确的 daemon **没有控制终端**，因此内核永远不会向 daemon 自动发送这个信号。这使得 `SIGHUP` 成为了一个“空闲”的、可以被赋予新含义的信号，并按照惯例用于触发 daemon 重新初始化。

-----

#### **程序示例**

程序清单 37-3 提供了一个 daemon 如何使用 `SIGHUP` 的示例。这个程序会：

1.  建立一个 `SIGHUP` 信号处理器。为保证安全，处理器只设置一个全局标记变量。
2.  将自身转变为一个 daemon。
3.  打开日志文件和配置文件。
4.  进入一个主循环，定期工作（向日志文件写入消息），并在每次循环后检查 `SIGHUP` 标记。
5.  如果标记被设置，则重新打开日志文件并重新读取配置文件。

**程序清单 37-3：使用 SIGHUP 重新初始化一个 daemon**

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>
#include <string.h>
#include <time.h>
#include <fcntl.h>
#include <sys/stat.h>

#define CONFIG_FILE "/tmp/daemon.conf"
#define LOG_FILE "/tmp/daemon.log"
#define BUF_SIZE 100

// ① SIGHUP 处理器只设置一个全局标记变量
static volatile sig_atomic_t hupReceived = 0;

static FILE *logfp; // 日志文件指针

// 简单的日志函数
static void logMessage(const char *msg) {
    if (logfp != NULL) {
        time_t t;
        time(&t);
        fprintf(logfp, "[%s] %s\n", strtok(ctime(&t), "\n"), msg);
        fflush(logfp);
    }
}

// ④ 打开日志文件
static void logOpen() {
    logfp = fopen(LOG_FILE, "a");
    if (logfp == NULL) exit(EXIT_FAILURE);
}

// ⑤ 读取配置文件
static void readConfigFile() {
    FILE *configfp;
    char buf[BUF_SIZE];
    
    configfp = fopen(CONFIG_FILE, "r");
    if (configfp == NULL) return; // 配置文件可能不存在

    if (fgets(buf, BUF_SIZE, configfp) != NULL) {
        logMessage(buf);
    }
    fclose(configfp);
}

// SIGHUP 信号处理器
static void sighupHandler(int sig) {
    hupReceived = 1;
}

int main(int argc, char *argv[]) {
    // ② 建立 SIGHUP 信号处理器
    struct sigaction sa;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART;
    sa.sa_handler = sighupHandler;
    if (sigaction(SIGHUP, &sa, NULL) == -1) {
        perror("sigaction");
        exit(EXIT_FAILURE);
    }

    // ③ 将自身转变为 daemon
    if (daemon(0, 0) == -1) { // 使用 glibc 的 daemon() 函数简化
        perror("daemon");
        exit(EXIT_FAILURE);
    }

    logOpen();
    readConfigFile();

    int count = 0;
    // ⑧ 主循环
    for (;;) {
        // ⑥ sleep() 模拟真实应用程序的工作
        sleep(15);

        // ⑦ 检查 SIGHUP 标记
        if (hupReceived) {
            hupReceived = 0; // 清除标记
            logMessage("SIGHUP received, reinitializing...");
            fclose(logfp);
            logOpen();
            readConfigFile();
        }
        
        char msg_buf[BUF_SIZE];
        snprintf(msg_buf, BUF_SIZE, "Main loop iteration %d", ++count);
        logMessage(msg_buf);
    }
}
```

**编译和运行演示**

1.  **编译程序**: `gcc reinit_daemon.c -o reinit_daemon`

2.  **准备环境并启动 daemon**:

    ```bash
    # 创建一个初始配置文件
    $ echo "Initial configuration" > /tmp/daemon.conf

    # 在后台启动 daemon
    $ ./reinit_daemon &
    [1] 12345

    # 查看 daemon 的 PID
    $ ps -C reinit_daemon -o pid
      PID
    12345
    ```

3.  **修改配置，轮转日志，并发送 SIGHUP 信号**:

    ```bash
    # 修改配置文件
    $ echo "Updated configuration" > /tmp/daemon.conf

    # 重命名(轮转)日志文件
    $ mv /tmp/daemon.log /tmp/daemon.log.old

    # 向 daemon 发送 SIGHUP 信号
    $ kill -HUP 12345
    ```

4.  **检查结果**:

    ```bash
    # 查看旧日志文件，daemon 在收到信号前仍在向它写入
    $ cat /tmp/daemon.log.old
    [Fri Sep 12 11:19:10 2025] Initial configuration
    [Fri Sep 12 11:19:25 2025] Main loop iteration 1

    # 查看新日志文件，daemon 重新打开了文件并读取了新配置
    $ cat /tmp/daemon.log
    [Fri Sep 12 11:19:35 2025] SIGHUP received, reinitializing...
    [Fri Sep 12 11:19:35 2025] Updated configuration
    [Fri Sep 12 11:19:40 2025] Main loop iteration 2
    ```

这个过程清晰地展示了如何通过发送 `SIGHUP` 信号，在不中断服务的情况下，让一个正在运行的 daemon 重新加载配置并切换到新的日志文件。