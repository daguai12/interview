### **37.2 创建一个 daemon**

要将一个普通程序转变为守护进程（daemon），该程序需要完成以下一系列标准化步骤。

#### **Daemon 化步骤**

1.  **执行 `fork()`，父进程退出**

      * **目的1 (脱离 shell)**: 如果程序是从命令行启动的，父进程退出会立即返回 shell 提示符，让子进程在后台继续运行。
      * **目的2 (非进程组首进程)**: 子进程继承了父进程的 PGID，但拥有自己唯一的 PID，因此 `pid != pgid`。这就保证了子进程**不是**一个进程组首进程，这是成功调用 `setsid()` 的前提。

2.  **调用 `setsid()` 创建新会话**

      * 子进程调用 `setsid()`，使其成为新会话和新进程组的首进程，并彻底脱离它与原会话、原进程组以及控制终端的所有关联。

3.  **再次 `fork()`，父进程退出（可选但推荐）**

      * **目的**: 确保 daemon 永远不会再重新获得一个控制终端。
      * **原理**: 只有**会话首进程**才能获得控制终端。经过第二次 `fork()` 后，父进程（即第一次 `fork` 的子进程，也是会话首进程）退出，留下的孙子进程继续运行。这个孙子进程**不是**会话首进程，因此它无法再获得控制终端。

4.  **清除文件模式创建掩码 `umask`**

      * 调用 `umask(0)`。这样做是为了确保当 daemon 创建文件和目录时，可以完全控制其权限，而不受从父进程继承来的 `umask` 的影响。

5.  **修改当前工作目录为根目录**

      * 调用 `chdir("/")`。这是为了防止 daemon 保持在一个挂载的文件系统上，从而导致该文件系统无法被卸载。

6.  **关闭所有继承而来的文件描述符**

      * Daemon 会从其父进程继承打开的文件描述符（如标准输入、输出、错误）。由于 daemon 已与终端脱离，这些描述符已无意义，且会浪费资源，甚至可能阻止文件系统卸载。因此，一个健壮的 daemon 应该关闭所有这些描述符。

7.  **将标准输入、输出、错误重定向到 `/dev/null`**

      * 在关闭文件描述符 0、1 和 2 之后，通常会重新打开它们，并都指向 `/dev/null` 设备。
      * **目的1**: 防止 daemon 中调用的库函数因尝试读写标准输入/输出而意外失败。
      * **目的2**: 防止 daemon 后续打开文件时意外占用了 0、1 或 2 这几个文件描述符，导致库函数向这些文件写入数据而破坏文件内容。

-----

#### **可重用的函数：`becomeDaemon()`**

下面是一个可重用的函数，它封装了上述步骤，可以将调用它的程序转变为一个守护进程。

**程序清单 37-1：`become_daemon.h` 的头文件**

```c
#ifndef BECOME_DAEMON_H
#define BECOME_DAEMON_H

// flags 的位掩码常量
#define BD_NO_CHDIR           01  // 不将当前工作目录切换到 "/"
#define BD_NO_CLOSE_FILES     02  // 不关闭所有已打开的文件
#define BD_NO_REOPEN_STD_FDS  04  // 不将标准 IO 重定向到 /dev/null

// 函数原型
int becomeDaemon(int flags);

#endif
```

**程序清单 37-2：创建一个 daemon 进程**

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/stat.h>


int becomeDaemon(int flags) {
    int maxfd, fd;

    // 步骤 1 & 2: fork() 并创建新会话
    switch (fork()) {
        case -1: return -1;
        case 0:  break; // 子进程继续
        default: _exit(EXIT_SUCCESS); // 父进程退出
    }

    if (setsid() == -1) {
        return -1;
    }

    // 步骤 3: 再次 fork() (可选)
    switch (fork()) {
        case -1: return -1;
        case 0:  break;
        default: _exit(EXIT_SUCCESS);
    }

    // 步骤 4: 清除 umask
    umask(0);

    // 步骤 5: 切换工作目录
    if (!(flags & BD_NO_CHDIR)) {
        chdir("/");
    }

    // 步骤 6: 关闭所有打开的文件描述符
    if (!(flags & BD_NO_CLOSE_FILES)) {
        maxfd = sysconf(_SC_OPEN_MAX);
        if (maxfd == -1) {
            maxfd = 1024; // 使用一个保守的猜测值
        }
        for (fd = 0; fd < maxfd; fd++) {
            close(fd);
        }
    }

    // 步骤 7: 重定向标准 IO 到 /dev/null
    if (!(flags & BD_NO_REOPEN_STD_FDS)) {
        close(STDIN_FILENO); // 确保标准输入是关闭的

        fd = open("/dev/null", O_RDWR);
        if (fd != STDIN_FILENO) return -1; // fd 应该为 0
        if (dup2(STDIN_FILENO, STDOUT_FILENO) != STDOUT_FILENO) return -1;
        if (dup2(STDIN_FILENO, STDERR_FILENO) != STDERR_FILENO) return -1;
    }

    return 0; // 成功
}
```

#### **验证 Daemon**

当一个程序调用 `becomeDaemon(0)` 后，我们可以使用 `ps` 命令来查看其进程特性，以验证 daemon 是否创建成功。

```bash
$ ps -C my_daemon -o pid,ppid,pgid,sid,tty,comm
   PID   PPID   PGID    SID TT       COMMAND
 12345      1  12345  12345 ?        my_daemon
```

  * **PPID 为 1**: 证明原父进程已退出，该进程已被 `init` 进程收养。
  * **TT 为 `?`**: 表示该进程**没有**控制终端。
  * **PID, PGID, SID 相同**: 证明它是一个会话首进程和进程组首进程。如果我们使用了第二次 `fork` 的技巧，那么 PID 会与 SID 不同，更能确保它不会再获得控制终端。


# 为什么执行第7步

问得非常好！这是一个非常关键且容易让人困惑的点。

你的观察完全正确：**步骤6已经通过一个循环 `close(fd)` 关闭了包括 0, 1, 2 在内的所有文件描述符。**

那么为什么步骤7还要多此一举，重新处理 0, 1, 2 呢？

答案是：**为了程序的健壮性和安全性，防止未来发生意想不到的错误。**

我们来分析两种情况：

-----

### 情况一：如果只做步骤6，不做步骤7（即只关闭，不重定向）

1.  **库函数调用失败**：
    守护进程在后台运行，但它仍然可能调用一些标准的库函数，比如 `printf`（用于调试日志）、`scanf`、`perror` 等。这些函数在底层实现上，默认会向标准输出（fd 1）或标准错误（fd 2）写入数据。如果文件描述符 1 和 2 已经被关闭，这些函数调用就会失败，并返回一个 `EBADF` (Bad file descriptor) 错误。这可能会导致程序行为异常或崩溃。

2.  **更危险的“文件描述符劫持”**：
    这是最严重的问题。在步骤6执行完后，文件描述符 0, 1, 2 都变成了“可用”状态。
    假设守护进程在后续的代码中需要打开一个文件，比如一个日志文件：

    ```c
    // 假设这是守护进程后面的逻辑
    log_fd = open("/var/log/mydaemon.log", O_WRONLY | O_CREAT);
    ```

    `open()` 系统调用的规则是返回**当前未被使用的、编号最小的**文件描述符。因为 0 是可用的，所以这次调用会返回 `0`！这意味着你的日志文件 `mydaemon.log` 被关联到了文件描述符 0 (原本的标准输入)。

    现在，如果再打开一个配置文件：

    ```c
    config_fd = open("/etc/mydaemon.conf", O_RDONLY);
    ```

    这次调用会返回 `1`！你的配置文件被关联到了文件描述符 1 (原本的标准输出)。

    接下来，如果代码中有一句无心的 `printf`：

    ```c
    printf("守护进程已启动，PID=%d\n", getpid());
    ```

    `printf` 会向文件描述符 1 写入数据。但现在文件描述符 1 对应的不是终端，而是你的**配置文件 `mydaemon.conf`**！这会导致你的配置文件被意外地写入了启动信息，从而被破坏。这是一个非常隐蔽且致命的 bug。

-----

### 情况二：执行了步骤7（先关闭，再重定向到 `/dev/null`）

步骤7通过以下操作，完美地解决了上述两个问题：

1.  `fd = open("/dev/null", O_RDWR);`
    这会打开“黑洞”设备，并占用掉当前最小的可用文件描述符，也就是 `0`。

2.  `dup2(STDIN_FILENO, STDOUT_FILENO);`
    这会把文件描述符 `1` 也指向 `/dev/null`。

3.  `dup2(STDIN_FILENO, STDERR_FILENO);`
    这会把文件描述符 `2` 也指向 `/dev/null`。

执行完之后，状态变为：

  * 文件描述符 0 (stdin) -\> `/dev/null`
  * 文件描述符 1 (stdout) -\> `/dev/null`
  * 文件描述符 2 (stderr) -\> `/dev/null`

**这样做的好处是：**

1.  **提供一个安全的“垃圾桶”**：现在，文件描述符 0, 1, 2 都是**有效且打开的**。任何向标准输出或标准错误打印信息的尝试（如 `printf`）都会成功执行，只不过输出内容会被默默地丢进 `/dev/null` 这个黑洞里。程序不会因 `EBADF` 错误而崩溃。
2.  **杜绝劫持风险**：因为 0, 1, 2 已经被占用了，所以守护进程后续再调用 `open()` 打开新文件时，会从文件描述符 `3` 开始分配。这就从根本上避免了标准 I/O 流被业务文件（如日志、配置）意外劫持的风险。

### 总结

| 操作 | 存在的问题 |
| :--- | :--- |
| **仅关闭 (只做步骤6)** | 1. 库函数(printf等)写入标准输出/错误时会失败。<br>2. 未来 `open()` 新文件时会复用 0, 1, 2，可能导致标准流被“劫持”，造成数据损坏。 |
| **关闭并重定向 (做完步骤7)** | **无**。为标准 I/O 提供了一个安全的“黑洞”，并保护了低位文件描述符不被滥用。这是编写健壮守护进程的**标准实践**。 |

所以，**“关闭所有文件描述符”是为了切断与父进程和终端的联系，而“重新打开并重定向标准I/O”则是为了给守护进程自身创建一个安全、可预测的运行环境。** 两者都是必不可少的步骤。