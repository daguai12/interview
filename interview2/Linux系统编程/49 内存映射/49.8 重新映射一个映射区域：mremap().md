### **49.8 重新映射一个映射区域：mremap()**

在大多数 UNIX 实现上，一个内存映射一旦被创建，其位置和大小就无法改变了。但 Linux 提供了一个**不可移植的** `mremap()` 系统调用，允许对已存在的映射进行扩展或收缩。

```c
#define _GNU_SOURCE
#include <sys/mman.h>

void *mremap(void *old_address, size_t old_size,
             size_t new_size, int flags, ... /* void *new_address */);
```

  * **`old_address`**: 需变更的既有映射的起始地址，必须是分页对齐的。
  * **`old_size`**: 既有映射的当前大小。
  * **`new_size`**: 映射预期的新大小。
  * **`flags`**: 一个位掩码，用于控制重映射的行为。

#### **`flags` 参数**

`flags` 参数的值可以包含以下标记：

  * **`MREMAP_MAYMOVE`**:

      * 如果指定了这个标记，那么在扩展映射时，如果当前位置之后没有足够的连续虚拟地址空间，内核可以为映射**在进程的虚拟地址空间中重新寻找一个位置**（即移动映射）。
      * 如果**没有**指定这个标记，并且在当前位置无法扩展映射，那么 `mremap()` 调用会失败并返回 `ENOMEM` 错误。

  * **`MREMAP_FIXED`** (自 Linux 2.4 起):

      * 这个标记**必须**与 `MREMAP_MAYMOVE` 一起使用。
      * 它告诉内核将映射移动到一个**指定的**新地址。此时，`mremap()` 需要第五个参数 `void *new_address`，该参数指定了一个分页对齐的新地址。所有之前在该新地址范围之内的映射将会被解除。

**返回值**:
`mremap()` 在成功时会返回映射区域的新起始地址。

> **警告**: 由于内核可能会移动映射（当指定了 `MREMAP_MAYMOVE` 时），这个返回的地址可能与 `old_address` 不同。因此，任何指向旧映射区域内部的绝对指针都可能会变得无效。使用 `mremap()` 的应用程序在引用映射区域中的地址时，应该只使用相对于起始地址的**偏移量**。

#### **主要用途 (`realloc`)**

`glibc` 中的 `realloc()` 函数会使用 `mremap()` 来高效地为那些由 `malloc()` 创建的大内存块（`malloc` 底层使用了 `mmap()`）重新指定大小。使用 `mremap()` 使得 `realloc()` 在重新分配空间的过程中，有可能**避免复制字节**，从而获得巨大的性能提升。

-----

#### **程序示例**

下面的简单程序演示了如何使用 `mremap()` 来扩展一个匿名映射。

```c
#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/mman.h>

int main() {
    long page_size = sysconf(_SC_PAGE_SIZE);
    char *addr, *new_addr;

    // 1. 创建一个 1 页大小的匿名映射
    addr = mmap(NULL, page_size, PROT_READ | PROT_WRITE,
                MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
    if (addr == MAP_FAILED) {
        perror("mmap");
        exit(EXIT_FAILURE);
    }
    printf("Mapped 1 page at address: %p\n", addr);
    
    // 写入初始数据
    strcpy(addr, "Hello from the original mapping!");
    printf("Initial content: %s\n", addr);

    // 2. 使用 mremap() 将其扩展到 2 页，允许移动
    new_addr = mremap(addr, page_size, 2 * page_size, MREMAP_MAYMOVE);
    if (new_addr == MAP_FAILED) {
        perror("mremap");
        exit(EXIT_FAILURE);
    }
    printf("Remapped to 2 pages at address: %p\n", new_addr);

    // 3. 验证旧数据仍然存在
    printf("Content after remap: %s\n", new_addr);
    
    // 4. 写入新扩展的区域
    strcat(new_addr, " And this is the new extended part.");
    printf("Content after writing to extended part: %s\n", new_addr);

    // 清理
    munmap(new_addr, 2 * page_size);

    return 0;
}
```