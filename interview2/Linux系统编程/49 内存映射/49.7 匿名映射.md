### **49.7 匿名映射**

**匿名映射 (Anonymous Mapping)** 是没有对应磁盘文件的一种内存映射，其映射区域会被初始化为 0。本节将介绍如何创建匿名映射以及私有和共享匿名映射的用途。

#### **创建匿名映射的两种方法**

在 Linux 上，使用 `mmap()` 创建匿名映射存在两种不同但等价的方法：

1.  **使用 `MAP_ANONYMOUS` 标志**:

      * 在 `mmap()` 的 `flags` 参数中指定 `MAP_ANONYMOUS`。
      * 将 `fd` 参数指定为 `-1`。
      * `offset` 参数会被忽略。

    <!-- end list -->

    ```c
    // 示例
    addr = mmap(NULL, length, PROT_READ | PROT_WRITE,
                MAP_SHARED | MAP_ANONYMOUS, -1, 0);
    ```

    > `MAP_ANONYMOUS` 源自 BSD，为保证可移植性，在使用此标志时应总是将 `fd` 设为 -1。

2.  **映射 `/dev/zero` 设备文件**:

      * `open()` 特殊设备文件 `/dev/zero`。
      * 将 `open()` 返回的文件描述符传递给 `mmap()`。
      * `offset` 参数同样会被忽略。

    <!-- end list -->

    ```c
    
    // 示例
    fd = open("/dev/zero", O_RDWR);
    addr = mmap(NULL, length, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
    ```

    > 映射 `/dev/zero` 的方法源自 System V。

-----

#### **私有匿名映射 (`MAP_PRIVATE`)**

`MAP_PRIVATE` 匿名映射主要用于为进程**分配私有的、用零填充的内存块**。

  * **主要用途**: `glibc` 中的 `malloc()` 实现在分配大块内存时（默认大于 128 KB），就会使用 `MAP_PRIVATE` 匿名映射。这样做的好处是，当调用 `free()` 时，可以通过 `munmap()` 高效地将这块内存归还给系统。

<!-- end list -->

```c
// 使用 /dev/zero 技术创建私有匿名映射
fd = open("/dev/zero", O_RDWR);
addr = mmap(NULL, length, PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, 0);
```

-----

#### **共享匿名映射 (`MAP_SHARED`)**

`MAP_SHARED` 匿名映射允许**相关进程**（通常是父子进程）共享一块内存区域，而无需创建一个对应的映射文件。

  * **主要用途**: 作为一种**进程间通信 (IPC)** 的方式。
  * **工作机制**: 当一个进程创建了共享匿名映射后调用 `fork()`，子进程会继承这个映射。由于是 `MAP_SHARED`，**没有**写时复制，父子进程共享同样的物理 RAM 分页，一方对映射内容的修改会对另一方立即可见。

<!-- end list -->

```c
// 使用 MAP_ANONYMOUS 技术创建共享匿名映射
addr = mmap(NULL, length, PROT_READ | PROT_WRITE,
            MAP_SHARED | MAP_ANONYMOUS, -1, 0);
```

-----

#### **程序示例**

程序清单 49-3 演示了如何使用共享匿名映射在父进程和子进程之间共享一个整数。

**程序清单 49-3：在父进程和子进程之间共享一个匿名映射**

```c
#include <stdio.h>
#include <stdlib.hh>
#include <unistd.h>
#include <sys/mman.h>
#include <sys/wait.h>
#include <fcntl.h>

int main(int argc, char *argv[]) {
    int *addr; // 指向共享整数的指针

#ifdef USE_MAP_ANON // 通过编译选项选择创建方式
    // 方法一：使用 MAP_ANONYMOUS 标志
    addr = mmap(NULL, sizeof(int), PROT_READ | PROT_WRITE,
                MAP_SHARED | MAP_ANONYMOUS, -1, 0);
    if (addr == MAP_FAILED) {
        perror("mmap anon");
        exit(EXIT_FAILURE);
    }
#else
    // 方法二：映射 /dev/zero 文件
    int fd = open("/dev/zero", O_RDWR);
    if (fd == -1) {
        perror("open /dev/zero");
        exit(EXIT_FAILURE);
    }
    addr = mmap(NULL, sizeof(int), PROT_READ | PROT_WRITE,
                MAP_SHARED, fd, 0);
    if (addr == MAP_FAILED) {
        perror("mmap /dev/zero");
        exit(EXIT_FAILURE);
    }
    if (close(fd) == -1) {
        perror("close");
    }
#endif

    *addr = 1; // 父进程将共享整数初始化为 1

    switch (fork()) {
        case -1:
            perror("fork");
            exit(EXIT_FAILURE);
        case 0: // 子进程
            printf("Child started, value = %d\n", *addr);
            (*addr)++; // 子进程递增共享整数
            printf("Child finished, value = %d\n", *addr);
            _exit(EXIT_SUCCESS);
        default: // 父进程
            if (wait(NULL) == -1) {
                perror("wait");
                exit(EXIT_FAILURE);
            }
            printf("Parent sees final value = %d\n", *addr);
            
            // 解除映射
            if (munmap(addr, sizeof(int)) == -1) {
                perror("munmap");
            }
            exit(EXIT_SUCCESS);
    }
}
```

##### **编译和运行**

```bash
# 编译 (默认使用 /dev/zero)
$ gcc anon_mmap_share.c -o anon_mmap_share

$ ./anon_mmap_share
Child started, value = 1
Child finished, value = 2
Parent sees final value = 2

# 编译 (使用 MAP_ANONYMOUS)
$ gcc -DUSE_MAP_ANON anon_mmap_share.c -o anon_mmap_share_anon

$ ./anon_mmap_share_anon
Child started, value = 1
Child finished, value = 2
Parent sees final value = 2
```

无论采用哪种方式，父子进程都成功地共享了同一块内存，子进程的修改对父进程可见。