### **49.1 概述**

`mmap()` 系统调用在调用进程的虚拟地址空间中创建一个新的内存映射。映射主要可以从两个维度来划分：

**1. 映射类型 (文件映射 vs. 匿名映射)**

* **文件映射 (File Mapping)**: 将一个文件的某个部分直接映射到调用进程的虚拟内存中。一旦映射完成，进程就可以通过操作内存中的字节来直接读写文件内容，无需再调用 `read()` 或 `write()`。这种映射也被称为**内存映射文件 (memory-mapped file)**。
* **匿名映射 (Anonymous Mapping)**: 这种映射没有对应的文件。映射的内存区域会被初始化为 0。

**2. 映射可见性 (私有映射 vs. 共享映射)**

当多个进程（例如，通过 `fork()` 或多个进程映射同一个文件）的页表条目指向同一块物理内存分页时，可见性决定了一个进程对内存的修改是否对其他进程可见。

* **私有映射 (`MAP_PRIVATE`)**: 进程对映射内容的修改**对其他进程不可见**。对于文件映射，这些修改也**不会**被写回到原始文件中。内核通过**写时复制 (copy-on-write)** 技术来实现这一点：当一个进程试图修改一个共享的物理分页时，内核会先为该进程创建一个该分页的私有副本，然后让该进程的修改发生在这个副本上。
* **共享映射 (`MAP_SHARED`)**: 进程对映射内容的修改**对所有共享同一个映射的其他进程都可见**。对于文件映射，这些修改将会被**写回到原始文件**中。

---

#### **四种映射组合及其用途**

将上述两个维度组合起来，就得到了四种不同类型的内存映射。

**表 49-1：各种内存映射的用途**

|          | **私有 (`MAP_PRIVATE`)**    | **共享 (`MAP_SHARED`)**  |
| :------- | :------------------------ | :--------------------- |
| **文件映射** | 根据文件内容初始化内存               | 内存映射 I/O；进程间共享内存 (IPC) |
| **匿名映射** | 分配新内存 (例如 `malloc` 的底层实现) | 相关进程间的共享内存 (IPC)       |

下面是这四种组合的详细说明：

* **私有文件映射 (`MAP_PRIVATE` + 文件)**
    * **用途**: 使用一个文件的内容来初始化一块内存区域。最常见的例子是加载器根据可执行文件或共享库文件的内容来初始化进程的代码段和数据段。
    * **行为**: 多个进程映射同一个文件时，初始时共享同样的物理内存分页，但任何一方的修改都会触发“写时复制”，之后修改便对彼此不可见。

* **私有匿名映射 (`MAP_PRIVATE` + 匿名)**
    * **用途**: 为进程分配新的、用零填充的内存。`malloc()` 在分配大块内存时通常会使用这种方式。
    * **行为**: 每次调用 `mmap()` 都会产生一个全新的、不与任何其他映射共享的内存区域。`fork()` 之后，父子进程间的修改同样遵循“写时复制”原则，彼此不可见。

* **共享文件映射 (`MAP_SHARED` + 文件)**
    * **用途1 (内存映射 I/O)**: 作为 `read()` 和 `write()` 的替代方案。程序可以直接读写内存，内核会自动将变更同步到底层文件中。
    * **用途2 (IPC)**: 允许**无关**的进程通过映射同一个文件来共享一块内存，实现快速的进程间通信，功能上类似于 System V 共享内存。

* **共享匿名映射 (`MAP_SHARED` + 匿名)**
    * **用途 (IPC)**: 用于**相关**进程（通常是父子进程）间的共享内存。
    * **行为**: 当一个进程 `fork()` 时，子进程会继承这个映射。由于没有“写时复制”，父进程和子进程共享同样的物理 RAM 分页，一方对映射内容的修改对另一方**立即可见**。

---

##### **其他特性**
* **继承与销毁**: 映射关系在 `fork()` 时被子进程继承，但在 `exec()` 时会全部丢失。
* **查看映射**: 可以通过读取 Linux 特有的 `/proc/PID/maps` 文件来查看一个进程的所有内存映射。
* **与 POSIX 共享内存的关系**: `mmap()` 也是与 POSIX 共享内存对象（第 54 章）配合使用的核心函数，它允许无关进程在不创建关联磁盘文件的情况下共享一块内存。