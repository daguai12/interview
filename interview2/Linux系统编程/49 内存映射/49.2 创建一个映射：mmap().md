
# 49.2 创建一个映射：mmap()

`mmap()` 系统调用会在调用进程的虚拟地址空间中创建一个新的映射区域。

---

## 1. 基本行为

* **返回值**

  * 成功：返回新映射的起始虚拟地址
  * 失败：返回 `MAP_FAILED`（Linux 上是 `(void*)-1`，标准规定了这个常量）

* **地址选择**

  * `addr = NULL` → 由内核选择合适地址（推荐做法）
  * `addr ≠ NULL` → 内核将 `addr` 作为提示，最终仍可能调整位置
  * 如果指定了 `MAP_FIXED`，则 `addr` 必须是 **分页对齐**，内核严格使用它（可能覆盖已有映射）

---

## 2. 参数解析

### (1) `length`

* 映射的字节数
* 不必是页面大小的整数倍，但内核会 **向上取整** 到最近的页面边界

### (2) `prot`（保护标志，位掩码）

* `PROT_NONE` → 区域无法访问
* `PROT_READ` → 可读
* `PROT_WRITE` → 可写
* `PROT_EXEC` → 可执行

> 注意：不同硬件/系统实现会有差异，比如老式 x86-32 上 `PROT_READ` 可能隐含 `PROT_EXEC`。现代内核（带 NX 支持）则能严格区分。

### (3) `flags`（映射类型及选项）

* **必须包含下列之一**：

  * `MAP_PRIVATE` → 私有映射（修改对其他进程不可见，文件不变）
  * `MAP_SHARED` → 共享映射（修改会反映到底层文件，对其他映射可见）
* 还可以 OR 其他标志（后面章节介绍，如 `MAP_ANONYMOUS`、`MAP_FIXED` 等）

### (4) `fd` 与 `offset`

* 用于 **文件映射**
* `fd`：文件描述符
* `offset`：映射的文件偏移，必须是页面大小的倍数
* 映射整个文件 → `offset=0`，`length=文件大小`
* 匿名映射（`MAP_ANONYMOUS`）时忽略这两个参数

---

## 3. 内存保护机制

* 如果访问权限超出 `prot` 限制，内核会给进程发送 `SIGSEGV`（有的实现可能用 `SIGBUS`）。
* `PROT_NONE` 常用于做 **守护页**（guard page），防止越界访问。
* 保护信息是进程私有的，不同进程映射同一段物理内存时可拥有不同的 `prot` 设置。
* `mprotect()` 系统调用可动态修改映射区域的保护位。

---

## 4. 标准中的对齐约束

* SUSv3 要求：

  * `offset` 必须是页面大小的倍数
  * 如果指定了 `MAP_FIXED`，则 `addr` 也必须对齐
* SUSv4 放宽：

  * 允许实现自己决定是否要求对齐
  * 如果 `MAP_FIXED` 且 `addr≠0`，则 `addr` 和 `offset` 的对齐余数必须相等

---

## 5. 示例程序（简化版 cat）

一个使用 `mmap()` 将整个文件映射进内存，然后写到标准输出的程序：

```c
#include <sys/mman.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>

int main(int argc, char *argv[]) {
    int fd;
    struct stat sb;
    char *addr;

    fd = open(argv[1], O_RDONLY);
    fstat(fd, &sb);

    addr = mmap(NULL, sb.st_size, PROT_READ, MAP_PRIVATE, fd, 0);

    write(STDOUT_FILENO, addr, sb.st_size);

    munmap(addr, sb.st_size);
    close(fd);
    return 0;
}
```

这个程序相当于一个精简版的 `cat` 命令：

* 打开文件
* 获取大小
* 使用 `mmap()` 映射整个文件
* 把内容直接写到标准输出

---

要不要我接下来帮你把 **`mmap()` 和 `read/write` 的性能差异对比** 也解释一下？这样你会更清楚 mmap 在实际使用中的意义。
