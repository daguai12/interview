### **49.10 MAP\_FIXED 标记**

在 `mmap()` 的 `flags` 参数中指定 `MAP_FIXED` 标记会**强制**内核在 `addr` 参数指定的地址处创建映射，而不是将 `addr` 仅仅作为一种提示信息。

  * **要求**: 如果指定了 `MAP_FIXED`，那么 `addr` **必须**是分页对齐的。
  * **行为**: 如果 `MAP_FIXED` 请求的内存区域 (`addr` 到 `addr + length`) 与之前的某个既有映射重叠了，那么重叠的分页会被丢弃，并由新映射替代。

#### **可移植性警告与常规用法**

一般来讲，一个可移植的应用程序**不应该**使用 `MAP_FIXED`。推荐的做法是将 `addr` 参数指定为 `NULL`，这样就允许内核自己选择一个合适的、空闲的地址来放置映射。

这样做的原因与 System V 共享内存中推荐将 `shmat()` 的 `shmaddr` 参数设为 `NULL` 的原因是一样的：它避免了因硬编码地址而导致的程序在不同系统或不同运行环境下因地址空间布局变化而失败的问题。

#### **一个可移植的 `MAP_FIXED` 用例**

然而，存在一种特殊情况，可以巧妙且可移植地使用 `MAP_FIXED`。这个技巧用于将一个或多个文件的不同部分，映射到一块**连续的**内存区域中。

该过程分两步完成：

1.  **预留连续的虚拟地址空间**:

      * 首先，使用 `mmap()` 创建一个足够大的**匿名映射**。在这次调用中，将 `addr` 指定为 `NULL` 并且**不**指定 `MAP_FIXED`。
      * 这就让内核为我们寻找并预留了一块连续的、可用的虚拟地址空间。

2.  **用文件映射覆盖**:

      * 接着，进行一次或多次 `mmap()` 调用来映射文件。
      * 在这些后续的调用中，**指定 `MAP_FIXED` 标志**，并将 `addr` 参数设置为第一步中预留的匿名映射区域内的某个地址。
      * 这样，每次调用都会将匿名映射的一部分“挖掉”，并用一个具体的文件映射来“填充”。

**为什么这种做法是可移植的？** 因为第一步让内核为我们选择了地址，我们没有硬编码任何地址，只是在内核为我们分配好的空间内进行操作。

**代码片段示例**:

```c
// 伪代码演示
char *base_addr;
int fd1, fd2;
off_t offset1 = ...;
off_t offset2 = ...;

// 1. 预留 2 页的连续虚拟地址空间
base_addr = mmap(NULL, 2 * PAGE_SIZE, PROT_NONE,
                 MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
if (base_addr == MAP_FAILED) { /* handle error */ }

// 2. 将文件1的一部分映射到第一页
mmap(base_addr, PAGE_SIZE, PROT_READ,
     MAP_SHARED | MAP_FIXED, fd1, offset1);

// 3. 将文件2的一部分映射到第二页
mmap(base_addr + PAGE_SIZE, PAGE_SIZE, PROT_READ,
     MAP_SHARED | MAP_FIXED, fd2, offset2);
```

> **`remap_file_pages()`**: 从 Linux 2.6 开始，`remap_file_pages()` 系统调用（下一节介绍）也能够取得类似的效果，但使用 `MAP_FIXED` 的两步式做法可移植性更强，因为 `remap_file_pages()` 是 Linux 特有的。