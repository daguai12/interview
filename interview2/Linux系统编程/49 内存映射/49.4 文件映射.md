### **49.4 文件映射**

要创建一个文件映射，需要执行以下步骤：

1.  获取文件的一个描述符，通常通过调用 `open()` 来完成。
2.  将该文件描述符作为 `fd` 参数传入 `mmap()` 调用。

执行上述步骤之后，`mmap()` 会将打开的文件的内容映射到调用进程的地址空间中。一旦 `mmap()` 调用成功，就可以关闭文件描述符，而不会对映射产生任何影响。

> 除了普通的磁盘文件，使用 `mmap()` 还能够映射各种真实和虚拟设备的内容，如硬盘、光盘以及 `/dev/mem`。

#### **参数详解**

  * **`fd` 与权限**:
    在 `open()` 文件时，必须具备与 `mmap()` 的 `prot` 和 `flags` 参数值相匹配的权限。特别地：

      * 文件**必须**被打开以允许读取（即 `O_RDONLY` 或 `O_RDWR`）。
      * 如果在 `mmap()` 中指定了 `PROT_WRITE` 和 `MAP_SHARED`（即希望修改能写回文件），那么文件**必须**以读写模式 (`O_RDWR`) 打开。

  * **`offset` 和 `length`**:

      * **`offset`**: 指定了从文件的哪个字节开始映射。这个值**必须是系统分页大小的倍数**。将 `offset` 指定为 0 会导致从文件的起始位置开始映射。
      * **`length`**: 指定了映射的字节数。
        这两个参数共同确定了文件的哪个区域会被映射进内存。

**文件映射示意图 (对应原文图 49-1):**

![[Pasted image 20250917103658.png]]

#### **数据加载机制 (按需分页)**

在 Linux 上，一个文件映射的分页并不会在 `mmap()` 调用时立即被加载进内存。相反，内核采用的是**按需分页 (paging on demand)** 或称**惰性加载 (lazy loading)** 的方式。

这意味着，只有当进程**首次访问**映射区域中的某个内存地址时，才会触发一个**缺页中断 (page fault)**。此时，内核才会从磁盘文件中读取相应的数据页，并将其加载到物理内存（RAM）中。

> **注意**: 这种行为是依赖于具体实现的。如果底层文件在 `mmap()` 调用之后、但在相应分页被首次访问之前被修改，那么进程可能会看到修改后的新内容。可移植的应用程序应该避免依赖于这种不确定的行为。


#### **49.4.1 私有文件映射**

私有文件映射 (`MAP_PRIVATE`) 最常见的两个用途如下所述。

1.  **共享程序和库的文本段 (代码段)**
    * **用途**: 允许多个执行同一个程序或使用同一个共享库的进程，共享同样的物理内存分页来存放只读的程序代码。
    * **实现**: 这些代码段是从底层可执行文件或库文件的相应部分，以私有文件映射的方式映射而来的。
    * **为何使用 `MAP_PRIVATE`**: 尽管代码段通常是只读的，但仍然使用 `MAP_PRIVATE` 而不是 `MAP_SHARED`。这是因为调试器（例如，为了设置断点）或自修改程序可能会修改程序代码。使用 `MAP_PRIVATE` 可以确保这些变更通过“写时复制”机制被限制在单个进程内，而**不会**影响到底层文件或其他正在运行该程序的进程。

2.  **初始化数据段**
    * **用途**: 映射一个可执行文件或共享库的已初始化数据段（即全局和静态变量）。
    * **实现**: 这种映射被处理成私有的，以确保一个进程对全局变量内容的变更**不会**发生在底层文件上，也不会影响到其他进程。

这两个用途通常对应用程序员是透明的，因为这些映射是由程序加载器和动态链接器在程序启动时自动创建的。

**另一个不太常见的用途是简化程序的文件输入逻辑**。程序可以私有地映射一个文件，然后直接从内存中读取其内容。这与使用共享文件映射进行内存映射 I/O 类似，但由于是私有映射，任何对内存的修改都不会写回文件，因此只适用于文件输入。

#### **49.4.2 共享文件映射**

当多个进程创建同一个文件区域的**共享映射 (`MAP_SHARED`)** 时，它们会共享同样的内存物理分页。此外，对映射内容的变更将会反映到底层文件上。实际上，这个文件被当成了该块内存区域的分页存储（backing store）。

**共享映射关系示意图 (对应原文图 49-2):**

![[Pasted image 20250917104558.png]]

共享文件映射存在两个主要的用途：内存映射 I/O 和进程间通信 (IPC)。

##### **内存映射 I/O**

通过内存映射 I/O，程序可以通过直接访问内存中的字节来执行文件 I/O，而无需调用 `read()` 和 `write()`。内核会自动确保对内存的变更会被传递到映射的文件中。

**潜在优势**:

  * **简化逻辑**: 使用内存访问来取代 `read()` 和 `write()` 系统调用能够简化一些应用程序的逻辑。
  * **提升性能**:
    1.  **减少数据拷贝**: `read()`/`write()` 需要在“文件-内核缓冲区”和“内核缓冲区-用户空间缓冲区”之间进行两次数据传输。使用 `mmap()`，用户进程直接访问内核的页面高速缓存，省去了第二次传输。
    2.  **节省内存**: 使用 `mmap()` 时，内核空间和用户空间共享同一个缓冲区。如果多个进程映射同一个文件，它们可以共享同一份内核缓冲区，从而节省内存消耗。

**适用场景与缺点**:

  * **最有效场景**: ==在大型文件中执行**重复的随机访问**时，性能优势最有可能体现出来。
  * **效果有限场景**: 如果是顺序访问文件，并且 `read()`/`write()` 使用了足够大的缓冲区，那么 `mmap()` 带来的性能提升非常有限。
  * **缺点**: 对于小数据量 I/O，`mmap()` 的开销（映射、缺页中断、解除映射等）实际上可能比简单的 `read()`/`write()` 更大。

##### **使用共享文件映射的 IPC**

由于所有映射同一文件区域的进程共享同样的内存物理分页，因此共享文件映射是作为一种**快速的 IPC 方法**。

与 System V 或 POSIX 共享内存不同的是，共享区域中内容的变更会反映到底层映射文件上。这个**持久化**的特性对那些需要在应用程序或系统重启时能够保留共享内存内容的应用程序来讲非常有用。

-----

#### **程序示例**

程序清单 49-2 演示了如何使用 `mmap()` 创建一个共享文件映射，并向其中写入数据。

**程序清单 49-2：使用 `mmap()` 创建一个共享文件映射**

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/stat.h>

int main(int argc, char *argv[]) {
    char *addr;
    int fd;
    struct stat sb;

    if (argc < 2 || strcmp(argv[1], "--help") == 0) {
        fprintf(stderr, "Usage: %s file [string]\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    // 1. 以读写模式打开文件
    fd = open(argv[1], O_RDWR);
    if (fd == -1) {
        perror("open");
        exit(EXIT_FAILURE);
    }
    
    // 2. 获取文件大小
    if (fstat(fd, &sb) == -1) {
        perror("fstat");
        exit(EXIT_FAILURE);
    }

    // 3. 将文件映射到内存
    addr = mmap(NULL, sb.st_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
    if (addr == MAP_FAILED) {
        perror("mmap");
        exit(EXIT_FAILURE);
    }
    
    // 4. mmap 成功后即可关闭文件描述符
    if (close(fd) == -1) {
        perror("close");
        exit(EXIT_FAILURE);
    }
    
    // 打印当前映射区域的内容
    printf("Current string: %s\n", addr);

    // 5. 如果提供了第二个参数，则将其写入映射区域
    if (argc > 2) {
        printf("Copying new string: '%s'\n", argv[2]);
        if (strlen(argv[2]) >= sb.st_size) {
            fprintf(stderr, "String is too large for the file\n");
            exit(EXIT_FAILURE);

        }
        memset(addr, 0, sb.st_size); // 先清空
        strcpy(addr, argv[2]);

        // 将变更同步到磁盘文件
        if (msync(addr, sb.st_size, MS_SYNC) == -1) {
            perror("msync");
        }
    }
    
    exit(EXIT_SUCCESS);
}
```

##### **编译和运行演示**

1.  **编译程序**: `gcc mmap_shared_file.c -o mmap_demo`

2.  **创建一个 1024 字节的空文件**:

    ```bash
    $ dd if=/dev/zero of=testfile bs=1024 count=1
    ```

3.  **第一次运行，写入一个字符串**:

    ```bash
    $ ./mmap_demo testfile "Hello"
    Current string: 
    Copying new string: 'Hello'
    ```

    > **解读**: 第一次运行时，文件内容全是 0，所以 `printf` 打印出一个空字符串。然后程序将 "Hello" 写入内存。

4.  **第二次运行，写入另一个字符串**:

    ```bash
    $ ./mmap_demo testfile "World"
    Current string: Hello
    Copying new string: 'World'
    ```

    > **解读**: 第二次运行时，程序首先读取并打印出了上一次写入的 "Hello"。然后程序将其覆盖为 "World"。

5.  **最后验证文件内容**:

    ```bash
    $ od -c testfile | head -n 1
    0000000   W   o   r   l   d  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0
    ```

    > **解读**: 文件的内容确实被修改为了 "World"。

> **关于同步**:
> 这个简单的程序没有使用任何机制来同步多个进程对映射文件的访问。现实世界中的应用程序通常需要使用**信号量**或**文件锁**来协调对共享映射的访问。

#### **49.4.3 边界情况**

在很多情况下，一个映射的大小是系统分页大小的整数倍，并且映射会完全落入映射文件的范围之内。但这不是必需的，下面来看一下当这些条件不满足时会发生什么事情。

##### **场景一：映射长度不是分页大小的整数倍 (但在文件范围内)**

  * **规则**: 内核总是以**整页**为单位来处理内存映射。因此，如果 `mmap()` 中指定的 `length` 不是系统分页大小的整数倍，那么映射到进程虚拟地址空间的区域会被**向上舍入 (rounded up)** 到系统分页大小的下一个整数倍。

**示意图 (对应原文图 49-3):**

![[Pasted image 20250917110102.png]]

  * 假设分页大小为 4096 字节，文件大小为 10000 字节。
  * 程序请求映射 2200 字节 (`length=2200`)。
  * 内核实际会为进程分配一个 **4096 字节**的虚拟内存区域。
  * 这个 4096 字节区域的内容会由文件的前 4096 字节来填充。
  * 进程可以合法地访问从偏移量 0 到 4095 的所有字节。
  * 试图访问映射区域之外的字节（即偏移量 4096 及以后）将会导致 **`SIGSEGV`** 信号的产生。

-----

##### **场景二：映射区域超出文件末尾**

当映射区域延伸超过了底层文件的末尾时，情况就变得更加复杂了。

  * **规则**: 映射区域仍然会被向上舍入到分页大小的整数倍，但访问不同部分的内存会产生不同的结果。

**示意图 (对应原文图 49-4):**
![[Pasted image 20250917110323.png]]


  * 假设分页大小为 4096 字节，文件大小为 2000 字节。
  * 程序请求映射 2200 字节 (`length=2200`)。
  * 内核同样会为进程分配一个 **4096 字节**的虚拟内存区域。

此时，访问这个 4096 字节的内存区域，行为如下：

1.  **访问 0-1999 字节**: 这部分区域由文件内容支持。读操作会返回文件的内容，写操作（对于 `MAP_SHARED`）会被写回文件。
2.  **访问 2000-4095 字节**: 这部分区域超出了文件末尾，但在第一个内存页内。
      * 访问是**合法**的。
      * 这部分内存会被初始化为 **0**。
      * 对这部分内存的任何修改都**不会**被写回到文件中，并且对于其他映射该文件的进程是不可见的（即这部分是私有的）。
3.  **访问 4096 字节及以后**: 试图访问一个完全超出文件末尾的内存分页。
      * 这会导致 **`SIGBUS`** 信号的产生。这个信号警告进程，它试图访问一个由文件支持的映射区域，但在底层文件中没有与之对应的部分。

> **用途**: 创建一个大小超过底层文件大小的映射，在需要扩展文件时会变得很有用。通过调用 `ftruncate()` 或 `write()` 扩展文件后，可以使得映射中之前不可访问的部分（会导致 `SIGBUS` 的部分）变得可用。

#### **49.4.4 内存保护和文件访问模式交互**

通过 `mmap()` 的 `prot` 参数指定的内存保护，与映射文件被 `open()` 打开的模式之间存在着交互关系。

**一般原则**:
* 请求 **`PROT_READ`** 或 **`PROT_EXEC`** 保护，要求被映射的文件以 `O_RDONLY` 或 `O_RDWR` 打开。
* 请求 **`PROT_WRITE`** 保护，要求被映射的文件以 `O_WRONLY` 或 `O_RDWR` 打开。

然而，由于一些硬件架构提供的内存保护粒度有限（例如，在某些架构上，可写的内存页也必定是可读的，即 `PROT_WRITE` 隐含了 `PROT_READ`），情况会变得更加复杂。

---
##### **具体规则**
以下是 `open()` 模式与 `mmap()` 参数组合的兼容性规则总结：

* **当文件以 `O_RDWR` 打开时**:
    * **兼容所有**内存保护组合。这是最灵活的打开方式，因为文件本身既可读又可写，满足了所有 `prot` 标志的要求。

* **当文件以 `O_WRONLY` 打开时**:
    * **不兼容任何**内存保护组合。`mmap()` 调用会失败并返回 `EACCES` 错误。
    * **原因**: 因为 `PROT_WRITE` 在底层可能隐含了 `PROT_READ`，而 `O_WRONLY` 模式禁止读取文件内容，两者产生了冲突。

* **当文件以 `O_RDONLY` 打开时**:
    * **`MAP_PRIVATE` (私有映射)**:
        * **兼容所有**内存保护组合，**包括 `PROT_WRITE`**。
        * **原因**: 因为是私有映射，任何对内存的写入操作都只会发生在“写时复制”的内存副本上，**不会**被写回到原始的只读文件中，因此不会违反文件的只读权限。
    * **`MAP_SHARED` (共享映射)**:
        * **只兼容** `PROT_READ` 和 `PROT_READ | PROT_EXEC`。
        * **不兼容**任何包含 `PROT_WRITE` 的组合。
        * **原因**: 因为是共享映射，任何 `PROT_WRITE` 的写入操作都需要同步回底层文件，但这与文件的 `O_RDONLY` 打开模式产生了直接冲突。

##### **兼容性总结表**

| `open()` 模式 | `mmap()` 标志   | 允许的 `prot` 组合              | 结果              |
| :---------- | :------------ | :------------------------- | :-------------- |
| `O_RDWR`    | (任意)          | 所有组合 (r, w, x)             | **成功**          |
| `O_WRONLY`  | (任意)          | (无)                        | **失败 (EACCES)** |
| `O_RDONLY`  | `MAP_PRIVATE` | 所有组合 (r, w, x)             | **成功**          |
| `O_RDONLY`  | `MAP_SHARED`  | 仅 `PROT_READ`, `PROT_EXEC` | **成功**          |
| `O_RDONLY`  | `MAP_SHARED`  | 包含 `PROT_WRITE`            | **失败 (EACCES)** |


# 案例

### 案例目标

我们将创建一个小程序来完成以下操作：

1.  创建一个非常小的初始文件（例如，只包含字符串 "Start."）。
2.  使用 `mmap()` 创建一个远大于该文件大小的内存映射（例如，映射 8KB 的空间）。
3.  **尝试访问**超出文件初始大小、但在第一个内存页内的内存，这应该是合法的。
4.  **尝试访问**一个完全超出文件初始大小的内存分页，这将导致内核发送 **`SIGBUS`** 信号，我们会捕获这个信号。
5.  在捕获信号后，我们使用 `ftruncate()` **扩展**底层文件的大小。
6.  **再次尝试访问**之前导致 `SIGBUS` 错误的同一块内存地址，这次访问将会**成功**。

### 完整代码: `mmap_extend_demo.c`

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <signal.h>

#define FILENAME "test.map"
#define INITIAL_CONTENT "Start."

// 用于从信号处理器向 main 函数通信的全局标志
static volatile sig_atomic_t sigbus_caught = 0;

// SIGBUS 信号处理器
static void sigbus_handler(int sig) {
    sigbus_caught = 1;
}

int main(int argc, char *argv[]) {
    int fd;
    char *addr;
    long page_size;
    
    page_size = sysconf(_SC_PAGE_SIZE);
    if (page_size == -1) {
        perror("sysconf");
        exit(EXIT_FAILURE);
    }
    
    // 准备信号处理器以捕获 SIGBUS
    struct sigaction sa;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;
    sa.sa_handler = sigbus_handler;
    if (sigaction(SIGBUS, &sa, NULL) == -1) {
        perror("sigaction");
        exit(EXIT_FAILURE);
    }

    // 1. 创建一个小的初始文件
    fd = open(FILENAME, O_RDWR | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR);
    if (fd == -1) {
        perror("open");
        exit(EXIT_FAILURE);
    }
    if (write(fd, INITIAL_CONTENT, strlen(INITIAL_CONTENT)) != strlen(INITIAL_CONTENT)) {
        fprintf(stderr, "Partial/failed write to file\n");
        exit(EXIT_FAILURE);
    }
    printf("1. Initial file created. Size: %ld bytes.\n", (long)strlen(INITIAL_CONTENT));

    // 2. 创建一个远大于文件大小的映射 (映射 2 个内存页)
    size_t map_size = 2 * page_size;
    addr = mmap(NULL, map_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
    if (addr == MAP_FAILED) {
        perror("mmap");
        exit(EXIT_FAILURE);
    }
    printf("2. Memory mapped for %ld bytes, which is larger than the file.\n\n", (long)map_size);

    // 3. 尝试访问一个完全超出文件范围的内存页
    printf("3. Attempting to access memory at offset %ld (which has no backing file yet)...\n", page_size);
    addr[page_size] = 'X'; // 尝试写入

    if (sigbus_caught) {
        printf("   >> SUCCESS: As expected, kernel sent SIGBUS signal!\n\n");
    } else {
        printf("   >> FAILED: Expected a SIGBUS signal but didn't get one.\n\n");
    }

    // 4. 使用 ftruncate() 扩展文件
    printf("4. Extending the file to %ld bytes using ftruncate()...\n", map_size);
    if (ftruncate(fd, map_size) == -1) {
        perror("ftruncate");
        exit(EXIT_FAILURE);
    }
    printf("   >> File extended successfully.\n\n");

    // 5. 再次尝试访问之前导致错误的同一块内存
    printf("5. Attempting to access the same memory at offset %ld AGAIN...\n", page_size);
    sigbus_caught = 0; // 重置标志
    addr[page_size] = 'Y'; // 再次尝试写入

    if (sigbus_caught) {
        printf("   >> FAILED: Got a SIGBUS signal even after extending the file.\n");
    } else {
        printf("   >> SUCCESS: Memory access is now valid! Wrote '%c' to that location.\n", addr[page_size]);
    }
    
    // 清理
    munmap(addr, map_size);
    close(fd);
    unlink(FILENAME);

    exit(EXIT_SUCCESS);
}
```

### 如何编译和运行

```bash
$ gcc mmap_extend_demo.c -o mmap_extend_demo
$ ./mmap_extend_demo
```

### 预期输出与解读

```
1. Initial file created. Size: 6 bytes.
2. Memory mapped for 8192 bytes, which is larger than the file.

3. Attempting to access memory at offset 4096 (which has no backing file yet)...
   >> SUCCESS: As expected, kernel sent SIGBUS signal!

4. Extending the file to 8192 bytes using ftruncate()...
   >> File extended successfully.

5. Attempting to access the same memory at offset 4096 AGAIN...
   >> SUCCESS: Memory access is now valid! Wrote 'Y' to that location.
```

**解读**:

  * **第3步**: 当程序第一次尝试写入 `addr[4096]` 时，这个内存地址属于映射区域，但它对应的文件部分（偏移量4096之后）在物理磁盘上**尚不存在**。因此，内核无法为这个内存访问找到对应的文件页，从而向进程发送了一个 `SIGBUS` 信号。
  * **第4步**: `ftruncate()` 调用在磁盘上将文件“拉长”到了 8192 字节，用空字节填充了新的空间。
  * **第5步**: 当程序第二次尝试写入 `addr[4096]` 时，内核发现这个地址现在**已经有了对应的文件部分**。因此，它正常处理缺页中断，将文件的新部分加载到内存，允许写入操作成功。

这个例子清晰地展示了 `mmap` 的一种强大用途：可以预先为可能增长的文件（如日志文件、数据库文件）保留一块大的虚拟地址空间，然后在文件实际增长后，这块预留的地址空间就自动变得可用，而无需重新进行 `munmap` 和 `mmap` 操作。