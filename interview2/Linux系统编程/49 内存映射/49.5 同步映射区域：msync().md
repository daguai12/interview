### **49.5 同步映射区域：msync()**

内核会自动将发生在 `MAP_SHARED` 映射内容上的变更写入到底层文件中，但在默认情况下，内核**不保证**这种同步操作会在何时发生。

`msync()` 系统调用让应用程序能够显式地控制何时完成共享映射与映射文件之间的同步。这在多种情况下都非常有用，例如：

  * 数据库应用程序为确保数据完整性，可能会调用 `msync()` 强制将事务日志写入到磁盘上。
  * 确保一个进程通过内存映射所做的更新，能对另一个使用 `read()` 读取该文件的进程可见。

<!-- end list -->

```c
#include <sys/mman.h>

int msync(void *addr, size_t length, int flags);
```

  * **`addr`**: 待同步内存区域的起始地址，必须是分页对齐的。
  * **`length`**: 待同步区域的大小（字节数）。
  * **`flags`**: 一个位掩码，由以下值中的一个，与一个可选值进行“或”运算组成。

#### **`flags` 参数**

##### **同步模式 (必须指定以下两者之一)**

  * **`MS_SYNC` (同步)**:

      * 执行一个**同步的**文件写入。
      * 这个调用会**阻塞**，直到内存区域中所有被修改过的分页都被实际写入到底层磁盘为止。

  * **`MS_ASYNC` (异步)**:

      * 执行一个**异步的**文件写入。
      * 调用会安排被修改过的分页在未来某个时刻被写入磁盘，然后**立即返回**。

> 另一种区分方式是：`MS_SYNC` 操作之后，内存区域与**磁盘**同步；而 `MS_ASYNC` 操作之后，内存区域仅仅是与**内核的高速缓冲区**同步，实际写入磁盘的操作由内核稍后完成。

##### **可选标志**

  * **`MS_INVALIDATE`**:
      * 使映射数据的缓存副本失效。
      * 当内存区域中所有被修改过的分页被同步到文件中之后，内存区域中所有与底层文件不一致的分页会被标记为无效。
      * 当下次引用这些分页时，会从文件的相应位置处重新加载内容。
      * **用途**: 使得由**其他进程**对文件做出的更新（例如，通过 `write()` 系统调用）能够在当前进程的内存映射区域中变得可见。

#### **统一虚拟内存系统与可移植性**

  * **Linux 的实现**: 与很多其他现代 UNIX 实现一样，Linux 提供了一个所谓的**统一虚拟内存系统 (Unified Virtual Memory System)**。这意味着内存映射和内核的 I/O 高速缓冲区会尽可能地共享同样的物理内存分页。
  * **在 Linux 上的效果**: 由于内存视图是统一的，通过 `mmap()` 修改的内容对使用 `read()` 的进程是立即可见的，反之亦然。因此，在 Linux 上，`msync()` 的唯一用途就是**强制将一个映射区域中的内容实际写入到磁盘**。
  * **可移植性警告**: SUSv3 并**没有**要求实现统一虚拟 memory 系统。在不具备该特性的系统上，应用程序**必须**恰当使用 `msync()`：
      * 使用 `MS_SYNC` 或 `MS_ASYNC` 来使得 `mmap` 的变更对 `read()` 可见。
      * 使用 `MS_INVALIDATE` 来使得 `write()` 的变更对 `mmap` 可见。