### **53.2 命名信号量**

要使用命名信号量，必须使用下列函数：

  * **`sem_open()`**: 打开或创建一个信号量并返回一个句柄。如果创建了新信号量，还会对其进行初始化。
  * **`sem_post()`** 和 **`sem_wait()`**: 分别递增（释放）和递减（等待）一个信号量的值。
  * **`sem_getvalue()`**: 获取一个信号量的当前值。
  * **`sem_close()`**: 关闭调用进程与它之前打开的一个信号量之间的关联关系。
  * **`sem_unlink()`**: 删除一个信号量的名称，并将其标记为在所有进程都关闭该信号量时再实际删除该信号量。

#### **在 Linux 上的实现**

SUSv3 并没有规定如何实现命名信号量。在 Linux 上：

  * 命名信号量被实现为 `/dev/shm` 目录下的一个特殊文件，其名字的形式为 `sem.name`。
  * `/dev/shm` 是一个 `tmpfs` 文件系统，具备**内核持久性**。这意味着信号量对象将会持久存在，即使当前没有进程打开它们；但如果系统被关闭，这些对象就会丢失。
  * Linux 从内核 2.6 起开始支持命名信号量。

-----

#### **53.2.1 打开一个命名信号量**

`sem_open()` 函数创建和打开一个新的命名信号量，或打开一个已存在的信号量。

```c
#include <semaphore.h>
#include <fcntl.h>           /* For O_* constants */
#include <sys/stat.h>        /* For mode constants */

sem_t *sem_open(const char *name, int oflag,
                mode_t mode, unsigned int value);
```

  * **`name`**: 标识信号量的名称。它必须以一个斜杠 (`/`) 开头，且不能包含其他斜杠（例如 `/mysem`）。
  * **`oflag`**: 一个位掩码，用于控制操作。
      * 如果为 `0`，则打开一个已存在的信号量。
      * 如果包含 `O_CREAT`，则当信号量不存在时创建一个新的。
      * 如果同时包含 `O_CREAT` 和 `O_EXCL`，则当信号量已存在时调用会失败。
  * **`mode`** (仅在指定 `O_CREAT` 时): 一个位掩码，指定新信号量的权限。该值会受到进程 `umask` 的影响。
  * **`value`** (仅在指定 `O_CREAT` 时): 一个无符号整数，指定新信号量的**初始值**。信号量的创建和初始化是**原子操作**，这比 System V 信号量的初始化要简单得多。
  * **返回值**:
      * 成功时，返回一个指向 `sem_t` 类型的指针，该指针是后续操作中使用的信号量句柄。
      * 发生错误时，返回 `SEM_FAILED`。

> 子进程会通过 `fork()` 继承其父进程打开的所有命名信号量的引用。

-----

#### **程序示例**

程序清单 53-1 为 `sem_open()` 函数提供了一个命令行界面。

**程序清单 53-1：使用 `sem_open()` 打开或创建一个 POSIX 命名信号量**

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <semaphore.h>
#include <fcntl.h>
#include <sys/stat.h>

static void usageError(const char *progName) {
    fprintf(stderr, "Usage: %s [-cx] [-v value] sem-name\n", progName);
    fprintf(stderr, "    -c           Create semaphore (O_CREAT)\n");
    fprintf(stderr, "    -x           Create exclusively (O_EXCL)\n");
    fprintf(stderr, "    -v value     Set initial value\n");
    exit(EXIT_FAILURE);
}

int main(int argc, char *argv[]) {
    int flags, opt;
    mode_t perms;
    unsigned int value;
    sem_t *sem;

    flags = 0;
    value = 0; // 默认初始值为 0

    while ((opt = getopt(argc, argv, "cxv:")) != -1) {
        switch (opt) {
        case 'c': flags |= O_CREAT; break;
        case 'x': flags |= O_EXCL; break;
        case 'v': value = atoi(optarg); break;
        default:  usageError(argv[0]);
        }
    }

    if (optind >= argc)
        usageError(argv[0]);
    
    // 默认权限为所有用户可读写
    perms = S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH; // 0666

    // 如果创建新信号量，则调用四参数版本
    if (flags & O_CREAT) {
        sem = sem_open(argv[optind], flags, perms, value);
    } else { // 否则，调用两参数版本
        sem = sem_open(argv[optind], 0);
    }
    
    if (sem == SEM_FAILED) {
        perror("sem_open");
        exit(EXIT_FAILURE);
    }

    printf("Semaphore opened successfully. Pointer: %p\n", sem);
    
    exit(EXIT_SUCCESS);
}
```

##### **编译和运行演示**

1.  **编译程序 (需要链接 `-lpthread`)**:

    ```bash
    $ gcc sem_create.c -o sem_create -lpthread
    ```

2.  **运行演示**:

    ```bash
    # 首先，设置 umask，屏蔽掉 "other" 用户的写权限
    $ umask 022

    # 以独占方式创建一个名为 /mysem 的信号量，初始值为 1
    $ ./sem_create -cx -v 1 /mysem
    Semaphore opened successfully. Pointer: 0x...

    # 查看 /dev/shm 目录下的信号量文件及其权限
    $ ls -l /dev/shm/sem.mysem
    -rw-r--r-- 1 daguai daguai 32 Sep 15 14:00 /dev/shm/sem.mysem
    ```

    > **解读**: 尽管我们在程序中指定的权限是 `0666` (`-rw-rw-rw-`)，但由于 `umask` 设置为 `022`，最终创建的信号量文件的权限是 `0644` (`-rw-r--r--`)，"other" 用户的写权限被成功屏蔽。

3.  **再次尝试以独占方式创建同名信号量，将会失败**:

    ```bash
    $ ./sem_create -cx -v 1 /mysem
    sem_open: File exists
    ```

#### **53.2.2 关闭一个信号量**

`sem_close()` 函数会终止调用进程与一个已打开的命名信号量之间的关联关系。

```c
#include <semaphore.h>

int sem_close(sem_t *sem);
```

  * **作用**:
      * 释放系统为该进程关联到该信号量之上的所有资源。
      * 将内核中对该信号量对象的**引用计数**减一。
  * **自动关闭**: 进程打开的所有命名信号量会在进程终止或执行 `exec()` 时被自动关闭。
  * **与删除的区别**: 关闭一个信号量**并不会**从系统中删除这个信号量。要删除信号量，需要使用 `sem_unlink()`。

#### **53.2.3 删除一个命名信号量**

`sem_unlink()` 函数从系统中删除一个命名信号量的**名称**。

```c
#include <semaphore.h>

int sem_unlink(const char *name);
```

  * **作用**:
      * 该函数会立即删除信号量的名称，使得后续的 `sem_open()` 调用无法再通过这个名称找到该信号量。
      * 同时，内核会将该信号量**标记为“待删除”**。
      * 只有当所有之前打开过该信号量的进程都通过 `sem_close()` 关闭了它（即引用计数降为 0 时），该信号量对象才会被真正地销毁。

这个机制与文件系统中的 `unlink()` 非常相似。

-----

##### **程序示例**

程序清单 53-2 演示了如何使用 `sem_unlink()`。

**程序清单 53-2：使用 `sem_unlink()` 来断开一个 POSIX 命名信号量的链接**

```c
#include <stdio.h>
#include <stdlib.h>
#include <semaphore.h>

int main(int argc, char *argv[]) {
    if (argc != 2 || strcmp(argv[1], "--help") == 0) {
        fprintf(stderr, "Usage: %s sem-name\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    // 调用 sem_unlink() 删除信号量名称
    if (sem_unlink(argv[1]) == -1) {
        perror("sem_unlink");
        exit(EXIT_FAILURE);
    }

    printf("Semaphore %s unlinked.\n", argv[1]);
    
    exit(EXIT_SUCCESS);
}
```

##### **编译和运行演示**

1.  **编译程序 (需要链接 `-lpthread`)**:
    ```bash
    $ gcc sem_unlink.c -o sem_unlink -lpthread
    ```
2.  **先用上一节的 `sem_create` 程序创建一个信号量**:
    ```bash
    $ ./sem_create -c /mysem
    Semaphore opened successfully. Pointer: 0x...
    $ ls /dev/shm
    sem.mysem
    ```
3.  **运行程序删除该信号量**:
    ```bash
    $ ./sem_unlink /mysem
    Semaphore /mysem unlinked.
    ```
4.  **再次查看 `/dev/shm` 目录，确认文件已被删除**:
    ```bash
    $ ls /dev/shm
    # (sem.mysem 文件已不存在)
    ```