### **53.3 信号量操作**

一个 POSIX 信号量是一个整数，并且系统不允许其值小于 0。其操作与 System V 信号量不同，具体包括：

  * POSIX 信号量的函数 `sem_post()` 和 `sem_wait()` 一次只操作**一个**信号量；而 System V 的 `semop()` 能够原子地操作一个集合中的多个信号量。
  * `sem_post()` 和 `sem_wait()` 只对信号量值**加 1** 和**减 1**；而 `semop()` 能够加减任意值。
  * System V 信号量提供了一个“等待信号量变为 0”的操作，而 POSIX 信号量没有。

尽管 POSIX 信号量的 API 看起来功能较少，但通过它仍然可以完成 System V 信号量能完成的所有工作，并且对于大多数应用场景，其编程模型要简单得多。

-----

#### **53.3.1 等待一个信号量**

`sem_wait()` 函数、`sem_trywait()` 函数和 `sem_timedwait()` 函数都用于递减（等待或锁定）一个信号量。

##### **`sem_wait()` (阻塞式等待)**

`sem_wait()` 函数会尝试将 `sem` 引用的信号量的值减 1。

```c
#include <semaphore.h>

int sem_wait(sem_t *sem);
```

  * **行为**:
      * 如果信号量的当前值**大于 0**，那么 `sem_wait()` 会立即将其值减 1 并返回。
      * 如果信号量的当前值**等于 0**，那么 `sem_wait()` 会**阻塞**，直到有其他进程或线程调用 `sem_post()` 使信号量的值大于 0 为止。一旦可以减 1，函数就会返回。
  * **信号中断**: 如果一个阻塞的 `sem_wait()` 调用被信号处理器中断，它会失败并返回 `EINTR` 错误（即使信号处理器设置了 `SA_RESTART` 标志）。

**程序清单 53-3：使用 `sem_wait()` 来递减一个 POSIX 信号量**

```c
#include <stdio.h>
#include <stdlib.h>
#include <semaphore.h>
#include <fcntl.h>

int main(int argc, char *argv[]) {
    sem_t *sem;

    if (argc != 2 || strcmp(argv[1], "--help") == 0) {
        fprintf(stderr, "Usage: %s sem-name\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    // 打开一个已存在的命名信号量
    sem = sem_open(argv[1], 0);
    if (sem == SEM_FAILED) {
        perror("sem_open");
        exit(EXIT_FAILURE);
    }

    // 调用 sem_wait()
    if (sem_wait(sem) == -1) {
        perror("sem_wait");
        exit(EXIT_FAILURE);
    }

    printf("PID %ld has successfully decremented semaphore %s\n", (long) getpid(), argv[1]);
    
    // sem_close(sem); // 实际应用中应关闭信号量
    exit(EXIT_SUCCESS);
}
```

> **编译**: `gcc sem_wait.c -o sem_wait -lpthread`

##### **`sem_trywait()` (非阻塞式等待)**

`sem_trywait()` 函数是 `sem_wait()` 的一个非阻塞版本。

```c
#include <semaphore.h>

int sem_trywait(sem_t *sem);
```

  * **行为**: 如果递减操作无法立即被执行（即信号量的值为 0），那么 `sem_trywait()` **不会阻塞**，而是会立即失败并返回 `EAGAIN` 错误。

##### **`sem_timedwait()` (带超时的等待)**

`sem_timedwait()` 函数是 `sem_wait()` 的另一个变体，它允许为阻塞操作设置一个超时上限。

```c
#include <semaphore.h>
#include <time.h>

int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout);
```

  * **`abs_timeout`**: 一个 `timespec` 结构，它将超时时间表示成一个**绝对时间值**（自 1970 年 1 月 1 日以来的秒数和纳秒数）。
  * **行为**: 如果在 `abs_timeout` 指定的时间到达之前，信号量的值都无法被递减，那么这个调用就会失败并返回 `ETIMEDOUT` 错误。

#### **53.3.2 发布一个信号量**

`sem_post()` 函数递增（增加 1）`sem` 引用的信号量的值。

```c
#include <semaphore.h>

int sem_post(sem_t *sem);
```

  * **行为**: `sem_post()` 是一个原子操作。如果调用该函数之前信号量的值为 0，并且有其他某个进程（或线程）正在 `sem_wait()` 中阻塞以等待该信号量，那么 `sem_post()` 会唤醒那个等待的进程。
  * **唤醒顺序**:
      * 对于采用**普通调度策略**的进程，当多个进程都在等待同一个信号量时，哪个进程会被唤醒是**不确定**的。
      * 对于采用**实时调度策略**的进程，SUSv3 规定，优先级最高、等待时间最长的进程将会被唤醒。

`sem_post()` 通常对应于“释放”一个共享资源。

##### **程序示例**

程序清单 53-4 为 `sem_post()` 函数提供了一个命令行界面。

**程序清单 53-4：使用 `sem_post()` 递增一个 POSIX 信号量**

```c
#include <stdio.h>
#include <stdlib.h>
#include <semaphore.h>
#include <fcntl.h>

int main(int argc, char *argv[]) {
    sem_t *sem;

    if (argc != 2 || strcmp(argv[1], "--help") == 0) {
        fprintf(stderr, "Usage: %s sem-name\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    // 打开一个已存在的命名信号量
    sem = sem_open(argv[1], 0);
    if (sem == SEM_FAILED) {
        perror("sem_open");
        exit(EXIT_FAILURE);
    }

    // 调用 sem_post()
    if (sem_post(sem) == -1) {
        perror("sem_post");
        exit(EXIT_FAILURE);
    }

    printf("PID %ld has successfully incremented semaphore %s\n", (long) getpid(), argv[1]);
    
    exit(EXIT_SUCCESS);
}
```

> **编译**: `gcc sem_post.c -o sem_post -lpthread`

-----

#### **53.3.3 获取信号量的当前值**

`sem_getvalue()` 函数将 `sem` 引用的信号量的当前值通过 `sval` 指向的 `int` 变量返回。

```c
#include <semaphore.h>

int sem_getvalue(sem_t *sem, int *sval);
```

  * **返回值 `sval` 的行为**:
      * 如果当前没有进程阻塞在该信号量上，`sval` 将返回信号量的当前值（一个大于等于 0 的整数）。
      * 如果有一个或多个进程正在 `sem_wait()` 中阻塞，那么 `sval` 中的返回值将**取决于实现**：
          * **在 Linux 上**: 返回 **0**。
          * **在其他一些实现上**: 可能返回一个**负数**，其绝对值等于正在等待的进程数目。
  * **竞争条件**: `sem_getvalue()` 返回的值可能在函数返回的瞬间就已经过时了，因为其他进程可能已经改变了信号量的值。因此，**不应**基于 `sem_getvalue()` 的返回值来做同步决策，这会导致“检查时-使用时 (time-of-check, time-of-use)”的竞争条件。

##### **程序示例**

程序清单 53-5 使用了 `sem_getvalue()` 来获取一个命名信号量的值。

**程序清单 53-5：使用 `sem_getvalue()` 获取一个 POSIX 信号量的值**

```c
#include <stdio.h>
#include <stdlib.h>
#include <semaphore.h>
#include <fcntl.h>

int main(int argc, char *argv[]) {
    sem_t *sem;
    int value;

    if (argc != 2 || strcmp(argv[1], "--help") == 0) {
        fprintf(stderr, "Usage: %s sem-name\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    // 打开一个已存在的命名信号量
    sem = sem_open(argv[1], 0);
    if (sem == SEM_FAILED) {
        perror("sem_open");
        exit(EXIT_FAILURE);
    }

    // 调用 sem_getvalue()
    if (sem_getvalue(sem, &value) == -1) {
        perror("sem_getvalue");
        exit(EXIT_FAILURE);
    }

    printf("Value of semaphore %s is %d\n", argv[1], value);
    
    exit(EXIT_SUCCESS);
}
```

> **编译**: `gcc sem_getvalue.c -o sem_getvalue -lpthread`

-----

#### **综合演示**

下面的 shell 会话日志演示了如何结合使用本章到目前为止给出的各个程序。

```bash
# 1. 创建一个名为 /mysem 的信号量，初始值为 0
$ ./sem_create -cx -v 0 /mysem
Semaphore opened successfully. Pointer: 0x...

# 2. 在后台启动一个进程等待该信号量，它会立即阻塞
$ ./sem_wait /mysem &
[1] 12345

# 3. 获取信号量的值 (在 Linux 上，即使有进程在等待，值也显示为 0)
$ ./sem_getvalue /mysem
Value of semaphore /mysem is 0

# 4. 发布(递增)信号量，这将唤醒后台的 sem_wait 进程
$ ./sem_post /mysem
PID 12346 has successfully incremented semaphore /mysem
PID 12345 has successfully decremented semaphore /mysem  <-- 后台进程的输出

# 5. 按下回车，shell 会报告后台作业已完成
$
[1]+  Done                    ./sem_wait /mysem

# 6. 再次检查信号量的值，它现在又变回了 0 (因为被后台进程消耗了)
$ ./sem_getvalue /mysem
Value of semaphore /mysem is 0

# 7. 清理信号量
$ ./sem_unlink /mysem
Semaphore /mysem unlinked.
```