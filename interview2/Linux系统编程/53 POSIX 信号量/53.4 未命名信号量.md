### **53.4 未命名信号量**

**未命名信号量 (Unnamed Semaphores)**，也被称为**基于内存的信号量**，是类型为 `sem_t` 并存储在由应用程序分配的内存中的变量。通过将这个信号量放在由几个进程或线程共享的内存区域中，就能够使这个信号量对这些进程或线程可用。

操作未命名信号量除了使用与命名信号量相同的函数（`sem_wait()`, `sem_post()` 等）外，还需要用到另外两个专有函数：

  * **`sem_init()`**: 对一个未命名信号量进行初始化。
  * **`sem_destroy()`**: 销毁一个未命名信号量。

#### **未命名与命名信号量对比**

使用未命名信号量无需为信号量在文件系统中创建一个名称，这种做法在下列情况中非常有用：

  * **线程间共享**: 信号量只需要作为一个共享的全局变量或堆变量，即可自动对同一进程的所有线程可见。
  * **相关进程间共享**: 如果一个父进程在一块共享内存区域中分配了一个未命名信号量，那么通过 `fork()` 创建的子进程会自动继承这个映射，从而也继承了这个信号量。
  * **动态数据结构**: 当需要为一个动态数据结构（如链表、二叉树）的每个节点都关联一个信号量时，在节点结构体中直接内嵌一个未命名信号量，远比为每个节点去管理一个唯一的命名信号量要简单得多。

-----

#### **53.4.1 初始化一个未命名信号量**

`sem_init()` 函数使用 `value` 中指定的值来对 `sem` 指向的未命名信号量进行初始化。

```c
#include <semaphore.h>

int sem_init(sem_t *sem, int pshared, unsigned int value);
```

  * **`sem`**: 指向要初始化的 `sem_t` 变量的指针。
  * **`value`**: 信号量的初始值。
  * **`pshared`**: 一个关键参数，表明这个信号量的共享范围：
      * **`pshared == 0`**: 信号量将在调用进程的**线程间**共享。在这种情况下，`sem` 通常被指定为一个全局变量或在堆上分配的变量的地址。
      * **`pshared != 0`**: 信号量将在**进程间**共享。在这种情况下，`sem` **必须**被放置在一个共享内存区域中（例如，POSIX 共享内存对象或 `mmap()` 创建的共享映射）。

> **权限**: 未命名信号量没有相关的权限设置。对一个未命名信号量的访问将由进程在底层共享内存区域上的权限来控制。
> **重复初始化**: 对一个已初始化过的未命名信号量再次进行初始化操作，将会导致未定义的行为。

-----

#### **程序示例**

程序清单 53-6 使用一个未命名的、线程间共享的信号量来解决两个线程访问同一个全局变量时产生的竞争条件问题。

**程序清单 53-6：使用一个 POSIX 未命名信号量来保护对全局变量的访问**

```c
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <semaphore.h>

static int glob = 0;
static sem_t sem; // 声明一个未命名信号量

// 线程函数
static void *threadFunc(void *arg) {
    int loops = *((int *) arg);

    for (int j = 0; j < loops; j++) {
        // 等待信号量 (P操作 / lock)
        if (sem_wait(&sem) == -1) {
            perror("sem_wait");
            exit(EXIT_FAILURE);
        }

        // --- 临界区开始 ---
        int loc = glob;
        loc++;
        glob = loc;
        // --- 临界区结束 ---

        // 发布信号量 (V操作 / unlock)
        if (sem_post(&sem) == -1) {
            perror("sem_post");
            exit(EXIT_FAILURE);
        }
    }
    
    return NULL;
}

int main(int argc, char *argv[]) {
    pthread_t t1, t2;
    int loops = (argc > 1) ? atoi(argv[1]) : 10000000;

    // 初始化信号量
    // pshared = 0: 线程间共享
    // value = 1: 初始值为1，使其作为互斥锁 (mutex) 使用
    if (sem_init(&sem, 0, 1) == -1) {
        perror("sem_init");
        exit(EXIT_FAILURE);
    }
    
    // 创建两个线程
    if (pthread_create(&t1, NULL, threadFunc, &loops) != 0) {
        perror("pthread_create 1");
        exit(EXIT_FAILURE);
    }
    if (pthread_create(&t2, NULL, threadFunc, &loops) != 0) {
        perror("pthread_create 2");
        exit(EXIT_FAILURE);
    }
    
    // 等待两个线程结束
    if (pthread_join(t1, NULL) != 0) {
        perror("pthread_join 1");
        exit(EXIT_FAILURE);
    }
    if (pthread_join(t2, NULL) != 0) {
        perror("pthread_join 2");
        exit(EXIT_FAILURE);
    }
    
    printf("glob = %d\n", glob);

    // 销毁信号量
    if (sem_destroy(&sem) == -1) {
        perror("sem_destroy");
        exit(EXIT_FAILURE);
    }

    exit(EXIT_SUCCESS);
}
```

##### **编译和运行**

```bash
# 编译程序 (需要链接 -lpthread)
$ gcc unnamed_sem_threads.c -o unnamed_sem_threads -lpthread

# 运行程序
$ ./unnamed_sem_threads
glob = 20000000
```

程序的输出结果是正确的 `2 * loops`，证明了信号量成功地保护了临界区，避免了竞争条件。