### **35.4 CPU 亲和力**

在多处理器系统上，当一个进程被重新调度时，它不一定会在上一次执行的 CPU 上运行。这种进程在 CPU 之间的切换会对性能产生一定影响，因为原 CPU 高速缓存中的进程数据需要失效，并重新加载到新 CPU 的高速缓存中，这个过程会消耗时间。

  * **软 CPU 亲和力 (Soft CPU affinity)**: 这是 Linux 内核的默认行为。调度器会**尝试**将进程重新调度到它上次运行的 CPU 上，以提高缓存命中率，但这并非强制。
  * **硬 CPU 亲和力 (Hard CPU affinity)**: 允许**显式地**将一个进程或线程绑定到一个或一组特定的 CPU 上运行。

设置硬 CPU 亲和力的主要原因如下：

  * 避免因进程在 CPU 间切换而导致的缓存失效所带来的性能影响。
  * 如果多个线程（或进程）访问同样的数据，将它们限制在同一个 CPU 上可能会带来性能提升。
  * 对于时间关键的应用程序，可以为其预留一个或多个 CPU，同时将系统中其他大多数进程限制在别的 CPU 上运行。

> **内核参数**:
> 可以通过 `isolcpus` 内核启动参数来将一个或多个 CPU 从常规的内核调度算法中完全分离出来，这些 CPU 只能通过 CPU 亲和力系统调用来分配。

#### **CPU 亲和力系统调用**

Linux 2.6 提供了一对非标准的系统调用来修改和获取进程的硬 CPU 亲和力：`sched_setaffinity()` 和 `sched_getaffinity()`。

##### **`sched_setaffinity()`**: 设置 CPU 亲和力

```c
#define _GNU_SOURCE
#include <sched.h>

int sched_setaffinity(pid_t pid, size_t len, const cpu_set_t *set);
```

  * **`pid`**: 目标进程的 ID。如果为 0，则表示调用线程自身。
  * **`set`**: 一个指向 `cpu_set_t` 结构的指针，该结构是一个位掩码，指定了允许进程运行的 CPU 集合。
  * **`len`**: `set` 结构体的大小，通常为 `sizeof(cpu_set_t)`。

`cpu_set_t` 结构体应被视为一个不透明的结构，必须使用以下宏来操作它：

  * **`CPU_ZERO(cpu_set_t *set)`**: 将 `set` 初始化为空集合。
  * **`CPU_SET(int cpu, cpu_set_t *set)`**: 将 CPU `cpu` 添加到 `set` 中。
  * **`CPU_CLR(int cpu, cpu_set_t *set)`**: 从 `set` 中删除 CPU `cpu`。
  * **`CPU_ISSET(int cpu, cpu_set_t *set)`**: 检查 CPU `cpu` 是否是 `set` 的成员。

下面的代码片段演示了如何将一个进程限制在除第一个 CPU（CPU 0）之外的其他 CPU 上运行：

```c
cpu_set_t set;
int num_cpus = sysconf(_SC_NPROCESSORS_CONF);

CPU_ZERO(&set);
for (int i = 1; i < num_cpus; i++) {
    CPU_SET(i, &set);
}
sched_setaffinity(pid, sizeof(set), &set);
```

**权限**:

  * **特权进程 (`CAP_SYS_NICE`)**: 可以设置任意进程的 CPU 亲和力。
  * **非特权进程**: 只能设置其有效用户 ID 与目标进程的真实或有效用户 ID 相匹配的进程的 CPU 亲和力。

##### **`sched_getaffinity()`**: 获取 CPU 亲和力

```c
#define _GNU_SOURCE
#include <sched.h>

int sched_getaffinity(pid_t pid, size_t len, cpu_set_t *set);
```

该函数获取 `pid` 指定进程的当前 CPU 亲和力掩码，并将其存放在 `set` 指向的结构中。

  * **权限**: **不需要**特殊权限。非特权进程能够获取系统上所有进程的 CPU 亲和力掩码。
  * **继承**: 子进程会通过 `fork()` 继承其父进程的 CPU 亲和力掩码，并且该掩码在 `exec()` 调用之间会得以保留。

-----

#### **程序示例**

下面的程序演示了如何获取当前进程的 CPU 亲和力，然后将其修改为只在 CPU 0 上运行，并最后验证修改是否成功。

```c
#define _GNU_SOURCE
#include <sched.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main(int argc, char *argv[]) {
    cpu_set_t set;
    int num_cpus = sysconf(_SC_NPROCESSORS_ONLN); // 获取在线的 CPU 数量

    // --- 1. 获取并打印当前 CPU 亲和力 ---
    if (sched_getaffinity(0, sizeof(set), &set) == -1) {
        perror("sched_getaffinity");
        exit(EXIT_FAILURE);
    }
    printf("Current CPU affinity mask: ");
    for (int i = 0; i < num_cpus; i++) {
        if (CPU_ISSET(i, &set)) {
            printf("%d ", i);
        }
    }
    printf("\n");

    // --- 2. 设置新的亲和力，只允许在 CPU 0 上运行 ---
    CPU_ZERO(&set);    // 清空集合
    CPU_SET(0, &set);  // 只加入 CPU 0
    
    if (sched_setaffinity(0, sizeof(set), &set) == -1) {
        perror("sched_setaffinity");
        exit(EXIT_FAILURE);
    }
    printf("Set CPU affinity mask to CPU 0\n");

    // --- 3. 再次获取并打印，以验证修改 ---
    if (sched_getaffinity(0, sizeof(set), &set) == -1) {
        perror("sched_getaffinity");
        exit(EXIT_FAILURE);
    }
    printf("New CPU affinity mask: ");
    for (int i = 0; i < num_cpus; i++) {
        if (CPU_ISSET(i, &set)) {
            printf("%d ", i);
        }
    }
    printf("\n");
    
    // 让程序运行一会，以便在 top 或 htop 中观察
    // sleep(10);

    exit(EXIT_SUCCESS);
}
```