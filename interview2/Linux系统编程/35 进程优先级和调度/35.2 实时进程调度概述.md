好的，这是根据您提供的文本内容，保留原始结构和标题整理的结果。

### **35.2 实时进程调度概述**

标准的循环时间共享调度算法虽然能满足一般交互式和后台进程的需求，但**实时应用 (real-time application)** 对调度器有更严格的要求：

* **有保障的响应时间**: 必须在可担保的最大时间内响应外部输入，这个时间通常非常短。
* **高优先级抢占**: 高优先级进程必须能快速取得 CPU 控制权，抢占当前运行的所有低优先级进程。
* **独占式访问**: 高优先级进程应该能够持续独占 CPU，直到它完成任务或自愿放弃 CPU。
* **精确的控制**: 实时应用应该能够精确地控制其内部各进程的调度顺序。

#### **POSIX 实时调度 API**

为满足这些要求，SUSv3 规定了实时进程调度 API，它提供了两种实时调度策略，以及一种标准的非实时策略：

1.  **`SCHED_FIFO` (First-In, First-Out)**: 实时先进先出策略。
2.  **`SCHED_RR` (Round-Robin)**: 实时循环调度策略。
3.  **`SCHED_OTHER`**: 标准的循环时间共享策略。

**优先级层次**:
使用 `SCHED_FIFO` 或 `SCHED_RR` 策略的进程，其优先级**总是高于**使用 `SCHED_OTHER` 策略的进程。

**实时优先级范围**:
* SUSv3 要求至少提供 32 个离散的实时优先级。
* 在 Linux 上，提供了 **99 个**实时优先级，数值范围从 **1 (最低) 到 99 (最高)**。
* 这个 1-99 的范围同时适用于 `SCHED_RR` 和 `SCHED_FIFO` 策略。一个优先级为 50 的 `SCHED_RR` 进程和一个优先级为 50 的 `SCHED_FIFO` 进程处于同一优先级队列中。
* 内核总是从优先级最高的非空队列的队头选择下一个要运行的进程。

##### **多处理器系统上的注意事项**

“高优先级进程总是优先于低优先级进程”的规则在多处理器系统上有一个重要的例外。这是因为在多处理器系统中，**每个 CPU 都有自己独立的运行队列**。

* **场景**: 假设一个双核系统中，CPU 0 正在运行一个优先级为 30 的进程 B，而一个优先级为 20 的进程 A 正在 CPU 0 的队列中等待。此时，即使 CPU 1 正在运行一个优先级仅为 10 的进程 C，等待中的进程 A **仍然需要等待 CPU 0**，而不会被自动迁移到空闲的 CPU 1 上。
* **解决方案**: 实时应用可以使用 **CPU 亲和力 (CPU affinity)** API（见 35.4 节）来将关键进程绑定到特定的 CPU，以避免这种调度行为可能引起的问题。

#### **POSIX 实时与硬实时对比**

* **硬实时 (Hard Real-time)**: 指应用程序必须**绝对满足**其所有时间期限，任何延迟都可能导致灾难性后果。
* **软实时 (Soft Real-time)**: 指应用程序允许偶尔错过时间期限，虽然这会降低服务质量，但不会导致系统完全失败。

标准的 **POSIX 实时进程调度 API** 提供的仅仅是**软实时**支持。它允许应用程序控制调度哪个进程使用 CPU，但它本身无法提供机制来确保处理输入的响应时间（例如，它无法阻止由缺页中断或设备中断引起的不可预测的延迟）。

> **Linux 内核的演变**:
> 传统的 UNIX 内核（包括早期的 Linux）为了不给普通的时间共享应用增加额外开销，并未提供对硬实时的原生支持。但从 Linux 2.6.18 版本开始，各种特性（如 PREEMPT_RT 补丁集）被逐渐添加到内核中，使得 Linux 能够为硬实时应用程序提供完全的原生支持。



#### **35.2.1 SCHED_RR 策略**

在 `SCHED_RR` (Round-Robin, 循环) 策略中，**优先级相同**的进程以循环时间共享的方式执行，每个进程每次使用 CPU 的时间为一个固定长度的**时间片 (time slice)**。

一旦被调度执行，一个 `SCHED_RR` 进程会保持对 CPU 的控制，直到发生以下情况之一：
* **时间片用完**: 进程被移动到其优先级队列的**队尾**。
* **自愿放弃 CPU**: 进程因执行阻塞式系统调用或调用 `sched_yield()` 而放弃 CPU，它会被移动到其优先级队列的**队尾**。
* **进程终止**。
* **被更高优先级的进程抢占**: 当更高优先级的进程执行结束后，这个被抢占的进程会继续执行其**剩余**的时间片（即它仍然位于其优先级队列的**队头**）。

##### **与 `SCHED_OTHER` 的对比**
`SCHED_RR` 策略与标准的 `SCHED_OTHER` 策略（基于 `nice` 值）相似，因为它们都允许同优先级的进程共享 CPU。但它们之间有两点重要区别：
1.  **严格的优先级**: `SCHED_RR` 存在严格的优先级级别，高优先级的进程**总是**优先于低优先级的进程。而在 `SCHED_OTHER` 中，`nice` 值仅作为一个权重，低优先级的进程仍然能获得一些 CPU 时间。
2.  **精确的控制**: `SCHED_RR` 策略允许程序员精确控制进程被调度的顺序。

#### **35.2.2 SCHED_FIFO 策略**

`SCHED_FIFO` (First-In, First-Out, 先入先出) 策略与 `SCHED_RR` 策略非常相似，但有一个最主要的差别：**在 `SCHED_FIFO` 策略中不存在时间片**。

一旦一个 `SCHED_FIFO` 进程获得了 CPU 的控制权，它就会一直执行（即“运行到完成”），直到发生以下情况之一：
* **自愿放弃 CPU**: 进程被移动到其优先级队列的**队尾**。
* **进程终止**。
* **被更高优先级的进程抢占**: 当更高优先级的进程结束后，这个被抢占的进程会继续执行（即它仍然位于其优先级队列的**队头**）。

> 这意味着，一个 CPU 密集型的 `SCHED_FIFO` 进程会**独占** CPU，使所有**同优先级以及更低优先级**的实时进程都无法得到执行机会，直到它自己放弃 CPU 为止。

#### **35.2.3 SCHED_BATCH 和 SCHED_IDLE 策略**

Linux 内核还添加了两个非标准的调度策略，尽管它们通过 POSIX 实时调度 API 来设置，但实际上它们**不是**实时策略。

* **`SCHED_BATCH`**:
    * 在内核 2.6.16 中加入。
    * 与 `SCHED_OTHER` 类似，但它会惩罚那些频繁被唤醒的任务，使它们被调度的次数较少。
    * **用途**: 适用于非交互式的、CPU 密集型的**批处理式 (batch-style)** 任务，以避免它们干扰到交互式进程。

* **`SCHED_IDLE`**:
    * 在内核 2.6.23 中加入。
    * 也与 `SCHED_OTHER` 类似，但它提供的功能等价于一个**极低的 `nice` 值**（甚至低于 +19）。
    * **用途**: 用于运行优先级极低的任务，这些任务只应在系统中没有任何其他任务需要使用 CPU 时（即 CPU 完全空闲时）才大量使用 CPU。


