#### **35.3.1 实时优先级范围**

`sched_get_priority_min()` 和 `sched_get_priority_max()` 系统调用用于返回一个指定调度策略的有效优先级取值范围。

```c
#include <sched.h>

int sched_get_priority_min(int policy);
int sched_get_priority_max(int policy);
```

  * **`policy`**: 指定要查询的调度策略，通常是 `SCHED_RR` 或 `SCHED_FIFO`。
  * **返回值**:
      * `sched_get_priority_min()` 返回指定策略的**最小**优先级数值。
      * `sched_get_priority_max()` 返回指定策略的**最大**优先级数值。

在 **Linux** 上，这两个函数为 `SCHED_RR` 和 `SCHED_FIFO` 策略返回的范围都是 **1 到 99**。

##### **可移植性注意事项**

不同 UNIX 实现中的实时策略的取值范围是不同的。例如：

  * Solaris 8 的优先级范围是 0～59。
  * FreeBSD 6.1 的优先级范围是 0～31。

因此，为了保证程序的可移植性，**不应该在应用程序中硬编码实时优先级的值**（如 `50` 或 `99`）。

正确的做法是，在程序运行时根据这两个函数的返回值来动态计算和指定优先级。例如：

  * **最低的实时优先级**应使用: `sched_get_priority_min(SCHED_FIFO)`
  * **最高的实时优先级**应使用: `sched_get_priority_max(SCHED_FIFO)`
  * **中等的实时优先级**可以计算为:
    ```c
    int min_prio = sched_get_priority_min(SCHED_FIFO);
    int max_prio = sched_get_priority_max(SCHED_FIFO);
    int mid_prio = (min_prio + max_prio) / 2;
    ```

##### **用法示例**

下面的代码片段演示了如何获取并打印出系统中 `SCHED_FIFO` 和 `SCHED_RR` 的优先级范围。

```c
#include <sched.h>
#include <stdio.h>
#include <stdlib.h>

int main() {
    int fifo_min, fifo_max, rr_min, rr_max;

    fifo_min = sched_get_priority_min(SCHED_FIFO);
    fifo_max = sched_get_priority_max(SCHED_FIFO);
    if (fifo_min == -1 || fifo_max == -1) {
        perror("sched_get_priority_min/max for FIFO");
        exit(EXIT_FAILURE);
    }

    rr_min = sched_get_priority_min(SCHED_RR);
    rr_max = sched_get_priority_max(SCHED_RR);
    if (rr_min == -1 || rr_max == -1) {
        perror("sched_get_priority_min/max for RR");
        exit(EXIT_FAILURE);
    }
    
    printf("SCHED_FIFO priority range: %d to %d\n", fifo_min, fifo_max);
    printf("SCHED_RR   priority range: %d to %d\n", rr_min, rr_max);

    return 0;
}
```

在 Linux 系统上运行此程序，输出将会是：

```
SCHED_FIFO priority range: 1 to 99
SCHED_RR   priority range: 1 to 99
```



#### **35.3.2 修改和获取策略和优先级**

本节将介绍用于修改和获取进程调度策略和优先级的系统调用。

##### **修改调度策略和优先级**

`sched_setscheduler()` 系统调用用于修改指定进程的调度策略和优先级。

```c
#include <sched.h>

int sched_setscheduler(pid_t pid, int policy,
                       const struct sched_param *param);
```

  * **`pid`**: 目标进程的 ID。如果为 0，则表示调用进程自身。
  * **`policy`**: 新的调度策略，其值为下表中的一个。
  * **`param`**: 指向 `sched_param` 结构的指针，该结构用于指定新策略下的参数（主要是优先级）。
    ```c
    struct sched_param {
        int sched_priority;
    };
    ```
    对于 `SCHED_RR` 和 `SCHED_FIFO`，`sched_priority` 的取值必须在 1 到 99 之间；对于其他策略，该值必须是 0。

**表 35-1：Linux 实时和非实时调度策略**
| 策略 | 描述 | SUSv3 |
| :--- | :--- | :---: |
| `SCHED_FIFO` | 实时先入先出 | ✓ |
| `SCHED_RR` | 实时循环 | ✓ |
| `SCHED_OTHER`| 标准的循环时间分享 | ✓ |
| `SCHED_BATCH`| 用于批量执行 (自 Linux 2.6.16 起) | |
| `SCHED_IDLE` | 优先级极低 (自 Linux 2.6.23 起) | |

`sched_setparam()` 系统调用只修改进程的调度参数（即优先级），而不改变其策略。

```c
int sched_setparam(pid_t pid, const struct sched_param *param);
```

**程序清单 35-2：修改进程的调度策略和优先级**

```c
#include <sched.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main(int argc, char *argv[]) {
    int policy;
    struct sched_param sp;

    if (argc < 4 || strchr("rfo", argv[1][0]) == NULL) {
        fprintf(stderr, "Usage: %s policy priority pid...\n", argv[0]);
        fprintf(stderr, "    policy is 'r' (RR), 'f' (FIFO), or 'o' (OTHER)\n");
        exit(EXIT_FAILURE);
    }

    policy = (argv[1][0] == 'r') ? SCHED_RR :
             (argv[1][0] == 'f') ? SCHED_FIFO : SCHED_OTHER;
    sp.sched_priority = atoi(argv[2]);

    for (int j = 3; j < argc; j++) {
        if (sched_setscheduler(atoi(argv[j]), policy, &sp) == -1) {
            perror("sched_setscheduler");
        }
    }

    exit(EXIT_SUCCESS);
}
```

##### **权限和资源限制**

从 Linux 内核 2.6.12 开始，非特权进程能否设置实时调度策略和优先级，取决于 `RLIMIT_RTPRIO` 资源限制：

  * **特权进程 (`CAP_SYS_NICE`)**: 可以随意修改任意进程的调度策略和优先级。
  * **非特权进程**:
      * 如果进程拥有**非零的 `RLIMIT_RTPRIO` 软限制**，那么它就能修改自己的调度策略和优先级，只要设置的实时优先级不高于其 `RLIMIT_RTPRIO` 软限制值。
      * 如果进程的 `RLIMIT_RTPRIO` 软限制值为 **0**，那么它只能降低自己的实时优先级，或从实时策略切换到非实时策略。
      * 一个非特权进程也能修改**其他**进程的策略和优先级，前提是该进程的有效用户 ID 与目标进程的真实或有效用户 ID 匹配。

##### **获取调度策略和优先级**

`sched_getscheduler()` 和 `sched_getparam()` 系统调用用于获取进程的调度策略和优先级。

```c
#include <sched.h>

int sched_getscheduler(pid_t pid);
int sched_getparam(pid_t pid, struct sched_param *param);
```

  * **`pid`**: 目标进程的 ID。如果为 0，则查询调用进程自身。
  * **权限**: 任何非特权进程都可以使用这两个调用来获取系统上任意进程的信息。
  * `sched_getscheduler()` 返回一个策略常量（如 `SCHED_FIFO`）。
  * `sched_getparam()` 通过 `param` 参数返回进程的 `sched_priority`。

**程序清单 35-3：获取进程的调度策略和优先级**

```c
#include <sched.h>
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char *argv[]) {
    int policy;
    struct sched_param sp;

    for (int j = 1; j < argc; j++) {
        policy = sched_getscheduler(atoi(argv[j]));
        if (policy == -1) {
            perror("sched_getscheduler");
            continue;
        }

        if (sched_getparam(atoi(argv[j]), &sp) == -1) {
            perror("sched_getparam");
            continue;
        }

        printf("PID %s: policy=%s, priority=%d\n", argv[j],
               (policy == SCHED_FIFO)  ? "FIFO" :
               (policy == SCHED_RR)    ? "RR" :
               (policy == SCHED_OTHER) ? "OTHER" :
               (policy == SCHED_BATCH) ? "BATCH" :
               (policy == SCHED_IDLE)  ? "IDLE" : "???",
               sp.sched_priority);
    }
    exit(EXIT_SUCCESS);
}
```

**运行演示 (需要 root 权限来设置实时策略):**

```bash
# 编译程序
$gcc sched_set.c -o sched_set$ gcc sched_get.c -o sched_get

# 在后台运行一个 sleep 进程
$ sleep 60 &
[1] 12345

# 查看其默认策略和优先级
$ ./sched_get 12345
PID 12345: policy=OTHER, priority=0

# 使用 root 权限将其策略改为 SCHED_FIFO, 优先级设为 10
$ sudo ./sched_set f 10 12345

# 再次查看，确认变更已生效
$ ./sched_get 12345
PID 12345: policy=FIFO, priority=10
```

-----

##### **防止实时进程锁住系统**

由于实时进程会抢占所有低优先级进程，一个失控的实时进程可能会导致系统被锁住。可以通过以下方法来避免：

  * **设置 CPU 时间限制**: 使用 `setrlimit()` 设置 `RLIMIT_CPU`，当进程超出 CPU 时间限制后，它会收到 `SIGXCPU` 信号（默认会杀死进程）。
  * **使用 `alarm()`**: 设置一个警报定时器，超时后 `SIGALRM` 信号会杀死进程。
  * **使用看门狗进程**: 创建一个拥有更高实时优先级的“看门狗”进程，用于监控其他实时进程的状态，并在其行为异常时采取措施。
  * **使用 `RLIMIT_RTTIME` 限制**: (自内核 2.6.25 起) 这个资源限制可以控制一个实时进程在不执行阻塞式系统调用时能够**连续**消耗的 CPU 时间。

##### **避免子进程继承特权调度策略**

从 Linux 2.6.32 开始，可以在 `sched_setscheduler()` 的 `policy` 参数中“或”上 `SCHED_RESET_ON_FORK` 标志。

  * **效果**: 如果设置了这个标志，那么由该进程 `fork()` 创建的子进程将**不会**继承特权调度策略和优先级。例如，一个 `SCHED_FIFO` 策略的父进程会创建出 `SCHED_OTHER` 策略的子进程。
  * **用途**: 用于媒体播放等需要自身实时权限、但又不希望其创建的子进程也拥有这些权限的应用程序。

#### **35.3.3 释放 CPU**

实时进程可以通过两种方式自愿释放 CPU：

1.  通过调用一个会**阻塞**进程的系统调用（例如，从终端 `read()` 数据）。
2.  调用 `sched_yield()` 系统调用。

##### **`sched_yield()`**

`sched_yield()` 的操作很简单：它将调用进程移动到其所属优先级队列的**队尾**。

```c
#include <sched.h>

int sched_yield(void);
```

  * **效果**:
      * 如果存在与调用进程**优先级相同**的其他可运行进程正在排队，那么调用 `sched_yield()` 会让队列头部的那个进程立即被调度执行。
      * 如果在该优先级队列中**不存在**其他可运行的进程，那么 `sched_yield()` **不做任何事情**，调用进程会继续使用 CPU。
  * **非实时进程**: `sched_yield()` 对非实时进程（如 `SCHED_OTHER`）的使用结果是未定义的。

#### **35.3.4 SCHED\_RR 时间片**

通过 `sched_rr_get_interval()` 系统调用，能够找出 `SCHED_RR` 策略下的进程被分配到的时间片的长度。

```c
#include <sched.h>

int sched_rr_get_interval(pid_t pid, struct timespec *tp);
```

  * **`pid`**: 标识需查询信息的进程。当 `pid` 为 0 时表示调用进程。
  * **`tp`**: 一个指向 `timespec` 结构的指针，用于返回时间片长度。
  * **典型值**: 在 Linux 2.6 及之后的内核中，实时循环调度的时间片长度通常是 **0.1 秒 (100 毫秒)**。

##### **用法示例**

下面的代码片段演示了如何获取 `SCHED_RR` 的时间片长度。

```c
#include <sched.h>
#include <stdio.h>
#include <time.h>

int main() {
    struct timespec ts;

    if (sched_rr_get_interval(0, &ts) == -1) {
        perror("sched_rr_get_interval");
        return 1;
    }

    printf("SCHED_RR time slice is: %ld seconds, %ld nanoseconds\n",
           (long)ts.tv_sec, ts.tv_nsec);

    // 在一个实时循环中，可以像这样调用 sched_yield()
    // while (some_condition) {
    //     do_some_work();
    //     sched_yield(); // 允许其他同优先级的任务运行
    // }

    return 0;
}
```