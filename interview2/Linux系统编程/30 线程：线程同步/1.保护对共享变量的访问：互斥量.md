# 30.1.1 静态分配的互斥量

### 讲解 (Explanation)

这段文字的核心是向我们介绍 Pthreads 互斥量 (mutex) 中最简单的一种创建和初始化方式：**静态分配**。我们可以把它分解成三个要点来理解。

#### 1\. 什么是“静态分配”？

  * **含义**：所谓“静态分配”，指的是互斥锁变量像一个全局变量或者 `static` 局部变量一样被声明。它的内存空间在程序编译或加载时就已经确定并分配好了，而不是在程序运行时通过 `malloc()` 这类函数动态申请的。
  * **对比**：
      * **静态 (Static)**: `pthread_mutex_t my_lock;` (在全局或函数内用 `static` 关键字声明)
      * **动态 (Dynamic)**: `pthread_mutex_t *my_lock = malloc(sizeof(pthread_mutex_t));` (在运行时分配)

这段文字的重点是前者，也就是静态方式。

#### 2\. 如何初始化静态互斥量？

  * **必须初始化**：互斥量是一个复杂的同步工具，在使用之前必须进行初始化，以确保其内部状态是正确的（例如，设置为“未锁定”状态）。
  * **初始化方法**：对于静态分配的互斥量，Pthreads 提供了一个非常方便的宏（macro）来进行初始化：`PTHREAD_MUTEX_INITIALIZER`。
  * **示例代码**：
    ```c
    #include <pthread.h>

    // 声明一个静态（这里是全局）的互斥量并使用宏进行初始化
    pthread_mutex_t my_mutex = PTHREAD_MUTEX_INITIALIZER;

    void some_function() {
        // 现在可以直接使用这个互斥量了
        pthread_mutex_lock(&my_mutex);
        // ... 临界区代码 ...
        pthread_mutex_unlock(&my_mutex);
    }
    ```
    这种方式非常简洁，它会使用默认的属性来初始化互斥量。

#### 3\. 最重要的规则：互斥量是“真身”，不可复制

这是本节内容中**最关键、最需要警惕**的一个安全准则。

  * **规则原文**：“对某一互斥量的副本（copy）执行...操作将导致未定义的结果。”

  * **通俗解释**：你不能像复制一个整数或一个字符那样去复制一个互斥量。所有对互斥量的操作（如 `pthread_mutex_lock()`, `pthread_mutex_unlock()`）都必须作用于那个**被初始化的原始变量本身**，我们称之为“真身”。

  * **为什么不能复制？**

      * 互斥量不仅仅是一个简单的变量，它是一个复杂的对象，内部包含了锁的状态、等待队列等由操作系统内核或线程库管理的底层信息。
      * 这些底层信息与互斥量变量所在的**内存地址**是紧密绑定的。
      * 如果你创建了一个副本（例如，通过值传递给一个函数），你只是复制了它在某个瞬间的表面状态。操作系统并不知道这个副本的存在。对副本进行加锁或解锁，完全不会影响到那个真正的、被所有线程共享的原始互斥量。
      * 这会彻底破坏同步机制，导致多个线程可以同时进入临界区，从而引发数据竞争、程序崩溃等各种无法预测的严重问题，这就是所谓的“未定义的结果 (undefined behavior)”。

  * **正确和错误的做法**：

    ```c
    // 错误示例：通过值传递，创建了互斥量的副本
    void bad_function(pthread_mutex_t mtx_copy) {
        // 这里的 mtx_copy 是 my_mutex 的一个副本
        // 对它加锁是未定义的行为，无法保护任何东西！
        pthread_mutex_lock(&mtx_copy); 
        // ...
        pthread_mutex_unlock(&mtx_copy);
    }

    // 正确示例：通过指针传递，操作的是互斥量的“真身”
    void good_function(pthread_mutex_t *mtx_ptr) {
        // mtx_ptr 指向 my_mutex 的原始内存地址
        // 这里的操作是安全和正确的
        pthread_mutex_lock(mtx_ptr);
        // ...
        pthread_mutex_unlock(mtx_ptr);
    }

    // 调用
    pthread_mutex_t my_mutex = PTHREAD_MUTEX_INITIALIZER;
    // bad_function(my_mutex);   // 错误！
    // good_function(&my_mutex); // 正确！
    ```

-----

### 总结 (Summary)

关于 **30.1.1 静态分配的互斥量**，我们可以总结出以下三个核心知识点：

1.  **定义与创建**：静态分配的互斥量是指在编译时就分配好内存的全局或 `static` 变量，其类型为 `pthread_mutex_t`。

2.  **初始化方式**：对于静态互斥量，必须在使用前初始化。最简单直接的方法就是使用 Pthreads 提供的宏 `PTHREAD_MUTEX_INITIALIZER` 进行赋值。

3.  **黄金法则**：互斥量**绝对不能被复制**。所有操作（加锁、解锁等）都必须通过指针作用于被初始化的原始互斥量对象（“真身”）。任何对副本的操作都会导致“未定义行为”，破坏线程同步。在函数间传递互斥量时，**必须使用指针**。
4.  **适用场景：** 当你需要保护一个与程序生命周期一样长的共享资源时（如全局变量），应优先考虑使用**静态分配的互斥量**。
5.  **定义与初始化：** 定义一个 `pthread_mutex_t` 类型的变量，并将其直接初始化为宏 `PTHREAD_MUTEX_INITIALIZER`。这是一种简单、高效的编译时初始化方法。
      * `pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;`
6.  **核心规则（铁律）：** 互斥量是一个**状态对象 (Stateful Object)**，而不是一个简单的值。绝对不能对互斥量变量本身进行复制。所有线程必须操作**同一个互斥量实例**（同一块内存地址）。
7.  **实践准则：** 在函数间传递互斥量时，**永远传递它的指针 (`pthread_mutex_t *`)**，而不是互斥量变量本身。所有的 `pthread_mutex_*` 系列函数（如 `pthread_mutex_lock`）接收的参数也都是 `pthread_mutex_t *` 类型的指针。


# 30.1.2 加锁和解锁互斥量 (Locking and Unlocking Mutexes)

#### 讲解 (Explanation)

这一节详细阐述了使用互斥量的基本操作和规则，可以理解为互斥量的“使用说明书”。

**A. 核心操作：`pthread_mutex_lock()` 与 `pthread_mutex_unlock()`**

这是最基本、最常用的两个函数。
* `pthread_mutex_lock(mutex_t *m)`：**加锁**。可以想象成进入一个会议室前，必须先从门上取下“空闲”的牌子，并挂上“使用中”的牌子。
* `pthread_mutex_unlock(mutex_t *m)`：**解锁**。离开会议室时，必须把“使用中”的牌子翻回“空闲”，以便下一个人使用。

**B. `pthread_mutex_lock()` 的三种行为**

当你尝试加锁时，会遇到三种情况：
1.  **互斥量未锁定（会议室空闲）**：函数会立刻成功，将互斥量置为锁定状态，然后你的线程可以继续执行临界区代码。
2.  **互斥量被其他线程锁定（会议室有人）**：你的线程会被**阻塞（block）**，即暂停执行，进入等待队列，直到持有锁的线程调用 `unlock()`。一旦锁被释放，你的线程会被唤醒，尝试获取锁。
3.  **互斥量已被自己锁定（自己把自己锁在门外）**：这是一个致命的错误。如果一个线程试图锁定一个它已经持有的互斥量，默认情况下它会造成**死锁（Deadlock）**。因为线程会永远等待一个只有它自己才能释放的锁。

**C. `pthread_mutex_unlock()` 的使用规则**

解锁操作有严格的规定，违反会导致严重错误：
1.  **谁加锁，谁解锁**：一个线程只能解锁由它自己锁定的互斥量。你不能帮别人解锁。
2.  **不能解锁未锁定的互斥量**：对一个已经是“未锁定”状态的互斥量进行解锁是错误的。

**D. 非阻塞的加锁方式**

除了会“死等”的 `pthread_mutex_lock()`，Pthreads 还提供了两种更灵活的变体：
* `pthread_mutex_trylock()`：**“尝试一下”**。如果互斥量未被锁定，它就加锁并成功返回。如果互斥量已被锁定，它**不会等待**，而是立刻返回一个 `EBUSY` 错误。这适用于“如果锁不可用，我就先去做点别的事”的场景。
* `pthread_mutex_timedlock()`：**“等一会儿”**。它和 `lock` 一样会等待，但可以设定一个最长等待时间（一个未来的绝对时间点）。如果在超时前获得了锁，就成功返回；如果超时了还没获得锁，就返回 `ETIMEDOUT` 错误。这可以防止线程被无限期地阻塞。

**E. 实用建议**

书中提到，`trylock` 和 `timedlock` 使用频率远低于 `lock`。一个设计良好的多线程程序，线程持有锁的时间应该**尽可能短**，这样其他线程的等待时间也会很短，从而提高并发效率。频繁使用 `trylock` 进行“轮询”检查是一种不好的设计，可能会导致该线程一直抢不到锁（饥饿现象）。

#### 总结 (Summary)

1.  **基本操作**：使用 `pthread_mutex_lock()` 获取锁来保护临界区，使用 `pthread_mutex_unlock()` 释放锁。
2.  **阻塞行为**：`lock()` 在锁被占用时会阻塞线程，直到锁被释放。
3.  **核心规则**：线程不能对自己已持有的锁再次加锁（会导致死锁），且只能解锁自己加上的锁。
4.  **高级操作**：`trylock()` 提供非阻塞的加锁尝试，`timedlock()` 提供带超时的阻塞加锁，用于需要更复杂控制逻辑的特殊场景。
5.  **设计原则**：保持锁的持有时间简短是提升多线程程序性能的关键。


# 30.1.3 互斥量的性能 (Mutex Performance)

#### 讲解 (Explanation)

这一节深入探讨了互斥量的性能开销，并解释了为什么它在现代操作系统中是一个高效的同步工具。

**A. 表面印象 vs. 实际情况**

* **表面印象**：在一个只进行递增操作的极端测试中，加入互斥量让程序慢了近10倍，看起来性能代价极高。
* **实际情况**：这种印象是片面的。
    1.  **相对开销低**：在那个测试中，一次 `lock/unlock` 的开销大约等于10次简单的循环操作。对于一个几乎不做任何事的循环来说，这个比例显得很高。
    2.  **真实世界应用**：在实际程序中，临界区内的工作（如数据计算、文件操作等）远比几次循环复杂得多。相比之下，`lock/unlock` 的开销占比会变得微不足道。好比你花8小时在办公室工作，为开门和锁门多花的几秒钟时间完全可以忽略不计。

**B. 性能对比：为什么互斥量更快？**

书中将 Pthreads 互斥量与另外两种同步机制做了对比：
* **文件锁 (`fcntl()`)**：非常慢。
* **System V 信号量**：也比较慢。
* **Pthreads 互斥量**：快得多。

**根本原因在于是否需要“系统调用（System Call）”**。系统调用是应用程序请求操作系统内核服务的机制，这个过程涉及到用户态到内核态的切换，虽然单次开销不大，但频繁发生就会严重影响性能。

* 文件锁和 System V 信号量的每次操作都**必须**进行系统调用。
* Pthreads 互斥量的实现则非常智能，它**极力避免系统调用**。

**C. Pthreads 互斥量的性能秘诀：Futex**

Pthreads 互斥量在 Linux 上的高性能实现依赖于一个叫做 **Futex** (Fast User-space Mutex) 的机制。
* **无争用情况（The Fast Path）**：当一个线程试图锁定一个**未被占用**的互斥量时，它只需要在**用户空间**执行一两条原子指令（一种不会被中断的CPU指令）来修改内存中的一个标志位即可。这个过程**完全不涉及内核**，速度极快。这是最常见的情况。
* **有争用情况（The Slow Path）**：**只有当**一个线程试图锁定一个**已被占用**的互斥量时，它才需要陷入内核。这时它会发起 `futex()` 系统调用，请求内核将自己加入等待队列并投入睡眠。当锁被释放时，内核会负责唤醒等待的线程。

这种设计哲学是：**为最常见的情况（无锁争用）提供极致优化，只在必要时（发生锁争用）才承担系统调用的开销。**

#### 总结 (Summary)

1.  **相对性能**：尽管互斥量有开销，但在真实的应用程序中，由于临界区内的工作通常耗时更长，互斥量的性能影响通常很小。
2.  **压倒性优势**：相比于总是需要系统调用的文件锁和 System V 信号量，Pthreads 互斥量在性能上具有巨大优势。
3.  **核心优化**：其高性能的关键在于**区别对待“有争用”和“无争用”** 的情况。
4.  **实现机制**：在无争用时，仅通过用户空间的原子操作完成加锁，速度极快；仅在发生争用需要线程阻塞时，才通过 `futex` 系统调用请求内核介入。



# 30.1.4 互斥量的死锁 (Deadlock of Mutexes)

#### **讲解**

当一个程序中的多个线程需要同时锁定两个或更多的互斥量（mutex）时，就可能产生**死锁**。

**死锁是如何发生的？**
死锁的典型场景是：
1.  **线程 A** 成功锁定了 **Mutex 1**。
2.  **线程 B** 成功锁定了 **Mutex 2**。
3.  接下来，**线程 A** 尝试去锁定 **Mutex 2**，但由于 Mutex 2 已被线程 B 锁定，线程 A 进入阻塞（等待）状态。
4.  同时，**线程 B** 尝试去锁定 **Mutex 1**，但由于 Mutex 1 已被线程 A 锁定，线程 B 也进入阻塞（等待）状态。

此时，线程 A 在等待线程 B 释放 Mutex 2，而线程 B 也在等待线程 A 释放 Mutex 1。两个线程都无法继续执行，也无法释放自己持有的锁，从而陷入无限期的等待，程序被“卡死”。这就是死锁。

**如何避免死锁？**
文中提出了两种主要的解决方案：

1.  **定义互斥量的层级关系 (Mutex Hierarchy)**
    * **核心思想**：为程序中所有的互斥量定义一个全局的、固定的加锁顺序。所有线程在需要锁定多个互斥量时，都必须严格遵守这个顺序。
    * **举例**：规定所有线程必须先锁定 Mutex 1，再锁定 Mutex 2。这样一来，前述的死锁场景就不会发生。当线程 A 锁定了 Mutex 1 后，线程 B 就无法锁定 Mutex 1，它会直接在此处等待，而不会去锁定 Mutex 2。这就打破了死锁的循环等待条件。
    * **评价**：这是最简单、最高效、也是最推荐的避免死锁的方法。

2.  **“尝试一下，然后恢复” (Try and Back Off)**
    * **核心思想**：不强制规定加锁顺序，而是采用一种“先试探，失败就放弃重来”的策略。
    * **执行步骤**：
        1.  线程首先使用阻塞式的 `pthread_mutex_lock()` 锁定第一个互斥量。
        2.  然后，使用非阻塞式的 `pthread_mutex_trylock()` 尝试锁定后续所有需要的互斥量。
        3.  如果在尝试过程中，任何一次 `pthread_mutex_trylock()` 调用失败（表示该锁已被其他线程持有），则该线程必须**立即释放所有已经成功锁定的互斥量**。
        4.  等待一小段时间后，从头开始重新尝试整个过程。
    * **评价**：这种方法更加灵活，因为它不依赖于严格的层级关系。但它的效率较低，因为线程可能需要多次循环尝试才能成功，增加了系统的开销。

#### **总结**

* **问题**：当多个线程以不同的顺序锁定同一组互斥量时，会产生循环等待，导致死锁。
* **主要解决方案**：
    * **锁定顺序法**：强制所有线程按相同的顺序获取锁，这是最常用且最高效的策略。
    * **尝试并退让法**：尝试获取所有锁，一旦失败就释放全部已持有的锁并重试，此法更灵活但效率较低。

# 30.1.5 动态初始化互斥量 (Dynamic Initialization of Mutexes)

#### **讲解**

互斥量的初始化有两种方式：静态初始化和动态初始化。

1.  **静态初始化**
    * 使用宏 `PTHREAD_MUTEX_INITIALIZER`。
    * **限制**：这种方法只能用于**静态分配**的互斥量（如全局变量或 `static` 变量），并且只能为其赋予**默认属性**。

2.  **动态初始化**
    * 使用函数 `pthread_mutex_init()`。
    * 该函数接受两个参数：一个是指向要初始化的互斥量 `mutex` 的指针，另一个是指向互斥量属性对象 `attr` 的指针。如果 `attr` 为 `NULL`，则使用默认属性。
    * **必须使用动态初始化的情况**：
        1.  **堆中分配的互斥量**：当互斥量是动态数据结构（如链表节点）的一部分，通过 `malloc()` 在堆上分配内存时。
        2.  **栈中分配的互斥量**：当互斥量是函数内的局部变量（自动变量）时。
        3.  **需要非默认属性的互斥量**：即便是静态分配的互斥量，如果需要设置特定属性（如下文会提到的错误检查、递归等），也必须使用此函数。

**互斥量的销毁**
与动态初始化配对的是销毁操作。

* 使用函数 `pthread_mutex_destroy()`。
* **规则**：
    1.  凡是使用 `pthread_mutex_init()` 初始化的互斥量，在不再需要时都**应该**使用 `pthread_mutex_destroy()` 销毁。
    2.  对于静态初始化的互斥量，则**无需**调用此函数。
    3.  **销毁条件**：销毁一个互斥量是安全的，当且仅当它处于**未锁定**状态，并且未来不会再有任何线程尝试去锁定它。
    4.  **时机**：对于堆上的互斥量，应在 `free()` 内存之前销毁；对于栈上的互斥量，应在函数返回之前销毁。

**重要注意事项**
* 对一个已经初始化过的互斥量再次进行初始化，其行为是未定义的，应极力避免。
* 被销毁的互斥量可以通过 `pthread_mutex_init()` 重新初始化后再次使用。

#### **总结**

* **初始化方式**：
    * **静态 (`PTHREAD_MUTEX_INITIALIZER`)**：用于静态分配、默认属性的简单场景。
    * **动态 (`pthread_mutex_init()`)**：用于在堆、栈上分配的互斥量，或任何需要自定义属性的互斥量。
* **生命周期管理**：
    * 动态初始化的互斥量必须通过 `pthread_mutex_destroy()` 进行销毁。
    * 销毁操作必须在互斥量未被锁定时进行，并且要在其所在内存被释放或失效前完成。



# 30.1.6 互斥量的属性 (Mutex Attributes)

#### **讲解**
互斥量在创建时可以拥有一系列的**属性**，用于定制其行为。这些属性被封装在一个 `pthread_mutexattr_t` 类型的对象中。

当使用 `pthread_mutex_init()` 动态初始化一个互斥量时，可以将这个属性对象的地址作为第二个参数传入，从而创建一个带有特定属性的互斥量。如果传入 `NULL`，则互斥量会使用默认属性。

本节作为一个引子，指出可以通过属性对象来配置互斥量，但不会深入所有细节，而是将重点放在下一节要讨论的最重要的属性之一：**互斥量类型**。

#### **总结**
* 互斥量的行为可以通过**属性对象 (`pthread_mutexattr_t`)** 来配置。
* 这些属性在调用 `pthread_mutex_init()` 时指定，用于创建非默认行为的互斥量。


# 30.1.7 互斥量类型 (Mutex Types)

#### **讲解**
互斥量的**类型（type）**属性，决定了它在处理一些特殊（通常是错误）的加锁/解锁操作时的行为。主要关注以下三种情况：
1.  同一线程尝试对**已经被自己锁定**的互斥量再次加锁。
2.  线程尝试解锁一个**由其他线程锁定**的互斥量。
3.  线程尝试解锁一个**当前未被锁定**的互斥量。

SUSv3（Single UNIX Specification v3）定义了以下几种互斥量类型：

* **`PTHREAD_MUTEX_NORMAL` (普通锁)**
    * **行为**：不进行死锁自检测。如果线程对自己已持有的锁再次加锁，会立即造成**死锁**。对于后两种错误解锁情况，行为不确定（在 Linux 上，这些错误操作会“成功”返回，这可能会隐藏程序缺陷）。
    * **特点**：性能较高，但安全性较差。

* **`PTHREAD_MUTEX_ERRORCHECK` (检错锁)**
    * **行为**：提供全面的错误检查。对于上述所有三种错误情况，相关的 Pthreads 函数都会调用失败并返回一个错误码。
    * **特点**：运行速度比普通锁慢，但非常适合用于**程序调试**，可以帮助开发者快速定位不规范的互斥量使用问题。

* **`PTHREAD_MUTEX_RECURSIVE` (递归锁)**
    * **行为**：允许**同一个线程**对同一个互斥量进行多次加锁。它内部维护一个“锁计数器”。线程第一次加锁，计数器变为 1。之后该线程每次加锁，计数器递增；每次解锁，计数器递减。只有当计数器减至 0 时，该锁才会被真正释放，其他线程才能获取它。
    * **特点**：主要用于需要递归调用且在递归过程中需要保持锁的场景。解锁一个不属于自己或未被锁定的递归锁同样会失败。

* **`PTHREAD_MUTEX_DEFAULT` (默认锁)**
    * **行为**：这是使用静态宏 `PTHREAD_MUTEX_INITIALIZER` 或 `pthread_mutex_init()` 传入 `NULL` 属性时创建的锁的类型。标准有意未定义它在上述三种错误情况下的行为，以便系统实现者能追求最高效率。
    * **特点**：在 Linux 系统上，它的行为和 `PTHREAD_MUTEX_NORMAL` 完全一样。

**注意**：虽然 Linux 提供了一些非标准的静态初始值（如 `PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP`）来创建特定类型的静态互斥量，但为了保证代码的**可移植性**，应当避免使用它们。

#### **总结**
| 互斥量类型                          | 对“自己已持有的锁”再次加锁            | 主要用途            |
| :----------------------------- | :------------------------ | :-------------- |
| **`PTHREAD_MUTEX_NORMAL`**     | **死锁**                    | 追求最高性能的生产环境     |
| **`PTHREAD_MUTEX_ERRORCHECK`** | 返回错误                      | 程序开发和调试阶段       |
| **`PTHREAD_MUTEX_RECURSIVE`**  | 成功（锁计数器加 1）               | 递归函数或需要重复进入的临界区 |
| **`PTHREAD_MUTEX_DEFAULT`**    | 行为未定义 (Linux 上等同于 NORMAL) | 默认行为，兼顾效率       |



# 案例解释

首先，我们总结一下**何时使用静态初始化 vs 动态初始化**：

| 初始化方式                                      | 使用场景                                                                                                  | 优点                      | 缺点                                                |
| :----------------------------------------- | :---------------------------------------------------------------------------------------------------- | :---------------------- | :------------------------------------------------ |
| **静态初始化**\<br\>`PTHREAD_MUTEX_INITIALIZER` | 当互斥量是**全局变量**或**静态(static)局部变量**时，并且你**只需要默认属性**。                                                     | 代码简单，无需清理（调用`destroy`）。 | 功能受限，无法用于堆/栈变量，无法自定义属性。                           |
| **动态初始化**\<br\>`pthread_mutex_init()`      | 1. 互斥量位于**堆内存**中（如 `malloc` 创建的结构体）。\<br\>2. 互斥量是函数内的**局部变量**（在栈上）。\<br\>3. **需要设置非默认属性**（如检错锁、递归锁等）。 | 功能强大，灵活，是唯一可以自定义属性的方式。  | 必须手动调用 `pthread_mutex_destroy()` 进行销毁，否则可能导致资源泄露。 |

-----

### 案例代码

下面的 C 代码演示了所有这些概念：

1.  **静态初始化**：用于一个全局计数器。
2.  **动态初始化**：用于一个动态创建的共享资源对象。
3.  **属性使用**：
      * 演示 `PTHREAD_MUTEX_ERRORCHECK`（检错锁）的行为。
      * 演示 `PTHREAD_MUTEX_RECURSIVE`（递归锁）的行为。

<!-- end list -->

```c
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>

// =============================================================================
// 第一部分: 静态 vs 动态 初始化
// =============================================================================

// 1. 静态初始化案例: 一个全局的互斥量和计数器
// 因为是全局变量且使用默认属性，所以非常适合静态初始化。
pthread_mutex_t g_static_mutex = PTHREAD_MUTEX_INITIALIZER;
int g_counter = 0;

void* static_demo_thread(void* arg) {
    for (int i = 0; i < 100000; ++i) {
        pthread_mutex_lock(&g_static_mutex);
        g_counter++;
        pthread_mutex_unlock(&g_static_mutex);
    }
    return NULL;
}

// 2. 动态初始化案例: 一个动态分配的共享资源结构体
typedef struct {
    int value;
    pthread_mutex_t mutex; // 互斥量作为结构体成员
} SharedResource;

void* dynamic_demo_thread(void* arg) {
    SharedResource* resource = (SharedResource*)arg;
    for (int i = 0; i < 100000; ++i) {
        pthread_mutex_lock(&resource->mutex);
        resource->value++;
        pthread_mutex_unlock(&resource->mutex);
    }
    return NULL;
}


// =============================================================================
// 第二部分: 互斥量类型和属性演示
// =============================================================================

// 3. 演示 PTHREAD_MUTEX_ERRORCHECK (检错锁)
void demo_errorcheck_mutex() {
    printf("\n--- 演示检错锁 (ERRORCHECK) ---\n");
    pthread_mutex_t err_mutex;
    pthread_mutexattr_t attr;

    // 初始化属性对象
    pthread_mutexattr_init(&attr);
    // 设置类型为检错锁
    pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_ERRORCHECK);

    // 使用指定属性初始化互斥量
    pthread_mutex_init(&err_mutex, &attr);
    
    printf("尝试第一次加锁...\n");
    int ret = pthread_mutex_lock(&err_mutex);
    if (ret == 0) printf("成功: 第一次加锁成功\n");

    printf("在同一线程中尝试第二次加锁...\n");
    ret = pthread_mutex_lock(&err_mutex);
    if (ret != 0) {
        // EDEADLK: Resource deadlock would occur
        printf("失败: 第二次加锁失败, 错误码: %d (%s)\n", ret, strerror(ret));
    }

    printf("尝试第一次解锁...\n");
    ret = pthread_mutex_unlock(&err_mutex);
    if (ret == 0) printf("成功: 第一次解锁成功\n");

    printf("尝试解锁一个已经解锁的互斥量...\n");
    ret = pthread_mutex_unlock(&err_mutex);
    if (ret != 0) {
        // EPERM: Operation not permitted
        printf("失败: 解锁未锁定的互斥量失败, 错误码: %d (%s)\n", ret, strerror(ret));
    }

    // 销毁属性对象和互斥量
    pthread_mutexattr_destroy(&attr);
    pthread_mutex_destroy(&err_mutex);
}

// 4. 演示 PTHREAD_MUTEX_RECURSIVE (递归锁)
pthread_mutex_t recursive_mutex;

void recursive_function(int count) {
    if (count <= 0) {
        return;
    }

    printf("递归层级 %d: 尝试加锁...\n", count);
    pthread_mutex_lock(&recursive_mutex);
    printf("递归层级 %d: 加锁成功!\n", count);
    
    // 递归调用
    recursive_function(count - 1);
    
    pthread_mutex_unlock(&recursive_mutex);
    printf("递归层级 %d: 解锁成功。\n", count);
}


void demo_recursive_mutex() {
    printf("\n--- 演示递归锁 (RECURSIVE) ---\n");
    pthread_mutexattr_t attr;

    pthread_mutexattr_init(&attr);
    pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);
    pthread_mutex_init(&recursive_mutex, &attr);

    // 从顶层调用递归函数
    recursive_function(3);

    pthread_mutexattr_destroy(&attr);
    pthread_mutex_destroy(&recursive_mutex);
}


int main() {
    // --- 第一部分演示 ---
    printf("--- 演示静态 vs 动态初始化 ---\n");
    
    // 静态初始化演示
    pthread_t t1, t2;
    pthread_create(&t1, NULL, static_demo_thread, NULL);
    pthread_create(&t2, NULL, static_demo_thread, NULL);
    pthread_join(t1, NULL);
    pthread_join(t2, NULL);
    printf("静态初始化 - 全局计数器最终值: %d\n", g_counter);

    // 动态初始化演示
    SharedResource* resource = (SharedResource*)malloc(sizeof(SharedResource));
    resource->value = 0;
    // 因为 resource 是在堆上动态分配的，所以其内部的 mutex 必须动态初始化
    pthread_mutex_init(&resource->mutex, NULL); // 使用默认属性

    pthread_t t3, t4;
    pthread_create(&t3, NULL, dynamic_demo_thread, resource);
    pthread_create(&t4, NULL, dynamic_demo_thread, resource);
    pthread_join(t3, NULL);
    pthread_join(t4, NULL);
    printf("动态初始化 - 共享资源最终值: %d\n", resource->value);
    
    // 动态初始化的互斥量必须销毁
    pthread_mutex_destroy(&resource->mutex);
    free(resource);

    // --- 第二部分演示 ---
    demo_errorcheck_mutex();
    demo_recursive_mutex();

    return 0;
}
```

### 如何编译和运行

将代码保存为 `mutex_demo.c`，然后使用以下命令编译（需要链接 pthread 库）：

```sh
gcc -o mutex_demo mutex_demo.c -pthread
```

运行程序：

```sh
./mutex_demo
```

### 代码讲解与分析

#### 第一部分：静态 vs 动态初始化

1.  **静态初始化 (`g_static_mutex`)**

      * `g_static_mutex` 是一个全局变量，它的生命周期贯穿整个程序。我们只需要默认的互斥量行为（在 Linux 上是 `PTHREAD_MUTEX_NORMAL`）。
      * 因此，使用 `PTHREAD_MUTEX_INITIALIZER` 是最简洁、最合适的选择。我们不需要在程序结束时手动销毁它。

2.  **动态初始化 (`resource->mutex`)**

      * `SharedResource` 是一个我们用 `malloc` 在**堆上**动态创建的结构体。它的生命周期由我们手动管理（`malloc`/`free`）。
      * 对于这种在堆上分配的、作为另一个对象一部分的互斥量，**必须**使用 `pthread_mutex_init()` 进行初始化。
      * 在这个例子中，我们给 `pthread_mutex_init()` 的第二个参数传了 `NULL`，表示我们接受默认的互斥量类型。
      * 最重要的一点是，在 `free(resource)` 之前，我们必须调用 `pthread_mutex_destroy(&resource->mutex)` 来释放互斥量占用的资源。

#### 第二部分：互斥量类型属性演示

1.  **检错锁 (`demo_errorcheck_mutex`)**

      * 我们创建了一个属性对象 `attr`，并使用 `pthread_mutexattr_settype()` 将其类型设置为 `PTHREAD_MUTEX_ERRORCHECK`。
      * 然后用这个 `attr` 初始化了 `err_mutex`。
      * **行为验证**：
          * 程序第一次加锁成功。
          * 当它尝试**在同一个线程中第二次加锁**时，`pthread_mutex_lock()` 立即返回了错误码 `EDEADLK` (表示“会引起死锁”)，而不是像普通锁那样永远阻塞。这在调试时非常有用！
          * 在解锁一次后，当我们尝试**再次解锁一个已经解锁的互斥量**时，`pthread_mutex_unlock()` 返回了错误码 `EPERM` (表示“操作不允许”)。这也能帮助我们发现代码逻辑错误。

2.  **递归锁 (`demo_recursive_mutex`)**

      * 我们同样通过属性对象将互斥量类型设置为 `PTHREAD_MUTEX_RECURSIVE`。
      * `recursive_function` 是一个典型的递归调用场景。
      * **行为验证**：
          * 在 `count=3` 的顶层调用中，程序成功锁定了互斥量。
          * 在 `count=2` 和 `count=1` 的递归调用中，程序**再次成功锁定了同一个互斥量**，这对于普通锁或检错锁来说是不可能的。
          * 程序会按照加锁的逆序（1 -\> 2 -\> 3）依次解锁，直到锁计数器归零，锁才被真正释放。
          * 这个例子完美展示了递归锁如何在递归调用中保护共享资源而不会导致死锁。

希望这个结合了详细解释和可运行代码的案例能帮助您清晰地理解这些概念。