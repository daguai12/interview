### 摘要

这段文本主要分为两个核心部分：

1.  **内核层面的自动清理**：当一个进程**无论以何种方式**终止时，操作系统内核为确保系统稳定性而强制执行的一系列资源回收动作。
2.  **应用程序层面的清理**：通过注册“退出处理程序”，允许程序在**正常终止**时执行自定义的清理代码。这里主要介绍了两个函数：标准的 `atexit()` 和非标准的 `on_exit()`。

-----

### 1\. 进程终止时的自动清理 (内核层面)

这部分描述的是操作系统内核的“兜底”行为。无论你的程序是正常 `exit()`，还是因为段错误、被 `kill` 命令杀死而非正常终止，内核都会出手完成以下清理工作，以防止资源泄露：

  * **关闭所有文件描述符**：所有打开的文件、socket、管道等都会被关闭。
  * **释放文件锁**：进程持有的任何文件锁都会被解除，以便其他进程可以获取。
  * **分离共享内存**：与System V共享内存段的连接会断开。
  * **处理System V信号量**：执行与信号量相关的调整。
  * **处理POSIX IPC对象**：关闭所有打开的POSIX有名信号量和消息队列。
  * **释放内存锁和内存映射**：通过 `mlock()` 锁定的内存会被解锁，通过 `mmap()` 映射的内存区域会被解除映射。
  * **处理终端和会话**：如果进程是会话的领导者，会向其前台进程组发送 `SIGHUP` 信号。
  * **处理孤儿进程组**：在特定情况下，向已停止的孤儿进程组发送 `SIGHUP` 和 `SIGCONT` 信号，防止它们永远处于停止状态。

**核心要点**：这些是内核级别的、强制性的资源回收。你不需要写任何代码，操作系统会自动帮你完成。它保证了即使程序异常崩溃，其占用的核心资源也能被系统回收。

-----

### 2\. 退出处理程序 (Exit Handlers)

这部分是应用程序开发者需要关心的。有时候，你需要在程序退出时执行一些比内核清理更高级的操作，例如：

  * 删除临时文件。
  * 将缓存中的数据写回磁盘。
  * 记录程序正常退出的日志。
  * 关闭数据库连接。

**问题**：如果你的代码是一个库，你无法控制主程序何时会调用 `exit()`。如何确保你的库的清理函数一定会被执行呢？

**解决方案**：使用**退出处理程序**。你可以编写一个清理函数，并使用 `atexit()` 将它“注册”到C库中。当程序通过调用 `exit()` 或从 `main` 函数返回来**正常终止**时，C库会自动调用所有已注册的清理函数。

#### 2.1 如何注册退出处理程序：`atexit()`

这是由 C 和 POSIX 标准定义的函数，可移植性最好。

  * **函数原型**: `int atexit(void (*func)(void));`
  * **参数**: 它接受一个函数指针 `func`。这个函数必须是 `void` 返回值且不接受任何参数 (`void (*)(void)`)。
  * **返回值**: 成功时返回 0，失败时返回非 0。

**简单示例**：

```c
#include <stdio.h>
#include <stdlib.h>

void cleanup_task_1() {
    printf("Executing cleanup task 1 (e.g., deleting temp files).\n");
}

void cleanup_task_2() {
    printf("Executing cleanup task 2 (e.g., closing database).\n");
}

int main() {
    printf("Program started.\n");

    // 注册退出处理程序
    atexit(cleanup_task_1);
    atexit(cleanup_task_2);

    printf("Main function is about to exit.\n");

    // 当 main 函数返回时，相当于调用 exit(0);
    return 0; 
}
```

**运行结果**:

```
Program started.
Main function is about to exit.
Executing cleanup task 2 (e.g., closing database).
Executing cleanup task 1 (e.g., deleting temp files).
```

#### 2.2 `atexit()` 的重要特性与规则

1.  **执行时机**：**只在正常终止时调用**。

      * 通过 `exit()` 或 `return` from `main()` 退出时会执行。
      * 通过 `_exit()` 或 `_Exit()` 退出，或者被信号杀死（如段错误、`kill -9`）**不会**执行。这是它的最大局限性。

2.  **执行顺序**：**后进先出 (Last-In, First-Out, LIFO)**。

      * 如上例所示，`cleanup_task_2` 比 `cleanup_task_1` 后注册，但它却先被执行。
      * 这种设计非常合理。想象你在初始化时，先初始化模块A，再基于A初始化模块B。那么清理时，理应先清理B，再清理A。

3.  **注册数量**：标准要求至少支持注册32个。在现代Linux (glibc) 上，这个数量几乎是无限的。

4.  **继承与替换**：

      * 子进程通过 `fork()` 会**继承**父进程所有已注册的退出处理程序。
      * 当进程调用 `exec()` 时，所有已注册的退出处理程序都会被**清除**，因为整个进程的内存映像都被新程序替换了。

5.  **不可取消**：没有标准的函数可以“注销”一个已经注册的 `atexit` 处理程序。

#### 2.3 `atexit()` 的局限与非标准替代品：`on_exit()`

`atexit()` 有两个局限性：

1.  处理函数无法知道程序的退出状态码（`exit(0)` 还是 `exit(1)`）。
2.  无法向处理函数传递任何自定义参数。

为了解决这个问题，GNU C 库 (glibc) 提供了一个非标准的、功能更强的替代品：`on_exit()`。

  * **函数原型**: `int on_exit(void (*func)(int status, void *arg), void *arg);`
  * **特点**:
      * 注册的函数 `func` 可以接收两个参数：`status` (程序的退出状态码) 和 `arg` (注册时传入的自定义参数指针)。
      * 这使得退出处理程序可以根据退出状态执行不同逻辑，或操作特定的数据。

**核心建议**：正如书中所强调的，`on_exit()` **不是标准函数**，在除Linux之外的大多数其他UNIX系统上都不存在。**为了保证程序的可移植性，应该坚持使用 `atexit()`**。

### 总结与应用

| 特性       | 内核自动清理            | `atexit()` 退出处理程序             |
| :------- | :---------------- | :---------------------------- |
| **触发时机** | **任何**进程终止        | **仅**在程序**正常**终止时             |
| **执行者**  | 操作系统内核            | 应用程序（通过C库）                    |
| **清理内容** | 底层系统资源（文件描述符、内存等） | 应用程序定义的逻辑（删除临时文件等）            |
| **控制权**  | 开发者无法控制           | 开发者通过注册函数来定义                  |
| **可移植性** | 所有UNIX/Linux系统都一样 | `atexit()` 标准，`on_exit()` 非标准 |

**如何使用这些知识？**
当你在编写一个需要管理自身状态或资源的模块时（比如一个库），使用 `atexit()` 注册一个清理函数是一种非常健壮的设计模式。它解耦了清理逻辑和主程序的退出逻辑，让你的模块更加自洽和可靠。