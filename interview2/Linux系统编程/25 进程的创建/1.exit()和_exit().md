### 核心摘要

这段文字的核心是区分两个终止进程的函数：

1.  **`_exit()`**: 这是一个**系统调用**，是进程终止的“原子操作”。它直接通知内核来终结进程，**不做任何清理工作**。
2.  **`exit()`**: 这是一个 C 语言标准**库函数**，是推荐的、更“文明”的退出方式。它在内部调用 `_exit()` 之前，会执行一系列**清理和善后工作**。

简单来说：`exit()` = **清理工作** + **`_exit()`**。

---

### 一个生动的比喻：下班离开办公室

想象一下你下班要离开办公室：

* **`_exit()` - 紧急疏散**
    * 相当于办公室火警响起。你什么都不管，扔下手中的一切，以最快的速度冲出大楼。
    * **结果**：你安全离开了（进程终止了），但你的电脑没关，文件没保存，桌子上一片狼藉（stdio 缓冲区没刷新，退出处理程序没执行）。

* **`exit()` - 正常下班**
    * 相当于到了正常的下班时间。
    * **第一步：执行收尾程序** (`atexit` handlers)：你会执行一系列固定的下班流程，比如提交今天的工作报告、给办公室的植物浇水等。
    * **第二步：保存并关闭文件** (刷新 stdio 缓冲区)：你会保存所有未保存的文档，关闭所有应用程序。
    * **第三步：离开大楼** (调用 `_exit()`)：完成所有事情后，你才关灯锁门，离开大楼。

这个比喻清晰地展示了 `exit()` 的优雅和 `_exit()` 的粗暴。

---

### 各函数详解

#### `_exit(status)`：内核的“终结者”

* **身份**：**系统调用 (System Call)**，是 UNIX/Linux 专有的。
* **行为**：
    * **立即**终止进程，从不返回。
    * 内核回收进程的所有资源（内存、文件描述符等）。
    * 不执行任何用户空间的清理工作。
* **它不做什么**：
    * **不**会调用 `atexit()` 注册的函数。
    * **不**会刷新标准 I/O（`stdio`）的缓冲区。这意味着你用 `printf` 打印的一些内容如果还在缓冲区里，就会丢失，永远不会显示出来。
* **`status` 参数**：
    * 定义进程的**退出状态码**。
    * 父进程通过 `wait()` 只能获取其**低8位**（0-255）。
    * **惯例**：`0` (或 `EXIT_SUCCESS`) 代表成功；非 `0` (如 `1` 或 `EXIT_FAILURE`) 代表失败。
    * **注意**：应避免使用大于 128 的值，以免与 shell 中表示“由信号终止”的退出码混淆。

#### `exit(status)`：程序的“管家”

* **身份**：**C标准库函数 (Library Function)**，具有良好的可移植性。
* **行为**：这是一个有序的、三部曲式的退场。
    1.  **调用退出处理程序**：按照与注册时**相反的顺序 (LIFO)**，依次调用由 `atexit()` 注册的函数。这允许你在程序退出前执行自定义的清理逻辑。
    2.  **刷新 stdio 缓冲区**：将所有打开的 `stdio` 流（如 `stdout`, `stderr`）中缓冲的数据全部“冲刷”到对应的设备（如终端或文件）。这是为什么即使你的 `printf("hello");` 后面没有 `\n`，在程序结束时通常也能看到输出的原因。
    3.  **调用 `_exit(status)`**：完成所有清理工作后，调用底层的 `_exit()` 系统调用，让内核来完成最后的终结。

---

### `return` from `main()` 与 `exit()`

* **`return n;`**：在 `main()` 函数中执行 `return n;`，在效果上**等同于调用 `exit(n);`**。这是C语言标准规定的，由编译器和运行时库来确保这一点。
* **执行到 `main()` 结尾** (没有 `return`)：
    * **C99 标准及以后**：等同于 `return 0;`，也就是 `exit(0);`。
    * **C89 标准**：行为未定义，退出码可能是一个随机值。因此，始终在 `main()` 中明确返回值是一个好习惯。

---

### 关键应用场景：`vfork()` 的子进程

我们在之前的讨论中提到，`vfork()` 创建的子进程**必须**使用 `_exit()` 而不是 `exit()`。现在原因就非常清晰了：

* `vfork()` 的子进程与父进程**共享内存**，包括 `stdio` 的内部缓冲区。
* 如果子进程调用了 `exit()`，它会去刷新和关闭这些**共享的**缓冲区。
* 当父进程恢复执行时，它会发现自己的 `stdio` 流已经被子进程搞得一团糟，后续的 I/O 操作将产生不可预测的错误。
* 因此，子进程必须调用 `_exit()`，直接“消失”，而不触碰任何与父进程共享的用户空间资源。

### 总结对比

| 特性              | `_exit()`               | `exit()`                   |
| :-------------- | :---------------------- | :------------------------- |
| **类型**          | **系统调用**                | **库函数**                    |
| **可移植性**        | UNIX/Linux 特定           | C 语言标准，非常通用                |
| **清理工作**        | **无**                   | **有**                      |
| **`atexit` 处理** | 不调用                     | 调用 (LIFO顺序)                |
| **`stdio` 缓冲区** | **不刷新** (可能丢失输出)        | **刷新** (保证输出)              |
| **核心关系**        | 被 `exit()` 在最后一步调用      | `exit()` 是 `_exit()` 的上层封装 |
| **推荐用法**        | 仅在特殊情况使用（如 `vfork` 子进程） | **绝大多数情况下的首选**             |