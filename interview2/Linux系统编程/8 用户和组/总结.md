### **8.1 密码文件：/etc/passwd**

`/etc/passwd` 文件是UNIX/Linux系统中核心的用户账户信息库。每个用户在该文件中占一行，该行由7个字段组成，字段之间用冒号 (`:`) 分隔。

**字段结构:** `登录名:加密的密码:用户ID:组ID:注释:主目录:登录shell`

1.  **登录名 (Username)**: 用户登录系统时使用的唯一名称。它是与数值型用户ID相对应的人类可读标识符。
2.  **经过加密的密码 (Password)**:
    * 在传统系统中，这里存放加密后的密码字符串。
    * 在现代系统中，如果启用了**shadow密码**（这是标准做法），该字段通常只含一个`x`字符，真正的加密密码存储在 `/etc/shadow` 文件中。
    * 如果此字段为空，则表示该账户登录**无需密码**。
3.  **用户ID (UID)**: 用户的唯一数字标识符。
    * UID为 **0** 的账户是超级用户（root），拥有最高权限。
    * 现代Linux系统使用32位整数存储UID。
4.  **组ID (GID)**: 用户所属的**主组 (Primary Group)** 的数字标识符。
5.  **注释 (Comment/GECOS)**: 用户的描述性信息，如全名、联系方式等。
6.  **主目录 (Home Directory)**: 用户登录后默认进入的目录，该路径会被设置为 `$HOME` 环境变量。
7.  **登录Shell (Login Shell)**: 用户登录后启动的程序，通常是一个shell（如 `/bin/bash`）。如果为空，则默认为 `/bin/sh`。

---

### **8.2 shadow 密码文件：/etc/shadow**

引入 `/etc/shadow` 文件的主要目的是增强系统安全性。

* **存在原因**:
    * `/etc/passwd` 文件需要对所有用户可读，以便系统程序获取用户信息。
    * 这导致了安全风险：任何人都可以读取到加密后的密码，并进行离线的暴力破解（字典攻击）。

* **解决方案**:
    * 将敏感的**加密密码**和其他安全相关信息从 `/etc/passwd` 中分离出来，存储到 `/etc/shadow` 文件中。
    * `/etc/shadow` 文件**只允许root用户读取**，从而保护了密码数据不被普通用户获取。

* **文件内容**: 除了用户名和加密密码外，还包含密码最后修改日期、密码过期策略、账户有效期等多种与安全相关的字段。

---

### **8.3 组文件：/etc/group**

`/etc/group` 文件定义了系统中的所有用户组及其成员。

* **用户与组的关系**:
    * **主组**: 在 `/etc/passwd` 文件中为每个用户定义的GID，是用户默认所属的组。
    * **辅助组 (Supplementary Groups)**: 在 `/etc/group` 文件中定义，一个用户可以同时属于多个辅助组。系统通过主组和所有辅助组来共同确定用户的文件访问权限。

**字段结构:** `组名:加密的密码:组ID:用户列表`

1.  **组名 (Group Name)**: 组的唯一名称，是与数值型组ID相对应的人类可读标识符。
2.  **经过加密的密码 (Group Password)**: 一个很少使用的特性。如果设置了组密码，不属于该组的用户可以通过 `newgrp` 命令并提供正确的密码来临时加入该组。在启用shadow机制时，实际密码存储在 `/etc/gshadow` 文件中。
3.  **组ID (GID)**: 组的唯一数字标识符。GID为 **0** 的通常是 `root` 组。
4.  **用户列表 (User List)**: 属于该组的**成员用户名列表**，用户名之间用逗号 (`,`) 分隔。这个列表定义了用户的**辅助组**关系。如果一个用户的主组是这个组，那么他的名字不一定需要出现在这个列表中。

### **8.4 获取用户和组的信息**

本节介绍了一系列标准库函数，用于从系统的用户和组数据库（`/etc/passwd`, `/etc/group`, `/etc/shadow`）中查询信息。这些函数封装了直接读取和解析这些文件的复杂性。

---

#### **1. 从密码文件 (`/etc/passwd`) 获取记录**

用于查询单个用户的基础信息。

* **`struct passwd *getpwnam(const char *name);`**
    * **功能**: 根据**用户名** (`name`) 查找对应的用户信息。
    * **示例**: `getpwnam("mtu");`

* **`struct passwd *getpwuid(uid_t uid);`**
    * **功能**: 根据**用户ID** (`uid`) 查找对应的用户信息。
    * **示例**: `getpwuid(1000);`

两个函数成功时都返回一个指向 `passwd` 结构的指针，该结构包含用户的详细信息，如：

* `pw_name` (用户名)
* `pw_uid` (用户ID)
* `pw_gid` (主组ID)
* `pw_dir` (主目录)
* `pw_shell` (登录Shell)
* `pw_gecos` (注释信息)

**重要特性与注意事项**:
* **静态内存**: 返回的指针指向一块**静态分配**的内存。这意味着**后续对 `getpwnam()` 或 `getpwuid()` 的任何调用都会覆盖之前的结果**。
* **不可重入 (Not Thread-Safe)**: 由于使用静态内存，这些函数在多线程环境中是不安全的。应使用其可重入版本 `getpwnam_r()` 和 `getpwuid_r()`。
* **错误处理**: 在区分“未找到记录”和“发生错误”时，不同系统的行为存在差异，导致可移植性问题。

---

#### **2. 从组文件 (`/etc/group`) 获取记录**

用于查询单个组的信息。

* **`struct group *getgrnam(const char *name);`**
    * **功能**: 根据**组名** (`name`) 查找对应的组信息。
    * **示例**: `getgrnam("developers");`

* **`struct group *getgrgid(gid_t gid);`**
    * **功能**: 根据**组ID** (`gid`) 查找对应的组信息。
    * **示例**: `getgrgid(2000);`

成功时返回一个指向 `group` 结构的指针，包含组名 (`gr_name`)、组ID (`gr_gid`) 和成员列表 (`gr_mem`) 等信息。这些函数同样**使用静态内存，不可重入**，并有对应的可重入版本 (`getgrnam_r()`, `getgrgid_r()`)。

---

#### **3. 扫描密码文件和组文件中的所有记录**

用于遍历整个用户或组数据库。

* **密码文件扫描**:
    * **`struct passwd *getpwent(void);`**: 逐条读取 `/etc/passwd` 中的记录。当读完所有记录或出错时返回 `NULL`。
    * **`void setpwent(void);`**: 将读取指针重置到文件开头，以便重新扫描。
    * **`void endpwent(void);`**: 关闭与密码文件关联的流。完成扫描后应调用此函数。

* **组文件扫描**:
    * 提供了功能完全相同的函数集：`getgrent()`、`setgrent()` 和 `endgrent()`，用于遍历 `/etc/group` 文件。

---

#### **4. 从 Shadow 密码文件 (`/etc/shadow`) 获取记录**

用于获取用户的加密密码和账户安全策略等敏感信息。

* **`struct spwd *getspnam(const char *name);`**
    * **功能**: 根据**用户名** (`name`) 查找对应的 shadow 记录。
    * **返回**: 成功时返回一个指向 `spwd` 结构的指针，其中包含了加密密码 (`sp_pwdp`) 和账户有效期等字段。

* **扫描函数**:
    * 同样提供了 `getspent()`、`setspent()` 和 `endspent()` 用于遍历整个 `/etc/shadow` 文件。

**重要特性**:
* 这些与 shadow 文件相关的函数**并非 SUSv3 (POSIX) 标准的一部分**，因此在所有 UNIX 实现上不一定都可用，但在 Linux 系统中是标准配置。

### **函数总结表**

| 函数               | 查询目标               | 查询键         | 主要特点                    |
| :--------------- | :----------------- | :---------- | :---------------------- |
| **`getpwnam()`** | 用户信息 (`passwd`)    | 用户名         | 使用静态内存，不可重入             |
| **`getpwuid()`** | 用户信息 (`passwd`)    | 用户 ID (UID) | 使用静态内存，不可重入             |
| **`getgrnam()`** | 组信息 (`group`)      | 组名          | 使用静态内存，不可重入             |
| **`getgrgid()`** | 组信息 (`group`)      | 组 ID (GID)  | 使用静态内存，不可重入             |
| **`getpwent()`** | 逐条扫描用户             | (无)         | 遍历整个 `/etc/passwd` 文件   |
| **`getgrent()`** | 逐条扫描组              | (无)         | 遍历整个 `/etc/group` 文件    |
| **`getspnam()`** | Shadow 信息 (`spwd`) | 用户名         | **非 POSIX 标准**，Linux 支持 |

### **8.5 密码加密和用户认证**

本节的核心内容是解释UNIX/Linux系统如何安全地验证用户密码，而不直接存储明文密码。

---

#### **1. 核心概念：单向加密认证**

出于安全考虑，系统绝不会存储用户的原始密码。而是采用**单向加密（更准确地说是哈希算法）**，这意味着：
* 可以从明文密码计算出加密后的字符串（哈希值）。
* 无法从加密后的字符串反向推导出原始密码。

因此，验证用户身份的流程如下：
1.  程序根据用户名从 `/etc/shadow` 文件中获取该用户已存储的、加密过的密码字符串。
2.  程序提示用户输入密码（明文）。
3.  程序使用**完全相同的算法和参数**，对用户刚刚输入的明文密码进行加密。
4.  比较第3步生成的新加密字符串与第1步从文件中读出的旧加密字符串。
5.  如果两者完全一致，则证明用户输入的密码正确，认证通过。

---

#### **2. `crypt()` 函数**

`crypt()` 是实现上述加密过程的核心C库函数。

* **函数原型**: `char *crypt(const char *key, const char *salt);`
* **参数**:
    * `key`: 用户输入的明文密码字符串。
    * `salt`: 一个两字符的字符串，被称为“盐值”。
* **返回值**: 返回一个指向**静态分配**内存的指针，内容是加密后的13个字符（传统DES算法）或更长的字符串。

**“盐” (Salt) 的作用**:
* **目的**: “盐”会扰动加密算法，即使两个用户设置了完全相同的密码，只要他们的“盐”不同，最终加密出来的字符串也完全不同。
* **安全性**: 这极大地增加了密码破解的难度。破解者不能只准备一份常用密码的“彩虹表”，而是需要为每一种可能的“盐”（传统DES有4096种）都准备一份，计算成本大大增加。

**`crypt()` 的巧妙设计**:
`crypt()` 函数返回的加密字符串，其**前两个字符就是加密时所使用的“盐”**。
这个设计使得验证过程非常方便：
1.  从 `/etc/shadow` 中读取完整的加密字符串（例如 `ab123456789XY`）。
2.  调用 `crypt()` 时，将用户输入的明文作为 `key`，并将从文件中读出的**整个加密字符串**作为 `salt` 参数。
3.  `crypt()` 函数会自动从 `salt` 参数中提取前两个字符（`ab`）作为真正的“盐”值来进行加密。

**编译注意**:
* 在Linux上编译使用 `crypt()` 的程序时，需要链接 `crypt` 库，即在编译命令中加入 `-lcrypt` 选项。

---

#### **3. `getpass()` 函数**

这是一个用于从终端安全读取密码的辅助函数。

* **函数原型**: `char *getpass(const char *prompt);`
* **功能**:
    1.  向终端打印 `prompt` 提示符。
    2.  **关闭终端的回显功能**，这样用户输入密码时屏幕上不会显示任何字符。
    3.  读取用户输入的一行内容。
    4.  恢复终端的原始设置。
    5.  返回一个指向静态分配内存的指针，内容是用户输入的密码。
* **状态**: `getpass()` 是一个比较老旧的函数，在SUSv3 (POSIX) 标准中已被废弃，但大多数UNIX系统为了兼容性依然提供支持。

---

#### **4. 编程中的安全要点**

程序清单 8-2 强调了一个非常重要的安全编程习惯：
* **尽快清除内存中的明文密码**：程序在获取到用户输入的明文密码后，应立即使用 `crypt()` 将其加密，然后马上用零或其他无效数据覆盖掉内存中存储明文密码的变量。
* **原因**: 这是为了防止在程序异常崩溃时，操作系统生成一个包含内存快照的核心转储文件（core dump），恶意攻击者可能通过分析这个文件来窃取明文密码。

# 案例讲解

### 示例文件内容

这里是为几个虚构用户（`root`, 系统用户`daemon`, 普通用户`mtu`和`ftpuser`）和组生成的配置文件。

#### `/etc/passwd`

```
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
mtu:x:1000:1000:Michael Tan:/home/mtu:/bin/bash
ftpuser:x:1001:1001::/home/ftpuser:/bin/false
```

#### `/etc/shadow`

```
root:$6$somesalt$longhashedpasswordstringforsuperuser:19970:0:99999:7:::
daemon:*:19965:0:99999:7:::
mtu:$6$anothersalt$longhashedpasswordstringforuser:19972:0:99999:7:::
ftpuser:!:19972:0:99999:7:::
```

#### `/etc/group`

```
root:x:0:
daemon:x:1:
mtu:x:1000:
ftpuser:x:1001:
developers:x:2000:mtu
docker:x:999:mtu
```

#### `/etc/gshadow`

```
root:!::
daemon:!::
mtu:!::
ftpuser:!::
developers:!::mtu
docker:!::mtu
```

-----

### 文件含义详解

#### 1\. `/etc/passwd` - 用户基本信息库

这个文件是所有用户账户的“花名册”，系统上的所有程序都可以读取它。它定义了用户是谁，但不包含敏感的密码信息。

**格式**: `用户名:密码占位符:用户ID:组ID:注释:主目录:登录Shell`

让我们以 `mtu` 这一行为例：
`mtu:x:1000:1000:Michael Tan:/home/mtu:/bin/bash`

| 字段 | 示例值 | 含义 |
| :--- | :--- | :--- |
| **用户名** | `mtu` | 用于登录系统的唯一名称。 |
| **密码占位符** | `x` | 一个占位符，表示用户的加密密码存储在 `/etc/shadow` 文件中。如果为空，则表示无需密码即可登录。 |
| **用户ID (UID)** | `1000` | 用户的唯一数字标识。**UID 0** 固定为超级用户 `root`。 |
| **组ID (GID)** | `1000` | 用户所属的**主组**的数字标识。 |
| **注释 (GECOS)** | `Michael Tan` | 用户的描述性信息，如全名、联系方式等。 |
| **主目录** | `/home/mtu` | 用户登录后默认所在的目录 (`$HOME`)。 |
| **登录Shell** | `/bin/bash` | 用户登录后启动的程序。`/bin/bash` 是一个交互式终端。像 `/usr/sbin/nologin` 或 `/bin/false` 则禁止用户登录。 |

-----

#### 2\. `/etc/shadow` - 用户安全密码库

这个文件是 `/etc/passwd` 的“影子”，专门存放包括加密密码在内的敏感信息。**只有 root 用户可以读取它**，这极大地增强了系统安全性。

**格式**: `用户名:加密密码:最后修改日期:最小间隔:最大间隔:警告期:宽限期:失效日期:保留字段`

让我们以 `mtu` 这一行为例：
`mtu:$6$anothersalt$...:19972:0:99999:7:::`

| 字段         | 示例值      | 含义                                                                |
| :--------- | :------- | :---------------------------------------------------------------- |
| **用户名**    | `mtu`    | 与 `/etc/passwd` 中的用户名对应，是两个文件关联的键。                                |
| **加密密码**   | `$6$...` | 经过哈希加盐处理的密码字符串。`$6$` 表示使用 SHA-512 加密。`!` 或 `*` 表示该账户被锁定，无法通过密码登录。 |
| **最后修改日期** | `19972`  | 从1970年1月1日算起，到最后一次修改密码时所经过的天数。                                    |
| **最小间隔**   | `0`      | 密码修改后，至少需要多少天才能再次修改。`0` 表示随时可以修改。                                 |
| **最大间隔**   | `99999`  | 密码必须被修改的最长天数（密码有效期）。`99999` 表示永不过期。                               |
| **警告期**    | `7`      | 在密码过期前多少天开始向用户发出警告。                                               |
| **宽限期**    | (空)      | 密码过期后，账户仍可用的天数。                                                   |
| **失效日期**   | (空)      | 账户彻底失效的日期（同样是从1970-01-01算起的天数）。                                   |
| **保留字段**   | (空)      | 保留给未来使用。                                                          |

-----

#### 3\. `/etc/group` - 用户组定义库

这个文件定义了系统中的用户组以及哪些用户属于这些组。它也是全局可读的。

**格式**: `组名:组密码占位符:组ID:组成员列表`

让我们以 `developers` 这一行为例：
`developers:x:2000:mtu`

| 字段 | 示例值 | 含义 |
| :--- | :--- | :--- |
| **组名** | `developers` | 组的唯一名称。 |
| **组密码占位符**| `x` | 一个占位符，表示组的密码（一个很少使用的功能）存储在 `/etc/gshadow` 文件中。 |
| **组ID (GID)** | `2000` | 组的唯一数字标识。 |
| **组成员列表** | `mtu` | 属于该组的用户名列表，用逗号分隔。这里列出的是用户的**辅助组**成员。`mtu` 的主组是 `mtu` (GID 1000)，同时他也是 `developers` 和 `docker` 组的成员。 |

-----

#### 4\. `/etc/gshadow` - 用户组安全密码库

这是 `/etc/group` 的“影子”文件，用于存放组密码（极少使用）和组管理员信息。**同样，只有 root 用户可以读取它**。

**格式**: `组名:加密的组密码:组管理员列表:组成员列表`

让我们以 `developers` 这一行为例：
`developers:!::mtu`

| 字段 | 示例值 | 含义 |
| :--- | :--- | :--- |
| **组名** | `developers` | 与 `/etc/group` 中的组名对应。 |
| **加密的组密码**| `!` | 加密的组密码哈希。`!` 表示没有设置组密码，禁止使用密码加入该组。 |
| **组管理员列表**| (空) | 一个用逗号分隔的用户名列表，这些用户有权添加或删除该组的成员。 |
| **组成员列表** | `mtu` | 与 `/etc/group` 中第四个字段的成员列表相同。 |

-----

### 总结：四个文件如何协同工作

这四个文件构成了一个完整的用户和组管理体系，让我们通过一个用户登录和文件访问的场景来理解它们的关系：

1.  **用户 `mtu` 登录**：

      * 系统读取 `/etc/passwd`，找到 `mtu` 这一行，发现密码字段是 `x`。
      * 系统接着去 `/etc/shadow` 文件中查找 `mtu`，获取其加密后的密码哈希值。
      * 系统将用户输入的密码进行同样的哈希计算，然后与 `/etc/shadow` 中存储的哈希值进行比对。如果匹配，则登录成功。

2.  **设置会话环境**：

      * 登录成功后，系统再次从 `/etc/passwd` 的 `mtu` 行获取信息：UID=1000，主GID=1000，主目录=/home/mtu，登录Shell=/bin/bash。
      * 接着，系统扫描整个 `/etc/group` 文件，查找第四个字段（成员列表）中包含 `mtu` 的所有组。在本例中，找到了 `developers` 和 `docker`。
      * 因此，`mtu` 用户的身份凭证是：UID=1000，主组GID=1000，辅助组GID列表=[2000, 999]。

3.  **访问文件**：

      * 当 `mtu` 尝试访问一个文件时，内核会检查该文件的权限。比如，一个文件属于 `developers` 组，并设置了组写权限。
      * 内核会比对文件的组ID和 `mtu` 的所有组ID（主组+辅助组）。因为 `mtu` 属于 `developers` 组，所以他将拥有对该文件的组写权限。