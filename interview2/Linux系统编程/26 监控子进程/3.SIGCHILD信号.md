#  为SIGCHILD建立信号处理程序
### 1\. 背景：为什么需要 `SIGCHLD`？

子进程的终止是一个**异步事件**，父进程不知道它何时会发生。

  * **方法1：阻塞式 `wait()`** - 父进程会卡住，无法做其他工作。这对于需要持续提供服务的程序（如Web服务器）是不可接受的。
  * **方法2：非阻塞式 `waitpid(WNOHANG)` 轮询** - 父进程需要在一个循环里不停地检查，这会浪费CPU时间，并且代码逻辑复杂。

**`SIGCHLD` 解决方案**：
当子进程终止时，内核会向其父进程发送一个 `SIGCHLD` 信号。父进程可以忽略这个信号（默认行为），也可以安装一个信号处理程序。当信号到达时，操作系统会自动中断父进程的主程序流程，转而执行这个处理程序。在处理程序中，我们就可以调用 `wait()` 来“收割”刚刚终止的子进程。这是一种高效的事件通知机制。

### 2\. 核心挑战：信号的合并问题

这是使用 `SIGCHLD` 时**必须理解**的最重要的一点。

  * **标准信号是不可靠、不排队的**。
  * **场景**：假设父进程有一个 `SIGCHLD` 处理程序。现在，有3个子进程在非常短的时间内（比如在处理程序开始执行之前）相继终止。
  * **后果**：内核会向父进程发送3次 `SIGCHLD` 信号，但由于信号处理程序正在运行（或者即将运行），父进程可能最终只“感知”到并处理**1次**信号。后续的 `SIGCHLD` 信号会被“合并”或丢弃。

**这会产生一个致命问题**：如果你的信号处理程序每次只调用一次 `wait()`，那么它只会收割一个僵尸进程，剩下的两个将成为“漏网之鱼”，永远留在系统中。

### 3\. 解决方案：在处理程序中循环调用 `waitpid()`

为了解决信号合并问题，`SIGCHLD` 处理程序的标准写法**必须包含一个循环**：

```c
// SIGCHLD 处理程序的标准模板
void sigchld_handler(int sig) {
    int saved_errno = errno; // 后面会解释为什么需要这个

    // 使用 WNOHANG 循环调用 waitpid，确保收割所有已终止的子进程
    while (waitpid(-1, NULL, WNOHANG) > 0) {
        continue;
    }

    errno = saved_errno; // 恢复 errno
}
```

**这个循环的逻辑是**：

1.  `waitpid(-1, NULL, WNOHANG)`: 等待**任何**(`-1`)已终止的子进程，不关心其状态(`NULL`)，并且**不阻塞**(`WNOHANG`)。
2.  如果 `waitpid` 返回值 `> 0`，说明成功收割了一个僵尸进程，我们继续循环，看看是否还有其他的。
3.  如果 `waitpid` 返回 `0`，说明当前已经没有已终止的子进程了，循环结束。
4.  如果 `waitpid` 返回 `-1`（并且 `errno` 不是 `ECHILD`），说明发生了错误。如果 `errno` 是 `ECHILD`，说明已经没有任何子进程了，循环也应该结束。

这个循环确保了**一次信号处理就能收割掉当前所有可收割的僵尸进程**，完美解决了信号合并问题。

### 4\. 编写健壮的 `SIGCHLD` 处理程序

除了循环，还有两个高级但重要的问题需要考虑：

1.  **可重入性与 `errno`**：

      * 信号处理程序会**随时中断**主程序的执行流程。
      * `waitpid()` 和处理程序中的其他函数可能会修改全局变量 `errno`。
      * **问题**：如果在主程序中一个系统调用失败了，主程序正准备检查 `errno` 的值时，一个 `SIGCHLD` 信号来了，处理程序中的 `waitpid()` 把 `errno` 的值给覆盖了。主程序恢复执行后，得到的 `errno` 就是错误的。
      * **解决方案**：在信号处理程序的开头保存 `errno` 的当前值，在处理程序返回前再恢复它。
        ```c
        int saved_errno = errno;
        // ... handler code ...
        errno = saved_errno;
        ```

2.  **竞争条件与 `sigsuspend()`**：

      * **问题**：父进程在主循环中通常需要等待信号。如果使用 `pause()`，会存在一个经典的竞争条件：
        ```c
        // 错误的代码
        while (numLiveChildren > 0) {
            // !!! 危险的窗口 !!!
            // 如果 SIGCHLD 信号恰好在这一瞬间到达并被处理，
            // numLiveChildren-- 变为 0。
            pause(); // 那么这个 pause() 将会永远阻塞，因为它在等待一个已经来过的信号。
        }
        ```
      * **解决方案**：使用 `sigprocmask()` 和 `sigsuspend()` 来原子性地等待信号。
        1.  在进入主循环和创建子进程**之前**，先**阻塞** `SIGCHLD` 信号。
        2.  在主循环中，使用 `sigsuspend()` 来**原子地**做两件事：(a) 解除对 `SIGCHLD` 的阻塞；(b) 挂起程序等待信号。
        3.  当 `sigsuspend` 从信号中返回后，它会自动**恢复**原来的信号掩码（即重新阻塞 `SIGCHLD`）。
        <!-- end list -->
          * 这个过程确保了在检查 `numLiveChildren` 和进入等待状态之间，`SIGCHLD` 信号不会被处理，从而消除了竞争条件。

-----

### 示例代码：程序清单 26-5 的实现

下面的代码完整实现了书中的例子，并包含了处理上述所有问题的最佳实践。

**文件名: `sigchld_handler.c`**

```c
#define _GNU_SOURCE // 为了使用 strsignal()
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
#include <signal.h>
#include <errno.h>
#include <string.h>
#include <time.h>

// 用于在处理程序和主函数之间通信的全局变量
static volatile int numLiveChildren = 0;

// 打印当前时间戳的辅助函数
static void print_time(const char *msg) {
    time_t t;
    time(&t);
    printf("%s: %s", msg, ctime(&t));
}

// SIGCHLD 信号处理程序
static void sigchld_handler(int sig) {
    int status, saved_errno;
    pid_t child_pid;

    // ① 保存 errno，防止 handler 内部的调用影响主程序
    saved_errno = errno;
    print_time("SIGCHLD handler started");

    // ② 人为延长处理程序时间，以模拟多个 SIGCHLD 信号被合并的情况
    sleep(2);

    // ③ 核心：循环调用 waitpid() 来收割所有僵尸进程
    while ((child_pid = waitpid(-1, &status, WNOHANG)) > 0) {
        printf("Handler: Reaped child %ld - ", (long)child_pid);
        // 这里可以像之前的例子一样用 WIF... 宏详细解析 status
        if (WIFEXITED(status)) {
            printf("exited with status %d\n", WEXITSTATUS(status));
        } else {
            printf("terminated abnormally\n");
        }
        numLiveChildren--;
    }

    // 如果 waitpid 返回-1且errno不是ECHILD，说明有错误
    if (child_pid == -1 && errno != ECHILD) {
        perror("waitpid");
    }

    print_time("SIGCHLD handler finished");
    errno = saved_errno; // 恢复 errno
}

int main(int argc, char *argv[]) {
    if (argc < 2 || strcmp(argv[1], "--help") == 0) {
        fprintf(stderr, "Usage: %s <sleep_time1> <sleep_time2> ...\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    // 设置 SIGCHLD 处理程序
    struct sigaction sa;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;
    sa.sa_handler = sigchld_handler;
    if (sigaction(SIGCHLD, &sa, NULL) == -1) {
        perror("sigaction");
        exit(EXIT_FAILURE);
    }

    // ④ 阻塞 SIGCHLD 信号，为后面的 sigsuspend() 做准备
    sigset_t block_mask, empty_mask;
    sigemptyset(&block_mask);
    sigaddset(&block_mask, SIGCHLD);
    if (sigprocmask(SIG_SETMASK, &block_mask, NULL) == -1) {
        perror("sigprocmask");
        exit(EXIT_FAILURE);
    }

    // 创建子进程
    numLiveChildren = argc - 1;
    for (int i = 1; i < argc; i++) {
        pid_t pid = fork();
        if (pid == -1) {
            perror("fork");
            exit(EXIT_FAILURE);
        }
        if (pid == 0) { // 子进程
            int sleep_time = atoi(argv[i]);
            sleep(sleep_time);
            printf("Child %d (PID=%ld) exiting.\n", i, (long)getpid());
            _exit(EXIT_SUCCESS);
        }
    }

    // ⑤ 等待所有子进程终止
    sigemptyset(&empty_mask);
    print_time("Parent ready to wait");

    while (numLiveChildren > 0) {
        // ⑥ 使用 sigsuspend 原子地解除阻塞并等待信号
        sigsuspend(&empty_mask);
    }

    print_time("Parent: All children have terminated.");
    exit(EXIT_SUCCESS);
}
```

**如何编译和运行:**

```bash
# 编译
gcc -o sigchld_handler sigchld_handler.c

# 运行，参数是多个子进程的休眠时间
# 使用较短的时间，让它们几乎同时退出，以观察信号合并
./sigchld_handler 1 1 1 2
```

**预期输出分析:**
你会观察到，尽管有4个子进程退出，但`SIGCHLD handler started/finished` 这对消息可能只打印了1次或2次，而不是4次。但这没关系，因为处理程序内部的 `while` 循环会确保所有4个僵尸进程都被正确地收割。这就完美地演示了 `SIGCHLD` 处理的核心模式。




# 向已停止的子进程发送SIGCHILD信号 和 忽略终止的子进程

### 核心摘要


1.  **监控范围的扩展**：`SIGCHLD` 不仅在子进程**终止**时发送，还可以在子进程**停止 (stop)** 或**恢复 (continue)** 时发送。这个行为是可以通过 `sigaction()` 的标志来控制的。
2.  **避免僵尸进程的“魔法”**：与其他信号不同，对 `SIGCHLD` 的处理方式会深刻地改变内核的行为。特别是，**显式地忽略 `SIGCHLD` 信号 (`SIG_IGN`)** 会触发内核的**自动回收机制**，让子进程在终止时不会变成僵尸进程。
3.  **历史渊源**：`SIGCHLD` (源自 BSD) 和 `SIGCLD` (源自 System V) 本是两个语义略有不同的信号，但现代 POSIX 标准采纳了 System V 的行为并统一使用了 `SIGCHLD` 这个名称。

-----

### 1\. `SIGCHLD` 的监控范围：不止是死亡通知

通常我们认为 `SIGCHLD` 是子进程的“死亡通知”，但它的功能不止于此。

  * **监控子进程停止 (Stop)**

      * 当子进程因收到 `SIGSTOP`、`SIGTSTP` 等信号而暂停执行时，内核**默认会**向父进程发送一个 `SIGCHLD` 信号。
      * **如何控制**：如果你在用 `sigaction()` 设置 `SIGCHLD` 处理程序时，指定了 `SA_NOCLDSTOP` 标志，那么内核就**不会**因为子进程停止而通知你。这让你能精确控制只关心子进程的终止事件。

  * **监控子进程恢复 (Continue)**

      * 当一个已停止的子进程因收到 `SIGCONT` 信号而恢复执行时，内核也**可以**向父进程发送一个 `SIGCHLD` 信号。这在较新版本的 Linux 内核中受支持。

**关键点**：`SIGCHLD` 是一个广义的“子进程状态变更”信号，其具体行为可以通过 `sigaction()` 的标志进行微调。

-----

### 2\. 避免僵尸进程的两种“自动化”策略

这是本节最核心、最实用的知识点。传统的做法是编写一个 `SIGCHLD` 信号处理函数，然后在其中调用 `wait()` 或 `waitpid()` 来回收子进程。但 POSIX 提供了两种更“懒”的方法。

#### 策略 A：显式忽略 `SIGCHLD` (使用 `SIG_IGN`)

这是 `SIGCHLD` 最独特的行为。

  * **默认行为 (隐式忽略)**：如果你不对 `SIGCHLD` 做任何处理，它的默认动作是“忽略”。但这种情况下，子进程终止后**依然会变成僵尸进程**，等待父进程调用 `wait()` 来回收。

  * **“魔法”行为 (显式忽略)**：如果你明确地告诉内核你要忽略这个信号，例如：

    ```c
    signal(SIGCHLD, SIG_IGN);
    // 或者使用 sigaction
    struct sigaction sa;
    sa.sa_handler = SIG_IGN;
    sigaction(SIGCHLD, &sa, NULL);
    ```

    这会触发一个特殊的内核模式：**内核会自动回收所有终止的子进程，它们根本不会进入僵尸状态**。

  * **代价**：这是一种“发射后不管”的策略。你放弃了获取子进程退出状态码的权利，因为当你想要 `wait()` 时，子进程早已被内核清理干净了。

  * **可移植性**：这是源于 System V 的行为，并已被 SUSv3/POSIX 标准化。但在非常古老的 UNIX 系统上可能不被支持。因此，**最可移植**的方法仍然是编写信号处理函数并调用 `wait()`。

#### 策略 B：使用 `SA_NOCLDWAIT` 标志

这是 SUSv3 标准引入的另一种实现自动回收的方式。

  * **如何使用**：在 `sigaction()` 的 `sa_flags` 中设置 `SA_NOCLDWAIT`。
    ```c
    struct sigaction sa;
    sa.sa_flags = SA_NOCLDWAIT;
    // ...
    sigaction(SIGCHLD, &sa, NULL);
    ```
  * **效果**：与 `SIG_IGN` 类似，它也告诉内核**不要将终止的子进程变为僵尸进程**。
  * **与 `SIG_IGN` 的细微差别**：
      * `SIG_IGN`：你明确表示“我不想收到这个信号”，所以内核**不会**向你的进程发送 `SIGCHLD` 信号。
      * `SA_NOCLDWAIT`：你没有说不想接收信号。标准规定，内核**可以**选择发送 `SIGCHLD` 信号。如果发送了，你的信号处理函数会被触发，但当你尝试在处理函数中调用 `wait()` 时，会立刻失败（返回 `ECHILD`），因为子进程已经被内核回收了。

**简单来说**：`SIG_IGN` 和 `SA_NOCLDWAIT` 都能实现自动回收。`SIG_IGN` 更像是“拒收邮件”，而 `SA_NOCLDWAIT` 更像是“邮件照收，但内容（子进程状态）已被自动处理”。

-----

### 3\. 历史渊源：`SIGCHLD` 与 `SIGCLD`

  * `SIGCHLD`：源自 BSD，是 POSIX 标准采用的名称。
  * `SIGCLD`：源自 System V，是 `SIGCHLD` 的“曾用名”。
  * **核心历史差异**：它们在处理“忽略”行为时有所不同。
      * 老 BSD 的 `SIGCHLD`：即使忽略，也会产生僵尸进程。
      * System V 的 `SIGCLD`：显式忽略，则不会产生僵尸进程。
  * **现状**：现代 POSIX 标准采纳了 **System V 的行为** 和 **BSD 的名称**。在 Linux 中，`SIGCLD` 和 `SIGCHLD` 是完全等价的同义词。

### 总结与实践建议

| 你的需求                    | 推荐策略                  | 代码实现                                                               | 优点              | 缺点                        |
| :---------------------- | :-------------------- | :----------------------------------------------------------------- | :-------------- | :------------------------ |
| **需要知道子进程的退出状态**        | **捕获信号并 `wait`**      | `sa.sa_handler = your_handler;`\<br\>`/* handler calls waitpid */` | 完全控制，可获取状态，最可移植 | 需要编写信号处理函数，逻辑稍复杂          |
| **不关心子进程状态，只想避免僵尸**     | **显式忽略 `SIGCHLD`**    | `sa.sa_handler = SIG_IGN;`                                         | 代码最简单，高效        | 无法获取子进程退出状态               |
| **不想产生僵尸，但可能想记录有子进程退出** | **使用 `SA_NOCLDWAIT`** | `sa.sa_flags = SA_NOCLDWAIT;`                                      | 内核自动回收，但仍可收到通知  | 收到通知也无法 `wait` 到子进程，有平台差异 |
| **只想关心子进程终止，不关心它停止**    | **使用 `SA_NOCLDSTOP`** | `sa.sa_flags = SA_NOCLDSTOP;`                                      | 精确控制信号来源        | 这是对已有处理程序的微调              |

对于大多数“发射后不管”的并发服务器模型，`signal(SIGCHLD, SIG_IGN);` 是一个极其简洁和高效的技巧。而对于需要监控子任务执行结果的场景，编写一个标准的 `SIGCHLD` 处理程序并调用 `waitpid()` 仍然是最好、最可靠的选择。



这个程序将演示：

1.  **默认行为**：子进程如何变成一个“僵尸进程”。
2.  **标准处理**：如何通过信号处理函数和 `waitpid()` 来正确回收子进程。
3.  **自动回收**：如何使用 `SIG_IGN` 技巧来让内核自动处理子进程，避免僵尸。
4.  **停止信号**：如何用 `SA_NOCLDSTOP` 来控制是否关心子进程的“停止”事件。

-----

### 教程代码 (`sigchld_demo.cpp`)

请将以下代码保存为 `sigchld_demo.cpp` 文件。

```cpp
#include <iostream>
#include <string>
#include <unistd.h>
#include <sys/wait.h>
#include <signal.h>
#include <string.h> // for strerror
#include <errno.h>

// --- 信号处理函数 ---
// 这是一个标准的 SIGCHLD 处理程序。
// 它使用 waitpid 循环来确保回收所有已终止的子进程。
void sigchld_handler(int sig) {
    // 写入终端在信号处理函数中技术上不安全，但用于演示很直观。
    const char* msg = "Caught SIGCHLD signal!\n";
    write(STDOUT_FILENO, msg, strlen(msg));

    int saved_errno = errno; // waitpid 可能会改变 errno
    // 使用 WNOHANG 循环，防止处理程序阻塞，并回收所有已终止的子进程
    while (waitpid(-1, NULL, WNOHANG) > 0) {
        continue;
    }
    errno = saved_errno;
}

// --- 主函数 ---
int main(int argc, char* argv[]) {
    if (argc != 2) {
        std::cerr << "Usage: " << argv[0] << " <mode>\n";
        std::cerr << "Modes:\n";
        std::cerr << "  --default : Child becomes a zombie.\n";
        std::cerr << "  --handler : Parent catches SIGCHLD and reaps child.\n";
        std::cerr << "  --ignore  : Parent sets SIG_IGN, kernel auto-reaps child.\n";
        std::cerr << "  --nostop  : Parent ignores child's STOP signal.\n";
        return 1;
    }

    std::string mode = argv[1];

    // --- 在 fork 之前设置信号处理方式 ---
    struct sigaction sa;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART; // 推荐的好习惯

    if (mode == "--handler" || mode == "--nostop") {
        sa.sa_handler = sigchld_handler;
        if (mode == "--nostop") {
            sa.sa_flags |= SA_NOCLDSTOP; // 添加 SA_NOCLDSTOP 标志
            std::cout << "[Parent] SA_NOCLDSTOP is set. Will NOT be notified of child stop.\n";
        }
        if (sigaction(SIGCHLD, &sa, NULL) == -1) {
            perror("sigaction");
            return 1;
        }
    } else if (mode == "--ignore") {
        sa.sa_handler = SIG_IGN; // 显式设置为 SIG_IGN
        if (sigaction(SIGCHLD, &sa, NULL) == -1) {
            perror("sigaction");
            return 1;
        }
        std::cout << "[Parent] SIGCHLD is set to SIG_IGN. Kernel will auto-reap child.\n";
    }
    // 对于 --default 模式，我们什么都不做，使用系统默认行为。

    // --- 创建子进程 ---
    pid_t child_pid = fork();
    if (child_pid < 0) {
        perror("fork");
        return 1;
    }

    if (child_pid == 0) {
        // --- 子进程代码 ---
        if (mode == "--nostop") {
            std::cout << "[Child] PID " << getpid() << " is stopping itself...\n";
            raise(SIGSTOP); // 发送 SIGSTOP 信号给自己
            // ... 当父进程发送 SIGCONT 后，会从这里继续 ...
            std::cout << "[Child] PID " << getpid() << " continued. Now exiting.\n";
            exit(0);
        } else {
            std::cout << "[Child] PID " << getpid() << " running for 2 seconds, then exiting.\n";
            sleep(2);
            std::cout << "[Child] PID " << getpid() << " is done.\n";
            exit(0);
        }
    } else {
        // --- 父进程代码 ---
        std::cout << "[Parent] Created child with PID " << child_pid << ".\n";

        if (mode == "--nostop") {
            std::cout << "[Parent] Waiting 5 seconds to see if SIGCHLD arrives for STOP...\n";
            sleep(5);
            std::cout << "[Parent] Sending SIGCONT to child.\n";
            kill(child_pid, SIGCONT);
            sleep(3); // 再等一会，让子进程有机会退出并发送最终的 SIGCHLD
        } else {
            if (mode == "--default") {
                std::cout << "[Parent] Waiting 5 seconds. The child should be a ZOMBIE now.\n";
                std::cout << "         => Open another terminal and run: ps -ho state -p " << child_pid << "\n";
                sleep(5);
                std::cout << "[Parent] Reaping the zombie child now...\n";
                wait(NULL);
            } else if (mode == "--ignore") {
                 std::cout << "[Parent] Waiting 5 seconds. The child should NOT be a zombie.\n";
                 std::cout << "         => Open another terminal and run: ps -p " << child_pid << "\n";
                 sleep(5);
            } else { // --handler 模式
                 std::cout << "[Parent] Waiting 5 seconds. The handler should reap the child.\n";
                 sleep(5);
            }
        }
        std::cout << "[Parent] Finished.\n";
    }

    return 0;
}
```

### 如何编译和进行实验

1.  **编译程序**:

    ```bash
    g++ -o sigchld_demo sigchld_demo.cpp
    ```

2.  **进行实验**:
    下面我们将逐一运行四种模式，并解释它们的行为。**有些实验需要你快速打开第二个终端**。

-----

#### 实验 1: 默认行为 - 僵尸进程 (`--default`)

```bash
# 在第一个终端运行
./sigchld_demo --default
```

**输出 & 操作**:
程序会打印出子进程的PID，然后让你在5秒内去检查。**立刻打开第二个终端**，并输入 `ps` 命令（将 `<child_pid>` 替换为程序显示的PID）：

```bash
# 在第二个终端输入
ps -ho state -p <child_pid>
```

你会看到一个 `Z` 或者 `Z+`，这代表**僵尸 (Zombie)** 状态！5秒后，第一个终端的父进程会调用 `wait()`，子进程被回收，程序结束。

**结论**: 在默认情况下，父进程必须调用 `wait()` 来为子进程“收尸”，否则就会产生僵尸进程。

#### 实验 2: 标准处理 (`--handler`)

```bash
# 在第一个终端运行
./sigchld_demo --handler
```

**输出 & 操作**:
这次，当子进程退出时，你会立刻看到 `Caught SIGCHLD signal!` 的消息。在父进程等待的5秒内，如果你去第二个终端用 `ps` 命令检查，会发现子进程**已经不存在了**。

**结论**: `SIGCHLD` 信号处理函数被成功触发，并调用 `waitpid()` 及时回收了子进程，没有产生僵尸。这是最标准、最可移植的处理方式。

#### 实验 3: 自动回收 (`--ignore`)

```bash
# 在第一个终端运行
./sigchld_demo --ignore
```

**输出 & 操作**:
和 `--handler` 模式一样，如果你在父进程等待的5秒内用 `ps` 去检查，子进程**也已经不存在了**。但不同的是，你**没有**看到任何 `Caught SIGCHLD signal!` 的消息。

**结论**: 将 `SIGCHLD` 的处置显式设置为 `SIG_IGN` 触发了内核的“魔法”。内核自动为你回收了子进程，整个过程悄无声息，非常高效。

#### 实验 4: 忽略停止信号 (`--nostop`)

这个实验分为两部分来对比。

**Part A: 不带 `--nostop` 标志 (修改代码)**
暂时将 `sa.sa_flags |= SA_NOCLDSTOP;` 这一行注释掉，重新编译，然后运行 `--handler` 模式并让子进程停止（你需要修改代码让子进程 `raise(SIGSTOP)`）。你会发现，当子进程停止时，父进程的 `SIGCHLD` 处理器**会被触发**。

**Part B: 正常运行 `--nostop` 模式**

```bash
# 在第一个终端运行
./sigchld_demo --nostop
```

**输出 & 操作**:
当子进程打印 "is stopping itself..." 时，父进程会等待5秒。在这期间，你**不会**看到 `Caught SIGCHLD signal!` 的消息。5秒后，父进程发送 `SIGCONT`，子进程恢复并最终退出，这时你才会看到 `Caught SIGCHLD signal!` 的消息。

**结论**: `SA_NOCLDSTOP` 标志成功地阻止了内核因子进程**停止**而向父进程发送 `SIGCHLD` 信号，但并不影响因子进程**终止**而发送的 `SIGCHLD` 信号。

通过这四个实验，你应该能非常具体地理解 `SIGCHLD` 信号背后那些丰富而强大的控制机制了。