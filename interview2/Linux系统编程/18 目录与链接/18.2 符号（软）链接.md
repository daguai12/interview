### **18.2 符号（软）链接**

**符号链接 (Symbolic Link)**，有时也称为**软链接 (soft link)**，是一种特殊的文件类型，其数据内容是**另一个文件的名称（路径）**。

与硬链接直接指向 i-node 不同，符号链接是指向一个文件路径的“快捷方式”。

  * **创建**: 在 shell 中，使用 `ln -s` 命令创建。
  * **标识**: `ls -F` 命令的输出结果中会在符号链接的尾部标记 `@` 符号。`ls -l` 的输出中，文件类型处会显示 `l`。

<!-- end list -->

```bash
$ ln -s /path/to/original/file my_link
$ ls -l my_link
lrwxrwxrwx 1 user group 25 Sep 11 09:28 my_link -> /path/to/original/file
```

#### **与硬链接的区别和优势**

  * **链接计数**: 创建符号链接**不会**增加目标文件 i-node 的链接计数。
  * **悬空链接**: 如果删除了符号链接所指向的原始文件，符号链接本身依然存在，但会失效，变成一个**悬空链接 (dangling link)**。
  * **跨文件系统**: 因为符号链接存储的是一个路径名而非 i-node 编号，所以它可以链接到位于**不同文件系统**中的文件。
  * **链接到目录**: 可以为**目录**创建符号链接。

#### **链接链路和循环限制**

符号链接之间可以形成链路（例如，a 指向 b，b 指向 c）。当系统调用遇到符号链接时，内核会对一系列链接层层**解引用 (dereference)**，直到抵达最终文件。

为了防止无限循环或因链路过长导致的堆栈溢出，内核会施加限制：

  * **链路深度**: Linux 内核限制在解析路径名中的单个组件时，最多解引用 8 次符号链接。
  * **总解引用次数**: Linux 将对一个完整路径名的总解引用次数限制为 40 次。

> **快速符号链接 (Fast Symlinks)**:
> 这是一个文件系统级别的优化。如果符号链接的目标路径名字符串很短（例如，在 ext4 上小于 60 字节），那么该字符串会直接存储在 i-node 内部，而无需为其分配一个单独的数据块。这可以节省磁盘空间并加速对符号链接的访问。

#### **系统调用对符号链接的解释**

许多系统调用都会对路径名最后的组件（文件名）进行解引用处理，从而对链接所指向的文件展开操作。还有一些系统调用则不作处理，直接操作于链接文件本身。

**约定**: 总是会对路径名中的**目录部分**（即最后一个斜线字符前的所有组成部分）的符号链接进行解引用操作。系统调用是否解引用，通常只针对路径的最后一部分。

下表对此作了总结（`✓` 表示解引用，`✗` 表示不解引用）：

| 函数                    | 是否解引用 | 备注                           |          |
| :-------------------- | :---: | :--------------------------- | -------- |
| `access()`            |   ✓   |                              |          |
| `chmod()`             |   ✓   |                              |          |
| `chown()`             |   ✓   |                              |          |
| `creat()`             |   ✓   |                              |          |
| `exec()` 系列           |   ✓   |                              |          |
| `link()`              |   ✗   |                              |          |
| `lchown()`            |   ✗   |                              |          |
| `lstat()`             |   ✗   |                              |          |
| `lutimes()`           |   ✗   |                              |          |
| `open()`              |   ✓   | 除非指定了 `O_NOFOLLOW` 或 `O_EXCL | O_CREAT` |
| `readlink()`          |   ✗   |                              |          |
| `rename()`            |   ✗   | 无论源路径还是目标路径中的链接，都不会被解引用      |          |
| `rmdir()`             |   ✗   | 若参数为符号链接，则调用失败 (`ENOTDIR`)   |          |
| `stat()`              |   ✓   |                              |          |
| `truncate()`          |   ✓   |                              |          |
| `unlink()`            |   ✗   |                              |          |
| `utime()`, `utimes()` |   ✓   |                              |          |

#### **符号链接的文件权限和所有权**

在绝大多数操作中，符号链接自身的权限和所有权都会被**忽略**。权限检查是针对其**指向的目标文件**进行的。

唯一的例外是：当在一个设置了**粘滞位 (sticky bit)** 的目录中删除或重命名一个符号链接时，系统会检查**符号链接自身**的所有权。