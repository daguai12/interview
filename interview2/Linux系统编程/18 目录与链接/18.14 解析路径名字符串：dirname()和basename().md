### **18.14 解析路径名字符串：dirname()和 basename()**

`dirname()` 和 `basename()` 库函数将一个路径名字符串分解成**目录部分**和**文件名部分**。这两个函数与 `dirname(1)` 和 `basename(1)` shell 命令的功能相类似。

```c
#include <libgen.h>

char *dirname(char *pathname);
char *basename(char *pathname);
```

例如，给定路径名为 `/home/britta/prog.c`：

  * `dirname()` 将返回字符串 `"/home/britta"`。
  * `basename()` 将返回字符串 `"prog.c"`。

#### **操作规则与边界情况**

  * 忽略 `pathname` 中尾部的斜线字符 (`/`)。
  * 如果 `pathname` 中未包含斜线，那么 `dirname()` 返回 `"."`，`basename()` 返回 `pathname` 自身。
  * 如果 `pathname` 仅由一个 `/` 组成，那么 `dirname()` 和 `basename()` 均返回 `"/"`。
  * 如果 `pathname` 为 `NULL` 指针或空字符串，那么 `dirname()` 和 `basename()` 均返回 `"."`。

下表所示为 `dirname()` 和 `basename()` 针对各种示例路径名所返回的字符串。

**表 18-3：`dirname()` 和 `basename()` 返回的字符串示例**

| 路径名字符串           | `dirname()` | `basename()` |
| :--------------- | :---------- | :----------- |
| `///`            | `/`         | `/`          |
| `/usr/bin/zip`   | `/usr/bin`  | `zip`        |
| `/etc/passwd///` | `/etc`      | `passwd`     |
| `/etc////passwd` | `/etc`      | `passwd`     |
| `etc/passwd`     | `etc`       | `passwd`     |
| `passwd`         | `.`         | `passwd`     |
| `passwd/.`       | `passwd`    | `.`          |
| `.`              | `.`         | `.`          |
| `..`             | `.`         | `..`         |
| `NULL`           | `.`         | `.`          |

#### **重要警告**

使用这两个函数时必须注意以下两点：

1.  **函数会修改输入字符串**: `dirname()` 和 `basename()` **均可修改** `pathname` 所指向的字符串。因此，如果希望保留原有的路径名字符串，就必须向它们传递该字符串的**副本**。
2.  **返回值可能指向静态内存**: 两个函数所返回的指针可能指向经由**静态分配**的字符数组。这意味着对**相同函数**的后续调用可能会覆盖之前调用的结果。

-----

#### **程序示例**

程序清单 18-5 演示了 `dirname()` 和 `basename()` 的正确、安全用法，即通过 `strdup()` 创建字符串副本再进行操作。

**程序清单 18-5：`dirname()` 和 `basename()` 的应用**

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <libgen.h>

int main(int argc, char *argv[]) {
    char *path_copy1, *path_copy2;
    char *dname, *bname;

    if (argc < 2 || strcmp(argv[1], "--help") == 0) {
        fprintf(stderr, "Usage: %s <path>...\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    for (int i = 1; i < argc; i++) {
        // 创建两个副本，因为 dirname 和 basename 都可能修改输入
        path_copy1 = strdup(argv[i]);
        if (path_copy1 == NULL) {
            perror("strdup");
            exit(EXIT_FAILURE);
        }

        path_copy2 = strdup(argv[i]);
        if (path_copy2 == NULL) {
            perror("strdup");
            exit(EXIT_FAILURE);
        }

        dname = dirname(path_copy1);
        bname = basename(path_copy2);

        printf("Path: \"%s\" ==> dirname: \"%s\", basename: \"%s\"\n",
               argv[i], dname, bname);
        
        // 释放 strdup() 分配的内存
        free(path_copy1);
        free(path_copy2);
    }

    exit(EXIT_SUCCESS);
}
```

**编译和运行演示:**

```bash
# 编译程序
$ gcc dirname_basename_demo.c -o demo

# 运行并提供一些测试路径
$ ./demo /usr/lib/ ./a.out file.txt /
Path: "/usr/lib/" ==> dirname: "/usr", basename: "lib"
Path: "./a.out" ==> dirname: ".", basename: "a.out"
Path: "file.txt" ==> dirname: ".", basename: "file.txt"
Path: "/" ==> dirname: "/", basename: "/"
```

这个程序清晰地展示了如何通过创建副本的方式来安全地使用 `dirname()` 和 `basename()`，从而避免了原始输入字符串被修改的问题。