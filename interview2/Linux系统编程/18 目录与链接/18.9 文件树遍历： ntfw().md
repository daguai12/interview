好的，这是根据您提供的文本内容，保留原始结构和标题整理的结果，并附上一个完整的代码案例。

### **18.9 文件树遍历：nftw()**

`nftw()` 函数允许程序对整个目录子树进行递归遍历，并为子树中的每个文件执行由程序员定义的函数。它是对老函数 `ftw()` 的加强版，新程序应优先考虑使用 `nftw()`。

```c
#define _XOPEN_SOURCE 500
#include <ftw.h>

int nftw(const char *dirpath,
         int (*func)(const char *pathname, const struct stat *statbuf,
                     int typeflag, struct FTW *ftwbuf),
         int nopenfd, int flags);
```

  * **`dirpath`**: 遍历的起始目录路径。
  * **`func`**: 一个回调函数，`nftw()` 会对树中的每个文件调用一次此函数。
  * **`nopenfd`**: `nftw()` 在遍历时可同时使用的文件描述符数量的最大值。在现代系统中，可以设置一个较大的值（如 10 或更多）。
  * **`flags`**: 一个位掩码，由 0 个或多个下列常量进行“或”(`|`)运算组成，用于修正函数的操作。

#### **flags 参数**

  * **`FTW_CHDIR`**: 在处理一个目录的内容之前，先 `chdir()` 进入该目录。
  * **`FTW_DEPTH`**: 执行**后序遍历 (post-order traversal)**。即先处理完一个目录下的所有文件和子目录，**最后**再处理该目录自身。
  * **`FTW_MOUNT`**: 不会跨越到另一个文件系统。
  * **`FTW_PHYS`**: “物理”遍历，即**不解引用**（跟随）符号链接。默认情况下，`nftw()` 会解引用符号链接。

#### **回调函数 `func`**

`nftw()` 为每个文件调用 `func` 时会传递 4 个参数：

1.  **`pathname`**: 文件的完整路径名。
2.  **`statbuf`**: 指向该文件的 `stat` 结构体的指针。
3.  **`typeflag`**: 提供文件类型信息的整数，其值可能是：
      * `FTW_D`: 这是一个目录。
      * `FTW_DNR`: 这是一个不可读的目录。
      * `FTW_DP`: 一个目录，其所有后代都已被处理（仅当使用 `FTW_DEPTH` 时出现）。
      * `FTW_F`: 一个普通文件（或设备、FIFO等）。
      * `FTW_NS`: `stat()` 调用失败。
      * `FTW_SL`: 一个符号链接（仅当使用 `FTW_PHYS` 时出现）。
      * `FTW_SLN`: 一个悬空的符号链接。
4.  **`ftwbuf`**: 指向 `FTW` 结构的指针，包含 `base` (文件名在 `pathname` 中的偏移量) 和 `level` (当前条目在树中的深度) 两个字段。

`func` 的返回值会控制 `nftw()` 的行为：

  * **返回 0**: 继续遍历。
  * **返回非 0 值**: 立即停止遍历，`nftw()` 也会将这个非 0 值作为自己的返回值。

-----

#### **程序示例**

程序清单 18-3 展示了 `nftw()` 的使用，它以层级缩进方式显示一个目录树中的文件。

**程序清单 18-3：使用 `nftw()` 遍历目录树**

```c
#define _XOPEN_SOURCE 500
#include <ftw.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// 回调函数，用于打印每个文件/目录的信息
static int dirTree(const char *pathname, const struct stat *sbuf,
                   int type, struct FTW *ftwb) {
    // 打印缩进
    for (int i = 0; i < ftwb->level; i++) {
        printf("  ");
    }

    // 根据文件类型打印 '?' 标记
    if (type == FTW_NS) {
        printf("? ");
    } else {
        switch (sbuf->st_mode & S_IFMT) {
        case S_IFREG:  printf("- "); break;
        case S_IFDIR:  printf("d "); break;
        case S_IFCHR:  printf("c "); break;
        case S_IFBLK:  printf("b "); break;
        case S_IFLNK:  printf("l "); break;
        case S_IFIFO:  printf("p "); break;
        case S_IFSOCK: printf("s "); break;
        default:       printf("? "); break;
        }
    }
    
    // 打印 i-node 编号和文件名
    printf("%7ld %s\n", (long) sbuf->st_ino, &pathname[ftwb->base]);
    
    return 0; // 继续遍历
}

int main(int argc, char *argv[]) {
    int flags = 0;

    if (argc > 1 && strcmp(argv[1], "-d") == 0) {
        flags |= FTW_DEPTH;
        argv++;
        argc--;
    }
    if (argc > 1 && strcmp(argv[1], "-p") == 0) {
        flags |= FTW_PHYS;
        argv++;
        argc--;
    }

    if (nftw((argc > 1) ? argv[1] : ".", dirTree, 10, flags) == -1) {
        perror("nftw");
        exit(EXIT_FAILURE);
    }
    
    exit(EXIT_SUCCESS);
}
```

**编译和运行演示**

1.  **准备环境**:

    ```bash
    $ gcc nftw_demo.c -o nftw_demo
    $ mkdir -p d1/d2
    $ touch d1/f1 d1/d2/f2
    $ ln -s d1/f1 s1
    ```

2.  **默认遍历 (跟随符号链接):**

    ```bash
    $ ./nftw_demo .
    d  131603 .
      d  131604 d1
        d  131605 d2
          -  131607 f2
        -  131606 f1
      -  131606 s1
    ```

    (注意：`s1` 和 `d1/f1` 的 i-node 编号相同，因为 `s1` 被解引用了)

3.  **使用 `FTW_PHYS` (不跟随) 和 `FTW_DEPTH` (后序) 遍历:**

    ```bash
    $ ./nftw_demo -p -d .
        d  131605 d2
          -  131607 f2
        -  131606 f1
      d  131604 d1
      l  131608 s1
    d  131603 .
    ```

    (注意：`s1` 被识别为 `l` (链接)，且其 i-node 编号与 `f1` 不同。同时，目录 `d1` 和 `.` 在其内容之后被打印出来，这是后序遍历的效果。)

-----

#### **nftw() 的 FTW\_ACTIONRETVAL 标识**

glibc 允许在 `flags` 中指定一个额外的非标准标志 `FTW_ACTIONRETVAL` (需要定义 `_GNU_SOURCE`)。这会改变 `nftw()` 对回调函数返回值的解释方式，允许更精细地控制遍历：

  * `FTW_CONTINUE`: 继续处理。
  * `FTW_SKIP_SIBLINGS`: 不再处理当前目录中的其他同级条目。
  * `FTW_SKIP_SUBTREE`: 如果当前条目是目录，则不进入该子树。
  * `FTW_STOP`: 立即停止整个遍历。