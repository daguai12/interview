### **18.13 解析路径名：realpath()**

`realpath()` 库函数将一个路径名 `pathname` 解析为一个绝对路径名。在这个过程中，它会完成以下工作：

  * **解引用 (dereference)** 路径中所有的符号链接。
  * **解析**路径中所有的 `.` (当前目录) 和 `..` (父目录) 引用。

最终生成一个以空字符结尾的、规范化的绝对路径名字符串。

```c
#include <stdlib.h> // 在 glibc 中
#include <limits.h> // For PATH_MAX

char *realpath(const char *pathname, char *resolved_path);
```

  * **`pathname`**: 待解析的输入路径名。
  * **`resolved_path`**: 用于存放结果的缓冲区。调用者必须确保该缓冲区足够大，长度至少应为 `PATH_MAX` 个字节。
  * **返回值**:
      * 成功时，返回一个指向 `resolved_path` 的指针。
      * 失败时（例如路径中的某个组件不存在），返回 `NULL`。

> **glibc 扩展**:
> glibc 的 `realpath()` 实现允许调用者将 `resolved_path` 参数指定为 `NULL`。这时，`realpath()` 会自动 `malloc` 一个足够大的缓冲区，并将指向该缓冲区的指针作为结果返回。在这种情况下，**调用者必须自行调用 `free()` 来释放该缓冲区**。此行为后被 SUSv4 标准化。

-----

#### **程序示例**

以下程序演示了如何结合使用 `readlink()` 和 `realpath()` 来首先读取符号链接的内容，然后将该链接解析为一个绝对路径名。

**程序清单 18-4：读取并解析一个符号链接**

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <limits.h> // For PATH_MAX

int main(int argc, char *argv[]) {
    char readlink_buf[PATH_MAX];
    char realpath_buf[PATH_MAX];
    ssize_t numBytes;

    if (argc != 2 || strcmp(argv[1], "--help") == 0) {
        fprintf(stderr, "Usage: %s <symlink-path>\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    // --- 1. 使用 readlink() 读取符号链接的内容 ---
    numBytes = readlink(argv[1], readlink_buf, PATH_MAX - 1);
    if (numBytes == -1) {
        perror("readlink");
        exit(EXIT_FAILURE);
    }
    readlink_buf[numBytes] = '\0'; // 手动添加 null 终止符
    printf("readlink: '%s' -> '%s'\n", argv[1], readlink_buf);

    // --- 2. 使用 realpath() 解析符号链接 ---
    // realpath 会自动处理解引用和路径解析
    if (realpath(argv[1], realpath_buf) == NULL) {
        perror("realpath");
        exit(EXIT_FAILURE);
    }
    printf("realpath: '%s' -> '%s'\n", argv[1], realpath_buf);

    exit(EXIT_SUCCESS);
}
```

**编译和运行演示**

1.  **准备环境**:

    ```bash
    # 编译程序
    gcc resolve_link.c -o resolve_link

    # 创建一个目录结构和相对路径的符号链接
    mkdir -p dir1/dir2
    touch dir1/a.txt
    cd dir1
    ln -s ../dir1/a.txt link_to_a
    cd .. 
    ```

    现在我们在当前目录下有一个 `dir1` 目录，`dir1` 内部有一个符号链接 `link_to_a`，它通过 `../` 指向了自身所在的目录中的 `a.txt` 文件。

2.  **运行程序来解析这个链接**:

    ```bash
    ./resolve_link dir1/link_to_a
    ```

3.  **预期输出**:

    ```
    readlink: 'dir1/link_to_a' -> '../dir1/a.txt'
    realpath: 'dir1/link_to_a' -> '/path/to/current/directory/dir1/a.txt'
    ```

      * `readlink()` 忠实地返回了符号链接的**原始内容**，即相对路径 `../dir1/a.txt`。
      * `realpath()` 则完成了所有的解析工作，将这个复杂的相对路径转换成了一个**绝对的、规范化的路径名**。