### **18.12 改变进程的根目录：chroot()**

每个进程都有一个**根目录**，该目录是其解析绝对路径（即以 `/` 开始的路径）时的起点。默认情况下，这是文件系统的真实根目录。特权级进程（需要 `CAP_SYS_CHROOT` 能力）可以通过 `chroot()` 系统调用来改变自身的根目录。

```c
#include <unistd.h>

int chroot(const char *pathname);
```

`chroot()` 系统调用将调用进程的根目录改为由 `pathname` 指定的目录。从此以后，对该进程而言，所有绝对路径名的解释都将以这个新位置作为起点。由于这会将应用程序限定于文件系统的特定区域，因此这种机制也被称为设立了一个 **chroot 监禁区 (chroot jail)**。

  * **典型应用**: `ftp` 服务器是应用 `chroot()` 的典型实例。当用户以匿名方式登录时，`ftp` 程序会调用 `chroot()` 将该会话的根目录设置为一个专门为匿名用户准备的目录。这样，用户将被“困”在这个新的根目录下，无法访问文件系统中的其他部分。
  * **查看进程根目录**: 可以通过读取 Linux 专有的 `/proc/PID/root` 符号链接的内容来获取任何进程的根目录。

#### **`chroot` 的局限性和安全问题**

`chroot()` 系统调用从未被视为一个完全安全的监禁机制。

**1. 运行依赖问题**
大多数程序都是动态链接的，依赖于共享库。要在 `chroot` 监禁区中运行这些程序，必须将所需的共享库目录（如 `/lib`）和相关文件复制或通过**绑定挂载**（见 14.9.4 节）的方式提供到监禁区内部。

**2. 特权级进程的逃逸**
一个在监禁区内运行的**特权级进程**可以轻易地“越狱”。例如，它可以自己创建一个设备文件（如 `/dev/mem`），并通过该设备来直接访问物理内存，从而绕过所有文件系统限制。因此，通常不应在 `chroot` 监禁区内放置 set-user-ID-root 程序。

**3. 非特权级进程的逃逸路线**
即使对于非特权进程，也必须小心防范如下几条可能的“越狱”路线：

  * **当前工作目录 (CWD) 未改变**
    `chroot()` 调用本身并**不会**改变进程的当前工作目录。如果调用 `chroot()` 时，进程的 CWD 位于监禁区之外，那么该进程仍然可以通过相对路径（如 `../..`）访问监禁区之外的文件。

      * **防范**: 必须在调用 `chroot()` 之后立即调用 `chdir("/")`，将当前工作目录切换到新的根目录。
        ```c
        chroot("/path/to/jail");
        chdir("/"); 
        ```

  * **已打开的文件描述符**
    如果进程在调用 `chroot()` **之前**就已经持有一个指向监禁区外某个目录的打开文件描述符，那么它可以利用 `fchdir()` “越狱”。

    ```c
    // 假设 fd 指向监禁区外的某个目录
    fchdir(fd);  // 成功将 CWD 切换到监禁区外
    chroot("/path/to/jail"); // 此时 chroot 已无意义，因为 CWD 已经在外
    ```

      * **防范**: 在调用 `chroot()` 之前，必须关闭所有可能指向监禁区外目录的文件描述符。

  * **通过套接字接收文件描述符**
    一个被监禁的进程仍然可以通过 UNIX 域套接字，从另一个未被监禁的协作进程那里接收一个指向监禁区外目录的文件描述符。一旦拿到这个描述符，它就可以通过 `fchdir()` 逃逸。这是最难防范的一种方式。

> **更好的替代方案**:
> 一些 BSD 衍生系统提供了 `jail()` 系统调用，它解决了 `chroot()` 的许多安全问题，能够创建即使对特权级进程也安全的监禁区。