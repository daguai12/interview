### **18.10 进程的当前工作目录**

一个进程的**当前工作目录 (current working directory, CWD)** 定义了该进程解析相对路径名的起点。新进程的当前工作目录继承自其父进程。

#### **获取当前工作目录**

进程可使用 `getcwd()` 来获取当前工作目录的绝对路径。

```c
#include <unistd.h>

char *getcwd(char *cwdbuf, size_t size);
```

  * **`cwdbuf`**: 一个由调用者预先分配的缓冲区，用于存放获取到的路径名字符串。
  * **`size`**: `cwdbuf` 缓冲区的大小。调用者必须确保该空间足够大（通常使用 `PATH_MAX` 常量作为其大小）。
  * **返回值**:
      * 成功时，返回指向 `cwdbuf` 的指针。
      * 如果当前工作目录的路径名长度超过 `size` 个字节，`getcwd()` 会返回 `NULL`，并将 `errno` 置为 `ERANGE`。

> **glibc 扩展 (非可移植)**:
> 若 `cwdbuf` 为 `NULL` 且 `size` 为 0，则 `glibc` 封装的 `getcwd()` 会自动分配一个足够大的缓冲区，并将指向该缓冲区的指针作为函数返回值。调用者之后必须调用 `free()` 来释放这一缓冲区。**为保证可移植性，应用程序应避免依赖此特性**。

> **其他函数**:
> GNU C 函数库还提供了 `getwd()` 和 `get_current_dir_name()`。`getwd()` 容易引起缓冲区溢出，已被废弃；`get_current_dir_name()` 则不具有可移植性。因此，`getcwd()` 是获取当前工作目录的最佳选择。

> **Linux 专有方法**:
> 只要具有合适的权限，就可通过读取（`readlink()`）Linux 专有符号链接 `/proc/PID/cwd` 的内容来确定任何进程的当前工作目录。

#### **改变当前工作目录**

`chdir()` 和 `fchdir()` 系统调用用于改变进程的当前工作目录。

  * **`chdir()`**

    ```c
    #include <unistd.h>
    int chdir(const char *pathname);
    ```

    将当前工作目录改变为由 `pathname` 指定的路径。如果 `pathname` 是符号链接，则会对其解引用。

  * **`fchdir()`**

    ```c
    #include <unistd.h>
    int fchdir(int fd);
    ```

    作用与 `chdir()` 相同，只是它使用一个已打开的、指向目录的**文件描述符 `fd`** 来指定目标目录。

##### **保存和恢复当前工作目录**

在程序中，一个常见的操作是临时切换到另一个目录执行某些任务，然后再切换回原始目录。`fchdir()` 提供了一种更健壮的方式来实现这一点，因为文件描述符是稳定的，而路径名可能会被改变。

**使用 `fchdir()` 的方法 (推荐):**

```c
int fd_cwd;

// 1. 获取指向当前目录的文件描述符并保存
fd_cwd = open(".", O_RDONLY);

// 2. 切换到新目录
chdir("/path/to/new_dir");

/* ... 在新目录中执行操作 ... */

// 3. 切换回原始目录
fchdir(fd_cwd);
close(fd_cwd);
```

**使用 `chdir()` 的方法:**

```c
char old_cwd[PATH_MAX];

// 1. 获取当前目录的路径名并保存
getcwd(old_cwd, PATH_MAX);

// 2. 切换到新目录
chdir("/path/to/new_dir");

/* ... 在新目录中执行操作 ... */

// 3. 切换回原始目录
chdir(old_cwd);
```