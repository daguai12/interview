### **18.4 更改文件名：rename()**

借助于 `rename()` 系统调用，既可以重命名文件，又可以将文件移至**同一文件系统**中的另一目录。

```c
#include <stdio.h>

int rename(const char *oldpath, const char *newpath);
```

该调用会将 `oldpath` 重命名为 `newpath`。这是一个原子操作，只操作目录条目，而**不移动文件数据**本身。因此，它不影响指向该文件的其他硬链接，也不影响持有该文件打开描述符的任何进程。

#### **调用规则**

以下规则适用于对 `rename()` 的调用：

  * **覆盖行为**: 若 `newpath` 已经存在，它将被 `oldpath` **原子地覆盖（替换）**。

  * **指向同一文件**: 若 `oldpath` 与 `newpath` 是指向同一文件的两个硬链接，则 `rename()` 调用成功，但**不发生任何变化** (`oldpath` 不会被移除)。

  * **符号链接**: `rename()` 系统调用对其两个参数中的符号链接**均不进行解引用**。

      * 如果 `oldpath` 是一个符号链接，那么将重命名该**符号链接本身**。
      * 如果 `newpath` 是一个符号链接，那么该符号链接将被**删除**，并由 `oldpath` 取代。

  * **文件移动**: 如果 `oldpath` 是一个文件，那么 `newpath` 不能是一个已存在的目录名 (会返回 `EISDIR` 错误)。要想将文件移动到另一目录，`newpath` 必须包含新的完整路径名。例如，以下调用既将一个文件移动到另一目录中，同时又将其改名：

    ```c
    // 将 a.txt 移动到 /tmp 目录下，并重命名为 b.txt
    rename("a.txt", "/tmp/b.txt");
    ```

  * **目录重命名**:

      * 如果 `oldpath` 是一个目录，那么 `newpath` 必须要么不存在，要么是一个**空目录**的名称。
      * 如果 `newpath` 是一个已有文件或一个**非空目录**，调用将出错（分别返回 `ENOTDIR` 和 `ENOTEMPTY`）。

  * **路径前缀限制**: `newpath` 不能是 `oldpath` 的子目录。例如，不能将 `/home/mtk` 重命名为 `/home/mtk/bin` (会返回 `EINVAL` 错误)。

  * **同一文件系统限制**: `oldpath` 和 `newpath` 所指代的文件**必须位于同一个文件系统**。这是因为 `rename()` 仅操作目录条目（硬链接），而硬链接不能跨越文件系统。试图将文件重命名至不同的文件系统将返回 `EXDEV` 错误。

    > `mv` 命令在遇到 `EXDEV` 错误时，会自动切换到“复制文件内容到新文件系统，然后删除源文件”的模式来完成跨文件系统的移动。