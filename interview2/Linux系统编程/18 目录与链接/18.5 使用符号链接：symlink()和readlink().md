### **18.5 使用符号链接：symlink()和 readlink()**

本节介绍用于创建符号链接，以及检查其内容的系统调用。

#### **symlink()**

`symlink()` 系统调用会创建一个新的符号链接。

```c
#include <unistd.h>

int symlink(const char *filepath, const char *linkpath);
```

  * **`filepath`**: 符号链接所**指向**的目标文件路径名。这个字符串将成为符号链接文件的内容。
  * **`linkpath`**: 要**创建**的符号链接本身的路径名。
  * **移除符号链接**: 使用 `unlink()` 调用。
  * **错误**: 若 `linkpath` 中给定的路径名已然存在，则调用失败，`errno` 被置为 `EEXIST`。
  * **目标存在性**: 调用 `symlink()` 时，由 `filepath` 所命名的文件或目录**无需存在**。如果目标文件不存在，创建出的链接就是一个“悬空链接”。

#### **readlink()**

`readlink()` 系统调用用于获取符号链接本身的内容，即其所指向的路径名字符串，而**不会**对链接进行解引用。

```c
#include <unistd.h>

ssize_t readlink(const char *pathname, char *buf, size_t bufsiz);
```

  * **`pathname`**: 符号链接文件的路径名。
  * **`buf`**: 用于存放读取到的路径名字符串的缓冲区。
  * **`bufsiz`**: 缓冲区 `buf` 的大小。
  * **返回值**: 如果成功，返回实际放入 `buf` 中的字节数。

**重要注意事项:**

1.  **截断**: 如果符号链接的内容长度超过 `bufsiz`，则置于 `buf` 中的是经**截断**处理的字符串，返回值将等于 `bufsiz`。
2.  **无空字符结尾**: `readlink()` **不会**在 `buf` 的尾部自动添加终止空字符 (`\0`)。

由于以上两点，如果 `readlink()` 的返回值恰好等于 `bufsiz`，程序将无法分辨返回的字符串是恰好填满了缓冲区，还是被截断了。为稳妥起见，并正确处理字符串，最佳实践是：

1.  使用一个足够大的缓冲区（例如 `PATH_MAX`，定义于 `<limits.h>`）。
2.  在调用 `readlink()` 之后，根据其返回值手动在缓冲区的末尾添加 `\0`。

-----

#### **程序示例**

程序清单 18-4 演示了 `readlink()` 的正确用法。

**程序清单 18-4：使用 `readlink()`**

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/stat.h>
#include <limits.h> // For PATH_MAX

int main(int argc, char *argv[]) {
    char buf[PATH_MAX];
    ssize_t numBytes;

    if (argc != 2 || strcmp(argv[1], "--help") == 0) {
        fprintf(stderr, "Usage: %s <symlink-path>\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    // 调用 readlink() 读取符号链接的内容
    numBytes = readlink(argv[1], buf, PATH_MAX - 1); // 留一个位置给 '\0'
    if (numBytes == -1) {
        perror("readlink");
        exit(EXIT_FAILURE);
    }

    // 手动添加终止空字符
    buf[numBytes] = '\0';

    printf("'%s' -> '%s'\n", argv[1], buf);

    exit(EXIT_SUCCESS);
}
```

**编译和运行演示:**

1.  **准备环境:**

    ```bash
    # 编译程序
    gcc readlink_demo.c -o readlink_demo

    # 创建一个文件和一个指向它的符号链接
    touch original_file.txt
    ln -s original_file.txt my_link

    # 创建一个指向绝对路径的链接
    ln -s /usr/bin/gcc gcc_link
    ```

2.  **运行程序查看链接内容:**

    ```bash
    # 查看第一个链接
    ./readlink_demo my_link
    # 输出: 'my_link' -> 'original_file.txt'

    # 查看第二个链接
    ./readlink_demo gcc_link
    # 输出: 'gcc_link' -> '/usr/bin/gcc'
    ```