### **18.3 创建和移除（硬）链接：link()和 unlink()**

`link()` 和 `unlink()` 系统调用分别创建和移除硬链接。

#### **link()**

`link()` 系统调用将以 `newpath` 参数所指定的路径名，为 `oldpath` 指定的已存在文件创建一个新链接。

```c
#include <unistd.h>

int link(const char *oldpath, const char *newpath);
```

  * 如果 `newpath` 指定的路径名已然存在，则 `link()` 不会将其覆盖，而是会返回一个 `EEXIST` 错误。
  * **对符号链接的处理 (可移植性问题)**:
      * **Linux 行为**: `link()` **不会**对符号链接进行解引用。若 `oldpath` 是一个符号链接，则 `newpath` 会被创建为指向该**符号链接文件自身**的一个全新硬链接。
      * **SUSv3 规范**: 要求 `link()` **应该**对符号链接进行解引用。大多数其他 UNIX 实现遵循此规范。
      * **结论**: 鉴于实现间的这种差异，为保障程序的可移植性，应避免将 `link()` 的 `oldpath` 参数指定为符号链接。

#### **unlink()**

`unlink()` 系统调用移除一个链接（即删除一个文件名）。如果此链接是指向文件的最后一个链接，那么还将移除文件本身（见下文）。

```c
#include <unistd.h>

int unlink(const char *pathname);
```

  * `unlink()` **不能**用于移除一个目录，完成该任务需要使用 `rmdir()`。
    > **可移植性问题**: 若对一个目录调用 `unlink()`，SUSv3 规定 `errno` 应置为 `EPERM`，但在 Linux 中，`errno` 会被置为 `EISDIR`。
  * `unlink()` **不会**对符号链接进行解引用。若 `pathname` 为符号链接，则移除的是链接本身，而非链接指向的文件。

#### **仅当关闭所有文件描述符时，方可删除一个已打开的文件**

这是一个非常重要的 UNIX 文件系统特性。内核除了为每个 i-node 维护链接计数之外，还对文件的**打开文件描述符**进行计数。

  * **规则**: 当移除指向文件的最后一个链接时（即链接计数降为 0），如果仍有进程持有指代该文件的打开文件描述符，那么在关闭所有此类描述符之前，系统实际上**不会**删除该文件的数据块。
  * **妙用 (临时文件技巧)**: 基于上述事实，可以实现一个可靠的临时文件方案：
    1.  创建一个临时文件并以 `open()` 打开它。
    2.  **立即**调用 `unlink()` 取消与该文件名的链接。
    3.  程序继续通过已打开的文件描述符使用该文件。
    4.  当程序终止或关闭该文件描述符时，内核会自动清理并删除该文件，因为此时文件的链接计数为 0 且打开文件描述符计数也降为 0。这确保了临时文件总能被清理，即使程序异常崩溃。

-----

#### **程序示例**

程序清单 18-1 对“unlink 一个已打开文件”的现象做了展示。

**程序清单 18-1：使用 `unlink()` 移除一个链接**

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/stat.h>

#define FILENAME "temp_file"
#define DUMMY_DATA "hello"
#define BLOCK_SIZE 1024

int main(int argc, char *argv[]) {
    int fd;
    int num_blocks = (argc > 1) ? atoi(argv[1]) : 10000;
    char *buf[BLOCK_SIZE];

    // 1. 创建并打开文件
    fd = open(FILENAME, O_WRONLY | O_CREAT | O_EXCL, S_IRUSR | S_IWUSR);
    if (fd == -1) {
        perror("open");
        exit(EXIT_FAILURE);
    }
    printf("File '%s' opened with fd = %d\n", FILENAME, fd);

    // 2. 立即 unlink 文件
    if (unlink(FILENAME) == -1) {
        perror("unlink");
        exit(EXIT_FAILURE);
    }
    printf("File '%s' has been unlinked.\n", FILENAME);
    printf(">> Check with 'ls': the file should be gone.\n");

    // 3. 写入数据到已 unlinked 但仍打开的文件
    printf("Writing %d blocks to the file...\n", num_blocks);
    for (int i = 0; i < num_blocks; i++) {
        if (write(fd, buf, BLOCK_SIZE) != BLOCK_SIZE) {
            fprintf(stderr, "write error\n");
            exit(EXIT_FAILURE);
        }
    }

    // 4. 显示磁盘使用情况，可以看到空间已被占用
    printf(">> Disk space consumed. Check with 'df .'\n");
    system("df .");

    // 5. 关闭文件描述符
    if (close(fd) == -1) {
        perror("close");
        exit(EXIT_FAILURE);
    }
    printf("File descriptor closed.\n");

    // 6. 再次显示磁盘使用情况，可以看到空间已被释放
    printf(">> Disk space should now be freed. Check with 'df .'\n");
    system("df .");

    exit(EXIT_SUCCESS);
}
```

**编译和运行演示:**

```bash
# 编译程序
$ gcc unlink_demo.c -o unlink_demo

# 运行程序，让它写入 10000 个 1KB 的块 (约 10MB)
$ ./unlink_demo 10000
File 'temp_file' opened with fd = 3
File 'temp_file' has been unlinked.
>> Check with 'ls': the file should be gone.
Writing 10000 blocks to the file...
>> Disk space consumed. Check with 'df .'
Filesystem     1K-blocks      Used Available Use% Mounted on
/dev/sda1      102398456  50183356  52215100  49% /
>> File descriptor closed.
>> Disk space should now be freed. Check with 'df .'
Filesystem     1K-blocks      Used Available Use% Mounted on
/dev/sda1      102398456  50173356  52225100  49% /
```

从 `df` 命令的两次输出中可以看到，当文件描述符被关闭后，`Used`（已用）空间减少了 10000 个 1K-blocks，证明了文件数据被内核自动清除了。