### **18.8 读目录：opendir()和 readdir()**

本节所述的库函数可用于打开一个目录，并逐一获取其包含文件的名称。这些函数是对 Linux 底层系统调用 `getdents()` 的封装，提供了更易于使用的接口。

#### **核心函数**

  * **`opendir()`**: 打开一个目录

    ```c
    #include <dirent.h>
    DIR *opendir(const char *dirpath);
    ```

    该函数打开由 `dirpath` 指定的目录，并返回一个指向 `DIR` 类型结构的指针。该结构即所谓的**目录流 (directory stream)**，用作后续函数的句柄。成功打开后，目录流指向目录列表的首条记录。

  * **`readdir()`**: 从目录流中读取一个条目

    ```c
    struct dirent *readdir(DIR *dirp);
    ```

    每调用一次 `readdir()`，就会从 `dirp` 指代的目录流中读取下一条目录记录，并返回一个指向**静态分配**的 `dirent` 结构体的指针。**注意**：由于是静态分配，下一次调用 `readdir()` 会覆盖该结构体的内容。

    `dirent` 结构体包含的主要信息如下：

    ```c
    struct dirent {
        ino_t  d_ino;       /* Inode number */
        char   d_name[256]; /* Null-terminated filename */
    };
    ```

    > **非标准但有用的 `d_type` 字段**:
    > 在 Linux 和 BSD 系统上，`dirent` 结构体还包含一个 `d_type` 字段，用于标识文件类型（如 `DT_REG` 代表常规文件，`DT_DIR` 代表目录）。使用此字段可以避免为确定文件类型而额外调用 `lstat()`，从而提升性能。但并非所有文件系统都支持此特性。

  * **`closedir()`**: 关闭目录流

    ```c
    int closedir(DIR *dirp);
    ```

    该函数关闭由 `dirp` 指代的目录流，并释放其使用的资源。

  * **`rewinddir()`**: 重置目录流

    ```c
    void rewinddir(DIR *dirp);
    ```

    该函数可将目录流 `dirp` 回移到起点，以便下一次调用 `readdir()` 将从目录的第一个文件开始读取。

#### **错误处理**

当 `readdir()` 到达目录结尾或发生错误时，都会返回 `NULL`。为了区分这两种情况，应采用以下编码模式：

```c
errno = 0; // 在循环前重置 errno
while ((entry = readdir(dirp)) != NULL) {
    // 处理 entry
}
if (errno != 0) {
    // 发生了错误
    perror("readdir");
}
// else, 到达了目录结尾
```

#### **相关函数**

  * **`fdopendir()`**: 功能与 `opendir()` 类似，但它接收一个已打开的目录的文件描述符作为参数。
  * **`dirfd()`**: 返回与目录流 `dirp` 相关联的文件描述符。
  * **`scandir()`**: 一个非标准的、但被广泛支持的函数，可以获取经过排序处理的文件列表。

> `opendir()` 会为其关联的文件描述符自动设置 **close-on-exec** 标志，以确保当执行 `exec()` 时自动关闭该文件描述符。

-----

#### **程序示例**

程序清单 18-2 使用 `opendir()`、`readdir()` 和 `closedir()` 函数来列出由命令行参数所指定目录的内容。

**程序清单 18-2：扫描一个目录**

```c
#include <dirent.h>
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>

static void listFiles(const char *dirpath) {
    DIR *dirp;
    struct dirent *dp;

    dirp = opendir(dirpath);
    if (dirp == NULL) {
        fprintf(stderr, "opendir failed on '%s'", dirpath);
        perror("");
        return;
    }

    // 循环读取目录条目
    errno = 0; // 重置 errno 以便区分 EOF 和错误
    while ((dp = readdir(dirp)) != NULL) {
        printf("%s\n", dp->d_name);
    }

    if (errno != 0) {
        perror("readdir");
    }

    if (closedir(dirp) == -1) {
        perror("closedir");
    }
}

int main(int argc, char *argv[]) {
    if (argc == 1) {
        listFiles("."); // 如果没有参数，列出当前目录
    } else {
        for (int i = 1; i < argc; i++) {
            listFiles(argv[i]);
        }
    }
    exit(EXIT_SUCCESS);
}
```

**编译和运行演示:**

```bash
# 编译程序
$ gcc list_files.c -o list_files
# 运行程序，列出 /bin 目录的部分内容
$ ./list_files /bin | head
.
..
bash
cat
chmod
chown
cp
date
dd
df
```

-----

#### **可重入版本：readdir\_r()**

`readdir_r()` 是 `readdir()` 的可重入（线程安全）变体。其关键差异在于它使用由调用者分配的缓冲区 `entry` 来返回目录条目信息，而不是使用静态分配的结构。

```c
int readdir_r(DIR *dirp, struct dirent *entry, struct dirent **result);
```

由于 `dirent` 结构中 `d_name` 字段的大小在不同 UNIX 系统上实现不一（有些系统将其定义为 1 字节数组），为确保可移植性，应以如下方式动态分配 `dirent` 结构：

```c
#include <stddef.h> // For offsetof()

size_t len = offsetof(struct dirent, d_name) + NAME_MAX + 1;
struct dirent *entry = malloc(len);
// ... 使用 entry ...
free(entry);
```

`offsetof()` 宏可以安全地计算出结构中 `d_name` 字段的偏移量，从而正确地为整个结构（包括足够长的文件名空间）分配内存。