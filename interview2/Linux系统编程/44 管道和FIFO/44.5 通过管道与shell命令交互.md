### **44.5 通过管道与 shell 命令进行通信：popen()**

管道的一个常见用途是执行一个 shell 命令，并以编程方式读取其输出或向其发送输入。`popen()` 和 `pclose()` 函数简化了这个任务。

#### **`popen()`**

`popen()` 函数会创建一个管道，然后 `fork()` 一个子进程来执行 shell，而 shell 又会执行 `command` 字符串中指定的命令。

```c
#include <stdio.h>

FILE *popen(const char *command, const char *type);
```

  * **`command`**: 要执行的 shell 命令字符串。
  * **`type`**: 一个字符串，确定通信方向：
      * **`"r"`**: 调用进程可以**读取** `command` 的**标准输出**。
      * **`"w"`**: 调用进程可以**写入** `command` 的**标准输入**。
  * **返回值**: 成功时，返回一个可供 `stdio` 库函数（如 `fgets()`, `fputs()`）使用的文件流指针 (`FILE *`)。失败时返回 `NULL`。

**数据流示意图 (对应原文图 44-4):**

  * **当 `type` 为 `"r"` 时:**
    `[ Shell Command ] --stdout--> [ Pipe ] --stdin--> [ Calling Process ]`
  * **当 `type` 为 `"w"` 时:**
    `[ Calling Process ] --stdout--> [ Pipe ] --stdin--> [ Shell Command ]`

#### **`pclose()`**

`pclose()` 函数用于关闭由 `popen()` 创建的管道，并等待子进程中的 shell 终止。

```c
#include <stdio.h>

int pclose(FILE *stream);
```

  * **注意**: 必须使用 `pclose()` 而不是 `fclose()` 来关闭 `popen()` 返回的流，因为 `pclose()` 还会负责 `wait()` 子进程。
  * **返回值**: 成功时，返回子进程中 shell 的终止状态。如果发生错误（例如，无法获取子进程状态），则返回 -1。

#### **与 `system()` 的对比**

`popen()` 在方便性上与 `system()` 类似，但它们之间存在显著差异：

1.  **并发性**: 使用 `system()` 时，调用进程会被阻塞直到命令执行完毕。而使用 `popen()` 时，调用进程与被执行的命令是**并行运行**的。
2.  **信号处理 (`SIGINT`, `SIGQUIT`)**: `popen()` **不会**忽略这些信号。当从键盘产生这些信号时，它们会被同时发送给调用进程和被执行的命令（因为它们通常在同一个前台进程组中）。
3.  **`SIGCHLD` 处理**: `popen()` **不会**阻塞 `SIGCHLD` 信号。这意味着，如果调用进程在调用 `pclose()` 之前执行了 `wait()`，它可能会意外地“收获”了 `popen()` 创建的子进程。这会导致后续的 `pclose()` 调用失败，并将 `errno` 设置为 `ECHILD`。

> **安全警告**: 与 `system()` 一样，在特权进程（如 set-user-ID 程序）中**永远都不应该使用 `popen()`**，因为它会带来严重的安全风险。

-----

#### **程序示例**

程序清单 44-5 演示了如何使用 `popen()` 来执行 `ls` 命令，从而实现文件名通配（globbing）。

**程序清单 44-5：使用 `popen()` 通配文件名模式**

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <sys/wait.h>

#define POPEN_FMT "/bin/ls -d %s 2> /dev/null"
#define PAT_SIZE 50
#define CMD_SIZE (sizeof(POPEN_FMT) + PAT_SIZE)

int main(int argc, char *argv[]) {
    char pat[PAT_SIZE];
    char cmd[CMD_SIZE];
    FILE *fp;
    char buf[1024];

    for (;;) {
        // ② 重复读取一个文件名通配符模式
        printf("pattern: ");
        fflush(stdout);
        if (fgets(pat, PAT_SIZE, stdin) == NULL) {
            break; // EOF
        }
        
        // 移除末尾的换行符
        size_t len = strlen(pat);
        if (len > 0 && pat[len - 1] == '\n') {
            pat[len - 1] = '\0';
        }

        // ③ 输入检测，防止命令注入
        for (char *p = pat; *p != '\0'; p++) {
            if (!isalnum((unsigned char) *p) && strchr("_*?-. ", *p) == NULL) {
                printf("Bad characters in pattern\n");
                continue;
            }
        }
        
        // ①④ 构建 shell 命令
        snprintf(cmd, CMD_SIZE, POPEN_FMT, pat);

        // ⑤ 使用 popen() 获取命令的输出
        fp = popen(cmd, "r");
        if (fp == NULL) {
            perror("popen");
            continue;
        }

        // 读取并打印输出
        while (fgets(buf, sizeof(buf), fp) != NULL) {
            printf("%s", buf);
        }

        // 关闭管道并获取终止状态
        int status = pclose(fp);
        printf("    pclose() status = %d\n", status);
    }

    exit(EXIT_SUCCESS);
}
```

**运行演示**

```bash
# 编译程序
$ gcc popen_glob.c -o popen_glob

# 运行程序
$ ./popen_glob
pattern: *.c
new_session_with_terminal.c
popen_glob.c
    pclose() status = 0
pattern: non_existent*
    pclose() status = 256
pattern: ^D  <-- 按下 Ctrl-D 结束
$ 
```

##### **关于输入检测的重要性**

程序中的输入检测至关重要。如果忽略了检测，恶意用户可以输入如下内容：

```
pattern: x; rm -rf *
```

程序会构建并执行命令 `ls -d x; rm -rf * 2> /dev/null`，这将导致**灾难性的后果**。因此，在使用 `popen()` 或 `system()` 执行根据用户输入构建的 shell 命令时，**永远都需要做严格的输入检测**。