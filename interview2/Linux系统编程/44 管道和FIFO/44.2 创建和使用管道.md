### 44.2 创建和使用管道

#### 创建管道

使用 `pipe()` 系统调用来创建一个新的管道。

```c
#include <unistd.h>
int pipe(int filedes[2]);
```

  * **返回值**: 成功时返回 0，失败时返回 -1。
  * **参数 `filedes`**: 这是一个包含两个整数的数组。调用成功后：
      * `filedes[0]` 是管道的**读取端**文件描述符。
      * `filedes[1]` 是管道的**写入端**文件描述符。

创建管道后，写入 `filedes[1]` 的数据可以立即从 `filedes[0]` 读取。数据 I/O 可以通过 `read()` 和 `write()` 系统调用完成。

#### 在进程间使用管道

管道最常见的用途是实现两个相关进程之间的通信。标准流程如下：

1.  **创建管道**: 父进程调用 `pipe()`。
2.  **创建子进程**: 父进程调用 `fork()`。子进程会继承父进程打开的文件描述符，因此父子进程现在都拥有对管道两端的访问权限。
3.  **关闭不用的文件描述符**: 为了建立单向数据流并确保正确的行为，每个进程都应关闭其不使用的管道文件描述符。
      * 如果父进程要向子进程发送数据，那么父进程应关闭管道的读取端 (`filedes[0]`)，而子进程应关闭管道的写入端 (`filedes[1]`)。
      * 反之亦然。

#### 为什么要关闭不用的文件描述符？

这是一个至关重要的步骤，原因如下：

  * **对于读取进程**:

      * 读取进程必须关闭其持有的管道**写入端**描述符。
      * 这样，当所有其他写入进程关闭其写入端后，读取进程在读完管道中所有数据后才能看到\*\*文件结束（EOF）\*\*标志（`read()` 返回 0）。
      * 如果不关闭，即使管道已空，`read()` 也会被永久阻塞，因为它认为自己（读取进程）仍然可能向管道写入数据。

  * **对于写入进程**:

      * 写入进程必须关闭其持有的管道**读取端**描述符。
      * 这样，如果管道的另一端（读取端）被所有进程关闭，而写入进程仍试图写入，内核会向该进程发送 `SIGPIPE` 信号（默认情况下会终止进程）。
      * 如果进程捕获或忽略了 `SIGPIPE`，`write()` 操作会失败并返回 `EPIPE` 错误（"Broken pipe"），这是一种有用的状态指示。
      * 如果不关闭，当所有读取进程都退出后，写入进程可能会写满整个管道，然后被永久阻塞。

  * **资源释放**:

      * 只有当所有引用管道的文件描述符都被关闭后，内核才会销毁该管道并释放其占用的资源。

#### 管道通信的范围

管道主要用于**相关进程**之间的通信。这意味着这些进程必须拥有一个共同的祖先进程，由该祖先进程创建管道，然后通过一系列的 `fork()` 调用将管道的文件描述符传递给后代进程（如父子、爷孙或兄弟进程之间）。

#### Linux 特有的 `pipe2()`

从 Linux 内核 2.6.27 开始，提供了非标准的 `pipe2()` 系统调用。它与 `pipe()` 功能相同，但增加了一个 `flags` 参数，可以用来：

  * **`O_CLOEXEC`**: 为新创建的文件描述符设置 "close-on-exec" 标记。
  * **`O_NONBLOCK`**: 将文件描述符设置为非阻塞模式，避免了额外的 `fcntl()` 调用。