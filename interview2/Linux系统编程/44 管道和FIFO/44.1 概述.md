好的，这是对您提供的关于管道的文本的概述。

### 管道（Pipe）概述

在 shell 环境中，管道是一种常见的进程间通信（IPC）机制，它允许一个进程的输出直接作为另一个进程的输入。例如，在命令 `ls | wc -l` 中，shell会创建两个进程（`ls` 和 `wc`），并通过一个管道将它们连接起来。`ls` 进程的标准输出会写入管道，而 `wc` 进程则从管道中读取其标准输入。这两个进程本身并不知道管道的存在，它们只是与各自的标准文件描述符进行交互。

以下是管道的几个核心特征：

1.  **字节流:**
    * 管道中的数据是无边界的字节流，没有消息或记录的概念。
    * 读取进程可以读取任意大小的数据块，而与写入进程写入的数据块大小无关。
    * 数据是顺序传输的，读取顺序与写入顺序完全一致，并且无法使用 `lseek()` 进行随机访问。

2.  **读取行为:**
    * 当管道为空时，任何试图从管道读取数据的操作都会被**阻塞**，直到有数据被写入。
    * 如果管道的写入端被关闭，读取进程在读完管道中所有剩余数据后，会接收到文件结束的信号（即 `read()` 返回 0）。

3.  **单向性:**
    * 数据在管道中是单向流动的。它有一个写入端和一个读取端。
    * 虽然某些系统实现了双向管道（流管道），但这并非 UNIX 标准。作为替代方案，可以使用标准的 `socketpair()` 来实现双向通信。

4.  **原子写入:**
    * 当有多个进程同时向一个管道写入数据时，可以保证写入操作的原子性，前提是每次写入的数据量不超过 `PIPE_BUF` 字节。这意味着数据不会与其他进程写入的数据发生交错。
    * `SUSv3` 标准要求 `PIPE_BUF` 至少为 512 字节。这个值在不同的 UNIX 系统上有所不同，例如在 Linux 上，其值为 4096 字节。
    * 如果写入的数据量超过 `PIPE_BUF`，内核可能会将数据分割成多个片段进行传输，这可能导致与其它进程的数据发生交叉。

5.  **有限的容量:**
    * 管道是在内核内存中实现的一个缓冲区，其容量是有限的。
    * 一旦管道被写满，后续的写入操作将会被**阻塞**，直到读取进程从管道中消费掉一部分数据为止。
    * 管道的容量在不同系统和内核版本中是不同的。例如，在 Linux 内核 2.6.11 之前，容量通常是 4096 字节，而从 2.6.11 开始，增加到了 65,536 字节。
    * 从 Linux 2.6.35 开始，可以通过 `fcntl()` 系统调用来修改管道的容量。