### **44.7 FIFO**

从语义上来讲，**FIFO (First-In, First-Out)** 与管道类似，它们之间最大的差别在于 **FIFO 在文件系统中拥有一个名称**，并且其打开方式与打开一个普通文件是一样的。这使得 FIFO 可以被用于**非相关进程**之间的通信（例如，客户端和服务器进程）。

FIFO 有时候也被称为**命名管道 (named pipe)**。

  * **创建与识别**:

      * **Shell 命令**: `mkfifo [options] pathname`
        ```bash
        $ mkfifo my_fifo
        $ ls -l my_fifo
        prw-r--r-- 1 user group 0 Sep 15 11:00 my_fifo
        ```
        `ls -l` 的输出中，文件类型为 `p` (pipe)。
      * **库函数**:
        ```c
        #include <sys/stat.h>
        int mkfifo(const char *pathname, mode_t mode);
        ```
        `mode` 参数指定了新 FIFO 的权限，这些权限会受到进程 `umask` 的影响。

  * **I/O 操作**:
    一旦打开了 FIFO，就能像操作普通文件一样，使用 `read()`、`write()` 和 `close()` 等系统调用。数据以“先入先出”的顺序被读取。与管道一样，当所有引用 FIFO 的文件描述符都被关闭之后，所有未被读取的数据都会被丢弃。

#### **打开 FIFO 的阻塞语义**

打开一个 FIFO 具备一些不寻常的、用于同步的语义：

  * 一个进程以**只读**模式 (`O_RDONLY`) 打开 FIFO，将会**阻塞**，直到另一个进程以**只写**模式 (`O_WRONLY`) 打开同一个 FIFO 为止。
  * 反之，一个进程以**只写**模式打开 FIFO，将会**阻塞**，直到另一个进程以**只读**模式打开它为止。

这个特性为读写进程提供了一个简单的同步点。

> **注意**: 在 Linux 上，可以通过指定 `O_RDWR` 标记来绕过打开 FIFO 时的阻塞行为，但这是一种**非可移植**的技术，并且会导致读取进程永远看不到文件结束（EOF），因此**不应使用**。标准的、避免阻塞的方法是使用 `O_NONBLOCK` 标记。

-----

#### **示例：使用 FIFO 和 `tee(1)` 创建分支管道**

标准的 shell 管道是线性的。但通过结合使用 FIFO 和 `tee` 命令，可以在管道线中创建分支，让数据流同时被多个进程处理。

`tee` 命令会将其从标准输入读取到的数据复制两份并输出：一份写入到**标准输出**，另一份写入到通过命令行参数指定的**文件**中。

**演示**:
下面的 shell 会话创建了一个名为 `myfifo` 的 FIFO，然后在后台启动一个 `wc` 命令来读取它。接着，执行一条管道线，将 `ls` 的输出发送给 `tee`，`tee` 会将输出一份传递给 `sort`，另一份写入 `myfifo` 供 `wc` 读取。

```bash
# 1. 创建 FIFO
$ mkfifo myfifo

# 2. 在后台启动一个消费者进程，它会阻塞在这里等待写入者
$ wc -l < myfifo &
[1] 12345

# 3. 启动主管道线
$ ls -l | tee myfifo | sort -k5n
# (sort 的输出会显示在这里...)
# (wc 的输出会显示在这里...)
[1]+  Done                    wc -l < myfifo
```

**工作流程图 (对应原文图 44-5):**

1.  `ls -l` 的输出被管道传给 `tee`。
2.  `tee` 将收到的数据**同时**发送到两个地方：
      * **标准输出**: 通过管道传给 `sort` 命令进行排序。
      * **文件 `myfifo`**: `wc -l` 进程之前已打开 `myfifo` 并被阻塞，现在它接收到数据，解除阻塞，并开始统计行数。
3.  最终，`sort` 和 `wc` 并行地处理了 `ls -l` 的同一份输出。
![[Pasted image 20250915105631.png]]