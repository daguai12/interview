### **44.8 使用管道实现一个客户端/服务器应用程序**

本节将介绍一个使用 FIFO 进行进程间通信（IPC）的客户端/服务器应用程序。服务器提供的服务是：向每个发送请求的客户端返回一个唯一的、递增的序列号。

#### **应用程序概述**

在这个应用中，通信模型如下：

  * **一个服务器 FIFO**: 所有客户端使用一个**众所周知**的 FIFO（例如 `/tmp/seqnum_sv`）来向服务器发送请求。
  * **多个客户端 FIFO**: 每个客户端都需要创建一个**唯一的** FIFO 来接收服务器的响应，以防止客户端之间互相读取对方的响应。
  * **命名约定**: 客户端根据一个模板和自身的进程 ID (PID) 来创建自己的 FIFO（例如 `/tmp/seqnum_cl.12345`）。客户端在发送请求时会将自己的 PID 告知服务器。

**通信流程图 (对应原文图 44-6)**:
![[Pasted image 20250915111212.png]]
#### **消息边界问题 (Message Boundaries)**

由于 FIFO 和管道中的数据是**字节流**，消息之间没有天然的边界。当多个客户端向同一个 FIFO 发送消息时，必须约定一种规则来分隔消息。常见的方法有：

1.  **分隔符**: 每条消息以特殊字符（如换行符）结束。读取时需要逐字节扫描。
2.  **固定头部+长度**: 每条消息包含一个固定大小的头部，头部内有一个字段指明了后续消息体的长度。
3.  **固定长度消息**: 所有消息都使用相同的、固定的长度。这种方法最简单，但可能浪费带宽（短消息需要填充），且如果客户端发送了错误长度的消息，后续的解析可能会全部错乱。

本章的示例应用程序将使用**第三种技术**，即固定长度的消息。
![[Pasted image 20250915111354.png]]

-----

#### **头文件**

程序清单 44-6 定义了客户端和服务器共用的常量和数据结构。



**程序清单 44-6：`fifo_seqnum.h`**

```c
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>

#define SERVER_FIFO "/tmp/seqnum_sv"

// 客户端 FIFO 名称模板 (PID 会被加在后面)
#define CLIENT_FIFO_TEMPLATE "/tmp/seqnum_cl.%ld"

// 客户端 FIFO 名称的最大长度
#define CLIENT_FIFO_NAME_LEN (sizeof(CLIENT_FIFO_TEMPLATE) + 20)

// 客户端 -> 服务器的请求结构体
struct request {
    pid_t pid;      // 客户端的 PID
    int seqLen;     // 想要的序列号长度
};

// 服务器 -> 客户端的响应结构体
struct response {
    int seqNum;     // 序列号的起始值
};
```

-----

#### **服务器程序**

程序清单 44-7 是服务器的代码。这是一个迭代式服务器，它一次处理一个客户端请求。

**程序清单 44-7：`fifo_seqnum_server.c`**

```c
#include "fifo_seqnum.h"

int main(int argc, char *argv[]) {
    int serverFd, dummyFd, clientFd;
    char clientFifo[CLIENT_FIFO_NAME_LEN];
    struct request req;
    struct response resp;
    int seqNum = 0;

    // ① 创建服务器的众所周知的 FIFO
    umask(0); // 确保权限正确
    if (mkfifo(SERVER_FIFO, S_IRUSR | S_IWUSR | S_IWGRP) == -1 && errno != EEXIST) {
        perror("mkfifo server");
        exit(EXIT_FAILURE);
    }

    // ② 打开 FIFO 以便读取 (会阻塞直到第一个客户端连接)
    serverFd = open(SERVER_FIFO, O_RDONLY);
    if (serverFd == -1) {
        perror("open server fifo read");
        exit(EXIT_FAILURE);
    }
    
    // ③ 再次打开 FIFO 以便写入
    // 这是为了确保即使所有客户端都关闭了写入端，服务器也不会在读取时看到 EOF
    dummyFd = open(SERVER_FIFO, O_WRONLY);
    if (dummyFd == -1) {
        perror("open server fifo write");
        exit(EXIT_FAILURE);
    }
    
    // ④ 忽略 SIGPIPE 信号
    if (signal(SIGPIPE, SIG_IGN) == SIG_ERR) {
        perror("signal");
        exit(EXIT_FAILURE);
    }
    
    // ⑤ 循环处理客户端请求
    for (;;) {
        if (read(serverFd, &req, sizeof(struct request)) != sizeof(struct request)) {
            fprintf(stderr, "Error reading request; discarding\n");
            continue; // 读取错误或部分读取，丢弃并继续
        }

        // ⑥ 构建客户端 FIFO 的名称
        snprintf(clientFifo, CLIENT_FIFO_NAME_LEN, CLIENT_FIFO_TEMPLATE, (long) req.pid);
        
        // ⑦ 打开客户端 FIFO
        clientFd = open(clientFifo, O_WRONLY);
        if (clientFd == -1) { // 如果打开失败，记录日志并继续
            fprintf(stderr, "open %s error", clientFifo);
            continue;
        }

        // 发送响应
        resp.seqNum = seqNum;
        if (write(clientFd, &resp, sizeof(struct response)) != sizeof(struct response)) {
            fprintf(stderr, "Error writing to FIFO %s\n", clientFifo);
        }
        
        if (close(clientFd) == -1) {
            perror("close client fifo");
        }
        
        seqNum += req.seqLen; // 更新序列号
    }
}
```

-----

#### **客户端程序**

程序清单 44-8 是客户端的代码。它会创建一个自己的 FIFO，向服务器发送请求，然后等待并读取响应。

**程序清单 44-8：`fifo_seqnum_client.c`**

```c
#include "fifo_seqnum.h"

static char clientFifo[CLIENT_FIFO_NAME_LEN];

// ① 退出处理器，确保客户端 FIFO 总能被删除
static void removeFifo(void) {
    unlink(clientFifo);
}

int main(int argc, char *argv[]) {
    int serverFd, clientFd;
    struct request req;
    struct response resp;
    
    if (argc > 1 && strcmp(argv[1], "--help") == 0) {
        fprintf(stderr, "Usage: %s [seq-len]\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    // ② 创建自己的 FIFO
    umask(0);
    snprintf(clientFifo, CLIENT_FIFO_NAME_LEN, CLIENT_FIFO_TEMPLATE, (long) getpid());
    if (mkfifo(clientFifo, S_IRUSR | S_IWUSR | S_IWGRP) == -1 && errno != EEXIST) {
        perror("mkfifo client");
        exit(EXIT_FAILURE);
    }
    
    // ③ 注册退出处理器
    if (atexit(removeFifo) != 0) {
        perror("atexit");
        exit(EXIT_FAILURE);
    }
    
    // ④ 构建请求消息
    req.pid = getpid();
    req.seqLen = (argc > 1) ? atoi(argv[1]) : 1;
    
    // ⑤ 打开服务器 FIFO 并发送请求
    serverFd = open(SERVER_FIFO, O_WRONLY);
    if (serverFd == -1) {
        perror("open server fifo");
        exit(EXIT_FAILURE);
    }
    
    // ⑥
    if (write(serverFd, &req, sizeof(struct request)) != sizeof(struct request)) {
        fprintf(stderr, "Can't write to server\n");
        exit(EXIT_FAILURE);
    }
    
    // ⑦ 打开自己的 FIFO 并读取响应
    clientFd = open(clientFifo, O_RDONLY);
    if (clientFd == -1) {
        perror("open client fifo");
        exit(EXIT_FAILURE);
    }
    
    // ⑧
    if (read(clientFd, &resp, sizeof(struct response)) != sizeof(struct response)) {
        fprintf(stderr, "Can't read response from server\n");
        exit(EXIT_FAILURE);
    }
    
    printf("Sequence number: %d\n", resp.seqNum);
    exit(EXIT_SUCCESS);
}
```

-----

#### **运行演示**

1.  **编译程序**:

    ```bash
    $ gcc fifo_seqnum_server.c -o fifo_server
    $ gcc fifo_seqnum_client.c -o fifo_client
    ```

2.  **在一个终端中启动服务器**:

    ```bash
    $ ./fifo_server
    # (服务器会阻塞在这里，等待客户端连接)
    ```

3.  **在另一个（或多个）终端中启动客户端**:

    ```bash
    # 客户端 1 (请求默认长度 1)
    $ ./fifo_client
    Sequence number: 0

    # 客户端 2 (请求长度 5)
    $ ./fifo_client 5
    Sequence number: 1

    # 客户端 3 (请求默认长度 1)
    $ ./fifo_client
    Sequence number: 6 
    ```

**解读**: 第一个客户端请求后，序列号变为 1。第二个客户端请求了长度为 5 的序列，所以服务器返回了当前的序列号 `1`，并将下一个可用的序列号更新为 `1 + 5 = 6`。第三个客户端请求时，就得到了 `6`。