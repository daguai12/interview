
### **44.10 管道和 FIFO 中 read()和 write()的语义**

本节总结了在管道和 FIFO 上执行 `read()` 和 `write()` 系统调用时的具体行为，特别是 `O_NONBLOCK` 标志如何影响这些行为。

#### **`read()` 操作的语义**

下表总结了从一个包含 `p` 字节数据的管道或 FIFO 中，尝试读取 `n` 字节数据时的各种情况。

| 是否启用 `O_NONBLOCK` | `p = 0` (空), 写入端打开 | `p = 0` (空), 写入端关闭 | `0 < p < n` (数据不足) | `p >= n` (数据足够) |
| :---------------- | :----------------- | :----------------- | :----------------- | :-------------- |
| **否 (阻塞模式)**      | **阻塞**             | 返回 0 (EOF)         | 读取 `p` 字节          | 读取 `n` 字节       |
| **是 (非阻塞模式)**     | **失败 (EAGAIN)**    | 返回 0 (EOF)         | 读取 `p` 字节          | 读取 `n` 字节       |

**总结**:
阻塞和非阻塞 `read()` 之间唯一的差别在于：当管道或 FIFO 中**没有数据**，但其**写入端仍然被打开**时。
* 在这种情况下，普通的 `read()` 会**阻塞**，等待数据到来。
* 而非阻塞的 `read()` 会立即**失败**，并返回 `EAGAIN` 错误。

#### **`write()` 操作的语义**

当 `O_NONBLOCK` 标记与 `PIPE_BUF` 限制（保证写入原子性，见 44.3 节）共同起作用时，`write()` 的行为会变得更加复杂。

**表 44-3：`write()` 操作的语义**

| 是否启用 `O_NONBLOCK` | 写入大小 `n <= PIPE_BUF`                                         | 写入大小 `n > PIPE_BUF`                                                   | 读取端已关闭              |
| :---------------- | :----------------------------------------------------------- | :-------------------------------------------------------------------- | :------------------ |
| **否 (阻塞模式)**      | **原子地**写入 `n` 字节；如果管道空间不足，**会阻塞**直到有足够空间。                    | 写入 `n` 字节；如果管道空间不足，**会阻塞**。数据**不保证**是原子的，可能会与其他进程写入的数据发生交叉。           | **SIGPIPE + EPIPE** |
| **是 (非阻塞模式)**     | 如果空间足以立即写入 `n` 字节，则**原子地**成功写入；否则**立即失败 (EAGAIN)**，不会执行部分写入。 | 如果有空间，则执行**部分写入**（返回 1 到 `n` 之间的字节数）；如果**完全没有空间**，则**立即失败 (EAGAIN)**。 | **SIGPIPE + EPIPE** |

**总结**:
* **`write()` 到一个没有读取者的管道或 FIFO**：无论是否阻塞，进程都会收到 `SIGPIPE` 信号，并且 `write()` 调用会失败，`errno` 被置为 `EPIPE`。
* **非阻塞 `write()`**:
    * 当写入的数据量**小于等于 `PIPE_BUF`** 时，为保证原子性，`write()` 要么一次性成功写入所有数据，要么在空间不足时直接失败返回 `EAGAIN`，绝不会只写入一部分。
    * 当写入的数据量**大于 `PIPE_BUF`** 时，写入操作无需是原子的。因此，`write()` 会尽可能多地传输字节（**部分写**），直到填满管道。如果管道已满，导致连一个字节都无法传输，那么 `write()` 才会失败并返回 `EAGAIN`。