### **44.9 非阻塞 I/O**

前面曾经提过，当一个进程打开 FIFO 的一端时，如果另一端还没有被打开，那么该进程会被阻塞。通过在调用 `open()` 时指定 `O_NONBLOCK` 标记，可以使 `open()` 调用不阻塞。

`O_NONBLOCK` 标记只在 FIFO 的另一端尚未被打开时才起作用。具体产生的影响则依赖于打开 FIFO 是用于读取还是写入：

  * **为读取而打开 (`O_RDONLY | O_NONBLOCK`)**:

      * `open()` 调用会**立即成功返回**，即使当前没有任何进程打开该 FIFO 的写入端。
      * 这是因为，在这种情况下，后续的 `read()` 调用只会返回 0（表示文件结束），直到有写入者出现为止，这种行为本身是安全的。

  * **为写入而打开 (`O_WRONLY | O_NONBLOCK`)**:

      * `open()` 调用会**立即失败**，并将 `errno` 设置为 `ENXIO`。
      * 这样做是因为，向一个没有读取者的 FIFO 写入数据会导致 `write()` 调用失败并产生 `SIGPIPE` 信号。因此，内核在 `open()` 阶段就直接阻止了这种情况的发生。

下表对打开 FIFO 的语义进行了总结。

**表 44-1：在 FIFO 上调用 `open()` 的语义**

| 打开目的 | 额外标记         | FIFO 另一端已打开 | FIFO 另一端未打开    |
| :--- | :----------- | :---------- | :------------- |
| 读取   | 无 (阻塞)       | 立即成功        | **阻塞**         |
| 读取   | `O_NONBLOCK` | 立即成功        | **立即成功**       |
| 写入   | 无 (阻塞)       | 立即成功        | **阻塞**         |
| 写入   | `O_NONBLOCK` | 立即成功        | **失败 (ENXIO)** |

#### **使用 O\_NONBLOCK 的原因**

在打开 FIFO 时使用 `O_NONBLOCK` 标记主要有两个目的：

1.  **允许单个进程打开 FIFO 的两端**:
    一个进程可以先以 `O_RDONLY | O_NONBLOCK` 方式打开 FIFO（此调用会立即成功），然后再以 `O_WRONLY` 方式打开同一 FIFO（此调用也会立即成功，因为读取端已被打开）。

2.  **防止进程间产生死锁 (Deadlock)**:
    当两个进程互相等待对方完成某个动作时，会产生死锁。
    **死锁场景示意图 (对应原文图 44-8):**

![[Pasted image 20250915111827.png]]


    在上图中，进程 X 等待 Y 打开 `fifo1` 的写入端，而进程 Y 等待 X 打开 `fifo2` 的写入端，两者都无法继续执行。通过让其中一个或两个进程在第一步打开时使用 `O_NONBLOCK` 标记，就可以避免阻塞，从而解决这个死锁问题。

#### **在已打开的文件描述符上修改 O\_NONBLOCK 标志**

`O_NONBLOCK` 标记不仅会影响 `open()`，也会影响后续的 `read()` 和 `write()` 调用。有时，我们需要在一个已经打开的文件描述符上动态地启用或禁用非阻塞模式（例如，一个从 `pipe()` 返回的文件描述符）。这可以通过 `fcntl()` 系统调用来完成。

**启用 `O_NONBLOCK` 标记的代码片段:**

```c
int flags;

// 获取当前文件状态标志
flags = fcntl(fd, F_GETFL); 
if (flags == -1) { /* handle error */ }

// 添加 O_NONBLOCK 标志
flags |= O_NONBLOCK;

// 设置新的文件状态标志
if (fcntl(fd, F_SETFL, flags) == -1) { /* handle error */ }
```

**禁用 `O_NONBLOCK` 标记的代码片段:**

```c
int flags;

// 获取当前文件状态标志
flags = fcntl(fd, F_GETFL);
if (flags == -1) { /* handle error */ }

// 移除 O_NONBLOCK 标志
flags &= ~O_NONBLOCK;

// 设置新的文件状态标志
if (fcntl(fd, F_SETFL, flags) == -1) { /* handle error */ }
```