下面我把书上的说明整理成一个 **可编译的示例程序**（等价于你提到的清单 44-4），并按你偏好的“分步函数/逐行”风格详细解释每一步的目的、常见陷阱与防御性写法。代码示例把 `ls` 的输出通过管道送给 `wc -l`（等同 shell 中的 `ls | wc -l`）。

# 代码：用管道把 `ls` 连接到 `wc -l`

```c
// pipe_ls_wc.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
#include <errno.h>

int main(void) {
    int pfd[2]; // pfd[0] - 读端，pfd[1] - 写端

    if (pipe(pfd) == -1) {
        perror("pipe");
        exit(EXIT_FAILURE);
    }

    pid_t pid1 = fork();
    if (pid1 < 0) {
        perror("fork");
        exit(EXIT_FAILURE);
    }

    if (pid1 == 0) { // 第一个子进程：执行 ls，把 stdout 重定向到管道写端
        // 将管道的写端绑定到标准输出
        if (pfd[1] != STDOUT_FILENO) {
            if (dup2(pfd[1], STDOUT_FILENO) == -1) {
                perror("dup2 child1");
                _exit(EXIT_FAILURE);
            }
        }
        // 子进程不再需要原始的管道文件描述符，应该关闭它们
        close(pfd[0]);
        close(pfd[1]);

        // 用 exec 执行 ls（注意使用 _exit / exec 后不会返回）
        execlp("ls", "ls", (char *)NULL);
        // 如果 exec 返回，说明失败
        perror("execlp ls");
        _exit(EXIT_FAILURE);
    }

    // 父进程继续，创建第二个子进程
    pid_t pid2 = fork();
    if (pid2 < 0) {
        perror("fork");
        exit(EXIT_FAILURE);
    }
    if (pid2 == 0) { // 第二个子进程：执行 wc -l，把 stdin 绑定到管道读端
        // 将管道的读端绑定到标准输入
        if (pfd[0] != STDIN_FILENO) {
            if (dup2(pfd[0], STDIN_FILENO) == -1) {
                perror("dup2 child2");
                _exit(EXIT_FAILURE);
            }
        }
        // 关闭不再需要的描述符
        close(pfd[0]);
        close(pfd[1]);

        // 执行 wc -l
        execlp("wc", "wc", "-l", (char *)NULL);
        perror("execlp wc");
        _exit(EXIT_FAILURE);
    }

    // 父进程：不再需要管道两端，关闭之
    close(pfd[0]);
    close(pfd[1]);

    // 等待两个子进程结束（可以更健壮地循环 wait）
    int status;
    waitpid(pid1, &status, 0);
    waitpid(pid2, &status, 0);

    return 0;
}
```

# 逐步详解（逐行/逐步）

1. `int pfd[2];`

   * 创建一个长度为 2 的数组用于保存 `pipe()` 返回的两个文件描述符：`pfd[0]` 是读端，`pfd[1]` 是写端。

2. `pipe(pfd)`

   * 创建匿名管道。内核分配两个可用的最小文件描述符并把它们写入 `pfd`。
   * **注意**：如果在 `pipe()` 之前进程关闭了 `0/1/2`，系统会分配这些最小可用的 fd（可能导致 `pfd[0]==0` 或 `pfd[1]==1`），这会影响后续的 `dup`/`dup2` 逻辑——后面会演示如何防御。

3. `fork()` 创建第一个子进程（`ls`）

   * 在子进程中：

     * `dup2(pfd[1], STDOUT_FILENO)`：把标准输出（fd 1）指向管道写端。`dup2` 会把 `STDOUT_FILENO` 重定向到 `pfd[1]`（如果 `pfd[1]` 已经是 1，`dup2` 会安全地返回）。
     * 关闭不需要的 `pfd[0]`（读端）和 `pfd[1]`（写端的原始拷贝）——这是必须的，因为如果写端在所有进程都没被关闭，读端永远不会收到 EOF。
     * 使用 `execlp("ls", "ls", NULL)` 替换进程映像为 `ls`。如果 `execlp` 成功，就不会返回。
     * 用 `_exit()` 而不是 `exit()`：在子进程执行失败时应调用 `_exit()` 避免调用父进程可能注册的 atexit handlers、冲突的 stdio 缓冲刷新等问题。

4. 父进程 `fork()` 第二个子进程（`wc -l`）

   * 在这个子进程中：

     * `dup2(pfd[0], STDIN_FILENO)`：把标准输入（fd 0）重定向到管道读端。
     * 关闭 `pfd[0]`、`pfd[1]` 的原始副本（同样必要）。
     * `execlp("wc", "wc", "-l", NULL)`：执行 `wc -l` 来统计行数。

5. 父进程清理并等待

   * 父进程在创建两个子进程后应关闭它自己的 `pfd[0]` 和 `pfd[1]`，否则会因为父进程保持写端打开而使 `wc` 无法在 `ls` 结束后接收到 EOF。
   * 父进程使用 `waitpid()` 等待子进程结束，防止产生僵尸进程。

# 防御性细节与常见陷阱

* **fd 0/1/2 已关闭**：如果在调用 `pipe()` 之前某些标准 fd 被关闭，`pipe()` 可能会返回 `pfd[0]=0, pfd[1]=1`（或类似）。如果随后直接 `dup2(pfd[1], STDOUT_FILENO)`，行为仍安全（dup2 会把 STDOUT 指向 pfd\[1]），但你可能在错误的语义上下文中操作。为防御，可按照示例中的 `if (pfd[1] != STDOUT_FILENO) dup2(...);` 来避免不必要操作（虽然 `dup2` 自身也能安全处理）。
* **关闭多余 fd**：非常重要——每个进程必须关闭不需要的管道端，否则读端不会看到 EOF，或者写端被不必要地保持打开。
* **使用 `dup2` 而不是 `close`+`dup`**：`dup2(oldfd, newfd)` 原子地将 `newfd` 指向 `oldfd`，不用先显式 `close(newfd)`，更安全也更清晰。
* **在子进程中用 `_exit()` 而不是 `exit()`**：如果 exec 失败，使用 `_exit()` 可以避免父进程的流或资源被错误地刷新或重复释放。
* **错误检查**：对 `pipe()`, `fork()`, `dup2()`, `execlp()` 都应检查返回值并报告错误（示例里已用 `perror`）。

# 运行与输出

* 编译：

  ```
  gcc -Wall -O2 -o pipe_ls_wc pipe_ls_wc.c
  ```
* 运行：

  ```
  ./pipe_ls_wc
  ```

  输出会是 `ls` 列表中条目的行数（因为 `wc -l` 统计 `ls` 的输出行数）。例如：

  ```
  42
  ```

# 扩展提示

* 如果你要把 **任意两个过滤器**（可执行程序 A 和 B）连接成 `A | B`，只需在第一个子进程用 `execlp("A", "A", ... , NULL)`，在第二个用 `execlp("B", "B", ..., NULL)` 并相应修改参数。
* 若需要实现多个管道链（`A | B | C`），通常做法是为链中每个相邻对创建管道并按顺序 fork/dup/close；通常把每一步封装到一个函数内以减少出错（注意仔细管理每个子进程的 fd）。
