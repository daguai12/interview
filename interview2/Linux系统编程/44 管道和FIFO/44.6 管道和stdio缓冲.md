### 44.6 管道和 stdio 缓冲

当通过 `popen()` 获取一个文件流（`FILE *`）或者使用 `fdopen()` 将一个管道文件描述符转换成文件流时，标准 I/O 库（stdio）的行为需要特别注意。

#### 缓冲问题

由于管道不是终端设备，stdio 库默认会对与其连接的文件流采用**块缓冲 (block buffering)**。

1.  **当写入管道时 (`popen` with `mode="w"`)**:
    * 写入的数据会首先被存放在 stdio 的内部缓冲区中。
    * 只有当缓冲区被填满，或者当流被关闭时（例如通过 `pclose()`），缓冲区中的数据才会被实际写入管道，并发送给另一端的读取进程。
    * 这会导致数据传输的延迟。读取进程可能无法立即收到写入的数据。

2.  **当从管道读取时 (`popen` with `mode="r"`)**:
    * 同样地，如果向管道写入数据的子进程也使用了 stdio 库（例如，它是一个普通的 C 程序），那么它的输出同样会被块缓冲。
    * 这意味着，父进程（读取方）只有在子进程的 stdio 缓冲区被填满或子进程退出（关闭其 `stdout`）时，才能从管道中读到数据。

#### 解决方案

* **对于写入进程**:
    * 如果你是写入方，为了确保数据能被立即发送给读取进程，可以采取以下措施：
        1.  在写入数据后，定期调用 `fflush()` 来强制刷新 stdio 缓冲区。
        2.  在开始写入前，调用 `setbuf(fp, NULL)` 来完全禁用对该流的缓冲。

* **对于读取进程**:
    * 如果你是读取方，能采取的措施则比较有限，因为问题出在写入方。
    * **理想情况**: 如果你能修改写入方程序的源代码，可以在其中加入对 `fflush()` 或 `setbuf()` 的调用。
    * **替代方案**: 如果无法修改写入方程序的源代码，可以考虑使用**伪终端（pseudo-terminal）**来代替管道。伪终端可以模拟一个真实的终端环境，这会使得写入方的 stdio 库自动切换到**行缓冲（line buffering）**模式，从而在每输出一个换行符后就刷新缓冲区。