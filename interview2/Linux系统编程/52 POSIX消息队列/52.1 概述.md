好的，这是根据您提供的文本内容，保留原始结构和标题整理的结果。

### **POSIX 消息队列介绍**

本章将介绍 POSIX 消息队列，它允许进程之间以消息的形式交换数据。POSIX 消息队列与 System V 消息队列相似，但它们之间仍然存在一些显著的差异，这些差异使得 POSIX 消息队列在很多方面更优越。

#### **与 System V 消息队列的显著差异**

1.  **引用计数与生命周期**: POSIX 消息队列是**引用计数**的。一个队列只有在所有当前使用它的进程都关闭了它之后，才会被标记以便删除。这解决了 System V 消息队列中“何时可以安全删除队列”的难题。

2.  **优先级 vs. 类型**:
    * System V 消息队列为每个消息关联一个整数**类型 (`mtype`)**，接收进程可以根据类型选择性地接收消息。
    * POSIX 消息队列为每个消息关联一个**优先级 (priority)**，消息总是严格地按照**从高到低的优先级顺序**被接收。

3.  **异步通知**: POSIX 消息队列提供了一个特性，允许在一个空队列中有新消息到达时，通过信号或线程**异步地通知**一个已注册的进程。

**在 Linux 上的可用性**:
POSIX 消息队列被添加到 Linux 中的时间相对较晚，需要在**内核 2.6.6** 及之后的版本，并配合 **glibc 2.3.4** 或之后的版本才可使用。

---

### **52.1 概述**

POSIX 消息队列的 API 主要由以下函数构成。

#### **主要 API 函数**

* **`mq_open()`**: 创建一个新消息队列或打开一个既有队列，返回一个**消息队列描述符 (message queue descriptor)**，供后续调用使用。
* **`mq_send()`**: 向队列写入（发送）一条消息。
* **`mq_receive()`**: 从队列中读取（接收）一条消息。
* **`mq_close()`**: 关闭进程之前打开的一个消息队列。这会减少队列的引用计数。
* **`mq_unlink()`**: 删除一个消息队列的**名称**。当该队列的引用计数降为 0 时，队列自身会被标记以便删除。

#### **特殊特性与函数**

此外，POSIX 消息队列 API 还具备一些特别的特性：
* **队列属性**:
    * 每个消息队列都有一组关联的特性（如最大消息数、最大消息大小等）。
    * **`mq_getattr()`** 和 **`mq_setattr()`** 函数分别用于获取和修改这些队列特性。
* **异步消息通知**:
    * **`mq_notify()`** 函数允许一个进程向一个队列注册，以接收“消息可用”的通知。
    * 当一个消息到达一个原本为空的队列时，内核会通过以下方式之一来通知已注册的进程：
        1.  发送一个**信号**。
        2.  在一个**单独的线程**中调用一个指定的函数。