### **52.3 描述符和消息队列之间的关系**

消息队列描述符和打开着的消息队列之间的关系，与文件描述符和打开着的文件描述之间的关系非常类似（见 5.2 节）。其核心思想可以概括为三层结构：

1.  **进程级 - 消息队列描述符 (`mqd_t`)**:

      * 这是每个进程持有的句柄，通过 `mq_open()` 获得。

2.  **系统级 - 打开的消息队列描述 (Open Message Queue Description)**:

      * 内核为**每一次成功**的 `mq_open()` 调用维护一个条目。
      * 这个条目包含了与这次“打开”操作相关的状态和标记（例如 `O_NONBLOCK` 标志）。

3.  **系统级 - 消息队列对象 (Message Queue Object)**:

      * 这是实际的消息队列本身，在内核中存在，由其名称（如 `/my_queue`）唯一标识。

**关系示意图 (对应原文图 52-1)**:
![[Pasted image 20250916090103.png]]

这张图阐明了消息队列描述符使用的两个重要场景：

  * **共享同一个“打开消息队列描述”**:

      * **发生场景**: 当一个进程在打开了一个消息队列之后调用 `fork()` 时，父子进程会拥有各自的消息队列描述符副本，但这两个描述符都指向**同一个**“打开的消息队列描述”。
      * **后果**: 这两个描述符会共享 `O_NONBLOCK` 等状态标记。如果一个进程修改了这个标记，另一个进程也会受到影响。

  * **拥有不同的“打开消息队列描述”**:

      * **发生场景**: 当两个独立的进程分别调用 `mq_open()` 打开同一个消息队列时，它们会获得各自的消息队列描述符，并且这两个描述符指向**不同**的“打开的消息队列描述”条目。
      * **后果**: 这两个“打开的消息队列描述”虽然都指向同一个底层的消息队列对象，但它们各自拥有**独立**的 `O_NONBLOCK` 状态标记。一个进程的描述符可以处于阻塞模式，而另一个则处于非阻塞模式，互不影响。

[[消息队列解释]]
> **Linux 的实现细节**:
> 在 Linux 上，POSIX 消息队列被实现成了虚拟文件系统 (`mqueuefs`) 中的 i-node。因此，一个消息队列描述符 (`mqd_t`) 实际上就是一个**文件描述符**，而一个“打开的消息队列描述”也就是一个内核的“打开文件描述”。
> **注意**: SUSv3 并未对实现细节进行规定，其他 UNIX 系统可能采用不同的实现方式，因此不应依赖于此 Linux 特有的行为来编写可移植的程序。