### **52.7 Linux 特有的特性**

POSIX 消息队列在 Linux 上的实现提供了一些非标准的、但相当有用的特性。

#### **通过命令行显示和删除消息队列对象**

在 Linux 上，POSIX IPC 对象被实现成了虚拟文件系统中的文件。因此，我们可以通过挂载这个文件系统，然后使用标准的 shell 命令（如 `ls` 和 `rm`）来列出和删除这些消息队列。

**1. 挂载消息队列文件系统 (`mqueue`)**
首先，需要创建一个挂载点（通常是 `/dev/mqueue`）并将 `mqueue` 文件系统挂载上去。

```bash
# 创建挂载点
$ sudo mkdir /dev/mqueue

# 挂载 mqueue 文件系统
$ sudo mount -t mqueue none /dev/mqueue
```

**2. 查看挂载点**
挂载后，可以通过 `/proc/mounts` 查看记录，并用 `ls` 查看挂载点权限。

```bash
$ grep mqueue /proc/mounts
none /dev/mqueue mqueue rw,relatime 0 0

$ ls -ld /dev/mqueue
drwxrwxrwt 2 root root 40 Sep 15 12:30 /dev/mqueue
```

**注意**: `mqueue` 文件系统在挂载时会自动为挂载目录设置**粘滞位 (sticky bit)** (权限末尾的 `t`)。这意味着非特权进程只能删除（unlink）它自己所拥有的消息队列。

**3. 使用标准命令管理消息队列**
挂载后，就可以像操作普通文件一样管理消息队列了。

```bash
# 使用上一节的程序创建一个名为 /my_mq 的队列
$ ./mq_create -c /my_mq

# 使用 ls 查看队列
$ ls -l /dev/mqueue
-rw-r--r-- 1 daguai daguai 80 Sep 15 12:35 my_mq

# 使用 rm 删除队列 (等效于 mq_unlink())
$ rm /dev/mqueue/my_mq
```

-----

#### **获取消息队列的相关信息**

可以通过 `cat` 命令显示挂载点中虚拟文件的内容，来获取其关联消息队列的详细信息。

```bash
$ cat /dev/mqueue/my_mq
QSIZE:163     NOTIFY:0    SIGNO:0    NOTIFY_PID:0
```

  * **`QSIZE`**: 队列中当前所有数据的总字节数。
  * **`NOTIFY_PID`**: 已向该队列注册接收消息通知的进程的 PID（如果为 0 则表示没有）。
  * **`NOTIFY`**: 通知方式。0 表示 `SIGEV_SIGNAL`，1 表示 `SIGEV_NONE`，2 表示 `SIGEV_THREAD`。
  * **`SIGNO`**: 如果通知方式是 `SIGEV_SIGNAL`，此字段指明了用于分发通知的信号编号。

-----

#### **使用另一种 I/O 模型操作消息队列**

在 Linux 的实现上，一个 POSIX 消息队列描述符 (`mqd_t`) 实际上就是一个**文件描述符**。

  * **带来的好处**:
    这意味着可以使用 **I/O 多路复用**系统调用（如 `select()`, `poll()`）或 **`epoll`** API 来监控这个文件描述符。

  * **解决的问题**:
    这项特性极大地简化了异步程序的设计。它允许一个程序在单个事件循环中，同时等待一个 POSIX 消息队列上的输入和其他文件描述符（如网络套接字、管道）上的输入，从而避免了在使用 System V 消息队列时所面临的困难局面。

> **可移植性警告**:
> 这项特性是 **Linux 特有的、非标准的**。SUSv3 规范并**没有**要求将消息队列描述符实现成文件描述符，因此，依赖此行为的程序将不具备可移植性。