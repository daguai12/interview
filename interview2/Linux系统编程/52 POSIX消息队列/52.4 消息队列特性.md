### **52.4 消息队列特性**

`mq_open()`、`mq_getattr()` 以及 `mq_setattr()` 函数都会使用一个指向 `mq_attr` 结构的指针。该结构在 `<mqueue.h>` 中定义，形式如下：

```c
struct mq_attr {
    long mq_flags;   /* Flags: 0 or O_NONBLOCK */
    long mq_maxmsg;  /* Max. # of messages on queue */
    long mq_msgsize; /* Max. message size (bytes) */
    long mq_curmsgs; /* # of messages currently in queue */
};
```

  * **创建时设置**: `mq_maxmsg` 和 `mq_msgsize` 字段在创建队列时 (`mq_open`) 设置。
  * **运行时获取/修改**: `mq_flags` 和 `mq_curmsgs` 字段反映了队列或描述符的当前状态，可通过 `mq_getattr()` 获取，`mq_flags` 可通过 `mq_setattr()` 修改。

-----

#### **在创建队列时设置消息队列特性**

在使用 `mq_open()` 创建新消息队列时，可以通过 `mq_attr` 结构中的以下两个字段来确定队列的特性：

  * **`mq_maxmsg`**: 定义了队列中能存放的消息数量的上限。
  * **`mq_msgsize`**: 定义了队列中每条消息的大小的上限（字节）。

这两个特性一旦在队列被创建时确定下来，之后就**无法再修改**。

**程序清单 52-2** (与 52.2 节中相同) 展示了如何在 `mq_open()` 中使用 `mq_attr` 结构。`-m` 和 `-s` 选项分别用于指定 `mq_maxmsg` 和 `mq_msgsize`。

```c
// (代码与 52.2 节中的 mq_open_demo.c 相同，此处不再重复)
// 关键逻辑在于通过 getopt 解析 -m 和 -s 选项，
// 并将值填入一个 mq_attr 结构体，然后将其指针传递给 mq_open()。
// 如果不提供这些选项，则传递 NULL，使用系统默认值。
```

-----

#### **获取消息队列特性**

`mq_getattr()` 函数返回与消息队列描述符 `mqdes` 相关联的特性。

```c
#include <mqueue.h>
int mq_getattr(mqd_t mqdes, struct mq_attr *attr);
```

调用成功后，`attr` 指向的结构中会包含以下字段：

  * **`mq_maxmsg`** 和 **`mq_msgsize`**: 队列的不可变属性。
  * **`mq_flags`**: 与此**描述符**关联的标记，目前只有 `O_NONBLOCK`。
  * **`mq_curmsgs`**: 调用时刻队列中**当前**的消息数。

**程序清单 52-3：获取 POSIX 消息队列特性**

```c
#include <mqueue.h>
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char *argv[]) {
    mqd_t mqd;
    struct mq_attr attr;

    if (argc != 2 || strcmp(argv[1], "--help") == 0) {
        fprintf(stderr, "Usage: %s mq-name\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    // 只读打开队列
    mqd = mq_open(argv[1], O_RDONLY);
    if (mqd == (mqd_t) -1) {
        perror("mq_open");
        exit(EXIT_FAILURE);
    }

    // 获取特性
    if (mq_getattr(mqd, &attr) == -1) {
        perror("mq_getattr");
        exit(EXIT_FAILURE);
    }
    
    // 打印特性
    printf("Maximum # of messages on queue:   %ld\n", attr.mq_maxmsg);
    printf("Maximum message size:             %ld\n", attr.mq_msgsize);
    printf("# of messages currently on queue: %ld\n", attr.mq_curmsgs);
    printf("O_NONBLOCK flag is:               %s\n", (attr.mq_flags & O_NONBLOCK) ? "ON" : "OFF");

    mq_close(mqd);
    exit(EXIT_SUCCESS);
}
```

**运行演示 (结合上一节的创建程序):**

```bash
# 1. 编译程序
$ gcc mq_getattr.c -o mq_getattr -lrt
$ gcc mq_open_demo.c -o mq_open_demo -lrt # (来自 52.2 节)

# 2. 使用默认值创建一个新队列
$ ./mq_open_demo -c /my_mq

# 3. 使用 getattr 程序查看其默认特性
$ ./mq_getattr /my_mq
Maximum # of messages on queue:   10
Maximum message size:             8192
# of messages currently on queue: 0
O_NONBLOCK flag is:               OFF

# 4. 删除队列
$ mq_unlink_demo /my_mq # (来自 52.2 节的 unlink 程序)
```

> **可移植性**: `mq_maxmsg` 和 `mq_msgsize` 的默认值在不同系统上差异很大，可移植的应用程序应显式指定这两个特性，而不是依赖于默认值。

-----

#### **修改消息队列特性**

`mq_setattr()` 函数用于设置与消息队列描述符 `mqdes` 相关联的特性。

```c
#include <mqueue.h>
int mq_setattr(mqd_t mqdes, const struct mq_attr *newattr,
               struct mq_attr *oldattr);
```

  * **`newattr`**: 指向一个 `mq_attr` 结构，函数将使用其中的 `mq_flags` 字段来修改描述符的标记。
  * **`oldattr`**: 如果不为 `NULL`，则用于返回修改**之前**的队列描述和特性（与 `mq_getattr()` 作用相同）。

SUSv3 规定，使用 `mq_setattr()` 能够修改的**唯一特性**是 **`O_NONBLOCK` 标记**的状态。

为保证可移植性，修改 `O_NONBLOCK` 标记的正确做法是“**获取-修改-设置**”三步曲。例如，为启用 `O_NONBLOCK`，应编写下列代码：

```c
struct mq_attr attr;

// 1. 获取当前特性
if (mq_getattr(mqdes, &attr) == -1) { /* handle error */ }

// 2. 在现有基础上修改 O_NONBLOCK 位
attr.mq_flags |= O_NONBLOCK;

// 3. 将修改后的结构设置回去
if (mq_setattr(mqdes, &attr, NULL) == -1) { /* handle error */ }
```