### **52.5 交换消息**

本节将介绍用来向 POSIX 消息队列发送消息和从队列中接收消息的函数。

#### **52.5.1 发送消息**

`mq_send()` 函数将一条消息添加到 `mqdes` 所引用的消息队列中。

```c
#include <mqueue.h>

int mq_send(mqd_t mqdes, const char *msg_ptr,
            size_t msg_len, unsigned int msg_prio);
```

  * **`mqdes`**: 通过 `mq_open()` 返回的消息队列描述符。
  * **`msg_ptr`**: 指向包含消息内容的缓冲区的指针。
  * **`msg_len`**: `msg_ptr` 指向的消息的长度（字节）。
      * 该值必须小于或等于队列的 `mq_msgsize` 特性，否则 `mq_send()` 会失败并返回 `EMSGSIZE` 错误。
      * 允许发送长度为零的消息。
  * **`msg_prio`**: 一个非负整数，用于指定消息的**优先级**。

##### **消息优先级与顺序**

消息在队列中是按照**优先级倒序**排列的（即数值越大的优先级越高，0 表示优先级最低）。当一条新消息被添加到队列中时，它会被放置在队列中所有具有相同优先级的消息之后（FIFO 顺序）。如果应用程序无需使用消息优先级，只需将 `msg_prio` 指定为 0 即可。

> **优先级上限**: 系统对消息优先级的最大值是有限制的。SUSv3 要求这个上限至少是 32（即优先级范围至少为 0 到 31）。在 Linux 上，这个上限值为 32768。

##### **阻塞行为**

如果消息队列已经满了（即已达到了队列的 `mq_maxmsg` 限制），那么：

  * **默认 (阻塞模式)**: `mq_send()` 调用会**阻塞**，直到队列中有足够的空间来存放新消息为止。
  * **非阻塞模式 (`O_NONBLOCK`)**: 如果队列是在 `mq_open()` 时以 `O_NONBLOCK` 标志打开的，那么 `mq_send()` 会立即失败并返回 `EAGAIN` 错误。

-----

#### **程序示例**

程序清单 52-4 为 `mq_send()` 函数提供了一个命令行界面。

**程序清单 52-4：向 POSIX 消息队列写入一条消息**

```c
#include <mqueue.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>

static void usageError(const char *progName) {
    fprintf(stderr, "Usage: %s [-n] mq-name msg [prio]\n", progName);
    fprintf(stderr, "    -n           Use O_NONBLOCK flag\n");
    exit(EXIT_FAILURE);
}

int main(int argc, char *argv[]) {
    int flags, opt;
    mqd_t mqd;
    unsigned int prio;

    flags = O_WRONLY;
    while ((opt = getopt(argc, argv, "n")) != -1) {
        switch (opt) {
        case 'n': flags |= O_NONBLOCK; break;
        default:  usageError(argv[0]);
        }
    }

    if (optind + 2 > argc)
        usageError(argv[0]);

    // 打开消息队列
    mqd = mq_open(argv[optind], flags);
    if (mqd == (mqd_t) -1) {
        perror("mq_open");
        exit(EXIT_FAILURE);
    }

    // 获取消息优先级 (如果提供了的话)
    prio = (argc > optind + 2) ? atoi(argv[optind + 2]) : 0;
    
    // 发送消息
    if (mq_send(mqd, argv[optind + 1], strlen(argv[optind + 1]), prio) == -1) {
        perror("mq_send");
        exit(EXIT_FAILURE);
    }
    
    printf("Message sent.\n");
    exit(EXIT_SUCCESS);
}
```

##### **编译和运行**

1.  **编译程序 (需要链接实时库 `-lrt`)**:
    ```bash
    gcc mq_send.c -o mq_send -lrt
    ```
2.  **用法将在下一节与消息接收程序一同演示**。例如，要向名为 `/my_mq` 的队列发送一条内容为 "hello"，优先级为 10 的消息，可以执行：
    ```bash
    ./mq_send /my_mq "hello" 10
    ```

#### **52.5.2 接收消息**

`mq_receive()` 函数从 `mqdes` 引用的消息队列中删除**一条优先级最高、存在时间最长**的消息，并将删除的消息放置在 `msg_ptr` 指向的缓冲区中。

```c
#include <mqueue.h>

ssize_t mq_receive(mqd_t mqdes, char *msg_ptr,
                   size_t msg_len, unsigned int *msg_prio);
```

  * **`mqdes`**: 消息队列描述符。
  * **`msg_ptr`**: 用于存放接收到的消息内容的缓冲区。
  * **`msg_len`**: `msg_ptr` 指向的缓冲区的可用字节数。**一个关键要求是：`msg_len` 的值必须大于或等于队列的 `mq_msgsize` 特性**，否则 `mq_receive()` 会失败并返回 `EMSGSIZE` 错误。可以使用 `mq_getattr()` 来获取队列的 `mq_msgsize` 值。
  * **`msg_prio`**: 如果不为 `NULL`，则接收到的消息的优先级会被复制到 `msg_prio` 指向的位置处。
  * **返回值**: 成功时，返回接收到的消息的字节数。

##### **阻塞行为**

如果消息队列当前为空：

  * **默认 (阻塞模式)**: `mq_receive()` 调用会**阻塞**，直到有可用的消息为止。
  * **非阻塞模式 (`O_NONBLOCK`)**: `mq_receive()` 会立即失败并返回 `EAGAIN` 错误。

-----

##### **程序示例**

程序清单 52-5 为 `mq_receive()` 函数提供了一个命令行界面。

**程序清单 52-5：从 POSIX 消息队列中读取一条消息**

```c
#include <mqueue.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>

static void usageError(const char *progName) {
    fprintf(stderr, "Usage: %s [-n] mq-name\n", progName);
    fprintf(stderr, "    -n           Use O_NONBLOCK flag\n");
    exit(EXIT_FAILURE);
}

int main(int argc, char *argv[]) {
    int flags, opt;
    mqd_t mqd;
    unsigned int prio;
    ssize_t numRead;
    struct mq_attr attr;
    char *buffer;

    flags = O_RDONLY;
    while ((opt = getopt(argc, argv, "n")) != -1) {
        switch (opt) {
        case 'n': flags |= O_NONBLOCK; break;
        default:  usageError(argv[0]);
        }
    }

    if (optind >= argc)
        usageError(argv[0]);

    // 打开消息队列
    mqd = mq_open(argv[optind], flags);
    if (mqd == (mqd_t) -1) {
        perror("mq_open");
        exit(EXIT_FAILURE);
    }

    // 获取队列特性，特别是 mq_msgsize，以分配足够大的缓冲区
    if (mq_getattr(mqd, &attr) == -1) {
        perror("mq_getattr");
        exit(EXIT_FAILURE);
    }
    buffer = malloc(attr.mq_msgsize);
    if (buffer == NULL) {
        perror("malloc");
        exit(EXIT_FAILURE);
    }

    // 接收消息
    numRead = mq_receive(mqd, buffer, attr.mq_msgsize, &prio);
    if (numRead == -1) {
        perror("mq_receive");
        exit(EXIT_FAILURE);
    }
    
    printf("Read %ld bytes; priority = %u\n", (long) numRead, prio);
    // 打印消息内容（假设是文本）
    if (numRead > 0) {
        printf("Message: %.*s\n", (int) numRead, buffer);
    }

    free(buffer);
    exit(EXIT_SUCCESS);
}
```

**运行演示 (结合上一节的发送和创建程序)**

```bash
# 1. 编译所有程序 (需要链接 -lrt)
$ gcc mq_open_demo.c -o mq_create -lrt
$ gcc mq_send.c -o mq_send -lrt
$ gcc mq_receive.c -o mq_receive -lrt

# 2. 创建一个消息队列
$ ./mq_create -c /my_mq

# 3. 发送一些不同优先级的消息 (注意顺序)
$ ./mq_send /my_mq "msg with prio 0" 0
$ ./mq_send /my_mq "msg with prio 2" 2
$ ./mq_send /my_mq "another msg with prio 0" 0
$ ./mq_send /my_mq "msg with prio 1" 1

# 4. 接收消息，验证它们是按优先级顺序被读取的
$ ./mq_receive /my_mq
Read 16 bytes; priority = 2
Message: msg with prio 2

$ ./mq_receive /my_mq
Read 16 bytes; priority = 1
Message: msg with prio 1

$ ./mq_receive /my_mq
Read 18 bytes; priority = 0
Message: msg with prio 0

$ ./mq_receive /my_mq
Read 24 bytes; priority = 0
Message: another msg with prio 0

# 5. 此时队列为空，阻塞式接收会挂起
$ ./mq_receive /my_mq
# (程序会阻塞在这里，等待新消息...)
# (可以按 Ctrl-C 终止)

# 6. 非阻塞式接收会立即失败并返回错误
$ ./mq_receive -n /my_mq
mq_receive: Resource temporarily unavailable
```

-----

#### **52.5.3 在发送和接收消息时设置超时时间**

`mq_timedsend()` 和 `mq_timedreceive()` 函数与 `mq_send()` 和 `mq_receive()` 几乎完全一样，唯一的差别在于，如果操作无法立即完成（例如，队列已满或为空），它们允许为阻塞操作设置一个**超时上限**。

```c
#include <time.h>
#include <mqueue.h>

int mq_timedsend(mqd_t mqdes, const char *msg_ptr,
                 size_t msg_len, unsigned int msg_prio,
                 const struct timespec *abs_timeout);

ssize_t mq_timedreceive(mqd_t mqdes, char *msg_ptr,
                        size_t msg_len, unsigned int *msg_prio,
                        const struct timespec *abs_timeout);
```

  * **`abs_timeout`**: 一个指向 `timespec` 结构的指针，它将超时时间描述为自新纪元（Epoch）以来的一个**绝对时间值**。
  * **超时返回**: 如果调用因超时而无法完成操作，那么调用就会失败并返回 `ETIMEDOUT` 错误。

要指定一个相对超时（例如，“等待 5 秒”），应用程序需要先获取当前时间（使用 `clock_gettime(CLOCK_REALTIME, ...)`），然后在此基础上加上所需的时间量来构造 `abs_timeout` 参数。