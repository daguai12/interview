好的，这是根据您提供的文本内容，保留原始结构和标题整理的结果，并附上相应的代码清单。

### **52.2 打开、关闭和断开链接消息队列**

本节将介绍用来打开、关闭和删除 POSIX 消息队列的函数。

#### **打开一个消息队列**

`mq_open()` 函数创建一个新消息队列或打开一个既有队列。

```c
#include <mqueue.h>

mqd_t mq_open(const char *name, int oflag, ... /* mode_t mode,
                                                struct mq_attr *attr */);
```

  * **`name`**: 标识消息队列的名称。它必须以一个斜杠 (`/`) 开头，并且不能包含其他斜杠。
  * **`oflag`**: 一个位掩码，用于控制 `mq_open()` 的操作。

**表 52-1：`mq_open()` `oflag` 参数的位值**

| 标记           | 描述                            |
| :----------- | :---------------------------- |
| `O_CREAT`    | 如果队列不存在，则创建队列                 |
| `O_EXCL`     | 与 `O_CREAT` 一起使用，如果队列已存在则调用失败 |
| `O_RDONLY`   | 以只读模式打开                       |
| `O_WRONLY`   | 以只写模式打开                       |
| `O_RDWR`     | 以读写模式打开                       |
| `O_NONBLOCK` | 以非阻塞模式打开                      |

  * **附加参数 (仅在指定 `O_CREAT` 时)**:
      * **`mode_t mode`**: 一个位掩码，用于指定新消息队列的权限，其规则与文件权限相同，并会受到进程 `umask` 的影响。
      * **`struct mq_attr *attr`**: 一个指向 `mq_attr` 结构的指针，用于指定新队列的特性（如最大消息数、最大消息大小等）。如果为 `NULL`，则使用系统默认特性。
  * **返回值**:
    成功时，`mq_open()` 返回一个**消息队列描述符 (`mqd_t`)**，它将在后续调用中用于引用这个打开的队列。

**程序清单 52-2：使用 `mq_open()`**

```c
#include <mqueue.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

static void usageError(const char *progName) {
    fprintf(stderr, "Usage: %s [-cx] [-m maxmsg] [-s msgsize] mq-name [octal-perms]\n", progName);
    fprintf(stderr, "    -c           Create queue (O_CREAT)\n");
    fprintf(stderr, "    -x           Create exclusively (O_EXCL)\n");
    fprintf(stderr, "    -m maxmsg    Set max messages on queue\n");
    fprintf(stderr, "    -s msgsize   Set max message size\n");
    exit(EXIT_FAILURE);
}

int main(int argc, char *argv[]) {
    int flags, opt;
    mode_t perms;
    mqd_t mqd;
    struct mq_attr attr, *attrp;

    flags = O_RDWR;
    attr.mq_maxmsg = -1; // -1 表示使用系统默认值
    attr.mq_msgsize = -1;
    attrp = NULL;

    while ((opt = getopt(argc, argv, "cm:s:x")) != -1) {
        switch (opt) {
        case 'c': flags |= O_CREAT; break;
        case 'm': attr.mq_maxmsg = atol(optarg); attrp = &attr; break;
        case 's': attr.mq_msgsize = atol(optarg); attrp = &attr; break;
        case 'x': flags |= O_EXCL; break;
        default:  usageError(argv[0]);
        }
    }
    
    if (optind >= argc) usageError(argv[0]);
    perms = (argc <= optind + 1) ? (S_IRUSR | S_IWUSR) : strtol(argv[optind + 1], NULL, 8);
    
    // 打开或创建消息队列
    mqd = mq_open(argv[optind], flags, perms, attrp);
    if (mqd == (mqd_t) -1) {
        perror("mq_open");
        exit(EXIT_FAILURE);
    }

    printf("Message queue descriptor is %d\n", (int) mqd);
    
    exit(EXIT_SUCCESS);
}
```

#### **fork()、exec() 以及进程终止的影响**

  * **`fork()`**: 子进程会继承其父进程的消息队列描述符的副本，这些描述符指向同一个打开着的消息队列。但子进程**不会**继承父进程的消息通知注册。
  * **`exec()` 和 `_exit()`**: 当一个进程执行 `exec()` 或终止时，所有其打开的消息队列描述符都会被自动关闭。

#### **关闭一个消息队列**

`mq_close()` 函数关闭一个已打开的消息队列描述符。

```c
#include <mqueue.h>

int mq_close(mqd_t mqdes);
```

这类似于文件操作中的 `close()`。它会减少队列的引用计数，但**不会**删除队列本身。如果进程曾在此队列上注册了消息通知，该注册会自动被删除。

#### **删除一个消息队列**

`mq_unlink()` 函数删除一个消息队列的**名称**，并当所有进程都关闭该队列后，将队列标记为销毁。

```c
#include <mqueue.h>

int mq_unlink(const char *name);
```

这类似于文件操作中的 `unlink()`。由于 POSIX 消息队列是**引用计数**的，`mq_unlink()` 调用会立即返回，但队列的实际销毁会被推迟到最后一个使用它的进程调用 `mq_close()` 为止。

**程序清单 52-1：使用 `mq_unlink()` 断开一个 POSIX 消息队列的链接**

```c
#include <mqueue.h>
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char *argv[]) {
    if (argc != 2 || strcmp(argv[1], "--help") == 0) {
        fprintf(stderr, "Usage: %s mq-name\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    if (mq_unlink(argv[1]) == -1) {
        perror("mq_unlink");
        exit(EXIT_FAILURE);
    }

    printf("Message queue %s unlinked.\n", argv[1]);
    exit(EXIT_SUCCESS);
}
```