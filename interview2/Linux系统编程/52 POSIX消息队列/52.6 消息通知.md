### **52.6 消息通知**

POSIX 消息队列区别于 System V 消息队列的一个关键特性是，它能够在一个之前为空的队列接收到新消息时，对进程进行**异步通知**。

这个特性意味着进程无需再使用阻塞的 `mq_receive()` 调用，或在非阻塞模式下不断轮询队列来检查新消息。相反，进程可以向队列注册一个消息到达通知，然后继续执行其他任务，直到收到通知为止。

进程可以选择通过**信号**的形式，或通过在一个**单独的线程**中调用一个函数的形式来接收通知。

#### **`mq_notify()`**

`mq_notify()` 函数用于注册调用进程，以便在 `mqdes` 引用的空队列接收到一条消息时接收通知。

```c
#include <mqueue.h>

int mq_notify(mqd_t mqdes, const struct sigevent *notification);
```

`notification` 参数指定了进程接收通知的机制。

##### **通知规则**

有关消息通知，需要注意以下几点核心规则：

1.  **独占注册**: 在任何一个时刻，**只有一个**进程能够向一个特定的消息队列注册接收通知。如果一个消息队列上已经存在注册进程，那么后续的注册请求将会失败，`mq_notify()` 返回 `EBUSY` 错误。

2.  **触发条件**: 只有当一条新消息进入一个**之前为空**的队列时，注册进程才会收到通知。如果在注册时队列中已经包含消息，那么只有当队列被清空、之后再有一条新消息到达时，才会发出通知。

3.  **一次性通知**: 当向注册进程发送了一个通知之后，该注册信息就会被**自动删除**。如果一个进程想要持续地接收通知，那么它必须在每次接收到通知之后**再次调用 `mq_notify()`** 来重新注册自己。

4.  **阻塞的读者优先**: 如果有其他进程在 `mq_receive()` 调用中被阻塞了，那么新到达的消息会**直接递交给那个被阻塞的进程**，而**不会**向已注册的进程发送通知。此时，通知注册会保持有效。

5.  **撤销注册**: 一个进程可以通过在调用 `mq_notify()` 时传入一个值为 `NULL` 的 `notification` 参数来撤销自己在该队列上的通知注册。

#### **通知机制 (`sigevent` 结构)**

`notification` 参数是一个指向 `sigevent` 结构的指针，该结构用于精确定义通知的方式。与 `mq_notify()` 相关的字段如下：

```c
struct sigevent {
    int          sigev_notify; /* Notification method */
    int          sigev_signo;  /* Notification signal for SIGEV_SIGNAL */
    union sigval sigev_value;  /* Data passed with notification */
    void       (*sigev_notify_function)(union sigval); /* Thread function */
    void        *sigev_notify_attributes; /* Thread attributes */
};
```

`sigev_notify` 字段将被设置成下列值中的一个：

  * **`SIGEV_NONE`**:
    注册进程接收通知，但当消息到达时**不实际通知**该进程。注册信息仍然会在消息到达后被删除。

  * **`SIGEV_SIGNAL`**:
    通过**发送一个信号**来通知进程。

      * `sigev_signo`: 指定要发送的信号编号（例如 `SIGUSR1`）。
      * `sigev_value`: 如果使用的是实时信号，这个值会作为附加数据随信号一同发送。
      * 在信号处理器的 `siginfo_t` 结构中，`si_code` 字段的值会被设置为 `SI_MESGQ`。

  * **`SIGEV_THREAD`**:
    通过**创建一个新线程来调用一个指定的函数**以通知进程。

      * `sigev_notify_function`: 指向要在新线程中执行的函数的指针。
      * `sigev_value`: 这个值会作为参数传递给 `sigev_notify_function` 函数。
      * `sigev_notify_attributes`: 可以为 `NULL`，或是一个指向 `pthread_attr_t` 结构的指针，用于定义新线程的特性。



#### **52.6.1 通过信号接收通知**

程序清单 52-6 提供了一个使用信号来进行消息通知的例子。

##### **核心逻辑**

1.  以非阻塞模式打开消息队列。
2.  阻塞通知信号（本例中为 `SIGUSR1`）并为其建立一个处理器。
3.  调用 `mq_notify()` 注册进程接收消息通知。
4.  进入一个无限循环，在循环中：
    a. 调用 `sigsuspend()` 等待信号。`sigsuspend()` 会原子地解除对 `SIGUSR1` 的阻塞并等待其到来。
    b. 从 `sigsuspend()` 返回后（表示已收到通知），立即**再次调用 `mq_notify()`** 重新注册，为下一次通知做准备。
    c. 进入一个 `while` 循环，使用非阻塞的 `mq_receive()` 将队列中的所有消息全部读取出来，直到队列变空。

**程序清单 52-6：通过信号接收消息通知**

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>
#include <mqueue.h>
#include <errno.h>

#define NOTIFY_SIG SIGUSR1

static void notify_handler(int sig) {
    // 信号处理器可以为空，它的作用只是中断 sigsuspend()
}

int main(int argc, char *argv[]) {
    struct sigevent sev;
    mqd_t mqd;
    struct mq_attr attr;
    void *buffer;
    ssize_t numRead;
    sigset_t blockMask, emptyMask;
    struct sigaction sa;

    if (argc != 2 || strcmp(argv[1], "--help") == 0) {
        fprintf(stderr, "Usage: %s mq-name\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    // ① 以非阻塞模式打开消息队列
    mqd = mq_open(argv[1], O_RDONLY | O_NONBLOCK);
    if (mqd == (mqd_t) -1) {
        perror("mq_open");
        exit(EXIT_FAILURE);
    }

    // ② 确定消息大小并分配缓冲区
    if (mq_getattr(mqd, &attr) == -1) {
        perror("mq_getattr");
        exit(EXIT_FAILURE);
    }
    // ③
    buffer = malloc(attr.mq_msgsize);
    if (buffer == NULL) {
        perror("malloc");
        exit(EXIT_FAILURE);
    }

    // ④ 阻塞通知信号并为其建立处理器
    sigemptyset(&blockMask);
    sigaddset(&blockMask, NOTIFY_SIG);
    if (sigprocmask(SIG_BLOCK, &blockMask, NULL) == -1) {
        perror("sigprocmask");
        exit(EXIT_FAILURE);
    }

    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;
    sa.sa_handler = notify_handler;
    if (sigaction(NOTIFY_SIG, &sa, NULL) == -1) {
        perror("sigaction");
        exit(EXIT_FAILURE);
    }
    
    // ⑤ 首次调用 mq_notify() 注册通知
    sev.sigev_notify = SIGEV_SIGNAL;
    sev.sigev_signo = NOTIFY_SIG;
    if (mq_notify(mqd, &sev) == -1) {
        perror("mq_notify");
        exit(EXIT_FAILURE);
    }

    sigemptyset(&emptyMask);
    for (;;) {
        // ⑥ 调用 sigsuspend()，解除信号阻塞并等待通知
        sigsuspend(&emptyMask);
        
        // ⑦ 再次调用 mq_notify() 重新注册，为下一次通知做准备
        if (mq_notify(mqd, &sev) == -1) {
            perror("mq_notify");
            exit(EXIT_FAILURE);
        }

        printf("Notification received!\n");
        // ⑧ 循环读取，直到清空队列
        while ((numRead = mq_receive(mqd, buffer, attr.mq_msgsize, NULL)) >= 0) {
            printf("Read %ld bytes\n", (long) numRead);
        }

        if (errno != EAGAIN) { // 预期的错误是 EAGAIN (队列已空)
            perror("mq_receive");
            exit(EXIT_FAILURE);
        }
    }
    
    free(buffer);
    exit(EXIT_SUCCESS);
}
```

##### **设计要点**

  * **使用 `sigsuspend()`**: 这是为了防止竞态条件。如果使用 `pause()`，信号可能在 `pause()` 被调用之前就已经到达，导致信号丢失和程序永久阻塞。
  * **非阻塞 `mq_receive()`**: 以非阻塞模式打开队列，可以确保在收到一次通知后，能用一个 `while` 循环将队列中的所有消息读尽（直到 `mq_receive` 返回 `EAGAIN`），从而使队列变空，为下一次通知的触发创造条件。
  * **重新注册的时机**: **必须**在开始清空队列**之前**就重新调用 `mq_notify()` 进行注册。如果颠倒顺序，可能会发生以下竞态条件：1. 队列被清空；2. 一个新消息到达；3. 程序调用 `mq_notify()` 注册。此时，由于队列已经非空，新的通知将不会产生，导致程序在下一次 `sigsuspend()` 时永久阻塞。

-----

#### **52.6.2 通过线程接收通知**

程序清单 52-7 提供了一个使用线程来发布消息通知的例子。

**程序清单 52-7：通过线程来接收消息通知**

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <pthread.h>
#include <mqueue.h>
#include <errno.h>

// ① 线程启动函数
static void threadFunc(union sigval sv) {
    mqd_t *mqd_ptr;
    struct mq_attr attr;
    void *buffer;
    ssize_t numRead;
    struct sigevent sev;

    mqd_ptr = sv.sival_ptr;

    printf("Thread notification function started.\n");

    // ② 再次调用 mq_notify() 重新注册，为下一次通知做准备
    sev.sigev_notify = SIGEV_THREAD;
    sev.sigev_notify_function = threadFunc;
    sev.sigev_notify_attributes = NULL;
    sev.sigev_value.sival_ptr = mqd_ptr;
    if (mq_notify(*mqd_ptr, &sev) == -1) {
        perror("mq_notify in thread");
        return;
    }
    
    if (mq_getattr(*mqd_ptr, &attr) == -1) perror("mq_getattr");
    buffer = malloc(attr.mq_msgsize);
    if (buffer == NULL) perror("malloc");
    
    // ⑤ 循环读取，直到清空队列
    while ((numRead = mq_receive(*mqd_ptr, buffer, attr.mq_msgsize, NULL)) >= 0) {
        printf("Read %ld bytes\n", (long) numRead);
    }
    if (errno != EAGAIN) perror("mq_receive in thread");
    
    free(buffer);
    pthread_exit(NULL);
}

int main(int argc, char *argv[]) {
    mqd_t mqd;
    struct sigevent sev;

    if (argc != 2 || strcmp(argv[1], "--help") == 0) {
        fprintf(stderr, "Usage: %s mq-name\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    // 以非阻塞模式打开消息队列
    mqd = mq_open(argv[1], O_RDONLY | O_NONBLOCK);
    if (mqd == (mqd_t) -1) {
        perror("mq_open");
        exit(EXIT_FAILURE);
    }
    
    // ③ 设置通知方式为 SIGEV_THREAD
    sev.sigev_notify = SIGEV_THREAD;
    sev.sigev_notify_function = threadFunc;
    sev.sigev_notify_attributes = NULL;
    // ④ 将消息队列描述符的地址作为参数传递给线程函数
    sev.sigev_value.sival_ptr = &mqd;

    // 注册通知
    if (mq_notify(mqd, &sev) == -1) {
        perror("mq_notify");
        exit(EXIT_FAILURE);
    }

    // ⑥ 主程序挂起，等待通知线程处理所有事务
    for (;;) {
        pause();
    }
    
    exit(EXIT_SUCCESS);
}
```

##### **设计要点**

  * **`SIGEV_THREAD`**: 在 `sigevent` 结构中将 `sigev_notify` 字段设置为 `SIGEV_THREAD`，并通过 `sigev_notify_function` 字段指定线程的启动函数。
  * **传递参数**: 通过 `sigev_value.sival_ptr` 字段，可以将一个指针（本例中是消息队列描述符 `mqd` 的地址）作为参数传递给通知线程的启动函数。
  * **主线程阻塞**: 注册通知后，主线程进入 `pause()` 循环，所有工作都由内核在收到消息时创建的通知线程来分发和处理。


# 案例解释

哦，我明白你的疑惑了 👍。
你问的是 **为什么说用 `mq_notify()` 是异步事件驱动，而不是像 `mq_receive()` 那样阻塞？**
这里的关键区别在于：

---

## 1. `mq_receive()` 的阻塞模式

* 调用线程会 **一直挂起**，直到消息队列里有消息。
* 谁来唤醒？ → 内核在有消息时唤醒阻塞的线程。
* 这种方式是 **直接阻塞等待**。

  * 调用线程不能去做别的事。
  * 如果你有多个事件源（比如 socket、信号、mq），需要多路复用（`select`/`epoll`），否则写起来会很笨重。

---

## 2. `mq_notify()` 的机制

* `mq_notify(mqd, sigevent*)` 注册了一个 **“通知机制”**。
* 它不会阻塞调用者，而是告诉内核：
  👉 “当消息队列里有新消息时，用指定方式（信号 / 线程）来通知我”。

### 具体模式：

1. **信号模式 (`SIGEV_SIGNAL`)**

   * 队列变为非空时，内核给你发一个信号（比如 `SIGUSR1`）。
   * 你在信号处理函数里调用 `mq_receive()` 把消息取走，或者只设置一个标志，主循环再调用。
   * 这个线程可以去做别的事，不用傻等。

2. **线程模式 (`SIGEV_THREAD`)**

   * 队列变为非空时，内核帮你启动一个新线程，调用你注册的回调函数。
   * 这个回调里你就能直接处理消息。

**注意：** `mq_notify()` 的语义是“注册通知”，不是“阻塞等待”。
只有在通知到来后你自己再调用 `mq_receive()` 才会阻塞（如果队列已经空了）。

---

## 3. 为什么叫“异步事件驱动”？

* `mq_receive()`：调用者 = 被动等待者。
* `mq_notify()`：调用者 = 注册监听者，内核主动通知 → 驱动你的处理逻辑。
* 这就类似：

  * `mq_receive()` = `read()` 阻塞读 socket。
  * `mq_notify()` = `epoll` 注册回调，事件来了内核再告诉你。

---

## 4. 一个简单对比例子

### 阻塞方式

```c
// 阻塞等待消息
char buf[8192];
while (1) {
    ssize_t n = mq_receive(mqd, buf, sizeof(buf), NULL);
    printf("Got message: %s\n", buf);
}
```

### 异步方式（信号通知）

```c
void handler(int signo) {
    char buf[8192];
    ssize_t n;
    while ((n = mq_receive(mqd, buf, sizeof(buf), NULL)) >= 0) {
        printf("Got message: %s\n", buf);
    }
}

struct sigevent sev;
sev.sigev_notify = SIGEV_SIGNAL;
sev.sigev_signo  = SIGUSR1;

mq_notify(mqd, &sev);

signal(SIGUSR1, handler);  // 注册信号处理
```

* 主线程不再被阻塞，可以继续执行别的逻辑；
* 有消息时，信号处理函数会被触发 → **事件驱动**。

---

✅ **总结一句话：**
`mq_notify()` 本身不会阻塞，它只是注册一个通知机制。真正“阻塞”的是你后续在信号处理函数或回调里调用 `mq_receive()` 时，如果队列已经被取空了才会阻塞。
所以 `mq_notify` 模式是 **事件驱动**，而 `mq_receive` 是 **同步阻塞等待**。

---

要不要我帮你画一个 **对比时序图**，展示 `mq_receive` vs `mq_notify` 的区别？
