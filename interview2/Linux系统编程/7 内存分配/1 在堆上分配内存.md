### 7.1.1 调整 Program Break：`brk()` 和 `sbrk()`

改变进程堆（heap）的大小，即在程序运行时动态地分配或释放内存，本质上是调整进程的 **program break** 的位置。最初，program break 位于进程未初始化数据段（BSS段）的末尾，这个位置在代码中通常用 `&end` 符号表示。

当 program break 的位置被抬升，进程就获得了访问新分配内存区域内任何地址的权限。然而，这仅仅是虚拟地址空间的扩展。物理内存页（physical memory pages）并不会在此时立即分配。相反，内核会等到进程**首次尝试访问**这些新的虚拟内存地址时，才会触发一个缺页中断（page fault），并自动分配相应的物理内存页。

传统的 UNIX 系统提供了两个用于操控 program break 的系统调用，`brk()` 和 `sbrk()`，它们在 Linux 系统中依然可用。尽管现代应用程序很少直接使用这两个系统调用（通常会使用 `malloc()` 等库函数），但理解它们有助于揭示底层内存分配的原理。
![[Pasted image 20250905211830.png]]
#### 系统调用 `brk()`

系统调用 `brk()` 用于将 program break 直接设置为参数 `end_data_segment` 所指定的地址。

```c
void* brk(void *end_data_segment);
```

* **对齐**：由于虚拟内存是以页（page）为单位进行管理的，因此 `end_data_segment` 的地址实际上会被内核向上取整（round up）到下一个内存页的边界。
* **行为限制**：试图将 program break 设置为一个低于其初始值（即低于 `&end`）的位置，可能会导致不可预知的行为。例如，如果程序后续试图访问那些位于数据段但已被“释放”的区域，就会引发分段内存访问错误（segmentation fault），并产生 `SIGSEGV` 信号。
* **上限**：program break 能够设置的精确上限受到多种因素的制约，包括：
    * 进程对数据段大小的资源限制（`RLIMIT_DATA`）。
    * 内存映射区域（memory mappings）、共享内存段（shared memory segments）以及共享库（shared libraries）在虚拟地址空间中的位置。

#### 库函数 `sbrk()`

```c
void *sbrk(inptr_t increment);
```

调用 `sbrk()` 可以在 program break 的现有地址基础上，增加由参数 `increment` 指定的字节数。（在 Linux 中，`sbrk()` 是基于 `brk()` 系统调用实现的一个库函数。）

* **参数类型**：`increment` 的类型是 `intptr_t`，这是一种能够存放指针的整数类型，可正可负。
* **返回值**：
    * 如果调用成功，`sbrk()` 会返回**调整前**的 program break 地址。换言之，如果 program break 被增加（即分配内存），返回值就是指向新分配内存块起始位置的指针。
    * 如果调用失败（例如，无法再分配更多内存），`sbrk()` 会返回 `(void *) -1`。

* **`sbrk(0)` 的特殊用法**：
    调用 `sbrk(0)` 不会改变 program break 的位置，而是直接返回其当前地址。这个特性可以用于查询堆的当前大小，或在调试时监视内存分配函数的行为。


### 7.1.2 在堆上分配内存：malloc() 和 free()

#### 1. `malloc()` 的特点

* **标准化**：属于 C 标准库，跨平台可用，而 `brk()/sbrk()` 是 UNIX/Linux 特有的。
* **更适合多线程**：内部实现带锁，能避免多线程同时分配时的竞态。
* **接口简单**：直接传 `size` 就能分配任意大小的内存。
* **内存复用**：通过 **空闲链表 (free list)** 管理释放过的内存，下次分配时会尽量重用。
* **对齐方式**：保证返回的指针地址满足字节对齐（通常是 8 或 16 字节），以适配任意类型的数据结构。
* **特殊情况**：

  * `malloc(0)` → SUSv3 标准允许返回 `NULL` 或一小块可 `free()` 的内存。Linux 的 `glibc` 选择了后者。
  * 失败时返回 `NULL`，并设置 `errno`。

---

### 2. `free()` 的特点

* **释放规则**：只能释放之前由 `malloc()` 或相关函数（如 `calloc()`、`realloc()`）分配的内存。
* **不会立即降低 program break**：
  * 释放的内存通常在堆中间，不能直接减少堆顶。
  * 内存会先放入空闲链表，供后续 `malloc()` 循环使用。
* **可能回收堆顶空间**：
  * 如果释放的是 **堆顶连续的一大块内存**，glibc 可能调用 `sbrk()` 来降低 program break。
  * 但只有在这块空闲内存“足够大”时才会这么做（glibc 里一般阈值是 128KB）。
* **合并空闲块**：glibc 会把相邻空闲块合并，避免内存碎片。
* **传 `NULL` 安全**：`free(NULL)` 什么都不做，不是错误。
* **重复释放是错误**：对同一指针 `free()` 两次会导致未定义行为（可能崩溃）。

---

### 3. `free()` vs 不调用 `free()`

* **不调用 free() 的情况**
  当进程结束时，操作系统会自动回收进程占用的所有内存，包括堆内存。所以很多程序在 **始终运行到结束** 并且分配内存直到进程退出时，可以省略 `free()`，不会有真正的内存泄漏。
  举例：命令行工具 `grep`，分配的内存在退出时会被系统统一回收。
* **调用 free() 的好处**

  * 程序可读性和可维护性更强。
  * 如果用工具（如 `valgrind`）检查内存泄漏，未 `free()` 的内存会被报告为“泄漏”，影响调试。
  * 对长期运行的服务程序（daemon、server）必须 `free()`，否则内存会持续增长，最终耗尽系统内存。

---

### 4. 程序示例说明的现象

书中提到的例子（分配 N 个块，然后选择性释放）：

* **释放所有块** → program break 仍然保持在高位（因为内存都被挂到空闲链表，而不是降低堆顶）。
* **只释放堆顶一大块连续内存** → program break 才可能降低（glibc 调用 `sbrk()` 收缩堆）。


### 7.1.3 `malloc()`和 `free()`的实现

尽管 `malloc()` 和 `free()` 提供了比 `brk()` 和 `sbrk()` 更易于使用的内存分配接口，但它们在使用时仍容易引发各种编程错误。理解其内部实现有助于我们洞悉这些错误产生的原因并学会如何避免。
#### `malloc()` 的实现

`malloc()` 的基本实现过程如下：

1.  **扫描空闲列表**：`malloc()` 首先会扫描一个由之前 `free()` 释放的内存块组成的**空闲列表**，寻找一个尺寸大于或等于请求大小的内存块。具体的扫描策略因实现而异，常见有的 **first-fit**（找到的第一个足够大的块）或 **best-fit**（找到的与请求大小最接近的块）。
2.  **处理找到的内存块**：
      * 如果找到的内存块大小与请求**正好相符**，就将其从空闲列表中移除并直接返回给调用者。
      * 如果找到的内存块**比请求的要大**，`malloc()` 会将其**分割**。一部分大小符合请求的内存返回给调用者，剩余的较小部分则继续留在空闲列表中。
3.  **扩展堆**：如果在空闲列表中**找不到**足够大的内存块，`malloc()` 就会调用 `sbrk()` 来抬升 program break，从而扩展堆以获取更多内存。为了减少 `sbrk()` 的调用开销，`malloc()` 通常会申请比当前所需字节数**更大的内存**（一般是虚拟内存页大小的整数倍），并将超出的部分添加到空闲列表中以备后续使用。

#### `free()` 的实现与内部机制

`free()` 函数的实现涉及一个巧妙的技巧，用以确定要释放的内存块的大小。

  * **长度记录**：当 `malloc()` 分配内存时，它实际上会额外分配几个字节（通常是一个字的长度）用于存放一个整数，这个整数记录了该内存块的实际大小。这个长度信息存储在内存块的起始位置，而 `malloc()` **返回给调用者的指针**实际上是指向这个长度记录**之后**的地址。

*图 7-1：malloc()返回的内存块*

  * **空闲列表管理**：当一个内存块被 `free()` 释放时，它会被添加到空闲列表中。这个空闲列表通常是一个**双向链表**。`free()` 会利用被释放内存块**本身的空间**来存放指向前一个和后一个空闲块的链表指针。

*图 7-2：空闲列表中的内存块*

随着程序不断地分配和释放内存，堆内存会呈现出一种已分配的“在用”内存块与空闲列表中的内存块相互交错的状态。

*图 7-3：包含有已分配内存和空闲内存列表的堆*

#### 潜在的风险与编程错误

C 语言的灵活性允许程序员创建指向堆中任意位置的指针并修改其内容。这带来了巨大的风险，因为程序可能会无意中修改由 `malloc()` 和 `free()` 维护的内部管理数据（如内存块长度、链表指针）。

例如，一个错误的指针可能会意外地修改某个已分配内存块头部的**长度值**。当这个内存块随后被 `free()` 释放时，一个错误长度的内存块会被记录到空闲列表中。之后，`malloc()` 可能会根据这个错误的长度信息重新分配这块内存，导致两个指针指向**相互重叠**的内存区域，而程序却认为它们是独立的。这种情况会引发极其隐晦和难以调试的缺陷。

#### 避免内存错误的规则

为了避免此类错误，应当严格遵守以下规则：

1.  **不要越界操作**：分配一块内存后，确保所有操作都在这块内存的边界之内。错误的指针运算或循环中的 “off-by-one”（一差一）错误是常见的越界原因。
2.  **不要重复释放**：对同一块内存调用 `free()` 超过一次是严重错误。在 Linux 的 glibc 实现中，这通常会触发分段错误（`SIGSEGV` 信号），这是一种及时的错误提醒。但在其他情况下，它可能导致不可预知的行为。
3.  **只释放 `malloc` 返回的指针**：`free()` 的参数必须是之前从 `malloc`、`calloc` 或 `realloc` 等函数返回的指针。
4.  **避免内存泄漏**：在需要长时间运行的程序（如服务器守护进程）中，必须确保所有动态分配且不再使用的内存都被及时释放。否则，程序的堆会持续增长，最终耗尽所有可用的虚拟内存，导致后续的内存分配失败。这种情况被称为“**内存泄漏**”。

-----

### `malloc` 调试的工具和库

若不遵循上述准则，代码中可能引入难以理解和重现的缺陷。使用 `malloc` 调试工具可以极大地简化发现这些问题的过程。

#### Glibc 提供的 `malloc` 调试工具

  * **`mtrace()` 和 `muntrace()`**：

      * 这两个函数用于开启和关闭对内存分配调用的跟踪。
      * 需要与环境变量 `MALLOC_TRACE` 配合使用，该变量指定了用于存放跟踪日志的文件路径。`mtrace()` 会检查该文件是否存在且可写，然后开始记录所有 `malloc` 相关函数的调用。
      * 由于日志文件本身不易阅读，glibc 提供了一个 `mtrace` 脚本来分析日志文件并生成易于理解的汇总报告。
      * 出于安全考虑，set-UID 和 set-GID 程序会忽略 `mtrace()` 调用。

  * **`mcheck()` 和 `mprobe()`**：

      * 这些函数允许程序对已分配的内存块进行一致性检查，例如，它们可以捕获试图在已分配内存块边界之外进行写操作的错误。
      * 使用这些函数的程序在编译时必须链接 `mcheck` 库（使用 `-lmcheck` 选项）。

  * **`MALLOC_CHECK_` 环境变量**：

      * 提供与 `mcheck()` 类似的功能，但**无需修改或重新编译代码**。
      * 通过设置不同的整数值来控制错误处理方式：
          * `0`: 忽略错误。
          * `1`: 在标准错误（stderr）上打印诊断信息。
          * `2`: 调用 `abort()` 立即终止程序。
      * 它能检测出许多常见错误，虽然不是全部。这种方法快速、易用，且运行时开销较低。
      * 出于安全考虑，set-UID 和 set-GID 程序会忽略此环境变量。

#### `malloc` 调试库

除了 glibc 自带的工具，还有许多第三方库提供了与标准 `malloc` 兼容的 API，但增加了强大的错误捕获功能。使用时，只需在链接阶段将程序与这些调试库链接即可。这些库通常会降低程序运行速度并增加内存消耗，因此应仅在调试阶段使用。

  * **Electric Fence**: 专注于检测缓冲区溢出（越界访问）。
  * **dmalloc**: 一个功能全面的内存调试库。
  * **Valgrind**: 一个强大的内存调试、内存泄漏检测和性能分析工具集。
  * **Insure++**: 一款商业级的运行时内存分析工具。

Valgrind 和 Insure++ 的功能远不止堆内存分配的调试。

### 控制和监测 `malloc` 函数包

glibc 提供了一些非标准函数，用于监测和控制 `malloc` 的行为。

  * **`mallopt()`**：用于修改 `malloc` 内部算法的参数。例如，可以设置在调用 `sbrk()` 收缩堆之前，空闲列表尾部必须保留的最小空闲空间；或者规定一个内存分配大小的阈值，超过该阈值的分配将使用 `mmap()` 系统调用而非 `sbrk()`。
  * **`mallinfo()`**：返回一个包含 `malloc` 分配内存的各种统计信息的结构体。

需要注意的是，`mallopt()` 和 `mallinfo()` 的接口在不同的 UNIX 实现中可能存在差异，因此不具备可移植性。

### 7.1.4 在堆上分配内存的其他方法

除了 `malloc()`，C 函数库还提供了一系列其他在堆上分配内存的函数，每种函数都有其特定的用途。

-----

#### 用 `calloc()` 和 `realloc()` 分配内存

##### `calloc()`

函数 `calloc()` 用于为一组相同大小的对象分配内存。

```c
void *calloc(size_t numitems, size_t size);
```

  * **参数**:
      * `numitems`: 指定要分配的对象的数量。
      * `size`: 指定每个对象的大小（以字节为单位）。
  * **返回值**:
      * 成功时，返回指向已分配内存块起始地址的指针。
      * 失败时（如无法分配所需内存），返回 `NULL`。
  * **与 `malloc()` 的关键区别**:
    `calloc()` 会将分配的内存区域**初始化为 0**，而 `malloc()` 不会进行初始化，其内容是未定义的。

下面是 `calloc()` 的一个使用范例：

```c
int *pt;
pt = calloc(10, sizeof(int)); // 分配10个整数大小的空间，并初始化为0
```

##### `realloc()`

函数 `realloc()` 用于调整一块已存在内存块的大小，这块内存必须是之前由 `malloc`、`calloc` 或 `realloc` 分配的。

```c
void *realloc(void *ptr, size_t size);
```

  * **参数**:

      * `ptr`: 指向需要调整大小的内存块的指针。
      * `size`: 调整后内存块的期望大小（以字节为单位）。

  * **返回值**:

      * 成功时，返回指向调整后内存块的指针。**这个新指针的地址可能与原始 `ptr` 不同**。
      * 失败时，返回 `NULL`，但**原始 `ptr` 指向的内存块将保持不变**且仍然有效。

  * **行为特性**:

      * 如果 `realloc()` 增加了内存块的大小，新增加的字节**不会被初始化**。
      * 调用 `realloc(ptr, 0)` 等效于 `free(ptr)`。
      * 如果 `ptr` 为 `NULL`，调用 `realloc(NULL, size)` 的效果等同于 `malloc(size)`。

  * **内部机制与性能考量**:
    当增大内存时，`realloc()` 会尝试在现有内存块之后合并相邻的空闲空间。如果空间足够，它会直接扩展。如果现有内存块位于堆的顶部，它会直接扩展堆。但最常见的情况是，如果相邻空间不足，`realloc()` 会：

    1.  在堆的其他位置分配一块足够大的新内存。
    2.  将原始内存块中的数据**复制**到新内存块中。
    3.  释放原始内存块。
        这个复制过程会占用大量 CPU 资源，因此应尽量避免频繁调用 `realloc()`。

  * **安全使用 `realloc()`**:
    由于 `realloc()` 在失败时返回 `NULL` 但不释放原始内存，直接将返回值赋给原指针是危险的。

    ```c
    // 错误的做法
    ptr = realloc(ptr, new_size);
    if (ptr == NULL) {
        // 原始内存的指针丢失了，造成内存泄漏！
    }

    // 正确的做法
    void *new_ptr;
    new_ptr = realloc(ptr, new_size);
    if (new_ptr != NULL) {
        ptr = new_ptr; // 仅在成功时更新原始指针
    } else {
        // 处理错误，此时 ptr 仍然有效
    }
    ```

  * **指针失效问题**:
    由于 `realloc()` 可能会移动整个内存块，任何指向该内存块**内部**的指针（而非块起始地址的指针）在调用后都可能失效。

**注意**：使用 `calloc()` 或 `realloc()` 分配的内存，都应该使用 `free()` 来释放。

-----

#### 分配对齐的内存：`memalign()` 和 `posix_memalign()`

在某些应用场景下（如直接 I/O 操作），需要分配起始地址满足特定对齐要求的内存。`memalign()` 和 `posix_memalign()` 就是为此设计的。

##### `memalign()`

```c
void *memalign(size_t boundary, size_t size);
```

  * **功能**: 分配 `size` 个字节的内存，其起始地址是 `boundary` 的整数倍。
  * **参数**:
      * `boundary`: 对齐边界，**必须是 2 的整数次幂**。
      * `size`: 要分配的内存大小。
  * **可移植性**: `memalign()` **并非标准函数**，在所有 UNIX 系统上不一定存在。在大多数系统中，其声明位于 `<malloc.h>` 而非 `<stdlib.h>`。

##### `posix_memalign()`

SUSv3 (Single UNIX Specification, version 3) 标准化了一个功能类似的函数 `posix_memalign()`。

```c
int posix_memalign(void **memptr, size_t alignment, size_t size);
```

  * **与 `memalign()` 的主要不同**:

    1.  **返回方式**: 已分配内存的地址通过第一个参数 `memptr` (一个指向指针的指针)返回，而不是通过函数返回值。
    2.  **对齐参数 `alignment`**: 必须是 `sizeof(void *)` (在32位系统上是4，64位系统上是8) 与 2 的某个整数次幂的乘积。
    3.  **错误处理**: 函数的返回值用于指示成功或失败。成功时返回 `0`，失败时返回一个正的错误号（如 `EINVAL` 或 `ENOMEM`），而不是返回 -1 并设置 `errno`。

  * **使用范例**:
    分配 65536 字节的内存，并与 4096 字节的边界对-齐（假设 `sizeof(void*)` 为 4）：

    ```c
    char *buf;
    int ret;
    ret = posix_memalign(&buf, 4096, 65536);
    if (ret != 0) {
        // 处理错误
    }
    ```

**注意**：由 `memalign()` 或 `posix_memalign()` 分配的内存块，同样应该调用 `free()` 来释放。在早期的某些 UNIX 实现中，`memalign()` 分配的内存不能用 `free()` 释放，但现代的 glibc 实现没有这个限制。

### 7.2 在堆栈上分配内存：`alloca()`

`alloca()` 是一个与 `malloc` 系列函数功能类似的动态内存分配函数，但它有本质上的不同：**它在程序的堆栈（stack）上分配内存，而不是在堆（heap）上**。

这是通过增加当前函数调用栈帧（stack frame）的大小来实现的。由于当前函数的栈帧总是在堆栈的顶部，其上方存在可扩展的空间，因此 `alloca()` 只需要简单地调整栈指针（stack pointer）寄存器的值即可完成内存分配。

```c
#include <alloca.h>

void *alloca(size_t size);
```

  * **参数 `size`**: 指定需要在堆栈上分配的字节数。
  * **返回值**: 返回指向已分配内存块的指针。

#### `alloca()` 的关键特性

1.  **自动内存释放**：

      * **不需要**（也绝不能）使用 `free()` 来释放由 `alloca()` 分配的内存。
      * 当调用 `alloca()` 的函数返回时，其对应的栈帧会被销毁，这块内存也随之**自动释放**。这是通过重置栈指针到前一个栈帧的位置来实现的。

2.  **不可调整大小**：

      * 不能使用 `realloc()` 来调整由 `alloca()` 分配的内存大小。

3.  **可移植性**：

      * `alloca()` **不是 SUSv3（Single UNIX Specification）标准的一部分**，但绝大多数 UNIX 实现都提供了此函数，因此它具有较好的事实可移植性。
      * 在 glibc 中，其声明位于 `<alloca.h>`，而在一些旧的或 BSD 派生的系统中，可能需要包含 `<stdlib.h>`。

#### 优点

  * **速度快**：`alloca()` 通常被编译器实现为内联（inline）代码，它仅仅是调整一下栈指针，无需像 `malloc` 那样维护复杂的空闲内存列表，因此执行速度非常快。
  * **简化编码**：由于内存是自动释放的，程序员无需在函数的所有可能返回路径上都确保调用 `free()`，从而简化了代码逻辑，并有效避免了内存泄漏。
  * **对非局部跳转友好**：在需要执行非局部跳转（如使用 `longjmp()` 或 `siglongjmp()`）的复杂场景中（例如信号处理程序），`alloca()` 的优势尤其明显。在跳转过程中，位于“起跳”和“落地”函数之间的栈帧会被“展开”（unwound），`alloca()` 分配的内存也因此被自动回收。而如果使用 `malloc()`，在这种情况下要避免内存泄漏会变得极其困难。

#### 风险与注意事项

  * **堆栈溢出（Stack Overflow）**：

      * 如果调用 `alloca()` 分配的内存过大，超出了堆栈的可用空间，就会导致堆栈溢出。
      * 发生堆栈溢出时，程序的行为是**无法预知的**。`alloca()` **不会返回 `NULL`** 来提示错误，程序很可能会收到一个 `SIGSEGV` 信号而崩溃。

  * **禁止在函数参数列表中使用**：
    不能在调用另一个函数的参数列表中直接调用 `alloca()`。

    ```c
    // 错误用法
    some_function(alloca(100)); 
    ```

    这样做会导致 `alloca()` 分配的空间出现在当前函数参数所在的位置，扰乱栈帧结构。

    必须先分配内存，再将其作为参数传递：

    ```c
    // 正确用法
    void *p = alloca(100);
    some_function(p);
    ```