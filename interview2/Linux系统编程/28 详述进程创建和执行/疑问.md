你问得非常好 👍，这里涉及 **“栈”** 和 **“虚拟内存地址空间”** 两个概念的区别。我们来逐步拆开解释：

---

### 1. **子进程栈 vs 父进程栈**

* 在 `clone()` 调用里，你传给它了一个新的栈空间 `stack`：

  ```c
  clone(child_func, stack + STACK_SIZE, CLONE_VM | SIGCHLD, &value);
  ```

  > 这告诉内核：**子进程运行 `child_func` 的时候，栈帧要从 `stack+STACK_SIZE` 这个位置开始**，而不是和父进程共用同一片栈。

* 所以 `child_func` 中的 **局部变量**、`printf` 的调用栈帧等，都会用你分配的 `stack` 空间，不会和父进程的栈打架。

---

### 2. **为什么还能访问父进程的变量 `value`？**

* 因为你在 `clone()` 的 `flags` 里设置了 **`CLONE_VM`**：

  ```c
  CLONE_VM
  ```

  这意味着 **父子进程共享整个虚拟内存空间**，包括：

  * `.data` 段（全局变量）
  * `.bss` 段（未初始化的全局变量）
  * `heap` 堆（malloc 出来的内存）
  * `stack` 栈（尽管父子栈帧不同，但地址空间是共享的）

* 这里 `int value = 123;` 是在 **父进程的栈帧里**，也就是在父进程的虚拟内存的 **stack 区域**。

* 因为设置了 `CLONE_VM`，子进程可以直接访问到这块内存，所以 `*p = 999;` 就能改到父进程的栈上 `value` 的值。

---

### 3. **总结区别**

* `stack`（你 malloc 的那块）只是子进程**运行时调用栈帧**所用的区域。
* `value` 在父进程的栈帧里，属于虚拟内存的一部分，而 **父子共享整个虚拟内存**（因为 `CLONE_VM`），所以子进程能读写它。

所以：
✅ **子进程有自己的栈帧（避免和父进程的调用栈踩内存）**
✅ **但子进程依然能访问父进程的整个虚拟地址空间，包括父亲的栈变量**

---

🔎 要是你不用 `CLONE_VM`，而是普通的 `fork()`：

* 子进程的 `value` 会在“写时拷贝”机制下变成**独立副本**，改动不会影响父进程。

---

要不要我帮你画一张内存布局图（父子进程的堆、栈、数据段在 `CLONE_VM` 和 `fork()` 下的对比）？
