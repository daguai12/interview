好的，这份文档（表 28-4）是一个非常详尽和有用的参考，它清晰地列出了 `fork()` 和 `exec()` 这两个核心系统调用对一个进程的各种属性会产生什么影响。

以下是对这个表格内容的总结和关键点解读，帮助您更好地理解其核心思想。

### 核心概念回顾

  * **`fork()`**: 创建一个新进程（子进程），这个子进程是调用进程（父进程）的**副本**。
  * **`exec()`**: 在**当前进程**的上下文中加载并运行一个新程序。它会**替换**当前进程的内存映像（代码、数据、堆栈等），但进程的“外壳”（即它的进程ID等标识符）保持不变。

### `fork()` 的影响：克隆与继承

`fork()` 的基本原则是**尽可能地复制父进程的一切**。子进程就像是父进程的一个快照。

#### 1\. 子进程继承的属性 (Copied/Inherited)

子进程会得到父进程绝大多数属性的一份**独立副本**。这意味着子进程后续对这些属性的修改不会影响到父进程。

  * **进程凭证**: 实际/有效/保存的用户ID和组ID (`uid`, `gid`)。
  * **环境**: 环境变量、当前工作目录、根目录、文件模式创建掩码 (`umask`)。
  * **资源**: 资源限制、调度优先级 (`nice` 值)。
  * **内存**: 栈、数据和堆段。这些段是写时复制（Copy-on-Write）的，意味着在父子进程任何一方尝试写入之前，它们实际上共享相同的物理内存页。
  * **信号**: 信号掩码和信号处置方式。

#### 2\. 子进程与父进程共享的属性 (Shared)

有些资源在 `fork()` 后是共享的，对其中一方的修改会立即对另一方可见。

  * **打开的文件描述符**: 这是最重要的一点。父子进程共享同一个**打开文件表项 (open file description)**。这意味着它们共享文件偏移量（offset）和文件状态标志。如果父进程读取文件的一部分，子进程的下一次读取将从父进程结束的位置开始。
  * **文本段**: 程序代码是只读的，所以父子进程共享同一份代码的物理内存。

#### 3\. 子进程独有的属性 (Unique)

有些属性在子进程中是独一无二的，与父进程不同。

  * **进程 ID (PID)**: 每个进程的 PID 都是唯一的。
  * **父进程 ID (PPID)**: 子进程的 PPID 是父进程的 PID。
  * **定时器**: `alarm()` 或 `setitimer()` 创建的定时器不会被继承。
  * **挂起的信号 (Pending Signals)**: 子进程的挂起信号集合会被清空。
  * **资源使用量**: CPU 时间、内存使用等统计信息会从 0 开始计算。

### `exec()` 的影响：替换与保留

`exec()` 的基本原则是**为新程序创建一个干净的运行环境，但保留进程的身份和部分外部状态**。

#### 1\. `exec()` 后保留的属性 (Preserved)

这些属性在 `exec()` 调用后保持不变，因为它们定义了进程的身份和它在系统中的位置。

  * **进程标识符**: PID, PPID, 进程组ID, 会话ID。
  * **用户和组ID**: 实际用户/组ID (`uid`, `gid`)。
  * **打开的文件描述符**: 除非设置了“执行时关闭”(`close-on-exec`)标志，否则所有打开的文件描述符都会被新程序继承。这是实现 I/O 重定向（如 `ls > file.txt`）的关键机制。
  * **目录**: 当前工作目录和根目录。
  * **资源**: 资源限制、CPU 时间等统计信息。
  * **信号掩码**: 新程序会继承旧程序的信号掩码。

#### 2\. `exec()` 后重置或丢弃的属性 (Reset/Discarded)

这些属性与旧程序的执行状态紧密相关，因此在加载新程序时必须被丢弃或重置。

  * **进程地址空间**: 这是最核心的变化。旧程序的文本、数据、堆和栈段会被完全**替换**为新程序的。
  * **信号处置**: 所有被**捕获**的信号处理函数地址在新程序中已无意义，因此它们的处置方式会被**重置为默认动作**。被设置为**忽略**的信号则保持不变。
  * **挂起的信号**: 挂起的信号集合会被清空。
  * **定时器和锁**: 大多数定时器（`alarm`, POSIX timers）和内存锁、记录锁都会被移除。
  * **线程**: `exec()` 会销毁调用进程中的所有其他线程。

### 总结

| 系统调用         | 核心行为             | 关键记忆点                                                                                             |
| :----------- | :--------------- | :------------------------------------------------------------------------------------------------ |
| **`fork()`** | **克隆 (Clone)**   | - 创建一个几乎完全相同的子进程。\<br\>- **共享文件偏移量**。\<br\>- 子进程有新的 PID，且定时器和挂起信号被清除。                             |
| **`exec()`** | **替换 (Replace)** | - 进程 ID 不变，但程序代码和数据被完全替换。\<br\>- **继承打开的文件描述符**（除非设置了 `close-on-exec`）。\<br\>- 信号处理函数恢复默认，信号掩码保留。 |

# 代码示例

当然可以。通过代码来理解这些概念是最好的方式。

下面我将为您编写 3 个小程序来分别演示：

1.  **`fork()` 与 `vfork()` 的创建速度差异** (对应第一个文档)
2.  **`fork()` 如何继承和共享父进程属性** (对应第二个文档)
3.  **`exec()` 如何保留和重置进程属性** (对应第二个文档)

-----

### 示例 1: `fork()` vs. `vfork()` 创建速度对比

这个程序将模拟第一个文档中的实验，通过分配一块大内存来模拟一个“大进程”，然后分别使用 `fork()` 和 `vfork()` 创建大量子进程，并计算耗时。

**代码 (`speed_test.c`):**

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
#include <time.h>

// 定义要创建的子进程数量
#define NUM_CHILDREN 10000
// 定义要分配的内存大小 (约 10MB)，模拟大进程
#define MEMORY_SIZE (10 * 1024 * 1024)

// 使用 fork() 进行测试
void test_fork(char *dummy_memory) {
    struct timespec start, end;
    clock_gettime(CLOCK_MONOTONIC, &start);

    for (int i = 0; i < NUM_CHILDREN; ++i) {
        pid_t pid = fork();
        if (pid == -1) {
            perror("fork failed");
            exit(1);
        } else if (pid == 0) {
            // 子进程立即退出
            _exit(0);
        } else {
            // 父进程等待子进程结束
            wait(NULL);
        }
    }

    clock_gettime(CLOCK_MONOTONIC, &end);
    double elapsed = end.tv_sec - start.tv_sec;
    elapsed += (end.tv_nsec - start.tv_nsec) / 1000000000.0;
    printf("fork() took: %.4f seconds\n", elapsed);
}

// 使用 vfork() 进行测试
void test_vfork(char *dummy_memory) {
    struct timespec start, end;
    clock_gettime(CLOCK_MONOTONIC, &start);

    for (int i = 0; i < NUM_CHILDREN; ++i) {
        pid_t pid = vfork();
        if (pid == -1) {
            perror("vfork failed");
            exit(1);
        } else if (pid == 0) {
            // 子进程立即退出
            // 注意：在 vfork() 的子进程中，必须调用 _exit() 而不是 exit()
            // 因为 exit() 会刷新 I/O 缓冲区，可能会影响父进程的内存空间
            _exit(0);
        } else {
            // 父进程等待子进程结束
            wait(NULL);
        }
    }

    clock_gettime(CLOCK_MONOTONIC, &end);
    double elapsed = end.tv_sec - start.tv_sec;
    elapsed += (end.tv_nsec - start.tv_nsec) / 1000000000.0;
    printf("vfork() took: %.4f seconds\n", elapsed);
}

int main() {
    // 分配内存来模拟一个大进程
    char *dummy_memory = malloc(MEMORY_SIZE);
    if (dummy_memory == NULL) {
        perror("malloc failed");
        return 1;
    }
    // 随便填充一下，防止编译器优化掉
    for(int i = 0; i < 100; ++i) dummy_memory[i] = 'a';

    printf("Testing creation of %d processes with a parent virtual memory size > 10MB...\n", NUM_CHILDREN);
    
    test_fork(dummy_memory);
    test_vfork(dummy_memory);

    free(dummy_memory);
    return 0;
}
```

**编译和运行:**

```bash
gcc -o speed_test speed_test.c -lrt
./speed_test
```

**预期输出及讲解:**

```
Testing creation of 10000 processes with a parent virtual memory size > 10MB...
fork() took: 1.3521 seconds
vfork() took: 0.3879 seconds
```

*(具体时间取决于您的机器性能，但 `vfork()` 会明显快于 `fork()`)*

  * **讲解**: 这个结果直观地验证了第一个文档的结论。`fork()` 因为需要复制大进程的页表，所以耗时较长。而 `vfork()` 不需要执行这个复制操作，直接共享父进程的地址空间，因此速度快得多。这与文档中“进程所占内存越大，`fork()` 所需时间也就越长”的描述完全一致。

-----

### 示例 2: `fork()` 的属性继承

这个程序将展示 `fork()` 后，子进程如何继承父进程的属性（如环境变量、文件描述符、工作目录），以及哪些是共享的，哪些是独立的。

**代码 (`fork_attributes.c`):**

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
#include <string.h>
#include <fcntl.h>

int global_var = 10; // 全局变量

int main() {
    int local_var = 100; // 栈变量
    char buffer[20];

    // 1. 设置环境变量
    putenv("MY_VAR=HelloFromParent");

    // 2. 打开一个文件
    int fd = open("shared_file.txt", O_RDWR | O_CREAT | O_TRUNC, 0644);
    if (fd == -1) {
        perror("open failed");
        return 1;
    }
    write(fd, "Parent", 6);

    printf("--- Before fork ---\n");
    printf("Parent (PID: %d): global_var=%d, local_var=%d\n", getpid(), global_var, local_var);
    printf("Parent (PID: %d): Current file offset is %lld\n", getpid(), (long long)lseek(fd, 0, SEEK_CUR));

    pid_t pid = fork();

    if (pid == -1) {
        perror("fork failed");
        exit(1);
    } else if (pid == 0) {
        // --- 子进程代码 ---
        printf("\n--- In Child Process ---\n");
        printf("Child (PID: %d, PPID: %d)\n", getpid(), getppid());
        
        // 3. 修改变量 (独立副本)
        global_var++;
        local_var++;
        printf("Child: Changed variables. global_var=%d, local_var=%d\n", global_var, local_var);

        // 4. 读取环境变量 (继承)
        printf("Child: Inherited env var: MY_VAR=%s\n", getenv("MY_VAR"));

        // 5. 使用文件描述符 (共享文件偏移)
        lseek(fd, 0, SEEK_SET); // 重置偏移到文件开头
        read(fd, buffer, 6);
        buffer[6] = '\0';
        printf("Child: Read from file (shared offset): '%s'\n", buffer);
        
        close(fd);
        exit(0);

    } else {
        // --- 父进程代码 ---
        wait(NULL); // 等待子进程结束

        printf("\n--- Back in Parent Process ---\n");
        
        // 3. 检查变量 (未被子进程修改)
        printf("Parent: Variables are unchanged. global_var=%d, local_var=%d\n", global_var, local_var);

        // 5. 再次检查文件偏移 (被子进程共享和修改)
        // 注意：子进程关闭了fd，但父进程的fd仍然有效，指向同一个打开文件表项
        lseek(fd, 0, SEEK_SET); // 重置偏移
        read(fd, buffer, 6);
        buffer[6] = '\0';
        printf("Parent: Read from file after child: '%s'\n", buffer);

        close(fd);
        unlink("shared_file.txt"); // 清理文件
    }

    return 0;
}
```

**编译和运行:**

```bash
gcc -o fork_attributes fork_attributes.c
./fork_attributes
```

**预期输出及讲解:**

```
--- Before fork ---
Parent (PID: 5010): global_var=10, local_var=100
Parent (PID: 5010): Current file offset is 6

--- In Child Process ---
Child (PID: 5011, PPID: 5010)
Child: Changed variables. global_var=11, local_var=101
Child: Inherited env var: MY_VAR=HelloFromParent
Child: Read from file (shared offset): 'Parent'

--- Back in Parent Process ---
Parent: Variables are unchanged. global_var=10, local_var=100
Parent: Read from file after child: 'Parent'
```

  * **讲解**:
      * **PID/PPID (独有)**: 子进程有自己的 PID，其 PPID 是父进程的 PID。
      * **变量 (独立副本)**: 子进程修改了 `global_var` 和 `local_var`，但这并未影响父进程中的值。这证明子进程获得了内存的独立副本（通过写时复制）。
      * **环境变量 (继承)**: 子进程成功读取了父进程设置的环境变量 `MY_VAR`。
      * **文件描述符 (共享)**: 父子进程操作的是同一个文件描述符 `fd`，它们共享文件的偏移量。子进程读取后，父进程也能从相同的位置读取。这完美对应了表中“打开文件描述符”和“文件偏移”是共享（`共用`）的说明。

-----

### 示例 3: `exec()` 的属性保留

这个例子需要两个程序：一个`launcher`程序，它设置好环境后调用`exec()`；一个`target`程序，被`launcher`执行，并检查哪些属性被保留了下来。

**代码 1 (`launcher.c`):**

```c
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <fcntl.h>
#include <signal.h>

void handler(int sig) {
    write(STDOUT_FILENO, "Caught SIGINT!\n", 15);
}

int main() {
    printf("Launcher (PID: %d) is starting...\n", getpid());

    // 1. 设置环境变量
    putenv("EXEC_VAR=PreservedAcrossExec");

    // 2. 打开一个文件，并获取其描述符
    int fd = open("exec_test.txt", O_WRONLY | O_CREAT | O_TRUNC, 0644);
    if (fd == -1) {
        perror("open failed");
        return 1;
    }
    char fd_str[10];
    sprintf(fd_str, "%d", fd); // 将fd转换为字符串以便传递

    // 3. 阻塞一个信号
    sigset_t new_mask;
    sigemptyset(&new_mask);
    sigaddset(&new_mask, SIGUSR1);
    sigprocmask(SIG_BLOCK, &new_mask, NULL);
    printf("Launcher: Blocked SIGUSR1.\n");

    // 4. 设置一个信号处理器 (这个会被exec重置)
    signal(SIGINT, handler);
    printf("Launcher: Set a custom handler for SIGINT.\n");

    printf("Launcher: About to exec './target'...\n\n");
    
    // 使用 execlp 执行 target 程序
    // 参数: 程序名, argv[0], argv[1], argv[2], ..., NULL
    execlp("./target", "target_program", fd_str, NULL);

    // 如果 exec 调用成功，下面的代码永远不会被执行
    perror("execlp failed");
    return 1;
}
```

**代码 2 (`target.c`):**

```c
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <signal.h>
#include <string.h>

int main(int argc, char *argv[]) {
    printf("--- Target program is now running ---\n");

    // 1. 检查 PID (应该与 launcher 相同)
    printf("Target: My PID is %d.\n", getpid());

    // 2. 检查环境变量 (被保留)
    char *env = getenv("EXEC_VAR");
    if (env) {
        printf("Target: Found env var EXEC_VAR=%s\n", env);
    } else {
        printf("Target: Could not find env var EXEC_VAR.\n");
    }

    // 3. 使用继承的文件描述符 (被保留)
    if (argc > 1) {
        int fd = atoi(argv[1]);
        printf("Target: Received file descriptor %d.\n", fd);
        write(fd, "Hello from target!", 18);
        close(fd);
        printf("Target: Wrote to file using inherited fd.\n");
    }

    // 4. 检查信号掩码 (被保留)
    sigset_t current_mask;
    sigprocmask(0, NULL, &current_mask);
    if (sigismember(&current_mask, SIGUSR1)) {
        printf("Target: SIGUSR1 is still blocked.\n");
    } else {
        printf("Target: SIGUSR1 is NOT blocked.\n");
    }

    // 5. 检查信号处理器 (被重置)
    struct sigaction sa;
    sigaction(SIGINT, NULL, &sa);
    if (sa.sa_handler == SIG_DFL) {
        printf("Target: SIGINT handler has been reset to default.\n");
    } else {
        printf("Target: SIGINT handler was NOT reset.\n");
    }
    
    printf("--- Target program finished ---\n");

    return 0;
}
```

**编译和运行:**

```bash
gcc -o launcher launcher.c
gcc -o target target.c
./launcher
# 检查生成的文件
cat exec_test.txt
```

**预期输出及讲解:**

```
Launcher (PID: 5025) is starting...
Launcher: Blocked SIGUSR1.
Launcher: Set a custom handler for SIGINT.
Launcher: About to exec './target'...

--- Target program is now running ---
Target: My PID is 5025.
Target: Found env var EXEC_VAR=PreservedAcrossExec
Target: Received file descriptor 3.
Target: Wrote to file using inherited fd.
Target: SIGUSR1 is still blocked.
Target: SIGINT handler has been reset to default.
--- Target program finished ---
```

同时，`exec_test.txt` 文件中会包含内容: `Hello from target!`

  * **讲解**:
      * **PID (保留)**: `launcher` 和 `target` 的 PID 完全相同，证明 `exec()` 只是替换了程序，而没有创建新进程。
      * **环境变量 (保留)**: `target` 成功获取了 `launcher` 设置的环境变量。
      * **文件描述符 (保留)**: `target` 通过命令行参数接收了文件描述符的编号，并成功地用它写入文件。这与表中“打开文件描述符”在 `exec()` 列为“见注释”（意为除非设置 close-on-exec 否则保留）的说明一致。
      * **信号掩码 (保留)**: `launcher` 阻塞了 `SIGUSR1`，`target` 检查后发现该信号仍然是阻塞的。
      * **信号处置 (重置)**: `launcher` 为 `SIGINT` 设置了自定义处理器，但 `target` 检查时发现它已被重置为默认行为 (`SIG_DFL`)。这与表中“已捕获的信号会恢复为默认处置”的说明一致。



您提了一个非常棒的问题，这正是 `fork()` 和 `exec()` 在文件描述符处理上最核心且容易混淆的区别。

简单来说：

  * **`fork()` 是关于“共享”**：创建了**两个独立进程**，它们共同使用同一个“打开的文件”。
  * **`exec()` 是关于“继承”**：还是那**一个进程**，只是它换了一套新代码，并把旧的文件描述符带了过去继续用。

下面我们用一个类比和详细的技术解释来彻底说明这个区别。

### 角色类比

想象一下在图书馆里：

  * **内核** = 图书馆
  * **打开文件描述 (Open File Description)** = 一本**具体的、被借出的书**，上面有唯一的借阅记录，记录着当前书签（文件偏移量）夹在哪一页。
  * **文件描述符 (File Descriptor)** = 你手里的**借书卡**，上面有个编号（比如3号），这张卡关联着那本被借出的书。
  * **进程** = 一个读者

-----

#### `fork()` 的情况：**复印了一张借书卡**

1.  你（**父进程**）用你的3号借书卡（**FD=3**）借了一本书（**打开文件描述**），并且看到了第50页（**文件偏移量=50**）。
2.  你调用 `fork()`，相当于你找来一个克隆人（**子进程**）。
3.  图书馆（**内核**）给你克隆人一张一模一样的3号借书卡（**子进程复制了父进程的文件描述符表**）。
4.  现在，**有两个读者（两个进程）**，每个人手里都有一张3号卡。但这两张卡都指向图书馆里**同一本被借出的书（同一个打开文件描述）**。

**关键结果 (共享):**

  * 如果你的克隆人（子进程）用他的3号卡继续读了10页，那么书里的书签（文件偏移量）就移动到了第60页。
  * 当你（父进程）再拿起你的3号卡去看书时，你会发现书签已经在第60页了。
  * **你们两个进程通过各自的描述符，影响的是同一个底层资源。这就是“共享”。**

-----

#### `exec()` 的情况：**换了一本指导手册**

1.  你（**进程 PID 123**）用你的3号借书卡（**FD=3**）借了一本C语言编程书（**旧程序**），看到了第50页。
2.  你觉得C语言太难了，决定换一本Python编程书（**新程序**），于是你调用 `exec()`。
3.  你**还是你（进程 PID 123没变）**，你没有离开图书馆，也没有克隆人。你只是把手里的C语言书放下了，换成了Python书。
4.  但是，你口袋里的那张3号借书卡（**FD=3**）还在，它**仍然关联着**你之前借的那本未读完的书（**同一个打开文件描述**）。

**关键结果 (继承):**

  * 你的新程序（Python）可以从口袋里拿出这张3号卡，继续操作之前打开的那个文件。
  * 由于还是你一个人，所以文件偏移量自然也是连续的。
  * **新程序继承了旧程序的资源。这里没有第二个进程参与，所以不是“共享”，而是“延续”或“继承”。**

### 技术总结

| 特性 | `fork()` 的行为 | `exec()` 的行为 |
| :--- | :--- | :--- |
| **进程数量** | **1 个变 2 个**。创建了一个全新的子进程。 | **仍然是 1 个**。没有创建新进程，PID 不变。 |
| **文件描述符表** | 子进程获得父进程文件描述符表的**一份副本**。 | 当前进程的**文件描述符表被保留**下来，供新程序使用。 |
| **打开文件描述** | 父子进程中对应的文件描述符**指向同一个内核的打开文件描述**。 | 新程序中保留的文件描述符**指向与旧程序完全相同的打开文件描述**。 |
| **核心概念** | **共享 (Sharing)** | **继承 (Inheritance)** |
| **主要后果** | 父子进程共享文件偏移量和文件状态。一个进程的`read/write`会影响另一个。 | 新程序可以无缝地继续使用旧程序打开的文件、套接字等资源。 |
| **例外** | 无 | 如果文件描述符被设置了 `close-on-exec` 标志，那么在`exec()`之后它会被自动关闭，新程序无法继承。 |

所以，在您的示例代码中：

  * `launcher` 打开文件，得到一个 FD。
  * `launcher` 调用 `exec()` 变身为 `target`。
  * `target` **继承**了这个 FD，继续使用。整个过程只有一个进程参与。

而 `fork()` 的例子中，是父子两个进程在一段时间内**共享**同一个打开的文件。