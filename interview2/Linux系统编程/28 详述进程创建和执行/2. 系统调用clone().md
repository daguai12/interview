# 概述
### 关于 `clone()` 系统调用的核心概念

`clone()` 是一个 Linux 特有的系统调用，用于创建一个新进程。它与常见的 `fork()` 和 `vfork()` 类似，但提供了更精细的控制，允许调用者明确指定父进程和子进程之间需要共享哪些资源。由于其复杂性和对资源共享的精确控制能力，`clone()` 主要被用于实现线程库（例如 POSIX 线程），而不是直接在应用程序中使用，以保证程序的可移植性。

### `clone()` 与 `fork()` 的主要区别

1.  **子进程的执行起点**:
    * `fork()` 创建的子进程从 `fork()` 调用返回处继续执行。
    * `clone()` 创建的子进程则会去执行一个通过参数 `func` 指定的特定函数（称为子函数）。

2.  **子进程的栈空间**:
    * `fork()` 会为子进程创建一个独立的虚拟地址空间，包括一个独立的栈。
    * `clone()` 创建的子进程可能会与父进程共享虚拟内存（通过 `CLONE_VM` 标志）。在这种情况下，子进程不能使用父进程的栈。因此，调用 `clone()` 时必须手动为子进程分配一块内存作为其栈空间，并通过 `child_stack` 参数传入。

3.  **参数传递**:
    * `clone()` 允许通过 `func_arg` 参数向子进程的启动函数 `func` 传递一个参数。

4.  **终止信号**:
    * `fork()` 和 `vfork()` 创建的子进程终止时，固定向父进程发送 `SIGCHLD` 信号。
    * `clone()` 允许通过 `flags` 参数的低字节来指定子进程终止时发送给父进程的信号，提供了更大的灵活性。

5.  **资源共享的控制**:
    * 这是 `clone()` 最核心的特点。通过在 `flags` 参数中设置不同的位掩码（如 `CLONE_VM`, `CLONE_FILES`, `CLONE_SIGHAND` 等），可以精确控制子进程与父进程共享哪些资源，例如：
        * **`CLONE_VM`**: 共享虚拟内存空间。
        * **`CLONE_FILES`**: 共享打开的文件描述符表。
        * **`CLONE_FS`**: 共享文件系统相关信息（如根目录、当前工作目录）。
        * **`CLONE_SIGHAND`**: 共享信号处理器表。
        * **`CLONE_THREAD`**: 将子进程放入父进程的线程组，这使得父子进程表现得像同一进程下的两个线程。

### `clone()` 的实现细节

* 在内核层面，`fork()`、`vfork()` 和 `clone()` 最终都由同一个内部函数 `do_fork()` 实现。
* 我们通常在C库（glibc）中使用的 `clone()` 函数实际上是对底层 `sys_clone()` 系统调用的一个封装。这个封装函数负责在子进程从系统调用返回后，调用我们指定的 `func` 函数。

### 程序清单 28-3 示例分析

该示例程序清晰地展示了 `clone()` 的 `CLONE_FILES` 标志的效果：

* **目标**: 验证父子进程是否共享文件描述符表。
* **流程**:
    1.  父进程打开一个文件描述符。
    2.  父进程调用 `clone()` 创建子进程。
    3.  子进程在其启动函数 `childFunc()` 中关闭这个文件描述符，然后退出。
    4.  父进程等待子进程结束后，尝试使用该文件描述符进行写入操作。

* **两种运行情况**:
    1.  **不带命令行参数 (`flags` = 0)**:
        * 父子进程拥有各自独立的文件描述符表。
        * 子进程关闭它的文件描述符副本，不会影响父进程的文件描述符。
        * 因此，父进程最后的 `write()` 操作 **成功**。
    2.  **带命令行参数 (`flags` = `CLONE_FILES`)**:
        * 父子进程共享同一个文件描述符表。
        * 子进程关闭文件描述符时，这个操作对父进程同样生效。
        * 因此，父进程最后的 `write()` 操作会因为文件描述符已被关闭而 **失败**。

这个例子完美地诠释了 `clone()` 如何通过 `flags` 参数来精确控制父子进程间的资源共享。


## clone()的flags参数

这是对您提供的关于 `clone()` 系统调用 `flags` 参数详细说明的文本内容的总结和要点提炼。

### `clone()` flags 参数的核心思想

`clone()` 的 `flags` 参数是一个通过“位或”操作组合起来的位掩码，它精确地控制了新创建的子进程（或线程）与父进程之间共享哪些资源。文本的核心观点是，所谓的“进程”和“线程”其实都是**内核调度实体（Kernel Scheduling Entity, KSE）**，它们之间的区别仅仅在于与其他KSE共享资源的程度不同。`clone()` 的 `flags` 参数正是实现这种不同共享程度的关键。

---

### 为实现 POSIX 线程而设计的标志 (资源共享)

这些标志定义了 POSIX 线程标准所要求的、同一进程内所有线程必须共享的核心资源。

* **`CLONE_FILES`**: **共享文件描述符表**。父子进程（线程）共享同一个文件描述符表。在一个线程中执行 `open()` 或 `close()` 会立即影响到所有其他线程。
* **`CLONE_FS`**: **共享文件系统信息**。父子进程共享如权限掩码 (umask)、当前工作目录和根目录等信息。在一个线程中调用 `chdir()` 会改变所有线程的当前目录。
* **`CLONE_SIGHAND`**: **共享信号处置表**。父子进程共享同一份信号处理函数的设置。在一个线程中调用 `sigaction()` 会改变所有线程对该信号的处理方式。**注意**：此标志不共享信号掩码（signal mask）和挂起信号（pending signals），这两者是每个线程独立的。
* **`CLONE_VM`**: **共享虚拟内存**。父子进程共享同一个虚拟内存空间。这是线程最关键的属性之一，一个线程对内存的修改对所有其他线程立即可见。

---

### 线程组概念: `CLONE_THREAD`

这是自 Linux 2.4 内核以来实现 POSIX 线程的核心标志。

* **作用**: 将新创建的子进程放入父进程的**线程组（thread group）**中。
* **线程组ID (TGID)**: 同一个线程组中的所有线程共享一个相同的线程组ID (TGID)。最关键的一点是，**TGID 就是我们通常所说的进程ID (PID)**。因此，组内任何线程调用 `getpid()` 都会返回相同的值。
* **线程ID (TID)**: 线程组内的每个线程都有一个全系统唯一的线程ID (TID)，可以通过 `gettid()` 系统调用获取。线程组的第一个线程（领导者）的TID与其TGID相同。
* **重要影响**:
    * 如果组内任一线程调用了 `exec()`，那么除领导者线程外的所有其他线程都会终止，新程序将在领导者线程的上下文中执行。
    * 只有当线程组中所有线程都终止后，其父进程才会收到 `SIGCHLD` 等终止信号。
    * 不能对设置了此标志的单个线程使用 `wait()` 来等待其结束，必须使用 `pthread_join()` 这样的线程同步机制。

---

### 为高级线程库 (NPTL) 提供的支持标志

这些标志主要在 Linux 2.6 中引入，用于支持 NPTL (Native POSIX Thread Library)，解决了线程创建时的竞争条件并实现了高效的线程同步。

* **`CLONE_PARENT_SETTID`**: 内核在 `clone()` 从父进程返回**之前**，将新线程的TID写入 `ptid` 参数指向的内存地址。这为父线程提供了一种无竞争的、可靠的获取子线程ID的方法。
* **`CLONE_CHILD_SETTID`**: 内核将新线程的TID写入 `ctid` 参数指向的、位于子线程内存中的地址。
* **`CLONE_CHILD_CLEARTID`**: 当子线程终止时，内核会自动将 `ctid` 指向的内存位置清零。这个机制与 **futex** (快速用户空间互斥锁) 结合使用，是 `pthread_join()` 实现的关键。等待线程可以通过在一个 futex 上休眠来监控这个内存地址，当内核清零该地址时，会唤醒等待的线程。
* **`CLONE_SETTLS`**: 为新线程设置线程本地存储 (Thread-Local Storage)，其描述信息由 `tls` 参数指定。
* **`CLONE_SYSVSEM`**: 父子进程共享 System V 信号量的“撤销值”列表，这是 POSIX 规范所要求的。

---

### 为实现命名空间隔离的标志 (容器技术)

这些标志是现代容器技术（如 Docker）的基石，它们允许进程拥有独立的系统资源实例，从而实现环境隔离。

* **`CLONE_NEWNS`**: 为子进程创建一个新的**挂载命名空间**。子进程中的 `mount()` 和 `umount()` 操作将独立于系统中的其他进程。
* **其他命名空间标志**:
    * `CLONE_NEWIPC`: 隔离 System V IPC 对象。
    * `CLONE_NEWNET`: 隔离网络栈（IP地址、路由表等）。
    * `CLONE_NEWPID`: 隔离进程ID。在新空间中，第一个进程的PID为1。
    * `CLONE_NEWUSER`: 隔离用户和组ID。
    * `CLONE_NEWUTS`: 隔离主机名和域名。

---

### 其他杂项标志

* **`CLONE_PARENT`**: 使子进程的父进程与调用者的父进程相同。
* **`CLONE_PID`**: (**已废止**) 使子进程与父进程拥有相同的PID。仅用于系统启动过程。
* **`CLONE_PTRACE`**: 如果父进程正在被跟踪（tracing），那么子进程也会被跟踪。
* **`CLONE_VFORK`**: 挂起父进程，直到子进程调用 `exec()` 或 `_exit()`。这模拟了 `vfork()` 的行为。

### 总结: `clone()` 在实践中的应用

文本最后总结了几个常见函数实际上是如何通过特定 `clone()` 标志组合实现的：

* **`fork()`**: 大致相当于 `clone(..., SIGCHLD, ...)`。
* **`vfork()`**: 相当于 `clone(..., CLONE_VFORK | CLONE_VM | SIGCHLD, ...)`。
* **LinuxThreads (旧版线程库)**: 使用 `CLONE_VM | CLONE_FILES | CLONE_FS | CLONE_SIGHAND`。
* **NPTL (现代线程库)**: 使用 `CLONE_VM | CLONE_FILES | CLONE_FS | CLONE_SIGHAND | CLONE_THREAD | CLONE_SYSVSEM | CLONE_SETTLS | CLONE_PARENT_SETTID | CLONE_CHILD_CLEARTID` 等一系列标志的组合。


![[Pasted image 20250828111412.png]]



## 因克隆生成的子进程而对 waitpid()进行扩展
## 一、3个扩展标志的核心功能（Linux特有）
`waitpid()` 的原型为：
```c
pid_t waitpid(pid_t pid, int *wstatus, int options);
```
其中 `options` 参数除了标准的 `WNOHANG`（非阻塞等待）、`WUNTRACED`（等待暂停子进程），针对 `clone()` 子进程新增了以下3个标志，核心是解决“区分克隆/非克隆子进程”“限制线程组内等待范围”的问题：

| 标志名           | 内核支持版本     | 核心功能                                             | 关键细节                                                                                                                                        |
| ------------- | ---------- | ------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------- |
| `__WCLONE`    | 早期Linux    | **仅等待“克隆子进程”**（即由 `clone()` 创建的子进程）。             | 1. 未设置时，`waitpid()` 仅等待“非克隆子进程”（如 `fork()` 创建的）；<br>2. 克隆子进程终止时，给父进程发的信号**不是 `SIGCHLD`**（需通过此标志捕获）；<br>3. 若与 `__WALL` 同时设置，`__WCLONE` 会被忽略。 |
| `__WALL`      | Linux 2.4+ | **等待所有子进程**，无论类型（克隆子进程、非克隆子进程通吃）。                | 解决“需同时等待 `fork()` 和 `clone()` 子进程”的场景，优先级高于 `__WCLONE`。                                                                                     |
| `__WNOTHREAD` | Linux 2.4+ | **限制等待范围**：仅等待“调用者自己创建的子进程”，不等待“同线程组其他线程创建的子进程”。 | 默认情况下，`wait()` 类函数会等待“整个线程组内所有进程创建的子进程”；此标志缩小范围到“当前线程的子进程”。                                                                                 |


## 二、关键场景对比：何时用哪个标志？
结合 `clone()` 的特性（可创建“轻量级子进程”，甚至共享PID），不同场景下标志的选择差异很大，通过示例可更直观理解：

### 场景1：仅等待 `clone()` 创建的克隆子进程
若父进程用 `clone()` 创建了子进程（如共享文件描述符的子进程），且需捕获其终止状态，需用 `__WCLONE`：
```c
pid_t child_pid = clone(child_func, stack_top, CLONE_FILES, NULL); // 创建克隆子进程
int wstatus;
// 仅等待该克隆子进程（非阻塞，避免阻塞主进程）
pid_t waited_pid = waitpid(child_pid, &wstatus, __WCLONE | WNOHANG);
if (waited_pid == child_pid) {
    printf("克隆子进程 %d 已终止\n", child_pid);
}
```


### 场景2：同时等待 `fork()` 和 `clone()` 子进程
若父进程既用 `fork()` 创建了常规子进程，又用 `clone()` 创建了克隆子进程，需用 `__WALL` 覆盖所有类型：
```c
// 1. fork() 创建非克隆子进程
pid_t fork_pid = fork();
// 2. clone() 创建克隆子进程
pid_t clone_pid = clone(child_func, stack_top, CLONE_VM, NULL);

int wstatus;
// 等待所有子进程（无论克隆/非克隆），阻塞直到有子进程终止
pid_t waited_pid = waitpid(-1, &wstatus, __WALL); 
printf("子进程 %d 已终止（可能是 fork 或 clone 创建的）\n", waited_pid);
```


### 场景3：线程组中仅等待“当前线程的子进程”
在多线程程序中，线程A创建的子进程默认会被线程B的 `waitpid()` 捕获（因同属一个线程组）。若线程B仅想等待自己的子进程，需用 `__WNOTHREAD`：
```c
// 线程函数：仅等待自己创建的子进程
void *thread_func(void *arg) {
    pid_t my_child = clone(child_func, stack_top, 0, NULL); // 线程创建的克隆子进程
    int wstatus;
    // 仅等待“当前线程创建的子进程”，不等待其他线程的子进程
    waitpid(-1, &wstatus, __WNOTHREAD | __WALL); 
    printf("当前线程的子进程 %d 已终止\n", my_child);
    return NULL;
}
```


## 三、关键注意事项
1. **`__WCLONE` 与 `SIGCHLD` 的关系**  
   常规 `fork()` 子进程终止时会给父进程发 `SIGCHLD`，但 `clone()` 子进程（尤其是设置了 `CLONE_THREAD` 等共享PID的标志时）终止时，发的信号**不是 `SIGCHLD`**（可能是 `SIGUSR1` 等自定义信号，或不发信号）。因此必须通过 `__WCLONE` 主动等待，否则克隆子进程可能变成“僵尸进程”。

2. **标志的兼容性限制**  
   - 这些标志是 **Linux特有**，不遵循POSIX标准（SUSv3未定义），跨UNIX系统（如BSD、Solaris）不兼容；  
   - `waitid()` 不支持这些标志（手册明确说明），若需用 `waitid()` 等待子进程，无法区分克隆/非克隆类型。

3. **`__WALL` 与 `__WCLONE` 的优先级**  
   若同时设置 `__WALL` 和 `__WCLONE`，`__WCLONE` 会被忽略——`__WALL` 的“等待所有”逻辑覆盖“仅等待克隆”的逻辑，避免冲突。


## 总结
这3个扩展标志的本质是 **为 `clone()` 的灵活性配套“精细化等待能力”**：
- `__WCLONE`：聚焦“克隆子进程”，解决“常规 `waitpid()` 抓不到克隆子进程”的问题；  
- `__WALL`：覆盖“所有子进程”，解决“混合使用 `fork()` 和 `clone()` 时的等待效率”问题；  
- `__WNOTHREAD`：缩小“等待范围”，解决“多线程环境下子进程归属混乱”的问题。  

在使用 `clone()` 时，需根据子进程的创建方式和业务需求，选择对应的 `waitpid()` 标志，避免僵尸进程或等待错误。


# 代码案例
**准备工作：必要的头文件**
所有案例都需要包含以下头文件。为了避免重复，这里统一列出：

```c
#define _GNU_SOURCE // 必须定义这个宏才能使用 clone 和 __WALL 等标志
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sched.h>
#include <sys/wait.h>
#include <sys/types.h>
#include <pthread.h> // 场景3需要
```

-----

### 场景1：仅等待 `clone()` 创建的特定子进程 (`__WCLONE`)

**目标**：父进程创建一个 `clone` 子进程，并使用 `waitpid()` 配合 `__WCLONE` 和 `WNOHANG` 标志，以非阻塞的方式专门等待这个子进程。

**完整代码 (`scenario1.c`)**

```c
#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sched.h>
#include <sys/wait.h>

#define STACK_SIZE (1024 * 1024) // 1 MB stack

// 子进程要执行的函数
int child_func(void *arg) {
    printf("  [克隆子进程 PID: %d] 正在运行...\n", getpid());
    sleep(3); // 模拟工作
    printf("  [克隆子进程 PID: %d] 准备退出。\n", getpid());
    return 42; // 退出状态码
}

int main() {
    // 为子进程分配栈空间
    char *stack = malloc(STACK_SIZE);
    if (!stack) {
        perror("malloc");
        exit(EXIT_FAILURE);
    }
    char *stack_top = stack + STACK_SIZE; // 栈顶在高地址

    printf("[父进程 PID: %d] 准备创建克隆子进程...\n", getpid());

    // 创建一个共享文件描述符的克隆子进程
    // SIGCHLD 信号确保父进程可以收到子进程终止的通知
    pid_t child_pid = clone(child_func, stack_top, SIGCHLD | CLONE_FILES, NULL);
    if (child_pid == -1) {
        perror("clone");
        free(stack);
        exit(EXIT_FAILURE);
    }

    printf("[父进程 PID: %d] 已创建克隆子进程，其 PID 为 %d\n", getpid(), child_pid);

    int wstatus;
    pid_t waited_pid;

    // 非阻塞轮询，专门等待该克隆子进程
    while ((waited_pid = waitpid(child_pid, &wstatus, __WCLONE | WNOHANG)) == 0) {
        printf("[父进程] 正在等待克隆子进程 %d，但它还没结束...\n", child_pid);
        sleep(1);
    }

    if (waited_pid > 0) {
        printf("\n[父进程] 成功捕获到克隆子进程 %d 的终止状态！\n", waited_pid);
        if (WIFEXITED(wstatus)) {
            printf("  -> 子进程正常退出，退出码为: %d\n", WEXITSTATUS(wstatus));
        }
    } else {
        perror("waitpid");
    }

    free(stack);
    return 0;
}
```

**编译与运行**

```bash
gcc -o scenario1 scenario1.c
./scenario1
```

**预期输出**

```
[父进程 PID: 12345] 准备创建克隆子进程...
[父进程 PID: 12345] 已创建克隆子进程，其 PID 为 12346
  [克隆子进程 PID: 12346] 正在运行...
[父进程] 正在等待克隆子进程 12346，但它还没结束...
[父进程] 正在等待克隆子进程 12346，但它还没结束...
[父进程] 正在等待克隆子进程 12346，但它还没结束...
  [克隆子进程 PID: 12346] 准备退出。

[父进程] 成功捕获到克隆子进程 12346 的终止状态！
  -> 子进程正常退出，退出码为: 42
```

**分析**：父进程通过 `__WCLONE` 明确告诉 `waitpid` 它要等待的是一个（可能与父进程共享资源的）`clone` 子进程。`WNOHANG` 使父进程不会被阻塞，可以继续执行其他任务。

-----

### 场景2：同时等待 `fork()` 和 `clone()` 创建的子进程 (`__WALL`)

**目标**：父进程同时创建了一个常规 `fork` 子进程和一个 `clone` 子进程，然后使用 `waitpid(-1, ..., __WALL)` 等待任何一个子进程终止。

**完整代码 (`scenario2.c`)**

```c
#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sched.h>
#include <sys/wait.h>

#define STACK_SIZE (1024 * 1024)

int clone_child_func(void *arg) {
    printf("  [克隆子进程 PID: %d] 正在运行 (将休眠4秒)...\n", getpid());
    sleep(4);
    printf("  [克隆子进程 PID: %d] 退出。\n", getpid());
    return 1;
}

int main() {
    char *stack = malloc(STACK_SIZE);
    if (!stack) {
        perror("malloc");
        exit(EXIT_FAILURE);
    }
    char *stack_top = stack + STACK_SIZE;

    printf("[父进程 PID: %d] 准备创建子进程...\n", getpid());

    // 1. 创建常规 fork 子进程
    pid_t fork_pid = fork();
    if (fork_pid == 0) { // fork 子进程代码
        printf("  [Fork子进程 PID: %d] 正在运行 (将休眠2秒)...\n", getpid());
        sleep(2);
        printf("  [Fork子进程 PID: %d] 退出。\n", getpid());
        exit(0);
    } else if (fork_pid < 0) {
        perror("fork");
    }

    // 2. 创建 clone 子进程
    pid_t clone_pid = clone(clone_child_func, stack_top, SIGCHLD | CLONE_VM, NULL);
    if (clone_pid < 0) {
        perror("clone");
    }

    printf("[父进程] 已创建 Fork子进程(%d) 和 Clone子进程(%d)\n", fork_pid, clone_pid);
    printf("[父进程] 等待任意一个子进程终止...\n");

    int wstatus;
    int children_waited = 0;
    while (children_waited < 2) {
        // 使用 __WALL 等待所有类型的子进程
        pid_t waited_pid = waitpid(-1, &wstatus, __WALL);
        if (waited_pid > 0) {
            printf("\n[父进程] 捕获到子进程 %d 终止！\n", waited_pid);
            if (waited_pid == fork_pid) {
                printf("  -> 这是 Fork 创建的子进程。\n");
            } else if (waited_pid == clone_pid) {
                printf("  -> 这是 Clone 创建的子进程。\n");
            }
            children_waited++;
        }
    }
    
    printf("[父进程] 所有子进程都已退出。\n");
    free(stack);
    return 0;
}
```

**编译与运行**

```bash
gcc -o scenario2 scenario2.c
./scenario2
```

**预期输出** (顺序可能因调度而不同)

```
[父进程 PID: 23456] 准备创建子进程...
  [Fork子进程 PID: 23457] 正在运行 (将休眠2秒)...
[父进程] 已创建 Fork子进程(23457) 和 Clone子进程(23458)
[父进程] 等待任意一个子进程终止...
  [克隆子进程 PID: 23458] 正在运行 (将休眠4秒)...
  [Fork子进程 PID: 23457] 退出。

[父进程] 捕获到子进程 23457 终止！
  -> 这是 Fork 创建的子进程。
  [克隆子进程 PID: 23458] 退出。

[父进程] 捕获到子进程 23458 终止！
  -> 这是 Clone 创建的子进程。
[父进程] 所有子进程都已退出。
```

**分析**：`__WALL` 标志像一张“通票”，让 `waitpid` 可以捕获所有类型的子进程，无论是 `fork` 创建的标准进程，还是 `clone` 创建的轻量级进程或线程。

-----

### 场景3：线程仅等待自己的子进程 (`__WNOTHREAD`)

**目标**：创建两个线程，每个线程都各自创建一个 `clone` 子进程。通过 `__WNOTHREAD` 标志，确保每个线程的 `waitpid` 调用只会捕获到自己创建的子进程，而不会“误捕”其他线程的子进程。

**完整代码 (`scenario3.c`)**

```c
#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sched.h>
#include <sys/wait.h>
#include <pthread.h>

#define STACK_SIZE (1024 * 1024)

// 线程子进程执行的函数
int child_func(void *arg) {
    long thread_id = (long)arg;
    printf("    [子进程 of 线程 %ld, PID: %d] 正在运行...\n", thread_id, getpid());
    sleep(2);
    printf("    [子进程 of 线程 %ld, PID: %d] 退出。\n", thread_id, getpid());
    return (int)thread_id;
}

// 线程函数
void *thread_func(void *arg) {
    long thread_num = (long)arg;
    printf("  [线程 %ld] 启动，准备创建自己的子进程。\n", thread_num);

    char *stack = malloc(STACK_SIZE);
    char *stack_top = stack + STACK_SIZE;

    // 线程创建自己的子进程，把线程号传给它
    pid_t my_child_pid = clone(child_func, stack_top, SIGCHLD, (void*)thread_num);
    if (my_child_pid == -1) {
        perror("clone in thread");
        free(stack);
        return NULL;
    }

    printf("  [线程 %ld] 已创建子进程 PID: %d，现在等待它...\n", thread_num, my_child_pid);
    
    int wstatus;
    // 使用 __WNOTHREAD，确保只等待自己创建的子进程
    // __WALL 配合使用，以捕获 clone 子进程
    pid_t waited_pid = waitpid(-1, &wstatus, __WNOTHREAD | __WALL);

    if (waited_pid > 0) {
        printf("  [线程 %ld] 成功捕获到**自己**的子进程 %d。\n", thread_num, waited_pid);
        if (WIFEXITED(wstatus)) {
            printf("    -> 子进程退出码: %d\n", WEXITSTATUS(wstatus));
        }
    } else {
        printf("  [线程 %ld] waitpid 失败或没有捕获到自己的子进程。\n", thread_num);
        perror("waitpid in thread");
    }

    free(stack);
    return NULL;
}

int main() {
    pthread_t t1, t2;
    printf("[主进程] 准备创建两个线程...\n");

    pthread_create(&t1, NULL, thread_func, (void*)1L);
    pthread_create(&t2, NULL, thread_func, (void*)2L);

    pthread_join(t1, NULL);
    pthread_join(t2, NULL);

    printf("[主进程] 所有线程执行完毕。\n");
    return 0;
}
```

**编译与运行**

```bash
gcc -o scenario3 scenario3.c -pthread
./scenario3
```

**预期输出** (线程和子进程的启动顺序不固定)

```
[主进程] 准备创建两个线程...
  [线程 1] 启动，准备创建自己的子进程。
  [线程 2] 启动，准备创建自己的子进程。
  [线程 1] 已创建子进程 PID: 34567，现在等待它...
    [子进程 of 线程 1, PID: 34567] 正在运行...
  [线程 2] 已创建子进程 PID: 34568，现在等待它...
    [子进程 of 线程 2, PID: 34568] 正在运行...
    [子进程 of 线程 1, PID: 34567] 退出。
  [线程 1] 成功捕获到**自己**的子进程 34567。
    -> 子进程退出码: 1
    [子进程 of 线程 2, PID: 34568] 退出。
  [线程 2] 成功捕获到**自己**的子进程 34568。
    -> 子进程退出码: 2
[主进程] 所有线程执行完毕。
```

**分析**：`__WNOTHREAD` 就像一个过滤器，它告诉 `waitpid`：“请不要管这个进程（线程组）中其他线程创建的子进程，我只关心由我这个特定线程直接创建的后代。” 这在复杂的并发程序中对于明确责任、避免“抢夺”子进程状态至关重要。