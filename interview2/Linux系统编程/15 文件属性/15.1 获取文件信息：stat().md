### **15.1 获取文件信息：stat()**

利用系统调用 `stat()`、`lstat()` 以及 `fstat()`，可获取与文件有关的详细信息，其中大部分信息提取自文件的 i-node。

```c
#include <sys/stat.h>

int stat(const char *pathname, struct stat *statbuf);
int lstat(const char *pathname, struct stat *statbuf);
int fstat(int fd, struct stat *statbuf);
```

以上三个系统调用之间唯一的区别在于对文件的描述方式不同：

  * **`stat()`**: 返回路径名 `pathname` 所指定文件的相关信息。如果 `pathname` 是一个符号链接，它会**跟随**链接，返回链接所指向文件的信息。
  * **`lstat()`**: 与 `stat()` 类似，但如果 `pathname` 是一个符号链接，它**不会**跟随链接，而是返回符号链接**自身**的信息。
  * **`fstat()`**: 返回由一个已打开的文件描述符 `fd` 所指代文件的相关信息。

这些系统调用都会在 `statbuf` 指向的 `stat` 结构体中返回信息，其格式如下：

```c
struct stat {
    dev_t     st_dev;         /* ID of device containing file */
    ino_t     st_ino;         /* Inode number */
    mode_t    st_mode;        /* File type and mode */
    nlink_t   st_nlink;       /* Number of hard links */
    uid_t     st_uid;         /* User ID of owner */
    gid_t     st_gid;         /* Group ID of owner */
    dev_t     st_rdev;        /* Device ID (if special file) */
    off_t     st_size;        /* Total size, in bytes */
    blksize_t st_blksize;     /* Block size for filesystem I/O */
    blkcnt_t  st_blocks;      /* Number of 512B blocks allocated */
    struct timespec st_atim;  /* Time of last access */
    struct timespec st_mtim;  /* Time of last modification */
    struct timespec st_ctim;  /* Time of last status change */
};
```

#### **`stat` 结构体字段详解**

  * **设备 ID 和 i-node 号 (`st_dev`, `st_ino`)**
    这两个字段的组合可以在整个系统中唯一地标识一个文件。`st_rdev` 字段则用于标识设备文件本身的主、辅 ID。

  * **文件所有权 (`st_uid`, `st_gid`)**
    这两个字段分别标识文件属主的用户 ID (UID) 和文件属组的组 ID (GID)。

  * **链接数 (`st_nlink`)**
    该字段包含了指向此文件的硬链接（hard link）数量。

  * **文件类型及权限 (`st_mode`)**
    这是一个位掩码，包含了文件类型和文件权限两部分信息。可以使用下表中定义的宏来方便地检查文件类型：

| 常量         | 测试宏          | 文件类型     |
| :--------- | :----------- | :------- |
| `S_IFREG`  | `S_ISREG()`  | 常规文件     |
| `S_IFDIR`  | `S_ISDIR()`  | 目录       |
| `S_IFCHR`  | `S_ISCHR()`  | 字符设备     |
| `S_IFBLK`  | `S_ISBLK()`  | 块设备      |
| `S_IFIFO`  | `S_ISFIFO()` | FIFO 或管道 |
| `S_IFSOCK` | `S_ISSOCK()` | 套接字      |
| `S_IFLNK`  | `S_ISLNK()`  | 符号链接     |

  * **文件大小、已分配块以及最优 I/O 块大小**

      * **`st_size`**: 对于常规文件，表示文件的字节数。对于符号链接，表示链接所指路径名的长度。
      * **`st_blocks`**: 表示实际分配给文件的总块数，单位是 **512 字节**。对于包含“空洞”的稀疏文件，该值会小于 `st_size` 推算出的块数。
      * **`st_blksize`**: 指进行文件 I/O 操作时的**最优块大小**（字节），通常是 4096。

  * **文件时间戳**

      * **`st_atime` (st\_atim)**: 文件的上次**访问**时间。
      * **`st_mtime` (st\_mtim)**: 文件的上次**修改**时间 (内容变更)。
      * **`st_ctime` (st\_ctim)**: 文件的上次**状态改变**时间 (i-node 变更)。

-----

#### **程序示例**

程序清单 15-1 使用 `stat()` (或 `lstat()`) 去获取文件信息，并将其打印出来。

**`stat_demo.c` 文件:**

```c
#include <sys/stat.h>
#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

// 辅助函数：将 st_mode 转换为 "rwxrwxrwx" 格式的字符串
// (这是程序清单 15-4 中 filePermStr() 的一个实现)
char* filePermStr(mode_t perm) {
    static char str[11];
    strcpy(str, "----------");

    if (S_ISDIR(perm)) str[0] = 'd';
    if (S_ISCHR(perm)) str[0] = 'c';
    if (S_ISBLK(perm)) str[0] = 'b';
    if (S_ISLNK(perm)) str[0] = 'l';
    if (S_ISFIFO(perm)) str[0] = 'p';
    if (S_ISSOCK(perm)) str[0] = 's';
    
    if (perm & S_IRUSR) str[1] = 'r';
    if (perm & S_IWUSR) str[2] = 'w';
    if (perm & S_IXUSR) str[3] = 'x';

    if (perm & S_IRGRP) str[4] = 'r';
    if (perm & S_IWGRP) str[5] = 'w';
    if (perm & S_IXGRP) str[6] = 'x';

    if (perm & S_IROTH) str[7] = 'r';
    if (perm & S_IWOTH) str[8] = 'w';
    if (perm & S_IXOTH) str[9] = 'x';

    return str;
}


int main(int argc, char *argv[]) {
    struct stat sb;
    int use_lstat = 0;
    int opt;

    // 解析 -l 选项
    while ((opt = getopt(argc, argv, "l")) != -1) {
        if (opt == 'l') {
            use_lstat = 1;
        }
    }

    if (optind >= argc) {
        fprintf(stderr, "Usage: %s [-l] file\n", argv[0]);
        exit(EXIT_FAILURE);
    }
    
    const char *filepath = argv[optind];
    int ret;

    if (use_lstat) {
        ret = lstat(filepath, &sb);
    } else {
        ret = stat(filepath, &sb);
    }

    if (ret == -1) {
        perror("stat/lstat");
        exit(EXIT_FAILURE);
    }

    printf("File:                     %s\n", filepath);
    printf("Inode number:             %ld\n", (long)sb.st_ino);
    printf("Mode:                     %lo (%s)\n", (unsigned long)sb.st_mode, filePermStr(sb.st_mode));
    printf("Link count:               %ld\n", (long)sb.st_nlink);
    printf("Ownership:                UID=%ld   GID=%ld\n", (long)sb.st_uid, (long)sb.st_gid);
    printf("Device ID:                [%lx,%lx]\n", (long)major(sb.st_dev), (long)minor(sb.st_dev));
    if (S_ISCHR(sb.st_mode) || S_ISBLK(sb.st_mode)) {
        printf("Device ID (if special file): [%lx,%lx]\n", (long)major(sb.st_rdev), (long)minor(sb.st_rdev));
    }
    printf("File size:                %lld bytes\n", (long long)sb.st_size);
    printf("Optimal I/O block size:   %ld bytes\n", (long)sb.st_blksize);
    printf("512B blocks allocated:    %lld\n", (long long)sb.st_blocks);
    
    printf("Last file access:         %s", ctime(&sb.st_atime));
    printf("Last file modification:   %s", ctime(&sb.st_mtime));
    printf("Last status change:       %s", ctime(&sb.st_ctime));

    exit(EXIT_SUCCESS);
}
```

**编译和运行演示**

1.  **准备环境:**

    ```bash
    # 编译程序
    gcc stat_demo.c -o stat_demo
    # 创建一个普通文件和一个指向它的符号链接
    echo "hello" > a.txt
    ln -s a.txt a_link
    ```

2.  **对普通文件执行 `stat()`:**

    ```bash
    ./stat_demo a.txt
    ```

    **输出:**

    ```
    File:                     a.txt
    Inode number:             123456
    Mode:                     100664 (-rw-rw-r--)
    Link count:               1
    ...
    File size:                6 bytes
    ...
    ```

3.  **对符号链接执行 `stat()` (跟随链接):**

    ```bash
    ./stat_demo a_link
    ```

    **输出:** (和上面对 a.txt 的输出几乎完全一样，因为 `stat` 跟随了链接)

    ```
    File:                     a_link
    Inode number:             123456
    Mode:                     100664 (-rw-rw-r--)
    ...
    File size:                6 bytes
    ...
    ```

4.  **对符号链接执行 `lstat()` (不跟随链接):**

    ```bash
    ./stat_demo -l a_link
    ```

    **输出:** (显示的是链接自身的信息)

    ```
    File:                     a_link
    Inode number:             123457
    Mode:                     120777 (lrwxrwxrwx)
    Link count:               1
    ...
    File size:                5 bytes  <-- 这是字符串 "a.txt" 的长度
    ...
    ```