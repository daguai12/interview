### **15.3 文件属主**

每个文件都有一个与之关联的用户 ID (UID) 和组 ID (GID)，籍此可以判定文件的属主和属组。

#### **15.3.1 新建文件的属主**

文件创建时，其所有权的确定规则如下：

* **用户 ID (UID)**: 规则很简单，新建文件的用户 ID **总是**继承自创建该文件的进程的有效用户 ID。

* **组 ID (GID)**: 规则较为复杂，存在两种可能的行为：
    1.  **System V 行为**: 新建文件的组 ID 继承自创建该文件的进程的有效组 ID。
    2.  **BSD 行为**: 新建文件的组 ID 继承自其**父目录**的组 ID。

    当需要让一个项目目录下的所有文件都属于同一个项目组时，BSD 的行为非常实用。

在 ext2、ext3、ext4 等文件系统上，具体采用哪种行为取决于文件系统的挂载选项以及父目录的权限位。

##### **ext2/ext3/ext4 文件系统上的 GID 继承规则**

1.  **挂载选项**: `mount` 命令可以带有 `-o grpid` (等效于 `-o bsdgroups`) 或 `-o nogrpid` (等效于 `-o sysvgroups`) 选项。默认选项为 `-o nogrpid`。
2.  **set-group-ID 位**: 可以对一个目录设置 `set-group-ID` 权限位 (通过 `chmod g+s directory` 命令)。

下表对确定新建文件组所有权的规则做了总结。

**表 15-3：确定新建文件组所有权的规则**

| 文件系统挂载选项                           | 有无设置父目录的 Set-group-ID 位 | 新建文件的组所有权取自何处               |
| :--------------------------------- | :---------------------- | :-------------------------- |
| **-o grpid**, -o bsdgroups         | (被忽略)                   | **父目录**的组 ID (BSD 行为)       |
| **-o nogrpid**, -o sysvgroups (默认) | **无**                   | 进程的有效**组 ID** (System V 行为) |
|                                    | **有** (`g+s`)           | **父目录**的组 ID (BSD 行为)       |

**总结来说**:
* 如果文件系统以 `grpid` 选项挂载，那么所有新建文件的组 ID 都将继承自其父目录。
* 如果文件系统以默认的 `nogrpid` 选项挂载，那么新建文件的组 ID 通常继承自进程。**但是**，如果父目录被设置了 `set-group-ID` 位 (`g+s`)，那么该目录下的新建文件将会强制继承父目录的组 ID。

> **set-group-ID 位的继承**: 一旦将某一目录的 `set-group-ID` 位置位后，在该目录下创建的所有新子目录也将自动继承 `set-group-ID` 位。这样，组 ID 继承的行为就可以在整个目录树中一直传递下去。


#### **15.3.2 改变文件属主：chown()、fchown()和 lchown()**

系统调用 `chown()`、`lchown()` 和 `fchown()` 可用来改变文件的属主（用户 ID）和属组（组 ID）。

```c
#include <unistd.h>

int chown(const char *pathname, uid_t owner, gid_t group);
int fchown(int fd, uid_t owner, gid_t group);
int lchown(const char *pathname, uid_t owner, gid_t group);
```

这三个系统调用之间的区别类似于 `stat()` 一族：

  * **`chown()`**: 改变路径名 `pathname` 所指定文件的所有权。如果 `pathname` 是一个符号链接，它会**跟随**链接，改变链接所指向文件的所有权。
  * **`lchown()`**: 与 `chown()` 类似，但如果 `pathname` 是一个符号链接，它**不会**跟随链接，而是改变符号链接**自身**的所有权。
  * **`fchown()`**: 改变由一个已打开的文件描述符 `fd` 所引用的文件的所有权。

参数 `owner` 和 `group` 分别为文件指定新的用户 ID 和组 ID。若只打算改变其中之一，只需将另一参数置为 `-1`，即可令与之相关的 ID 保持不变。

##### **权限**

  * **改变用户 ID (owner)**: 只有特权级进程 (拥有 `CAP_CHOWN` 能力) 才能改变文件的用户 ID。
  * **改变组 ID (group)**:
      * 特权级进程可将文件的组 ID 修改为任意值。
      * 非特权级进程，如果其有效用户 ID 与文件的用户 ID 相匹配（即进程是文件的所有者），可以将文件的组 ID 改为该进程所属的**任一**组的 ID。

##### **安全特性：自动清除 set-user-ID 和 set-group-ID 位**

这是一个重要的安全举措：如果一个非特权用户改变了**可执行文件**的属主或属组，那么该文件的 `set-user-ID` 和 `set-group-ID` 权限位会被**自动关闭（清除）**。

  * **原因**: 这是为了防止普通用户创建了一个 set-user-ID 程序，然后通过 `chown` 将其所有者改为 `root`，从而制造一个安全漏洞。
  * **例外情况**: 在以下情况下，`set-group-ID` 位**不会**被清除：
    1.  如果文件的**组执行权限位**没有被设置。此时，set-group-ID 位被用于**强制文件锁定**，而不是用于程序执行。
    2.  如果要改变所有权的是一个**目录**。此时，set-group-ID 位被用于控制在该目录下所创建新文件的组所有权。

-----

#### **程序示例**

程序清单 15-2 演示了 `chown()` 的用法，它是一个简化的 `chown(1)` 命令，允许用户改变一个或多个文件的属主和属组。

**`chown_demo.c` 文件:**

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pwd.h>
#include <grp.h>

// 辅助函数：通过用户名获取 uid
static uid_t userIdFromName(const char *name) {
    if (name == NULL || *name == '\0') return -1;
    struct passwd *pwd = getpwnam(name);
    return (pwd == NULL) ? -1 : pwd->pw_uid;
}

// 辅助函数：通过组名获取 gid
static gid_t groupIdFromName(const char *name) {
    if (name == NULL || *name == '\0') return -1;
    struct group *grp = getgrnam(name);
    return (grp == NULL) ? -1 : grp->gr_gid;
}

int main(int argc, char *argv[]) {
    uid_t uid;
    gid_t gid;
    char *user, *group;
    int i;

    if (argc < 3 || strcmp(argv[1], "--help") == 0) {
        fprintf(stderr, "Usage: %s owner[:group] file...\n", argv[0]);
        fprintf(stderr, "       owner can be a user name or UID\n");
        fprintf(stderr, "       group can be a group name or GID\n");
        exit(EXIT_FAILURE);
    }

    // 解析 "owner:group" 参数
    user = argv[1];
    group = strchr(argv[1], ':');
    if (group != NULL) {
        *group = '\0'; // 分割字符串
        group++;
    }

    // 将用户名/组名转换为 ID
    // 如果是数字字符串，atoi 会转换；否则 userIdFromName/groupIdFromName 会查找
    uid = (user == NULL || *user == '\0') ? -1 : 
          ( (uid = userIdFromName(user)) != -1 ? uid : atoi(user) );
    
    gid = (group == NULL || *group == '\0') ? -1 :
          ( (gid = groupIdFromName(group)) != -1 ? gid : atoi(group) );

    // 遍历所有文件参数
    for (i = 2; i < argc; i++) {
        if (chown(argv[i], uid, gid) == -1) {
            fprintf(stderr, "chown failed on file %s", argv[i]);
            perror("");
        }
    }

    exit(EXIT_SUCCESS);
}
```

**编译和运行演示 (需要 root 权限)**

1.  **准备环境:**

    ```bash
    # 编译程序
    gcc chown_demo.c -o chown_demo
    # 创建一个测试文件
    touch a.txt
    ls -l a.txt
    # 输出: -rw-rw-r-- 1 myuser mygroup 0 Sep 10 11:19 a.txt
    ```

2.  **改变文件的属主和属组:**

    ```bash
    # 假设系统上存在用户 'nobody' 和组 'nogroup'
    sudo ./chown_demo nobody:nogroup a.txt
    ```

3.  **检查结果:**

    ```bash
    ls -l a.txt
    # 输出: -rw-rw-r-- 1 nobody nogroup 0 Sep 10 11:19 a.txt
    ```

    文件的属主和属组已成功改变。

4.  **只改变属主:**

    ```bash
    # 将属主改回 myuser，组保持不变
    sudo ./chown_demo myuser a.txt
    ls -l a.txt
    # 输出: -rw-rw-r-- 1 myuser nogroup 0 Sep 10 11:19 a.txt
    ```

5.  **只改变属组:**

    ```bash
    # 属主保持不变，将组改回 mygroup
    sudo ./chown_demo :mygroup a.txt
    ls -l a.txt
    # 输出: -rw-rw-r-- 1 myuser mygroup 0 Sep 10 11:19 a.txt
    ```