### **15.4 文件权限**

本节将介绍应用于文件和目录的权限方案。这些规则可适用于所有文件类型，包括设备文件、FIFO 以及 UNIX 域套字等。

#### **15.4.1 普通文件的权限**

如 15.1 节所述，`stat` 结构体中 `st_mode` 字段的低 12 位定义了文件权限。其中的 9 位构成了定义权限的掩码，分别授予访问文件的三类用户。

**用户类别:**

  * **Owner (属主)**: 授予文件所有者的权限 (简写为 `u`)。
  * **Group (属组)**: 授予文件所属组成员用户的权限 (简写为 `g`)。
  * **Other (其他)**: 授予其他所有用户的权限 (简写为 `o`)。

**权限类型:**
可为每一类用户授予如下权限：

  * **Read (读)**: 可阅读文件的内容。
  * **Write (写)**: 可更改文件的内容。
  * **Execute (执行)**: 可以执行文件。要执行脚本文件，需同时具备读权限和执行权限。

执行 `ls –l` 命令，可查看文件的权限和所有权，如下所示：

```bash
$ ls -l a.out
-rwxr-x--- 1 mtk users 8633 Sep 10 11:30 a.out
```

在以上输出中，文件权限显示为 “rwxr-x---”。这 9 个字符分为三组：

1.  `rwx`: **属主**权限，表示属主具有读、写、执行权限。
2.  `r-x`: **属组**权限，表示组成员具有读、执行权限，但没有写权限。
3.  `---`: **其他用户**权限，表示其他用户没有任何权限。

头文件 `<sys/stat.h>` 定义了可与 `st_mode` 字段进行按位与(`&`)运算的常量，用于检查特定权限位。

**表 15-4：用来表示文件权限位的常量**
| 常量 | 八进制值 | 权限位 |
| :--- | :--- | :--- |
| `S_ISUID` | 04000 | Set-user-ID |
| `S_ISGID` | 02000 | Set-group-ID |
| `S_ISVTX` | 01000 | Sticky bit |
| `S_IRUSR` | 00400 | User-read (属主读) |
| `S_IWUSR` | 00200 | User-write (属主写) |
| `S_IXUSR` | 00100 | User-execute (属主执行) |
| `S_IRGRP` | 00040 | Group-read (属组读) |
| `S_IWGRP` | 00020 | Group-write (属组写) |
| `S_IXGRP` | 00010 | Group-execute (属组执行) |
| `S_IROTH` | 00004 | Other-read (其他读) |
| `S_IWOTH` | 00002 | Other-write (其他写) |
| `S_IXOTH` | 00001 | Other-execute (其他执行) |

此外，还定义了三类权限的组合常量：`S_IRWXU` (0700), `S_IRWXG` (0070) 和 `S_IRWXO` (0007)。

-----

#### **程序示例：将权限掩码转换为字符串**

程序清单 15-3 和 15-4 声明并实现了一个函数 `filePermStr()`，它会针对给定的文件权限掩码返回一个以 `ls(1)` 风格表示该掩码的字符串。

**程序清单 15-3：`file_perms.h` (头文件)**

```c
#ifndef FILE_PERMS_H
#define FILE_PERMS_H

#include <sys/stat.h>

#define FP_SPECIAL 1            /* A flag for filePermStr() */

// 函数原型
const char *filePermStr(mode_t perm, int flags);

#endif
```

**程序清单 15-4：`file_perms.c` (实现)**

```c
#include <sys/stat.h>
#include <stdio.h>
#include "file_perms.h"

#define STR_SIZE sizeof("rwxrwxrwx")

const char * filePermStr(mode_t perm, int flags) {
    static char str[STR_SIZE];

    snprintf(str, STR_SIZE, "%c%c%c%c%c%c%c%c%c",
            (perm & S_IRUSR) ? 'r' : '-', (perm & S_IWUSR) ? 'w' : '-',
            (perm & S_IXUSR) ?
                (((perm & S_ISUID) && (flags & FP_SPECIAL)) ? 's' : 'x') :
                (((perm & S_ISUID) && (flags & FP_SPECIAL)) ? 'S' : '-'),
            (perm & S_IRGRP) ? 'r' : '-', (perm & S_IWGRP) ? 'w' : '-',
            (perm & S_IXGRP) ?
                (((perm & S_ISGID) && (flags & FP_SPECIAL)) ? 's' : 'x') :
                (((perm & S_ISGID) && (flags & FP_SPECIAL)) ? 'S' : '-'),
            (perm & S_IROTH) ? 'r' : '-', (perm & S_IWOTH) ? 'w' : '-',
            (perm & S_IXOTH) ?
                (((perm & S_ISVTX) && (flags & FP_SPECIAL)) ? 't' : 'x') :
                (((perm & S_ISVTX) && (flags & FP_SPECIAL)) ? 'T' : '-'));

    return str;
}
```


#### **15.4.2 目录权限**

目录与常规文件拥有相同的 `rwx` 权限方案，只是对这三种权限的含义另有所指。

* **读权限 (Read: `r`)**:
    * **含义**: 允许列出目录下的内容，即读取目录中包含的**文件名列表**（例如，通过 `ls` 命令）。
    * **注意**: 仅有读权限，无法获取这些文件的元数据（如类型、大小、时间戳等），因为那需要访问 i-node，而访问 i-node 需要执行权限。

* **写权限 (Write: `w`)**:
    * **含义**: 允许在目录内**创建新文件**、**删除文件**和**重命名文件**。
    * **关键点**: 要删除一个文件，需要拥有对该文件**所在目录**的写权限，而**不**需要拥有对该文件本身的任何权限。

* **执行权限 (Execute: `x`)**:
    * **含义**: 允许**访问（access）**目录中的条目（文件或子目录）。因此，有时也称其为**搜索权限 (search permission)**。
    * **路径遍历**: 要想访问一个文件（例如 `/home/mtk/x`），必须拥有对路径中所有目录（`/`、`/home`、`/home/mtk`）的执行权限。

---

##### **权限组合的效果**

理解权限的组合至关重要：

* **有读权限、无执行权限 (`r--`)**:
    * 你可以 `ls` 这个目录，看到里面所有文件的**名字**。
    * 但是你无法 `cd` 进入这个目录，也无法 `stat` 或读取目录内任何文件的内容，因为你没有“穿过”这个目录去访问其中文件的权限。

* **有执行权限、无读权限 (`--x`)**:
    * 你**不能** `ls` 这个目录来查看文件名列表（会提示权限不足）。
    * 但是，如果你**已经知道**该目录中某个文件的确切名称，并且你对那个文件自身有相应的权限，那么你**可以**访问那个文件。
    * 这是一种常用于控制公共目录（如用户家目录）访问的技术：允许系统或程序访问特定文件，但不允许列出所有文件。

* **创建/删除文件所需的权限**:
    * 要在目录中添加或删除文件，需要**同时拥有**对该目录的**写权限 (`w`)** 和**执行权限 (`x`)**。

##### **权限组合小结**

| 你对 `/dir` 的权限 | 能否 `ls /dir`? | 能否 `cat /dir/file`? (假设已知文件名且对file有读权限) | 能否 `touch /dir/newfile`? |
| :------------ | :-----------: | :-------------------------------------: | :----------------------: |
| `r--`         |  能 (只能看到文件名)  |                 **不能**                  |            不能            |
| `--x`         |    **不能**     |                  **能**                  |            不能            |
| `r-x`         |       能       |                    能                    |            不能            |
| `-wx`         |    **不能**     |                    能                    |          **能**           |
| `rwx`         |       能       |                    能                    |          **能**           |


#### **15.4.3 权限检查算法**

只要在访问文件或目录的系统调用中指定了路径名称，内核就会检查相应文件的权限。如果路径名包含目录前缀，那么内核除了会检查对文件本身所需的权限以外，还会检查前缀所含每个目录的可执行权限（搜索权限）。

内核会使用进程的有效用户 ID、有效组 ID 以及辅助组 ID 来执行权限检查。

> **检查时机**: 一旦 `open()` 调用成功打开了文件，针对返回的文件描述符的后续系统调用（如 `read()`, `write()`, `fstat()`）将**不再**进行任何权限检查。权限检查只在“按名访问”的初始阶段发生。

检查文件权限时，内核所遵循的规则顺序如下：

1.  **超级用户检查**: 若进程为特权级进程（如 `root`，其有效 UID 为 0），则授予其所有访问权限（但有例外，见下文）。

2.  **属主检查**: 若进程的有效用户 ID 与文件的用户 ID（属主）相同，内核会根据文件的**属主权限位** (`rwx--- ---`) 授予或拒绝进程相应的访问权限。**检查到此为止**。

3.  **属组检查**: 若进程的有效组 ID 或任一附属组 ID 与文件的组 ID（属组）相匹配，内核会根据文件的**属组权限位** (`---rwx---`) 授予或拒绝进程相应的访问权限。**检查到此为止**。

4.  **其他用户检查**: 若以上条件皆不满足，内核会根据文件的**其他用户权限位** (`------rwx`) 授予或拒绝进程相应权限。

##### **一个意外的结果**

内核会依次执行上述检查，**只要匹配其中一条规则，便会停止后续检查**。这可能会导致一个看似意外的结果：文件属主所拥有的权限可能比属组成员的更少。

例如，一个文件的权限为 `r--rwx---`：

```
$ ls -l some_file
-r--rwx--- 1 mtk users 10 Sep 10 12:00 some_file
```

  * 当文件的属主 `mtk` 尝试访问此文件时，内核执行第 2 步检查，发现 UID 匹配。根据属主权限 `r--`，`mtk` **只被授予读权限**，检查就此停止。他**不能**写入或执行该文件。
  * 当一个同属于 `users` 组但不是 `mtk` 的用户访问此文件时，内核跳过第 2 步，执行第 3 步检查，发现 GID 匹配。根据属组权限 `rwx`，该用户被授予**读、写、执行**所有权限。

在这个例子中，文件属主的权限反而比普通组成员的要少。

##### **检查特权级别进程的权限**

上文提到特权级进程拥有所有访问权限，这一论述有一个限制条件：

  * 对于**非目录文件**，仅当该文件的三种权限类型（属主、属组、其他）中**至少有一类**设置了可执行权限时，Linux 才会将执行权限赋予特权级进程。
  * 对于**目录**，特权级进程总是拥有可执行（搜索）权限。

在现代 Linux 系统中，“特权级进程”的概念被更精细的**能力 (Capabilities)** 所取代：

  * **`CAP_DAC_READ_SEARCH`**: 拥有此能力的进程可以绕过所有权限检查来**读取**任何文件和**搜索**（执行）任何目录。
  * **`CAP_DAC_OVERRIDE`**: 拥有此能力的进程可以绕过所有权限检查来**写入**任何文件，并且如果文件的任意执行位被设置，也可以**执行**该文件。


#### **15.4.4 检查对文件的访问权限：access()**

当进程访问文件时，系统会以其 **effective (有效)** 用户 ID 和组 ID 来确定权限。然而，有时程序（尤其是 set-user-ID 程序）需要根据进程的 **real (真实)** 用户 ID 和组 ID 来检查对文件的访问权限。

系统调用 `access()` 正是用于此目的。它根据进程的**真实用户 ID** 和 **真实组 ID**（以及附属组 ID），去检查对 `pathname` 所指定文件的访问权限。

```c
#include <unistd.h>

int access(const char *pathname, int mode);
```

  * **`pathname`**: 标识欲检查的文件。如果 `pathname` 为符号链接，`access()` 将对其解引用（跟随链接）。
  * **`mode`**: 是由下表中常量进行“或”(`|`)运算而成的位掩码，用于指定要检查的权限。

| 常量     | 描述          |
| :----- | :---------- |
| `F_OK` | 文件是否存在？     |
| `R_OK` | 对该文件有读权限吗？  |
| `W_OK` | 对该文件有写权限吗？  |
| `X_OK` | 对该文件有执行权限吗？ |

若进程对文件具备 `mode` 参数中包含的所有权限，`access()` 将返回 0；只要有一项权限未得到满足（或发生其他错误），`access()` 则返回 -1。

-----

##### **安全警告：避免使用 access()**

**强烈建议杜绝使用 `access()`**，因为它会导致一个严重的安全漏洞，称为 **TOCTOU (Time-of-Check to Time-of-Use) 竞争条件**。

  * **问题所在**: 在 `access()` 检查权限（Time-of-Check）和后续实际操作文件（如 `open()`，Time-of-Use）之间存在一个时间窗口。攻击者可以利用这个窗口来改变文件系统的状态。

  * **攻击场景示例**:

    1.  一个 set-user-ID-root 程序需要打开一个由普通用户提供的文件。为安全起见，程序先调用 `access()` 检查该**普通用户**（真实用户）是否有权访问该文件。假设用户提供了一个指向安全文件 `/tmp/safe_file` 的符号链接。
    2.  `access()` 检查通过。
    3.  在 `access()` 返回和程序下一步调用 `open()` 之间的**极短时间内**，恶意用户迅速将该符号链接**改指向**一个他本无权访问的敏感文件，如 `/etc/shadow`。
    4.  程序随后调用 `open()`。由于程序是以 root 权限（有效用户）运行的，`open()` 操作成功，程序最终打开了 `/etc/shadow`，造成了安全漏洞。

  * **正确的替代方案**:
    对于需要检查真实用户权限的 set-user-ID 程序，不应使用 `access()`。正确的做法是：**暂时将进程的有效用户 ID 切换为真实用户 ID，然后直接尝试执行 `open()` 等操作，并通过检查其返回值和 `errno` 来判断操作是否因权限问题而失败**。这样，权限检查和文件操作是在同一个原子步骤中完成的，杜绝了竞争条件。

> **euidaccess()**: GNU C 库提供了一个功能相似的非标准函数 `euidaccess()`，该函数使用进程的**有效**用户 ID（而非真实 ID）来检查权限。

#### **15.4.5 Set-User-ID、Set-Group-ID 和 Sticky 位**

除了 9 位用来表明属主、属组和其他用户的 `rwx` 权限之外，文件权限掩码还另设有 3 个附加的特殊权限位：

  * **Set-User-ID bit** (八进制值: `04000`)
  * **Set-Group-ID bit** (八进制值: `02000`)
  * **Sticky bit** (八进制值: `01000`)

前两个权限位的主要用途是创建特权级程序（见 9.3 节）。`Set-Group-ID` 位还有两种其他用途：控制目录下新建文件的组所有权（见 15.3.1 节）和启用强制文件锁定（见 55.4 节）。本节将重点讨论 **Sticky 位**的用途。

##### **Sticky 位的历史用途 (已废弃)**

在老的 UNIX 实现中，`sticky` 位的目的在于让常用程序的运行速度更快。若对某个可执行文件设置了 `sticky` 位，则首次执行程序时，系统会将其程序文本（代码段）拷贝并保存于交换区中，即“粘”(stick) 在交换区内。这样，后续执行该程序时就可以从更快的交换区加载，而不是从慢速的磁盘加载。

现代 UNIX 系统拥有更先进的内存管理技术，因此权限位的这一用法已被废弃。

> `sticky` 位的常量名称 `S_ISVTX` 源于其别称：**saved-text** 位，这正反映了它的历史用途。

##### **Sticky 位的现代用途 (针对目录)**

在现代 UNIX 实现（包括 Linux）中，`sticky` 权限位的作用完全不同，它主要作用于**目录**，扮演**限制删除位 (restricted deletion bit)** 的角色。

  * **规则**: 为一个目录设置了 `sticky` 位后，该目录下的文件**只能被以下用户删除或重命名**：

    1.  文件的所有者。
    2.  目录的所有者。
    3.  特权级进程 (root)。

  * **用途**: 此机制常用于创建允许多个用户共享的目录，例如 `/tmp` 和 `/var/tmp`。在这些目录下，任何用户都可以创建自己的文件，但**不能删除或重命名属于其他用户的文件**。

  * **设置和显示**:

      * 可以通过 `chmod +t directory` 命令来为目录设置 `sticky` 位。
      * 当执行 `ls –ld` 命令时，`sticky` 位会显示在“其他用户”权限组的执行权限位上：
          * 如果该目录对其他用户有执行权限，则显示为小写 `t`。
          * 如果该目录对其他用户没有执行权限，则显示为大写 `T`。

**演示:**

```bash
# 创建一个目录并设置权限为 777 (rwxrwxrwx)
$ mkdir mydir
$ chmod 777 mydir
$ ls -ld mydir
drwxrwxrwx 2 mtk users 4096 Sep 10 15:30 mydir

# 添加 sticky 位
$ chmod +t mydir
# 因为原来有 'x' 权限，所以显示为 't'
$ ls -ld mydir
drwxrwxrwt 2 mtk users 4096 Sep 10 15:30 mydir

# 去掉其他用户的执行权限
$ chmod o-x mydir
# 因为现在没有 'x' 权限，所以显示为 'T'
$ ls -ld mydir
drwxrwxrwT 2 mtk users 4096 Sep 10 15:30 mydir
```


#### **15.4.6 进程的文件模式创建掩码：umask()**

当创建新文件或目录时，`open()`、`creat()` 或 `mkdir()` 等函数中的 `mode` 参数指定了初始权限。然而，最终的权限设置还会受到**文件模式创建掩码 (file mode creation mask)**，即 **`umask`** 的影响。

`umask` 是一种**进程属性**，它用于指明在创建文件或目录时，应该\*\*屏蔽（即关闭）\*\*哪些权限位。

最终的权限是这样计算的：

```
final_permissions = mode & ~umask
```

这意味着，在 `umask` 中被设置的位，将会在最终的权限中被清除。

##### **`umask` 的设置和继承**

进程的 `umask` 通常继承自其父进程（如 shell）。用户可以使用 shell 的内置命令 `umask` 来查看和改变 shell 进程的 `umask`，从而影响从该 shell 启动的所有程序。

大多数 shell 的初始化文件会将 `umask` 默认设置为八进制值 **`022`** (权限表示为 `----w--w-`)。

  * **效果**: 这个掩码会屏蔽掉**属组 (group)** 和**其他用户 (other)** 的**写权限**。
  * **示例 (umask=022)**:
      * 如果 `open()` 指定 `mode` 为 `0666` (`rw-rw-rw-`)，则新建文件的最终权限为 `0666 & ~022` = `0644` (`rw-r--r--`)。
      * 如果 `mkdir()` 指定 `mode` 为 `0777` (`rwxrwxrwx`)，则新建目录的最终权限为 `0777 & ~022` = `0755` (`rwxr-xr-x`)。

##### **`umask()` 系统调用**

`umask()` 系统调用将进程的 `umask` 改变为 `mask` 参数所指定的值。

```c
#include <sys/stat.h>

mode_t umask(mode_t mask);
```

  * **参数 `mask`**: 可以是一个八进制数，或是由权限常量（如 `S_IWGRP | S_IWOTH`）进行“或”运算得到的值。
  * **返回值**: `umask()` 调用总会成功，并返回进程**之前**的 `umask` 值。

-----

#### **程序示例**

程序清单 15-5 演示了 `umask()` 与 `open()` 和 `mkdir()` 的相互配合。

**程序清单 15-5：使用 umask()**

```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <fcntl.h>

#define MY_FILE "myfile"
#define MY_DIR  "mydir"
#define FILE_PERMS (S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH) // 0666
#define DIR_PERMS  (S_IRWXU | S_IRWXG | S_IRWXO)                             // 0777
#define UMASK_SETTING (S_IWGRP | S_IWOTH)                                    // 022

int main(int argc, char *argv[]) {
    mode_t old_umask;

    // 1. 查看默认 umask
    //    为了看到默认值，我们先设置一个临时 umask，然后再设置回来
    old_umask = umask(0); // 设置为0不会屏蔽任何位
    printf("1. Default umask is: %03o\n", old_umask);
    umask(old_umask); // 恢复原来的 umask

    // 2. 创建一个文件和目录，使用默认的 umask
    printf("\n2. Creating file and directory with default umask...\n");
    if (open(MY_FILE, O_WRONLY | O_CREAT | O_EXCL, FILE_PERMS) == -1)
        perror("open-default");
    if (mkdir(MY_DIR, DIR_PERMS) == -1)
        perror("mkdir-default");

    printf("   >> Check permissions with 'ls -l %s %s'\n", MY_FILE, MY_DIR);
    printf("   Press <Enter> to continue\n");
    getchar();

    // 3. 清理
    unlink(MY_FILE);
    rmdir(MY_DIR);

    // 4. 设置新的 umask
    old_umask = umask(UMASK_SETTING);
    printf("\n3. Set new umask to %03o, previous was: %03o\n", UMASK_SETTING, old_umask);

    // 5. 使用新的 umask 创建文件和目录
    printf("\n4. Creating file and directory with new umask...\n");
    if (open(MY_FILE, O_WRONLY | O_CREAT | O_EXCL, FILE_PERMS) == -1)
        perror("open-new");
    if (mkdir(MY_DIR, DIR_PERMS) == -1)
        perror("mkdir-new");
    
    printf("   >> Check permissions with 'ls -l %s %s'\n", MY_FILE, MY_DIR);
    printf("   Press <Enter> to continue\n");
    getchar();

    // 6. 清理
    unlink(MY_FILE);
    rmdir(MY_DIR);

    exit(EXIT_SUCCESS);
}
```

**编译和运行演示**

1.  **编译程序:**
    ```bash
    gcc umask_demo.c -o umask_demo
    ```
2.  **设置 shell 的 umask (例如 027) 并运行程序:**
    ```bash
    # umask 027
    # ./umask_demo
    ```

**预期交互过程:**

```
1. Default umask is: 027  <-- 程序正确地读到了 shell 设置的 umask

2. Creating file and directory with default umask...
   >> Check permissions with 'ls -l myfile mydir'
   Press <Enter> to continue
```

(此时，你在另一个终端窗口执行 `ls -l` 会看到 `myfile` 权限为 `rw-r-----` (0640)，`mydir` 权限为 `rwxr-x---` (0750)，因为 `027` 屏蔽了组的写权限和其他用户的全部权限。)

(按回车后)

```
3. Set new umask to 022, previous was: 027

4. Creating file and directory with new umask...
   >> Check permissions with 'ls -l myfile mydir'
   Press <Enter> to continue
```

(此时，你再次执行 `ls -l` 会看到 `myfile` 权限为 `rw-r--r--` (0644)，`mydir` 权限为 `rwxr-xr-x` (0755)，因为新的 `umask` `022` 只屏蔽了组和其他用户的写权限。)

(按回车后程序退出)


#### **15.4.7 更改文件权限：chmod()和 fchmod()**

可利用系统调用 `chmod()` 和 `fchmod()` 去修改文件权限。

```c
#include <sys/stat.h>

int chmod(const char *pathname, mode_t mode);
int fchmod(int fd, mode_t mode);
```

  * **`chmod()`**: 更改由 `pathname` 参数所指定文件的权限。若该参数所指为符号链接，`chmod()` 会**跟随链接**，改变链接所指向文件的权限，而非符号链接自身的权限。
  * **`fchmod()`**: 更改由已打开的文件描述符 `fd` 所指代文件的权限。

`mode` 参数用于描述文件的新权限，可以采用八进制数字形式，亦或是由权限位常量（如 `S_IRUSR`）进行“或”(`|`)运算而成的掩码。

##### **权限要求**

要想成功更改文件权限，调用进程必须满足以下条件之一：

1.  具有特权（拥有 `CAP_FOWNER` 能力）。
2.  其有效用户 ID 与文件的用户 ID（属主）相匹配。

##### **用法示例**

1.  **设置绝对权限**: 要将文件权限设为使所有用户仅具有读权限 (`r--r--r--` 或 `0444`)，需执行如下系统调用：

    ```c
    chmod("myfile", S_IRUSR | S_IRGRP | S_IROTH);
    ```

2.  **修改特定权限位**: 要修改文件的特定权限位（例如，为属组增加写权限），需先调用 `stat()` 来获取文件的现有权限，调整想修改的权限位，然后使用 `chmod()` 去更新权限。

    ```c
    struct stat sb;

    stat("myfile", &sb); // 获取当前权限
    // 在现有权限基础上，增加组写权限位
    chmod("myfile", sb.st_mode | S_IWGRP);
    ```

    这等价于执行如下 shell 命令：

    ```bash
    $ chmod g+w myfile
    ```

##### **安全措施：自动清除 Set-Group-ID 位**

这是一个重要的安全特性，用于防止非特权用户为其不隶属的组创建 set-group-ID 程序。

  * **场景**: 在某些情况下（见 15.3.1 节），一个用户可以在一个目录中创建一个文件，而该文件的组 ID 会继承自父目录，这个组可能是该用户不属于的组。

  * **规则**: 当一个**非特权级进程**调用 `chmod()` (或 `fchmod()`) 时，如果该文件的组 ID **不等于**进程的有效组 ID 或任一辅助组 ID，内核则会**自动清除该文件的 set-group-ID 权限位**。

  * **演示**:
    假设用户 `mtk` 不属于 `games` 组，但 `games` 组目录 `/tmp/gamesdir` 设置了 `set-group-ID` 位，允许 `mtk` 在其中创建文件。

    ```bash
    # 1. mtk 在该目录下创建一个文件，该文件组所有权自动变为 games
    $ touch /tmp/gamesdir/a.out
    $ ls -l /tmp/gamesdir/a.out
    -rw-r--r-- 1 mtk games ... a.out

    # 2. mtk 尝试为该文件添加 set-group-ID 位
    $ chmod g+s /tmp/gamesdir/a.out

    # 3. 检查权限，发现 set-group-ID 位没有被设置成功
    $ ls -l /tmp/gamesdir/a.out
    -rw-r-Sr-- 1 mtk games ... a.out   # 'S' 变成了 'r'
    ```

    在这个过程中，由于 `mtk` 不是 `games` 组的成员，当他调用 `chmod()` 时，内核检测到这一情况并自动清除了他试图设置的 `set-group-ID` 位，从而阻止了潜在的安全漏洞。

[[案例解读]]