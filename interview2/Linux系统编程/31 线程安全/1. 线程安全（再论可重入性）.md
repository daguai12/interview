### 核心概念：线程安全与可重入性

1.  **线程安全 (Thread-Safe)**
    * **定义**：一个函数如果可以被多个线程同时调用而不会产生错误或数据损坏，那么它就是线程安全的。
    * **不安全的原因**：最常见的原因是函数内部使用了所有线程共享的全局变量或静态变量。
    * **实现方式**：
        * **互斥量（Mutex）保护整个函数**：简单但会使函数调用串行化，牺牲并发性。
        * **互斥量保护临界区**：只锁定访问共享变量的代码块，比前者高效，但更复杂。
        * **可重入设计**：最高效的方式，无需锁。

2.  **可重入性 (Reentrancy)**
    * **定义**：可重入函数是一种特殊的线程安全函数，它不使用任何全局或静态变量。它所需的所有数据都由调用者提供（通过参数传入），因此不会与其它线程产生冲突。
    * **优点**：无需互斥锁的开销，效率高。
    * **局限性**：并非所有函数都能实现为可重入。
        * 有些函数天生需要访问全局资源（如 `malloc` 管理全局堆内存）。
        * 许多传统函数的接口设计使其不可重入（如返回一个指向函数内部静态缓冲区的指针）。

### 标准与实践

* **SUSv3/SUSv4 标准**：
    * 规定了绝大多数标准函数必须是线程安全的。
    * 但也明确列出了一份清单（如表 31-1），指明这些函数**不要求**是线程安全的。
    * 为了程序的可移植性，开发者应假定清单中的函数是**非线程安全**的。
    * SUSv4 对这个清单做了一些更新，移除了一些过时的函数，并增加了 `system()` 等。

* **可重入的“替身”函数（`_r` 后缀）**：
    * 为了解决传统不可重入函数的问题，SUSv3 为其中一部分函数定义了可重入版本，其函数名通常以 `_r` 结尾（例如 `asctime_r()`, `strtok_r()`）。
    * 这些 `_r` 函数通常要求调用者自己提供一个缓冲区来存放结果，从而避免了内部静态变量的使用。
    * 一些系统（如 glibc）提供了标准之外的 `_r` 函数，但使用它们会降低程序的可移植性。
    * 在某些情况下，推荐使用更新、功能更强且本身就是可重入的函数（如用 `getaddrinfo()` 替代 `gethostbyname()`）。

总而言之，这段文本强调了在多线程编程中，理解函数的线程安全和可重入性至关重要。实现线程安全的首选方法是设计可重入的函数，如果做不到，则需要通过互斥锁来保证。同时，开发者必须注意标准中关于哪些函数是线程安全的规定，并优先使用可重入的 `_r` 版本或更新的替代函数来确保程序的健壮性和可移植性。