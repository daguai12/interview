### 核心问题：一次性初始化需求

在多线程环境中，某些初始化代码（例如，使用 `pthread_mutex_init()` 初始化一个具有特殊属性的互斥量）必须确保在整个程序的生命周期中**只执行一次**，无论有多少线程尝试执行它。

对于应用程序，主线程可以在创建其他线程前完成这个初始化。但对于库函数而言，它无法预知自己何时被哪个线程首次调用，因此需要一种更健壮的机制。

### 解决方案：`pthread_once()` 函数

Pthreads 标准库提供了 `pthread_once()` 函数来专门解决这个问题。

* **功能**：`pthread_once()` 确保其指定的初始化函数在多线程环境下只被执行一次。
* **工作原理**：
    1.  **控制变量 (`once_control`)**：你需要定义一个类型为 `pthread_once_t` 的静态变量，并将其初始化为 `PTHREAD_ONCE_INIT`。这个变量被 `pthread_once()` 用来追踪初始化是否已经完成。
    2.  **初始化函数 (`init`)**：你需要提供一个无参数、无返回值的函数。这个函数包含了只应执行一次的初始化代码。
    3.  **调用**：所有需要依赖此初始化的线程都调用 `pthread_once()`，并传入上述的控制变量和初始化函数。

* **保证**：第一个调用 `pthread_once()` 的线程将会执行初始化函数。在此期间，其他尝试调用 `pthread_once()`（使用同一个控制变量）的线程将会被阻塞。一旦初始化完成，所有后续对 `pthread_once()` 的调用（包括被阻塞的线程和未来的调用）都会直接返回，不再执行初始化函数。

### 历史与现状

* **历史原因**：`pthread_once()` 的主要设计初衷之一是解决早期 Pthreads 版本中互斥量无法被静态初始化的问题。当时必须使用 `pthread_mutex_init()`，而 `pthread_once()` 是确保这个动态初始化只发生一次的标准方法。
* **当前价值**：尽管现在已经可以通过静态分配的互斥量和一个布尔标志来手动实现类似的功能，但 `pthread_once()` 作为一个标准、简洁且经过验证的模式被保留了下来，为开发者提供了便利。

简而言之，`pthread_once()` 是在多线程编程中实现**惰性初始化 (lazy initialization)** 和保证**单次执行 (exactly-once execution)** 的标准、线程安全机制。