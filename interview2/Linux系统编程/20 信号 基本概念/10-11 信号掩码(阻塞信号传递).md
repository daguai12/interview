好的，这两节内容介绍了信号处理中两个紧密关联的核心概念：**信号掩码 (Signal Mask)** 和 **等待信号 (Pending Signals)**。它们共同构成了信号阻塞机制。

以下是这两节内容的要点总结：

-----

### 第一部分总结：20.10 信号掩码（阻塞信号传递）

本节解释了什么是信号掩码以及如何操作它。

1.  **什么是信号掩码 (Signal Mask)？**

      * 内核为每个进程（严格来说是每个线程）维护的一个**信号集 (`sigset_t`)**。
      * 它的作用是**定义需要被阻塞的信号**。
      * 如果一个被发送给进程的信号存在于其信号掩码中，那么该信号的传递就会被**延迟**，直到它从掩码中被移除（即被解除阻塞）。

2.  **核心工具：`sigprocmask()` 系统调用**
    这是显式修改信号掩码的主要函数。

    ```c
    int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);
    ```

      * **`how` 参数 (决定操作类型)**：
          * `SIG_BLOCK`：**阻塞**。将 `set` 指向的信号集添加到当前的信号掩码中（取并集）。
          * `SIG_UNBLOCK`：**解除阻塞**。从当前信号掩码中移除 `set` 指向的信号集。
          * `SIG_SETMASK`：**直接设置**。用 `set` 指向的信号集替换当前的信号掩码。
      * **`set` 参数**：指向你想要操作的信号集。
      * **`oldset` 参数**：如果不为 `NULL`，它会用来**保存旧的信号掩码**。这非常重要，因为它允许你在操作后恢复掩码原状。

3.  **典型应用场景：临时保护关键代码**
    为了防止某段代码（临界区）被信号中断，可以使用以下经典三步操作：

    ```c
    sigset_t blockSet, prevMask;

    // 1. 定义需要阻塞的信号集
    sigemptyset(&blockSet);
    sigaddset(&blockSet, SIGINT);

    // 2. 阻塞信号，并保存旧的掩码
    sigprocmask(SIG_BLOCK, &blockSet, &prevMask);

    // ... 此处是不能被 SIGINT 中断的关键代码 ...

    // 3. 恢复之前的信号掩码，解除阻塞
    sigprocmask(SIG_SETMASK, &prevMask, NULL);
    ```

4.  **重要规则**

      * `SIGKILL` 和 `SIGSTOP` 这两个信号**永远不能被阻塞**，系统会忽略任何阻塞它们的请求。
      * 如果 `sigprocmask()` 的调用导致某个等待中的信号被解除阻塞，那么该信号会**立即被传递**，甚至在 `sigprocmask()` 函数返回之前。

-----

### 第二部分总结：20.11 处于等待状态的信号 (Pending Signals)

本节解释了当一个信号被阻塞时会发生什么。

1.  **什么是等待信号 (Pending Signal)？**

      * 当一个**已被阻塞**的信号被发送给进程时，该信号不会被丢弃，而是被加入到一个称作“**等待信号集**”的队列中。
      * 这个信号就处于\*\*等待（Pending）\*\*状态。
      * 当（且如果）这个信号后续被解除阻塞，它就会被从等待队列中取出并传递给进程。

2.  **核心工具：`sigpending()` 系统调用**
    这个函数用于检查哪些信号正处于等待状态。

    ```c
    int sigpending(sigset_t *set);
    ```

      * 它会获取当前进程的等待信号集，并将其存放在 `set` 指向的 `sigset_t` 结构中。
      * 获取后，你可以使用 `sigismember()` 来检查某个特定的信号是否正在等待。

### 两者的关系

**信号掩码**和**等待信号**的关系可以这样理解：

> **信号掩码** 就像一道“防火墙”。当一个信号到来时，内核会先检查它是否在“防火墙”（信号掩码）上。
>
>   * 如果**不在**，信号直接通过并被传递给进程。
>   * 如果**在**，信号就会被“防火墙”拦下，并被放入“等待区”（Pending Signal Set）。它会一直待在那里，直到“防火墙”规则改变，允许它通过为止。