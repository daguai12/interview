### 第一部分总结：20.4 信号处理器简介

本节介绍了信号处理器的基本概念和工作方式。

1.  **什么是信号处理器 (Signal Handler)？**

      * 它是一个**自定义函数**，当一个特定的信号被传递给进程时，内核会调用这个函数。
      * 也称为信号捕捉器 (Signal Catcher)。

2.  **执行流程是怎样的？**

      * 主程序正在执行。
      * 一个信号到达。
      * 内核会**暂停**主程序的当前执行点。
      * 内核转而**调用**你预先设定的信号处理器函数。
      * 信号处理器函数执行完毕并**返回**。
      * 主程序从之前被暂停的地方**恢复**执行。

3.  **信号处理器的参数 `int sig`**

      * 当内核调用处理器时，会把触发这次调用的**信号编号**作为唯一的整型参数传递给它。
      * **作用**：如果同一个处理器函数被用来处理多种不同的信号，你可以在函数内部通过检查这个 `sig` 参数来判断究竟是哪个信号到来了，从而执行不同的逻辑。

4.  **设计原则与重要警告**

      * **力求简单**：信号处理器的代码逻辑应该尽可能地简单。
      * **重要警告**：在实际的、健壮的应用程序中，**绝对不要在信号处理器中使用标准 I/O 函数**（如 `printf()`）。因为它们不是“异步信号安全”的，可能会导致程序死锁或其他问题。（本书中的示例仅为方便演示）。

-----

### 第二部分总结：20.5 发送信号：`kill()`

本节介绍了进程如何使用 `kill()` 系统调用来向其他进程发送信号。

1.  **`kill()` 函数的作用**

      * 允许一个进程向另一个或多个进程发送指定的信号。
      * 它的命名源于早期 UNIX 中大多数信号的默认行为是杀死进程。

2.  **函数原型**

    ```c
    int kill(pid_t pid, int sig);
    ```

3.  **`pid` 参数的四种情况（非常关键）**
    `pid` 参数决定了信号将发送给谁：

      * `pid > 0`：将信号发送给进程 ID 为 `pid` 的**单个进程**。
      * `pid == 0`：将信号发送给与调用者同属一个**进程组**的所有进程。
      * `pid < -1`：将信号发送给进程组 ID 为 `pid` **绝对值**的那个进程组中的所有进程。
      * `pid == -1`：**广播信号**。将信号发送给调用者有权限发送的所有进程，但**排除 init 进程 (PID=1) 和调用进程自身**。

4.  **发送信号的权限规则**
    一个进程不是能给任意其他进程发送信号的，必须满足权限要求：

      * **特权进程** (`CAP_KILL`)：可以向**任何**进程发送信号。
      * **非特权进程**：发送方的“真实用户ID”或“有效用户ID”必须与接收方的“真实用户ID”或“保存的设置用户ID”相匹配。简单来说，**普通用户只能向自己的其他进程发送信号**。
      * **特例**：
          * `init` 进程 (PID=1) 受到特殊保护，只能接收它自己安装了处理器的信号，防止被意外杀死。
          * `SIGCONT` 信号的权限更宽松，允许在同一会话中的进程间发送，这对于 Shell 的作业控制至关重要。

5.  **返回值**

      * **成功**：返回 0。
      * **失败**：返回 -1，并设置 `errno`。
          * `ESRCH`：找不到指定的进程或进程组。
          * `EPERM`：权限不足，无法发送信号。