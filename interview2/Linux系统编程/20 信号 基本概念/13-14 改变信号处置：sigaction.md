
### 第一部分总结：20.13 改变信号处置：`sigaction()`

本节详细介绍了 `sigaction()` 系统调用，它是 `signal()` 的一个更强大、更灵活且可移植性更好的替代品。

1.  **`sigaction()` 的优势**
    * **功能更强**：提供了对信号处理过程的精细控制。
    * **可移植性好**：在不同 UNIX 系统间的行为一致，是 POSIX 标准。
    * **可安全查询**：可以在不改变信号处置的情况下，查询其当前的处置方式。

2.  **核心数据结构：`struct sigaction`**
    `sigaction()` 的所有配置都通过填充这个结构体来完成，其关键成员如下：
    * `void (*sa_handler)(int);`
      * **作用**：指定信号处理函数地址，与 `signal()` 的 `handler` 参数一样。也可以设置为 `SIG_DFL` (默认行为) 或 `SIG_IGN` (忽略)。

    * `sigset_t sa_mask;`
      * **作用**：这是一个**非常重要**的特性。它定义了一个“**附加信号掩码**”。
      * **行为**：当 `sa_handler` 指定的处理器被调用时，内核会**自动**将 `sa_mask` 中的所有信号添加到进程的信号掩码中。当处理器执行完毕返回时，这些信号又会被自动解除阻塞。
      * **目的**：这可以防止在执行一个信号处理器时，被 `sa_mask` 中指定的其他信号所中断，从而保护处理器内部的临界区代码。

    * `int sa_flags;`
      * **作用**：一个位掩码，提供了一系列用于控制信号处理行为的选项。常用选项包括：
        * `SA_RESTART`：使被此信号中断的系统调用（如 `read`, `write`）**自动重启**。
        * `SA_NODEFER`：**不要**在执行处理器时自动阻塞引发调用的那个信号本身（默认是会阻塞的）。
        * `SA_RESETHAND`：当处理器被调用一次后，将该信号的处置恢复为默认值。这是一种“一次性”处理器。
        * `SA_SIGINFO`：使用一个更强大的、能接收额外信息的信号处理器原型（`sa_sigaction` 字段）。

3.  **两个重要的默认行为**
    * **自动阻塞触发信号**：当一个信号的处理器正在执行时，**内核默认会自动阻塞同一个信号的再次递送**。这可以防止处理器被自己递归中断。
    * **信号不排队**：如果处理器执行期间，同一个被阻塞的信号又发生了多次，那么在解除阻塞后，它仍然只会被递送**一次**。

---

### 第二部分总结：20.14 等待信号：`pause()`

本节介绍了一个简单的方法来使进程挂起，直到有信号到来。

1.  **`pause()` 函数的作用**
    * 调用 `pause()` 会使进程**暂停执行（挂起）**，并且不消耗任何 CPU 资源。
    * 进程会一直保持挂起状态，直到一个信号被捕获（即一个信号处理器被执行）。

2.  **`pause()` 的行为**
    * 当一个信号处理器被执行并成功返回后，`pause()` 调用就会被**中断**。
    * `pause()` **总是返回 -1**，并且 `errno` 会被设置为 `EINTR`（表示“被中断的系统调用”）。
    * 如果接收到的信号的默认行为是终止进程，那么进程会直接终止，`pause()` 不会返回。

**总结**：`sigaction()` 是建立信号处理器的**标准和推荐**方式，它通过 `sa_mask` 和 `sa_flags` 提供了强大的控制能力。而 `pause()` 则提供了一种**简单且高效**的方式来等待信号的发生，是替代 `while(1);` 这种忙等待循环的理想选择。