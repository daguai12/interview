### 核心概念总结

1.  **标准信号不会排队 (Not Queued)**

      * 内核用于记录“等待中”信号的数据结构（等待信号集）本质上是一个**位掩码 (bitmask)**。
      * 这个位掩码只能记录**某个信号是否发生 (Yes/No)**，而不能记录它**发生了多少次**。
      * **关键结论**：如果在信号被阻塞期间，同一个标准信号（例如 `SIGUSR1`）被发送了多次（比如100万次），那么当该信号被解除阻塞时，它**只会被传递一次**。之前的所有发生实例都被合并成了一个。

2.  **与实时信号的区别**

      * 这个“不排队”的特性是**标准信号**（编号1-31）和**实时信号**（Real-time Signals）的关键区别之一。实时信号是**会排队**的。

3.  **两种信号丢失的场景**
    原文通过两个实验展示了信号是如何“丢失”（即没有被全部接收）的：

      * **场景一：信号被阻塞时**

          * 接收方进程先**阻塞**某个信号（如 `SIGUSR1`）。
          * 发送方在此期间向它发送了 100 万次 `SIGUSR1`。
          * 当接收方解除阻塞时，它**只会收到 1 次** `SIGUSR1` 信号。这是因为在等待信号集中，`SIGUSR1` 对应的标志位从0变成了1，后续的999,999次信号到来时，该标志位已经是1，所以没有任何变化。

      * **场景二：信号发送过快时（即使未被阻塞）**

          * 接收方不阻塞任何信号，正常运行。
          * 发送方以极快的速度（例如在一个循环里）向它发送 100 万次 `SIGUSR1`。
          * 最终，接收方可能只收到了几十次信号。
          * **原因**：发送方进程在一次CPU时间片内可能已经发送了成千上万个信号。但对于内核来说，它检查接收方的等待信号集，发现 `SIGUSR1` 标志位已经是1了，就不会再做额外记录。直到接收方被调度运行，处理掉这个信号（标志位清0），才有可能记录下一次的 `SIGUSR1`。这个过程中的时间差导致了大量信号的丢失。

-----

### 代码示例

为了让您能亲自验证这个特性，以下是原文中提到的两个程序的完整代码：

#### 1\. 发送方程序 (程序清单 20-6)

这个程序用于向指定进程发送大量信号。

**`sender.c`**

```c
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(int argc, char *argv[]) {
    if (argc < 4 || strcmp(argv[1], "--help") == 0) {
        fprintf(stderr, "Usage: %s pid num-sigs sig-num [term-sig-num]\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    pid_t pid = atol(argv[1]);
    int numSigs = atoi(argv[2]);
    int sig = atoi(argv[3]);

    // 发送 numSigs 个信号
    printf("%s: sending signal %d to process %ld %d times\n",
           argv[0], sig, (long)pid, numSigs);

    for (int j = 0; j < numSigs; j++) {
        if (kill(pid, sig) == -1) {
            perror("kill error");
            exit(EXIT_FAILURE);
        }
    }

    // 如果提供了第四个参数，发送一个终止信号
    if (argc > 4) {
        int termSig = atoi(argv[4]);
        printf("%s: sending signal %d to process %ld\n", argv[0], termSig, (long)pid);
        if (kill(pid, termSig) == -1) {
            perror("kill error");
            exit(EXIT_FAILURE);
        }
    }

    printf("%s: Exiting\n", argv[0]);
    return EXIT_SUCCESS;
}
```

#### 2\. 接收方程序 (程序清单 20-7)

这个程序用于接收并统计信号。

**`receiver.c`**

```c
#define _GNU_SOURCE
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

// volatile sig_atomic_t 是在信号处理器中安全地修改变量的推荐方式
static volatile sig_atomic_t gotSigint = 0;
static int sigCounts[NSIG] = {0}; // 用来统计每个信号收到的次数

// 信号处理器
static void handler(int sig) {
    if (sig == SIGINT) {
        gotSigint = 1;
    } else {
        sigCounts[sig]++;
    }
}

// 打印信号集内容的辅助函数
void printSigset(FILE *of, const char *prefix, const sigset_t *set) {
    int sig, cnt = 0;
    for (sig = 1; sig < NSIG; sig++) {
        if (sigismember(set, sig)) {
            cnt++;
            fprintf(of, "%s%d (%s)\n", prefix, sig, strsignal(sig));
        }
    }
    if (cnt == 0) fprintf(of, "%s<empty signal set>\n", prefix);
}

int main(int argc, char *argv[]) {
    printf("%s: My PID is %ld\n", argv[0], (long)getpid());

    // 为所有信号设置同一个处理器
    for (int n = 1; n < NSIG; n++) {
        // SIGKILL 和 SIGSTOP 无法被捕获，所以 signal() 会失败，但我们忽略错误
        (void)signal(n, handler);
    }

    // 如果提供了命令行参数，则阻塞所有信号一段时间
    if (argc > 1) {
        int block_secs = atoi(argv[1]);
        printf("%s: Blocking all signals for %d seconds\n", argv[0], block_secs);
        
        sigset_t blockMask, prevMask;
        sigfillset(&blockMask); // 创建一个包含所有信号的满集
        sigprocmask(SIG_SETMASK, &blockMask, &prevMask); // 阻塞所有信号并保存旧掩码
        
        // 打印等待中的信号（此时应该为空）
        sigset_t pendingSigs;
        sigpending(&pendingSigs);
        printSigset(stdout, "\tPending signals are:\n", &pendingSigs);
        
        sleep(block_secs); // 在此期间，任何发来的信号都会变成 pending 状态

        // 打印在阻塞期间收到的等待信号
        sigpending(&pendingSigs);
        printSigset(stdout, "\tPending signals after sleep:\n", &pendingSigs);

        // 恢复之前的信号掩码（即解除阻塞）
        sigprocmask(SIG_SETMASK, &prevMask, NULL);
        printf("%s: Unblocked all signals\n", argv[0]);
    }
    
    // 循环等待，直到 SIGINT 信号被捕获
    while (!gotSigint) {
        continue;
    }

    // 打印所有信号的接收计数
    printf("\n--- Signal Counts ---\n");
    for (int i = 1; i < NSIG; i++) {
        if (sigCounts[i] != 0) {
            printf("%s: signal %d (%s) caught %d time(s)\n",
                   argv[0], i, strsignal(i), sigCounts[i]);
        }
    }

    return EXIT_SUCCESS;
}
```

### 如何编译和运行实验

1.  **编译代码**

    ```bash
    gcc -o sender sender.c
    gcc -o receiver receiver.c
    ```

2.  **执行实验一 (阻塞场景)**

      * **终端1**: 启动接收方，让它阻塞信号10秒。
        ```bash
        ./receiver 10
        ```
        记下它打印的 PID，比如 `23456`。
      * **终端2**: 在接收方阻塞的10秒内，快速运行发送方，发送100万次 `SIGUSR1` (信号编号10)，最后再发送一个 `SIGINT` (信号编号2) 来结束接收方。
        ```bash
        ./sender 23456 1000000 10 2
        ```
      * **观察结果**: 回到终端1，你会看到接收方在解除阻塞后，打印出的统计结果中 `SIGUSR1` (信号10) 只被捕获了 **1** 次。

3.  **执行实验二 (发送过快场景)**

      * **终端1**: 启动接收方，不带参数，让它不阻塞信号。
        ```bash
        ./receiver
        ```
        记下 PID，比如 `23457`。
      * **终端2**: 快速运行发送方。
        ```bash
        ./sender 23457 1000000 10 2
        ```
      * **观察结果**: 回到终端1，你会看到 `SIGUSR1` 被捕获的次数远少于100万次，可能只有几十次。