### 核心内容总结：信号集 (sigset_t)

1.  **什么是信号集？**
    * 它是一个名为 `sigset_t` 的**数据结构**，用来表示一个**包含多个信号的集合**。
    * 很多高级信号处理的系统调用（如 `sigprocmask`, `sigpending`, `sigaction`）都需要使用信号集来指定一组要操作的信号。例如，用它来定义“需要阻塞的一组信号”。

2.  **关键原则：可移植性与抽象**
    * 程序员**不应该**关心 `sigset_t` 的内部实现。虽然在 Linux 中它通常是一个位掩码，但在其他 UNIX 系统上可能不同。
    * 因此，必须将其当作一个**不透明的（opaque）**数据类型来对待。
    * **绝对不能**直接对其进行手动操作（例如使用 `memset` 清零或 `set = 0`）。必须使用下面这些标准函数来处理它，这样才能保证代码的可移植性。

3.  **标准信号集操作函数**
    这些函数是 POSIX 标准规定的，可移植性最好。

    * **初始化 (Initialization):**
        * `int sigemptyset(sigset_t *set);`
          将 `set` 初始化为一个**空集**（不包含任何信号）。
        * `int sigfillset(sigset_t *set);`
          将 `set` 初始化为一个**满集**（包含系统支持的所有信号）。
        * **注意**：在使用任何 `sigset_t` 变量之前，**必须**先调用这两个函数之一进行初始化。

    * **修改 (Modification):**
        * `int sigaddset(sigset_t *set, int signum);`
          向信号集 `set` 中**添加** `signum` 信号。
        * `int sigdelset(sigset_t *set, int signum);`
          从信号集 `set` 中**移除** `signum` 信号。

    * **查询 (Querying):**
        * `int sigismember(const sigset_t *set, int signum);`
          **测试** `signum` 信号是否存在于信号集 `set` 中。如果存在，返回 1；否则返回 0。

4.  **非标准的 GNU 扩展函数**
    这些函数在 GNU C 库 (glibc) 中提供，但在其他系统中可能不存在，可移植性较差。
    * `sigandset()`: 计算两个信号集的**交集 (AND)**。
    * `sigorset()`: 计算两个信号集的**并集 (OR)**。
    * `sigisemptyset()`: 测试一个信号集是否为**空**。

5.  **代码示例解读 (`printSigset`)**
    * 文中提供了一个名为 `printSigset` 的示例函数，它展示了如何正确地“读取”一个信号集的内容。
    * 它的工作方式是：
        1.  从信号 1 循环到 `NSIG` (系统定义的最大信号数)。
        2.  在循环的每一步，使用 `sigismember()` 函数来判断当前的信号编号是否存在于传入的信号集中。
        3.  如果存在，就打印出该信号的名称。
    * 这个函数是检查进程的信号掩码或待处理信号集的标准方法。