好的，这段内容介绍了用于改变信号处置的 `signal()` 函数。

以下是该段文字的核心内容总结：

### 核心内容总结：`signal()` 函数

1.  **功能定位：原始但不推荐的 API**

      * `signal()` 是 UNIX 系统中用于设置信号处置（如何处理信号）的**原始接口**。它比 `sigaction()` 更简单。
      * 尽管它很基础，但**强烈不推荐**在新的、追求可移植性的程序中使用它。**首选且推荐的接口是 `sigaction()`**。

2.  **不推荐使用的原因**

      * **可移植性差**：`signal()` 的行为在不同的 UNIX 实现之间存在差异，这可能导致代码在不同系统上表现不一。
      * **功能有限**：`sigaction()` 提供了 `signal()` 所不具备的更强大、更可靠的功能。

3.  **`signal()` 函数用法**

      * **函数原型大致可以理解为**：

        ```c
        void (*signal(int sig, void (*handler)(int)))(int);
        ```

        为了简化理解，可以将其看作：`signal(信号编号, 处理器);`

      * **参数说明**：

          * `int sig`：你希望改变处置的信号编号（例如 `SIGINT`）。
          * `handler`：一个指针，指定了如何处理该信号。它可以是以下三者之一：
            1.  **一个函数地址**：一个自定义的、返回值为 `void`、接收一个 `int` 参数的函数（即信号处理器）。
            2.  `SIG_DFL`：一个宏，用于将信号的处置恢复为其**默认行为**（如终止进程、忽略等）。
            3.  `SIG_IGN`：一个宏，用于**忽略**该信号。

4.  **返回值**

      * **成功时**：返回该信号**之前**的处置方式。这个返回值可能是上一个信号处理器的函数地址，也可能是 `SIG_DFL` 或 `SIG_IGN`。这个特性可以让你保存旧的处置，以便将来恢复。
      * **失败时**：返回 `SIG_ERR`。

5.  **一个重要限制**

      * 你无法使用 `signal()` **查询**一个信号当前的处置方式而不去**改变**它。要实现这一点，必须使用 `sigaction()`。

6.  **在 Linux 中的实现**

      * 在 Linux 系统中，`signal()` 并非一个独立的系统调用，而是 **glibc 库函数**。它的底层实现其实是**通过调用 `sigaction()` 系统调用**来完成的。

**总而言之，这段文字告诉我们：虽然你应该了解 `signal()` 的存在和基本用法，但在实际编程中，为了程序的健壮性和可移植性，应当始终优先使用 `sigaction()` 来处理信号。**