# 概述

除了底层的 `execve()` 系统调用之外，C 库还提供了一系列以 `exec` 开头的函数。它们的功能都是执行一个新程序，但提供了不同形式的接口，让开发者可以根据便利性来选择。

这些函数的命名差异可以通过其后缀字母来理解和记忆：

* **`p` (Path)**:
    * 如果函数名中包含 `p` (如 `execlp()`, `execvp()`)，你只需要提供程序的文件名（例如 `"ls"`）。函数会自动在 `PATH` 环境变量所指定的目录中搜索这个可执行文件。
    * 如果提供的文件名中含有 `/`，则将其视为路径名，不再搜索 `PATH`。

* **`l` (List)**:
    * 如果函数名中包含 `l` (如 `execl()`, `execlp()`, `execle()`)，命令行参数需要以**列表**的形式，作为独立的参数直接传递给函数，并以 `NULL` 结尾。
    * 例如: `execl("/bin/ls", "ls", "-l", NULL);`

* **`v` (Vector / Array)**:
    * 如果函数名中包含 `v` (如 `execv()`, `execvp()`, `execve()`)，命令行参数需要以一个**字符串指针数组**（即 "vector"）的形式传递，该数组的最后一个元素必须是 `NULL`。
    * 例如: `char *args[] = {"ls", "-l", NULL}; execv("/bin/ls", args);`

* **`e` (Environment)**:
    * 如果函数名中包含 `e` (如 `execve()`, `execle()`)，你可以显式地传递一个**自定义的环境变量数组** (`envp`) 给新程序。
    * 其他不带 `e` 的函数，新程序会直接**继承**调用者当前的环境变量。

**文本中表格 27-1 的总结如下：**

| 函数         | 如何指定程序        | 如何传递参数      | 如何指定环境变量     |
| :--------- | :------------ | :---------- | :----------- |
| `execve()` | 完整路径名         | 数组 (vector) | 通过 `envp` 参数 |
| `execle()` | 完整路径名         | 列表 (list)   | 通过 `envp` 参数 |
| `execlp()` | 文件名 (会搜索PATH) | 列表 (list)   | 继承调用者的环境     |
| `execvp()` | 文件名 (会搜索PATH) | 数组 (vector) | 继承调用者的环境     |
| `execv()`  | 完整路径名         | 数组 (vector) | 继承调用者的环境     |
| `execl()`  | 完整路径名         | 列表 (list)   | 继承调用者的环境     |

简单来说，这一系列函数就是 `execve()` 的不同“便利贴”，让开发者可以根据自己手头的数据格式（参数是列表还是数组？是否需要自定义环境变量？是否需要自动搜索路径？）选择最顺手的那个来用。

# 环境变量PATH

好的，这段内容详细解释了 `PATH` 环境变量的工作原理，以及它与 `execlp()` 和 `execvp()` 这两个函数的关系。

以下是核心要点的梳理：

1.  **`PATH` 的定义**:
    * `PATH` 是一个环境变量，其值是一个由冒号(`:`)分隔的目录列表字符串。
    * 例如：`/usr/local/bin:/usr/bin:/bin`。

2.  **`execlp()` 和 `execvp()` 的工作方式**:
    * 当给这两个函数一个不含斜杠(`/`)的文件名时（如 `"ls"`），它们会**依次遍历 `PATH` 环境变量中的每个目录**，去寻找同名的可执行文件。
    * 一旦找到第一个匹配的文件并成功执行，搜索就会停止。
    * 如果提供了包含斜杠的路径名（如 `"./myprog"` 或 `"/bin/ls"`），`PATH` 变量将被**忽略**。

3.  **当前工作目录**:
    * 要在 `PATH` 中包含当前工作目录，应显式地加入一个点 (`.`)。
    * 过去使用连续冒号(`::`)或首尾冒号的方式来隐式表示当前目录，但这种做法已被废弃。

4.  **`PATH` 的来源**:
    * `PATH` 通常在系统或用户的 shell 启动脚本中设置。
    * 由于子进程会继承父进程的环境变量，所以从 shell 启动的程序会自动获得 shell 的 `PATH` 设置。

5.  **安全注意事项 (非常重要)**:
    * **超级用户(root)** 的 `PATH` 通常**不应包含当前工作目录 (`.`)**。这是为了防止 `root` 用户在某个目录下意外执行了被恶意放置的、与标准命令同名的程序（例如，一个假的 `ls`）。
    * 在编写**设置了 set-user-ID 或 set-group-ID 权限**的程序时，应**极力避免**使用 `execlp()` 和 `execvp()`。因为攻击者可能通过修改 `PATH` 环境变量，让你的特权程序去执行一个恶意程序，从而造成严重的安全漏洞。如果必须使用，程序内部应先将 `PATH` 覆盖为一个已知的、安全的值。

6.  **示例说明**:
    * 文中的例子展示了：当 `/bin` 目录在 `PATH` 中时，`execlp("echo", ...)` 可以成功执行。
    * 当从 `PATH` 中移除 `/bin` 目录后，同样的调用就会失败，因为找不到 `echo` 命令。


# 将程序参数指定为列表

当您在编写程序时已经明确知道要执行的另一个程序的参数数量和内容时，使用 `execle()`、`execlp()` 或 `execl()` 会更方便。与需要先构建一个参数数组（`argv` 向量）的 `execve()` 不同，这些函数允许您直接将参数作为一连串的字符串列表传入。这样做可以使代码更简洁、更易于阅读。

文中提到的 **程序清单 27-4** 展示了如何使用 `execle()` 来达到与 **程序清单 27-1** (`execve()`) 相同的效果，但实现方式更为直接。

# 将调用者的环境传递给新程序

`exec()` 家族中的 `execlp()`、`execvp()`、`execl()` 和 `execv()` 函数会自动让被调用的新程序继承当前进程的环境变量。这在大多数情况下很方便，但也可能带来安全隐患。因为继承的环境变量可能包含不安全或未知的设置。为了确保新程序在受控、安全的环境下运行，有时需要手动指定一个全新的、干净的环境列表（如使用 `execve()` 或 `execle()`）。

文中提及的 **程序清单 27-5** 演示了 `execl()` 的这种继承行为。它首先通过 `putenv()` 修改了从 shell 继承来的环境变量，然后执行 `printenv` 程序来验证这些环境变量（如 `USER` 和 `SHELL`）确实被新程序继承和显示了。

# 通过文件描述符执行程序：`fexecve()`

从 glibc 2.3.2版本开始引入的 `fexecve()` 函数提供了一种更安全的执行程序的方式。它与 `execve()` 类似，但它不是通过文件路径名来指定要执行的程序，而是通过一个已经打开的文件的描述符（file descriptor, fd）。

这种方式的主要优点在于可以避免 **"检查时序-使用时序" (TOCTOU - Time-of-Check to Time-of-Use)** 的安全漏洞。一个典型的应用场景是：
1.  程序以只读方式打开一个可执行文件。
2.  程序读取文件内容并计算其校验和（checksum），以验证该文件是否为预期中的、未经篡改的程序。
3.  验证通过后，直接使用该文件的描述符调用 `fexecve()` 来执行它。

如果没有 `fexecve()`，程序在验证文件和通过路径名执行文件之间会存在一个时间窗口。攻击者可能利用这个窗口，将原来的合法文件替换成一个恶意文件。而 `fexecve()` 因为直接操作已经打开且验证过的文件描述符，所以能确保执行的正是刚才验证过的那个文件，从而避免了这种风险。