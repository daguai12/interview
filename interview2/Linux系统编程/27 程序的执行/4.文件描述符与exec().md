### 核心概念总结

1.  **文件描述符的继承**:

      * 默认情况下，当一个进程调用 `exec()` 成功后，所有在调用前打开的文件描述符在新程序中**依然保持打开和有效**。
      * Shell 正是利用这个特性来实现 I/O 重定向（如 `>`、`<`、`|`）。例如，当执行 `ls -l > dir.txt` 时，shell 在 `fork()` 出子进程后、`exec()` `ls` 命令之前，会先把子进程的标准输出（文件描述符 1）重定向到文件 `dir.txt`。这样，`ls` 程序启动后，它只需要像平常一样向标准输出写入数据，这些数据就会自然地流入 `dir.txt` 文件。

2.  **Shell 内建命令 (Built-in Commands)**:

      * 不是所有的 shell 命令都会通过 `fork()` + `exec()` 来执行。一些命令，如 `cd`, `exit`, `ulimit`, `pwd` 等，是作为 shell 进程自身的一部分来执行的，被称为内建命令。
      * 这么做的原因有两个：一是**效率**（如 `pwd`），二是这些命令需要**对 shell 进程本身产生副作用**（如 `cd` 必须改变 shell 自身的当前工作目录，而不是一个短暂子进程的目录）。

3.  **执行时关闭标志 (`close-on-exec` flag)**:

      * **问题**: 有时我们希望某些文件描述符在 `exec()` 执行新程序后能自动关闭，尤其是在编写库函数或需要提升安全性的特权程序时。如果手动 `close()`，万一 `exec()` 失败，文件描述符就永久关闭了，难以恢复。
      * **解决方案**: 内核为每个文件描述符提供了一个名为 `FD_CLOEXEC` 的标志。
      * **作用**: 如果一个文件描述符设置了此标志，那么在调用 `exec()` **成功**后，内核会自动关闭该文件描述符。如果 `exec()` 调用失败，该文件描述符则保持打开状态。
      * **如何操作**: 使用 `fcntl()` 系统调用来读取和设置这个标志。
        1.  `fcntl(fd, F_GETFD)`: 获取指定文件描述符 `fd` 的当前标志。
        2.  `flags |= FD_CLOEXEC;`: 在获取的标志上通过位或运算添加 `FD_CLOEXEC` 标志。
        3.  `fcntl(fd, F_SETFD, flags);`: 将修改后的新标志设置回去。

-----

### 动手实践：演示 `close-on-exec` 标志 (程序清单 27-6)

下面的 C 程序将完全复现“程序清单 27-6”的功能。它会检查命令行参数：

  * 如果**没有**命令行参数，它直接执行 `ls -l`。由于标准输出（fd 1）默认是打开的，`ls` 会将结果打印到终端。
  * 如果**有**命令行参数，它会先为标准输出设置 `FD_CLOEXEC` 标志，然后再执行 `ls -l`。由于标志被设置，`ls` 程序启动时它的标准输出已经被内核关闭了，因此会报错。

**文件名: `close_on_exec_example.c`**

```c
#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(int argc, char *argv[]) {
    int flags;

    // 检查是否提供了命令行参数
    if (argc > 1) {
        printf("为标准输出 (fd 1) 设置 close-on-exec 标志。\n");

        // 1. 获取标准输出的文件描述符标志
        flags = fcntl(STDOUT_FILENO, F_GETFD);
        if (flags == -1) {
            perror("fcntl - F_GETFD 失败");
            exit(EXIT_FAILURE);
        }

        // 2. 添加 FD_CLOEXEC 标志
        flags |= FD_CLOEXEC;

        // 3. 将修改后的标志设置回去
        if (fcntl(STDOUT_FILENO, F_SETFD, flags) == -1) {
            perror("fcntl - F_SETFD 失败");
            exit(EXIT_FAILURE);
        }
        
        printf("标志已设置。现在调用 execlp() 执行 'ls -l'...\n\n");
    } else {
        printf("未提供参数，不设置 close-on-exec 标志。\n");
        printf("现在调用 execlp() 执行 'ls -l'...\n\n");
    }

    // 执行 ls -l 命令
    // execlp 会在 PATH 环境变量中查找 ls
    execlp("ls", "ls", "-l", (char *) NULL);

    // 如果 execlp 成功，下面的代码不会被执行
    perror("execlp 调用失败");
    exit(EXIT_FAILURE);
}
```

#### 编译和运行

1.  **编译程序**:

    ```bash
    gcc close_on_exec_example.c -o close_on_exec_example
    ```

2.  **情况一：不带参数运行**

    ```bash
    ./close_on_exec_example
    ```

    **预期输出**:
    程序会先打印提示信息，然后 `ls -l` 命令会成功执行，并将其输出（当前目录的文件列表）打印到终端上。

    ```
    未提供参数，不设置 close-on-exec 标志。
    现在调用 execlp() 执行 'ls -l'...

    total 24
    -rwxr-xr-x 1 user user 16832 Aug 27 14:50 close_on_exec_example
    -rw-r--r-- 1 user user   887 Aug 27 14:50 close_on_exec_example.c
    ... (其他文件)
    ```

3.  **情况二：带任意参数运行**

    ```bash
    ./close_on_exec_example foo
    ```

    **预期输出**:
    程序会打印设置标志的提示信息，然后当 `ls -l` 启动时，它会发现自己的标准输出已经被关闭了，因此无法打印文件列表，转而向它的**标准错误**（仍然是连接到终端的）输出一条错误信息。

    ```
    为标准输出 (fd 1) 设置 close-on-exec 标志。
    标志已设置。现在调用 execlp() 执行 'ls -l'...

    ls: write error: Bad file descriptor
    ```

    这条 `Bad file descriptor` 错误信息精确地证明了 `FD_CLOEXEC` 标志生效了：在 `exec` 成功执行 `ls` 的那一刻，内核关闭了文件描述符 1。