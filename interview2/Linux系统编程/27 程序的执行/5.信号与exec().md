# 要点速记

* `exec()` 会替换进程的程序映像（文本段、数据段、堆、栈会被新程序替换）。
* **对先前用代码设置的信号处理器（handler）的处置会被重置为 `SIG_DFL`**（因为处理器函数在被丢弃的文本段里）。
* 对已经被设置为 `SIG_IGN`（忽略）或本就 `SIG_DFL` 的信号，其处置保持不变。
* **SIGCHLD 是一个例外/不一致点**：

  * SUSv3 未规定统一行为；Linux 在 `exec()` 后**保持**被忽略的 `SIGCHLD` 为忽略，Solaris 等会把它重置为 `SIG_DFL`。
  * 为了可移植性，**在 `exec()` 前应显式把 `SIGCHLD` 设为 `SIG_DFL`（如果你不想在新程序里继续忽略它）**。
* `sigaltstack()` 创建的备选信号栈会在 `exec()` 时被丢弃，且内核会清除所有信号的 `SA_ONSTACK` 标志。
* **进程的信号掩码（blocked set）和挂起的信号（pending）会被保留**。这允许 exec 后的新程序继承阻塞/挂起状态。
* SUSv3 建议：**不要在 exec 期间阻塞或忽略信号（尤其是你要执行的程序不是你自己写的）**，以避免可移植性问题。

# 实务建议（summary）

1. 如果程序在运行中忽略了 `SIGCHLD`，**在 exec 前显式把它设回 `SIG_DFL`**，保证在不同 UNIX 实现下行为一致。
2. 在 `exec` 之前不要保留不必要的信号阻塞（除非很清楚为什么要保留），或者在 `exec` 前把信号掩码恢复为不阻塞状态。
3. 如果你用过 `sigaltstack()`，不要指望 exec 后还能用原来的备用栈——新程序需要自己重新调用 `sigaltstack()`。
4. 不要假设进程启动时某些信号不是 `SIG_DFL`；可移植程序应显式设置所需的处置。

# 示例代码（可直接用）：

下面示例展示如何在调用 `execve()` 之前：

* 将 `SIGCHLD` 设为 `SIG_DFL`（以保证可移植）
* 解除所有阻塞信号（恢复为空阻塞集）
* 然后调用 `execve()` 执行新程序

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>
#include <errno.h>
#include <string.h>

int main(void) {
    /* 1) 可移植性：确保 SIGCHLD 在 exec 后为 SIG_DFL */
    struct sigaction sa;
    sa.sa_handler = SIG_DFL;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;
    if (sigaction(SIGCHLD, &sa, NULL) == -1) {
        fprintf(stderr, "sigaction(SIGCHLD) failed: %s\n", strerror(errno));
        /* 视情况决定是否继续 */
    }

    /* 2) 恢复信号掩码（解除所有阻塞），避免 exec 后新程序被意外阻塞 */
    sigset_t empty;
    sigemptyset(&empty);
    if (sigprocmask(SIG_SETMASK, &empty, NULL) == -1) {
        fprintf(stderr, "sigprocmask(SIG_SETMASK) failed: %s\n", strerror(errno));
    }

    /* 注意：如果你使用 sigaltstack(), 那些配置在 exec 后会丢失，
       如果新程序需要备用栈，应在新程序里重新调用 sigaltstack(). */

    /* 3) 执行新程序（示例：/bin/ls） */
    char *argv[] = { "ls", "-l", "/", NULL }; extern char **environ; /* 若希望继承父进程环境 */
    if (execve("/bin/ls", argv, environ) == -1) {
        fprintf(stderr, "execve failed: %s\n", strerror(errno));
        exit(EXIT_FAILURE);
    }

    /* exec 成功时不会返回 */
    return 0;
}
```

# 额外说明（常见误区）

* **不要指望 exec 会自动将所有信号恢复为默认**——只有先前安装了 *handler*（非 `SIG_IGN`/`SIG_DFL`）的信号会被重置为 `SIG_DFL`；被忽略的信号仍可能保持忽略（尤其是 `SIGCHLD` 在不同系统间行为不一）。
* `exec()` 不会清空挂起（pending）信号；如果某些信号在 exec 前已被阻塞并被挂起，exec 后这些信号仍然挂起并可在解阻时投递到新程序。
* 如果你的程序需要在 exec 后运行受控环境（比如确保某些信号处置、信号掩码、备用栈），应在 exec 之前把这些状态设置为你期望的新程序继承的状态，或在新程序的入口处重新设置。

---