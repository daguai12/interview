好——我把第 **27.6（`system()`）** 的要点浓缩成实用说明，并给你 **两段可直接编译运行的 C 代码**：

1. `demo_system.c`：交互式示例，用 `system()` 执行用户输入的 shell 命令，并**正确解析并打印返回状态**（演示 `command == NULL`、`-1` 情况，以及如何用 `WIFEXITED`/`WEXITSTATUS`/`WIFSIGNALED`/`WTERMSIG` 等宏解析 `system()` 返回值）。
2. `safe_exec.c`：展示当你关心\*\*安全性（例如 setuid 程序）\*\*时，**不要用 `system()`**，而是用 `fork()` + `execvp()` 直接运行指定程序（不经 shell），并说明为什么这样更安全。

下面先给要点速览，再给代码与使用建议。

---

# 要点速览（实用）

* `system(NULL)`：若存在 shell 返回非 0，否则返回 0（可用来检测 shell 是否可用）。
* `system(cmd)`：会创建子 shell 去解析并执行 `cmd`；返回值的形式与 `wait()`/`waitpid()` 的返回值相同（含有 exit status / signal info）。
* 若 `system()` 无法创建子进程或无法获取终止状态，则返回 `-1`。
* 如果子 shell 无法执行（例如 `/bin/sh` 不可用），有实现会返回与子 shell 调用 `_exit(127)` 相同的状态（127 常表示 shell 找不到要执行的命令）。
* **安全性警告**：在 set-user-ID/set-group-ID 程序中**绝对不要**用 `system()`（环境变量影响 shell 行为，可被利用）。要执行外部程序应用 `fork()` + `exec()`（不要调用 `execlp`/`execvp` 除非非常确定安全性），并清理环境。
* 性能：`system()` 比直接 `fork()`+`exec()` 更慢（会多出一个 shell 层，以及可能的多个子进程）。
* 若需要读写命令的 stdin/stdout，考虑 `popen()`/`pclose()`。

---

# 1) demo\_system.c（交互式，展示返回值解析）

```c
/* demo_system.c
 *
 * 交互式示例：读取用户命令，用 system() 执行，并解析返回值。
 * 编译：gcc demo_system.c -o demo_system
 */

#define _POSIX_C_SOURCE 200809L
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/wait.h>

void printWaitStatus(int status) {
    if (status == -1) {
        puts("system() returned -1 (unable to fork or wait)");
        return;
    }

    if (WIFEXITED(status)) {
        printf("Child exited normally, exit code = %d\n", WEXITSTATUS(status));
    } else if (WIFSIGNALED(status)) {
        printf("Child was terminated by signal %d", WTERMSIG(status));
#ifdef WCOREDUMP
        if (WCOREDUMP(status)) printf(" (core dumped)");
#endif
        putchar('\n');
    } else if (WIFSTOPPED(status)) {
        printf("Child stopped by signal %d\n", WSTOPSIG(status));
    } else {
        printf("Unknown child status: 0x%x\n", status);
    }
}

int main(void) {
    char *line = NULL;
    size_t len = 0;

    puts("demo_system: 输入 shell 命令并回车执行；输入 'exit' 或 EOF 退出；输入空行会跳过。");
    while (1) {
        fputs("> ", stdout);
        fflush(stdout);
        ssize_t n = getline(&line, &len, stdin);
        if (n == -1) { /* EOF */
            putchar('\n');
            break;
        }

        /* 去掉换行 */
        while (n > 0 && (line[n-1] == '\n' || line[n-1] == '\r')) { line[--n] = '\0'; }

        if (n == 0) continue; /* 空行忽略 */
        if (strcmp(line, "exit") == 0) break;

        /* 命令为 NULL 的情况示例（这里用固定判断） */
        if (strcmp(line, "check-shell") == 0) {
            int r = system(NULL);
            printf("system(NULL) -> %d (%s shell available)\n", r, r ? "has" : "no");
            continue;
        }

        int status = system(line); /* 这是阻塞调用，直到 shell/命令完成 */

        /* 解析并打印返回状态 */
        printWaitStatus(status);
    }

    free(line);
    puts("退出。");
    return 0;
}
```

**示例运行：**

```
$ ./demo_system
> echo hello
hello
Child exited normally, exit code = 0
> false
Child exited normally, exit code = 1
> kill -9 $$   # 这个会杀子 shell（示例），返回通常为 128+9
Child was terminated by signal 9
> check-shell
system(NULL) -> 1 (has shell available)
> exit
退出。
```

---

# 2) safe\_exec.c（在 setuid 情况或高安全要求下的代替：不走 shell）

```c
/* safe_exec.c
 *
 * 演示：在需要安全执行外部程序时，使用 fork()+execvp()（不经 shell）
 * 编译：gcc safe_exec.c -o safe_exec
 *
 * 用法示例：
 * ./safe_exec ls -l /
 * ./safe_exec /usr/bin/grep foo file.txt
 */

#define _POSIX_C_SOURCE 200809L
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
#include <errno.h>
#include <string.h>

int main(int argc, char *argv[]) {
    if (argc < 2) {
        fprintf(stderr, "Usage: %s <program> [args...]\n", argv[0]);
        return 2;
    }

    /* 安全检查：如果进程是 setuid/setgid（有效 uid/gid != 实际 uid/gid），不要直接使用继承的环境 */
    if (geteuid() != getuid() || getegid() != getgid()) {
        /* 推荐清理环境，保守策略：只保留 PATH=/usr/bin:/bin */
        clearenv();
        setenv("PATH", "/usr/bin:/bin", 1);
    }

    pid_t pid = fork();
    if (pid < 0) {
        fprintf(stderr, "fork failed: %s\n", strerror(errno));
        return 1;
    }

    if (pid == 0) {
        /* 子进程：用 execvp 执行，不经 shell（更安全） */
        execvp(argv[1], &argv[1]);
        /* execvp 失败才会返回 */
        fprintf(stderr, "execvp failed: %s\n", strerror(errno));
        _exit(127); /* 按照 convention，127 表示 exec 失败 */
    } else {
        /* 父进程等待子进程 */
        int status = 0;
        if (waitpid(pid, &status, 0) == -1) {
            fprintf(stderr, "waitpid failed: %s\n", strerror(errno));
            return 1;
        }
        if (WIFEXITED(status)) {
            printf("Child exited with %d\n", WEXITSTATUS(status));
            return WEXITSTATUS(status);
        } else if (WIFSIGNALED(status)) {
            printf("Child killed by signal %d\n", WTERMSIG(status));
            return 128 + WTERMSIG(status);
        } else {
            printf("Child stopped or unknown status\n");
            return 1;
        }
    }
}
```

**说明与优点：**

* 直接调用 `execvp()`（或 `execve()`）**不经过 shell**，因此不会触发 shell 扩展、环境变量注入、元字符解释等风险。
* 对于 setuid 程序，建议在 `exec()` 前清理环境（例如 `clearenv()`）并只设置受信任的变量（如 PATH 指向受信任的目录），并尽量不要允许外部输入直接决定命令字符串。
* 如果一定要用 shell 功能（比如通配/重定向/管道），请非常小心并尽可能避免在特权程序中使用 `system()`。

---

# 额外建议

* 若你只是需要捕获命令输出（读取 stdout），优先考虑 `popen()`/`pclose()`，比 `system()` 更方便。
* 若你的工具链（CMake/Make）能生成 `compile_commands.json` 等，clangd 等工具会更智能——同一章节中也提到 exec 系列的很多细节，结合上面的信号处理建议（27.5 节）能写出更健壮的父子进程交互代码。
* 总之：**方便时用 `system()`，但在安全/高性能/可控性 要求下用 fork+exec(+wait)。**

---

如果你想，我可以：

* 把 `demo_system.c` 改成同时展示 `popen()` 用法；或
* 在 `safe_exec.c` 里加入更严格的 setuid-safe 启动流程（清理更多环境变量、重置 signal handler、重置 umask 等）；或
* 给你一份可复制的 `printWaitStatus()` 实现（如果你要把它整合到别处）。

你要哪个我就直接给你代码。
