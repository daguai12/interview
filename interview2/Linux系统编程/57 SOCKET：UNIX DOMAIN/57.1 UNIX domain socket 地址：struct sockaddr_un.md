### **57.1 UNIX domain socket 地址：struct sockaddr\_un**

在 UNIX domain 中，socket 地址以文件系统**路径名**来表示。其 domain 特定的 socket 地址结构 `sockaddr_un` 定义如下：

```c
#include <sys/un.h>

struct sockaddr_un {
    sa_family_t sun_family;               /* AF_UNIX */
    char        sun_path[108];            /* pathname */
};
```

  * **`sun_family`**: 必须设置为 `AF_UNIX`。
  * **`sun_path`**: 用于标识 socket 的文件系统路径名。

> **可移植性注意**: `sun_path` 字段的大小在不同的 UNIX 实现中是不同的（例如 108, 104, 92 字节）。为避免缓冲区溢出，可移植的应用程序在向这个字段写入数据时应使用 `snprintf()` 或 `strncpy()`。

-----

#### **绑定 Socket**

为将一个 UNIX domain socket 绑定到一个地址上，需要初始化一个 `sockaddr_un` 结构，然后将其指针传递给 `bind()`。

**程序清单 57-1：绑定一个 UNIX domain socket**

```c
#include <sys/socket.h>
#include <sys/un.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define SV_SOCK_PATH "/tmp/us_xfr"

int main() {
    int sockfd;
    struct sockaddr_un addr;

    // 创建 socket
    sockfd = socket(AF_UNIX, SOCK_STREAM, 0);
    if (sockfd == -1) {
        perror("socket");
        exit(EXIT_FAILURE);
    }
    
    // 确保 addr 结构中所有字段都为 0
    memset(&addr, 0, sizeof(struct sockaddr_un));
    
    // 设置地址族和路径名
    addr.sun_family = AF_UNIX;
    strncpy(addr.sun_path, SV_SOCK_PATH, sizeof(addr.sun_path) - 1);

    // 绑定 socket 到地址
    if (bind(sockfd, (struct sockaddr *) &addr, sizeof(struct sockaddr_un)) == -1) {
        perror("bind");
        exit(EXIT_FAILURE);
    }

    // ... 后续的 listen() 和 accept() 调用 ...

    exit(EXIT_SUCCESS);
}
```

-----

#### **文件系统中的表现**

当 `bind()` 一个 UNIX domain socket 时，它会在文件系统中创建一个特殊的文件条目。

  * **文件类型**: 这个文件会被标记为一个 socket。`stat()` 调用会返回 `S_IFSOCK` 文件类型。
  * **`ls` 命令显示**:
      * `ls -l` 会在权限位的第一列显示类型 `s`。
      * `ls -F` 会在 socket 路径名后面附加上一个等号 (`=`)。

<!-- end list -->

```bash
$ ls -l /tmp/us_xfr
srwxr-xr-x 1 user group 0 Sep 17 10:30 /tmp/us_xfr
```

  * **I/O 操作**: 尽管 UNIX domain socket 在文件系统中有一个路径名，但在这些 socket 上发生的 I/O **无须**对底层磁盘设备进行操作，通信完全在内核中进行。

-----

#### **绑定规则与注意事项**

  * **地址已存在**: 无法将一个 socket 绑定到一个**已存在**的路径名上（`bind()` 会失败并返回 `EADDRINUSE` 错误）。在重新启动服务器前，通常需要先 `unlink()` 旧的 socket 文件。
  * **路径名类型**: 通常会将 socket 绑定到一个**绝对路径名**上，以确保其位置固定。
  * **唯一性**: 一个 socket 只能绑定到一个路径名，一个路径名也只能被一个 socket 绑定。
  * **`open()`**: **无法**使用 `open()` 系统调用来打开一个 socket 文件。
  * **删除**: 当不再需要一个 socket 时，应该使用 `unlink()`（或 `remove()`）来删除其路径名条目。

> **安全警告**:
> 在诸如 `/tmp` 此类的公共可写目录中创建 socket 文件可能会导致安全问题（例如，容易受到拒绝服务攻击）。现实世界中的应用程序应该将 UNIX domain socket `bind()` 到一个采取了恰当安全保护措施的目录中的绝对路径名上。