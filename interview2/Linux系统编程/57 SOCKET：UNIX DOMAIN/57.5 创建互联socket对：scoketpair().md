### **57.5 创建互联 socket 对：socketpair()**

有时候，让单个进程创建一对**预先连接好**的 socket 是非常有用的。虽然可以通过多个 `socket()`、`bind()`、`listen()`、`accept()`、`connect()` 调用来手动完成，但 `socketpair()` 系统调用为这个操作提供了一个快捷方式。

```c
#include <sys/socket.h>

int socketpair(int domain, int type, int protocol, int sockfd[2]);
```

  * **`domain`**: **必须**被指定为 `AF_UNIX`。
  * **`type`**: 可以被指定为 `SOCK_STREAM` 或 `SOCK_DGRAM`。
  * **`protocol`**: 必须为 0。
  * **`sockfd[2]`**: 这是一个**结果参数**。它是一个包含两个元素的整型数组，函数成功时，会返回两个相互连接的 socket 的文件描述符。

#### **流 Socket 对**

当 `type` 被指定为 `SOCK_STREAM` 时，`socketpair()` 的效果相当于创建了一个**双向管道 (bidirectional pipe)**，也被称为**流管道 (stream pipe)**。

  * 每个 socket 都可以用来读取和写入。
  * 这种方式通常被用在 `fork()` 之后，为父子进程之间创建一个私有的、双向的 IPC 通道。

#### **优点**

使用 `socketpair()` 创建的一对 socket **不会**被绑定到文件系统中的任何地址上，它们是**匿名的**。这样就能够避免一些安全问题，因为这对 socket 对系统上的其他无关进程是不可见的。

-----

#### **Linux 特有标志 (自内核 2.6.27 起)**

Linux 允许在 `type` 参数中通过“或”运算加入以下两个非标准标记：

  * **`SOCK_CLOEXEC`**: 在创建 socket 的同时，原子地为两个新文件描述符启用 **close-on-exec** 标志 (`FD_CLOEXEC`)。
  * **`SOCK_NONBLOCK`**: 在创建 socket 的同时，原子地为两个底层文件描述设置 **`O_NONBLOCK`** 标记，使得后续的 I/O 操作都变成非阻塞的。

这两个标志可以避免在多线程程序中因 `socketpair()` 和 `fcntl()` 之间的竞态条件而产生的问题。

-----

#### **程序示例**

下面的程序演示了 `socketpair()` 的典型用法：创建一个 socket 对，然后 `fork()` 一个子进程，父子进程通过这个 socket 对进行双向通信。

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/socket.h>
#include <sys/wait.h>

#define BUF_SIZE 100

int main() {
    int sv[2]; // sv[0] is for parent, sv[1] is for child
    char buf[BUF_SIZE];

    // 创建一个已连接的 UNIX domain 流 socket 对
    if (socketpair(AF_UNIX, SOCK_STREAM, 0, sv) == -1) {
        perror("socketpair");
        exit(EXIT_FAILURE);
    }
    
    switch (fork()) {
        case -1:
            perror("fork");
            exit(EXIT_FAILURE);
        
        case 0: // 子进程
            close(sv[0]); // 关闭父进程端
            
            // 从父进程读取数据
            if (read(sv[1], buf, BUF_SIZE) == -1) perror("read child");
            printf("Child received: %s\n", buf);

            // 向父进程发送响应
            if (write(sv[1], "Hello from child", 17) == -1) perror("write child");

            close(sv[1]);
            _exit(EXIT_SUCCESS);

        default: // 父进程
            close(sv[1]); // 关闭子进程端
            
            // 向子进程发送数据
            if (write(sv[0], "Hello from parent", 18) == -1) perror("write parent");

            // 从子进程读取响应
            if (read(sv[0], buf, BUF_SIZE) == -1) perror("read parent");
            printf("Parent received: %s\n", buf);
            
            wait(NULL); // 等待子进程结束
            close(sv[0]);
            exit(EXIT_SUCCESS);
    }
}
```

##### **编译和运行**

```bash
$ gcc socket_pair_demo.c -o socket_pair_demo
$ ./socket_pair_demo
Child received: Hello from parent
Parent received: Hello from child
```