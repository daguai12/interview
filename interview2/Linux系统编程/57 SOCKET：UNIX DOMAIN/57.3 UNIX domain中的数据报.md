### **57.3 UNIX domain 中的数据报 socket**

在 56.6 节中曾指出，数据报 socket 的通信是**不可靠的**。这个论断适用于通过网络传输的数据报（如 UDP）。但对于 **UNIX domain socket** 来说，情况有所不同：

  * **可靠性**: 由于数据报的传输完全在内核中发生，因此 UNIX domain 中的数据报 socket 是**可靠的**。所有消息都会按序被递送，并且也不会发生重复的状况。

  * **数据报大小**: SUSv3 并没有规定 UNIX domain socket 传输的数据报的最大大小。在 Linux 上可以发送相当大的数据报，但其他一些 UNIX 实现采用的限制值可能更小。可移植的应用程序应该为此设定一个较低的上限值。

-----

#### **示例程序**

本节给出了一个简单的使用 UNIX domain 数据报 socket 的客户端/服务器应用程序。服务器接收客户端发来的小写字符串，将其转换为大写，然后返回给客户端。

##### **头文件**

程序清单 57-5 是服务器和客户端都需要包含的头文件。

**程序清单 57-5：`ud_ucase.h`**

```c
#include <sys/un.h>
#include <sys/socket.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <ctype.h>

#define SV_SOCK_PATH "/tmp/ud_ucase"    // 服务器的众所周知地址
#define BUF_SIZE 10                    // 客户端接收响应的缓冲区大小
```

##### **服务器程序**

程序清单 57-6 是服务器的代码。它在一个无限循环中接收数据报，将其转换为大写，然后使用 `recvfrom()` 获取的客户端地址将响应发送回去。

**程序清单 57-6：一个简单的 UNIX domain 数据报服务器 (`ud_ucase_sv.c`)**

```c
#include "ud_ucase.h"

int main(int argc, char *argv[]) {
    struct sockaddr_un svaddr, claddr;
    int sfd;
    ssize_t numBytes;
    socklen_t len;
    char buf[BUF_SIZE];

    sfd = socket(AF_UNIX, SOCK_DGRAM, 0);
    if (sfd == -1) {
        perror("socket");
        exit(EXIT_FAILURE);
    }

    // 删除任何已存在的同名 socket 文件
    if (remove(SV_SOCK_PATH) == -1 && errno != ENOENT) {
        perror("remove");
        exit(EXIT_FAILURE);
    }
    
    // 绑定到众所周知地址
    memset(&svaddr, 0, sizeof(struct sockaddr_un));
    svaddr.sun_family = AF_UNIX;
    strncpy(svaddr.sun_path, SV_SOCK_PATH, sizeof(svaddr.sun_path) - 1);

    if (bind(sfd, (struct sockaddr *) &svaddr, sizeof(struct sockaddr_un)) == -1) {
        perror("bind");
        exit(EXIT_FAILURE);
    }
    
    // 循环接收和处理数据报
    for (;;) {
        len = sizeof(struct sockaddr_un);
        numBytes = recvfrom(sfd, buf, BUF_SIZE, 0, (struct sockaddr *) &claddr, &len);
        if (numBytes == -1) {
            perror("recvfrom");
            exit(EXIT_FAILURE);
        }

        printf("Server received %ld bytes from %s\n", (long) numBytes, claddr.sun_path);

        // 转换为大写
        for (int j = 0; j < numBytes; j++) {
            buf[j] = toupper((unsigned char) buf[j]);
        }

        // 将转换后的数据报发回给客户端
        if (sendto(sfd, buf, numBytes, 0, (struct sockaddr *) &claddr, len) != numBytes) {
            fprintf(stderr, "sendto failed\n");
            exit(EXIT_FAILURE);
        }
    }
}
```

##### **客户端程序**

程序清单 57-7 是客户端的代码。客户端必须创建自己的 socket 并将其 `bind()` 到一个唯一的地址，这样服务器才知道该将响应发送到哪里。

**程序清单 57-7：一个简单的 UNIX domain 数据报客户端 (`ud_ucase_cl.c`)**

```c
#include "ud_ucase.h"

int main(int argc, char *argv[]) {
    struct sockaddr_un svaddr, claddr;
    int sfd;
    ssize_t numBytes;
    char resp[BUF_SIZE];

    if (argc < 2 || strcmp(argv[1], "--help") == 0) {
        fprintf(stderr, "Usage: %s msg...\n", argv[0]);
        exit(EXIT_FAILURE);
    }
    
    // 创建客户端 socket
    sfd = socket(AF_UNIX, SOCK_DGRAM, 0);
    if (sfd == -1) {
        perror("socket");
        exit(EXIT_FAILURE);
    }

    // 为客户端 socket 构建一个唯一的地址并绑定
    memset(&claddr, 0, sizeof(struct sockaddr_un));
    claddr.sun_family = AF_UNIX;
    snprintf(claddr.sun_path, sizeof(claddr.sun_path), "/tmp/ud_ucase_cl.%ld", (long) getpid());

    if (remove(claddr.sun_path) == -1 && errno != ENOENT) perror("remove");
    if (bind(sfd, (struct sockaddr *) &claddr, sizeof(struct sockaddr_un)) == -1) {
        perror("bind client");
        exit(EXIT_FAILURE);
    }
    
    // 构建服务器地址
    memset(&svaddr, 0, sizeof(struct sockaddr_un));
    svaddr.sun_family = AF_UNIX;
    strncpy(svaddr.sun_path, SV_SOCK_PATH, sizeof(svaddr.sun_path) - 1);
    
    // 循环发送命令行参数作为消息
    for (int j = 1; j < argc; j++) {
        // 发送消息给服务器
        if (sendto(sfd, argv[j], strlen(argv[j]), 0, (struct sockaddr *) &svaddr, sizeof(struct sockaddr_un)) != strlen(argv[j])) {
            fprintf(stderr, "sendto failed\n");
            exit(EXIT_FAILURE);
        }
        
        // 接收服务器的响应
        numBytes = recvfrom(sfd, resp, BUF_SIZE, 0, NULL, NULL);
        if (numBytes == -1) {
            perror("recvfrom");
            exit(EXIT_FAILURE);
        }
        
        printf("Response %d: %.*s\n", j, (int) numBytes, resp);
    }

    // 删除客户端 socket 文件
    remove(claddr.sun_path);
    exit(EXIT_SUCCESS);
}
```

-----

#### **运行演示**

1.  **编译程序**:

    ```bash
    $ gcc ud_ucase_sv.c -o ud_ucase_sv
    $ gcc ud_ucase_cl.c -o ud_ucase_cl
    ```

2.  **在一个终端中启动服务器 (后台运行)**:

    ```bash
    $ ./ud_ucase_sv &
    [1] 12348
    ```

3.  **在另一个终端中运行客户端**:

    ```bash
    # 第一次运行，发送短消息
    $ ./ud_ucase_cl "hello" "world"
    Response 1: HELLO
    Response 2: WORLD

    # 第二次运行，发送一个长消息，触发截断
    $ ./ud_ucase_cl "Hello World!"
    Response 1: HELLO WORL
    ```

4.  **查看服务器端的输出**:

    ```bash
    $ fg
    ./ud_ucase_sv
    Server received 5 bytes from /tmp/ud_ucase_cl.12350
    Server received 5 bytes from /tmp/ud_ucase_cl.12350
    Server received 10 bytes from /tmp/ud_ucase_cl.12352
    ^C
    ```

**解读**:

  * 客户端第二次运行时发送了 12 字节的 "Hello World\!"，但它的接收缓冲区 `BUF_SIZE` 只有 10 字节。
  * 服务器端收到了 10 字节（因为它的 `recvfrom` 也使用了 `BUF_SIZE` 为 10），并打印了 `Server received 10 bytes`。
  * 客户端最终也只收到了 10 字节的响应 `HELLO WORL`。
  * 这个过程清晰地演示了当接收缓冲区小于数据报大小时发生的**静默截断**。