### **57.2 UNIX domain 中的流 socket**

本节将讲解一个使用了 UNIX domain 中的流 socket 的简单客户端-服务器应用程序。

  * **客户端**: 连接到服务器，并将其标准输入中的数据传输给服务器。
  * **服务器**: 接受客户端连接，并将从连接上接收到的数据传输到其标准输出。这是一个简单的**迭代式服务器**，即一次只处理一个客户端。

#### **头文件**

程序清单 57-2 是服务器和客户端都需要包含的头文件。

**程序清单 57-2：`us_xfr.h`**

```c
#include <sys/un.h>
#include <sys/socket.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>

#define SV_SOCK_PATH "/tmp/us_xfr" // 服务器的众所周知地址
#define BUF_SIZE 100
```

-----

#### **服务器程序**

程序清单 57-3 是服务器的代码。

**服务器执行的任务**:

1.  创建一个 UNIX domain 流 socket。
2.  **删除**任何已存在的同名 socket 文件，以便 `bind()` 成功。
3.  构建地址结构，调用 `bind()` 绑定到众所周知地址，然后调用 `listen()` 开始监听。
4.  进入一个无限循环，在循环中：
      * 调用 `accept()` 等待并接受客户端连接。
      * 从新连接的 socket 中循环读取所有数据，并写入到服务器的标准输出。
      * 关闭与该客户端的连接。

**程序清单 57-3：一个简单的 UNIX domain 流 socket 服务器 (`us_xfr_sv.c`)**

```c
#include "us_xfr.h"

int main(int argc, char *argv[]) {
    struct sockaddr_un addr;
    int sfd, cfd; // sfd: listening socket, cfd: connected socket
    ssize_t numRead;
    char buf[BUF_SIZE];

    // 1. 创建 socket
    sfd = socket(AF_UNIX, SOCK_STREAM, 0);
    if (sfd == -1) {
        perror("socket");
        exit(EXIT_FAILURE);
    }

    // 2. 删除任何已存在的同名 socket 文件
    if (remove(SV_SOCK_PATH) == -1 && errno != ENOENT) {
        fprintf(stderr, "remove-%s", SV_SOCK_PATH);
        perror("");
        exit(EXIT_FAILURE);
    }

    // 3. 构建地址并绑定
    memset(&addr, 0, sizeof(struct sockaddr_un));
    addr.sun_family = AF_UNIX;
    strncpy(addr.sun_path, SV_SOCK_PATH, sizeof(addr.sun_path) - 1);

    if (bind(sfd, (struct sockaddr *) &addr, sizeof(struct sockaddr_un)) == -1) {
        perror("bind");
        exit(EXIT_FAILURE);
    }

    // 4. 将 socket 标记为监听 socket
    if (listen(sfd, 5) == -1) {
        perror("listen");
        exit(EXIT_FAILURE);
    }

    // 5. 循环接受和处理连接
    for (;;) {
        printf("Waiting for a connection...\n");
        cfd = accept(sfd, NULL, NULL);
        if (cfd == -1) {
            perror("accept");
            exit(EXIT_FAILURE);
        }
        printf("Accepted connection.\n");

        // 从客户端读取数据并写入标准输出
        while ((numRead = read(cfd, buf, BUF_SIZE)) > 0) {
            if (write(STDOUT_FILENO, buf, numRead) != numRead) {
                fprintf(stderr, "partial/failed write\n");
                exit(EXIT_FAILURE);
            }
        }

        if (numRead == -1) {
            perror("read");
            exit(EXIT_FAILURE);
        }

        if (close(cfd) == -1) {
            perror("close");
        }
    }
}
```

-----

#### **客户端程序**

程序清单 57-4 是客户端的代码。

**客户端执行的任务**:

1.  创建一个 UNIX domain 流 socket。
2.  构建服务器的地址结构。
3.  调用 `connect()` 连接到服务器。
4.  进入一个循环，从其标准输入读取数据，并写入到 socket 连接中，直到标准输入遇到文件结尾 (EOF)。

**程序清单 57-4：一个简单的 UNIX domain 流 socket 客户端 (`us_xfr_cl.c`)**

```c
#include "us_xfr.h"

int main(int argc, char *argv[]) {
    struct sockaddr_un addr;
    int sfd;
    ssize_t numRead;
    char buf[BUF_SIZE];

    // 1. 创建 socket
    sfd = socket(AF_UNIX, SOCK_STREAM, 0);
    if (sfd == -1) {
        perror("socket");
        exit(EXIT_FAILURE);
    }

    // 2. 构建服务器地址
    memset(&addr, 0, sizeof(struct sockaddr_un));
    addr.sun_family = AF_UNIX;
    strncpy(addr.sun_path, SV_SOCK_PATH, sizeof(addr.sun_path) - 1);

    // 3. 连接到服务器
    if (connect(sfd, (struct sockaddr *) &addr, sizeof(struct sockaddr_un)) == -1) {
        perror("connect");
        exit(EXIT_FAILURE);
    }

    // 4. 从标准输入读取数据并发送到服务器
    while ((numRead = read(STDIN_FILENO, buf, BUF_SIZE)) > 0) {
        if (write(sfd, buf, numRead) != numRead) {
            fprintf(stderr, "partial/failed write\n");
            exit(EXIT_FAILURE);
        }
    }

    if (numRead == -1) {
        perror("read");
        exit(EXIT_FAILURE);
    }

    exit(EXIT_SUCCESS); // 关闭 socket 并退出
}
```

-----

#### **运行演示**

1.  **编译程序**:

    ```bash
    $ gcc us_xfr_sv.c -o us_xfr_sv
    $ gcc us_xfr_cl.c -o us_xfr_cl
    ```

2.  **在一个终端中，在后台运行服务器，并将输出重定向到文件**:

    ```bash
    $ ./us_xfr_sv > server.log &
    [1] 12347
    ```

    服务器会打印 "Waiting for a connection..." 并阻塞在 `accept()`。

3.  **在另一个终端中，创建测试文件并运行客户端**:

    ```bash
    $ echo "Hello from the client!" > testfile
    $ ./us_xfr_cl < testfile
    ```

    客户端会读取 `testfile` 的内容，通过 socket 发送给服务器，然后退出。

4.  **终止服务器并检查结果**:

    ```bash
    # 将后台的服务器进程调到前台
    $ fg
    ./us_xfr_sv > server.log

    # 按下 Ctrl-C 终止服务器
    ^C

    # 比较服务器的日志和客户端的输入文件
    $ diff -s testfile server.log
    Files testfile and server.log are identical
    ```

    `diff` 命令没有报告差异，表示服务器成功接收并输出了客户端发送的所有数据。

> **关于 `remove(SV_SOCK_PATH)`**:
> 在服务器终止之后，socket 路径名会继续存在于文件系统中。这就是为什么服务器在调用 `bind()` 之前，必须先使用 `remove()` 来删除可能存在的旧 socket 文件的原因。如果没有这样做，当服务器重启时，`bind()` 调用会因为地址已存在而失败。