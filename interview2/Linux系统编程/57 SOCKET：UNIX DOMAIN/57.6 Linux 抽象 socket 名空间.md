### **57.6 Linux 抽象 socket 名空间**

所谓的**抽象 socket 命名空间 (abstract socket namespace)** 是 Linux 特有的一项特性，它允许将一个 UNIX domain socket 绑定到一个名字上，但**不会在文件系统中创建该名字**对应的文件。

#### **优点**

这种做法具备几点优势：

1.  **无文件系统冲突**: 无需担心 socket 的名字与文件系统中的既有名字产生冲突。
2.  **自动清理**: 当所有引用该 socket 的文件描述符都被关闭之后，这个抽象名会被**自动删除**，没有必要在使用完 socket 之后手动 `unlink()` socket 路径名。
3.  **无需文件系统路径**: 无需为 socket 在文件系统中创建一个真实路径。这对于 `chroot` 环境以及在不具备文件系统写权限的场景下非常有用。

#### **如何创建抽象绑定**

要创建一个抽象绑定，关键在于初始化 `sockaddr_un` 结构的方式：

  * **必须**将 `sun_path` 字段的**第一个字节**指定为**空字节 (`\0`)**。
  * `sun_path` 字段中，跟在这个初始空字节**之后**的字节序列，构成了 socket 的抽象名字。
  * 在解释这个名字时，内核会用到全部的字节，而不是将其看成是一个以空字符结尾的 C 语言字符串。

-----

#### **程序示例**

程序清单 57-8 演示了如何创建一个抽象 socket 绑定。

**程序清单 57-8：创建一个抽象 socket 绑定**

```c
#include <sys/un.h>
#include <sys/socket.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(int argc, char *argv[]) {
    int sockfd;
    struct sockaddr_un addr;
    const char *abstract_name = "my_abstract_socket";

    sockfd = socket(AF_UNIX, SOCK_STREAM, 0);
    if (sockfd == -1) {
        perror("socket");
        exit(EXIT_FAILURE);
    }
    
    // 清空地址结构体
    memset(&addr, 0, sizeof(struct sockaddr_un));
    addr.sun_family = AF_UNIX;

    // --- 创建抽象 socket 地址 ---
    // 1. 将第一个字节设为 null byte ('\0')
    addr.sun_path[0] = '\0';
    
    // 2. 将抽象名称复制到后面的字节中
    strncpy(&addr.sun_path[1], abstract_name, sizeof(addr.sun_path) - 2);

    // 计算包含初始 null byte 和抽象名称的实际长度
    socklen_t addr_len = sizeof(addr.sun_family) + 1 + strlen(abstract_name);

    // 绑定到抽象地址
    if (bind(sockfd, (struct sockaddr *) &addr, addr_len) == -1) {
        perror("bind");
        exit(EXIT_FAILURE);
    }
    
    printf("Successfully bound to abstract socket name: %s\n", abstract_name);
    
    // ... 后续的 listen() 和 accept() 等操作 ...
    
    exit(EXIT_SUCCESS);
}
```

-----

#### **一个不寻常的陷阱**

使用初始空字节来区分抽象 socket 名和传统的 socket 名，可能会导致一个不寻常的、不易察觉的 bug。

假设一个程序无意中尝试将 socket 绑定到一个**长度为零的字符串**上：

```c
strncpy(addr.sun_path, "", sizeof(addr.sun_path) - 1);
```

  * **在其他 UNIX 实现中**: 这种 `bind()` 调用通常会失败。
  * **在 Linux 上**: 由于 `sun_path` 的第一个字节被设置为了 `\0`，内核会认为这是一个**抽象 socket 绑定**请求，其抽象名称的长度为零。这很可能不是程序员期望的行为，而是一个 bug。