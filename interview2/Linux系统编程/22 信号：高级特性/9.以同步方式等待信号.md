### `sigwaitinfo()` 与 `sigtimedwait()`：同步等待信号的简化方案  
`sigwaitinfo()` 和 `sigtimedwait()` 是用于**同步接收信号**的系统调用，它们无需编写信号处理器，直接在调用处阻塞等待信号，避免了异步信号处理的复杂性。以下是详细解析：


### 一、`sigwaitinfo()`：同步等待信号并获取详细信息  
`sigwaitinfo()` 的核心功能是**挂起进程，等待指定信号集中的信号到达**，并在信号到达后返回信号编号及详细信息（如发送方 PID、伴随数据等）。它适用于不需要异步处理信号的场景，简化了信号接收逻辑。  


#### 1. 函数原型与基本功能  
```c
#include <signal.h>
int sigwaitinfo(const sigset_t *set, siginfo_t *info);
```  
- **参数**：  
  - `set`：指向需要等待的信号集（仅关注该集合中的信号）。  
  - `info`：非空时，指向填充了信号详细信息的 `siginfo_t` 结构体（包含发送方 PID、信号来源、实时信号伴随数据等）。  
- **返回值**：  
  - 成功：返回收到的信号编号（从 `set` 中）。  
  - 失败：返回 `-1` 并设置 `errno`（如信号集无效时 `EINVAL`）。  


#### 2. 关键特性  
- **同步等待**：调用后立即阻塞进程，直至 `set` 中的信号到达（或已有未决信号），无需信号处理器。  
- **移除未决信号**：若调用时 `set` 中已有未决信号（因之前被阻塞），`sigwaitinfo()` 会立即返回该信号，并将其从进程的未决信号队列中移除。  
- **信号排队规则**：  
  - 标准信号：不支持排队，若同一标准信号多次未决，仅返回一次。  
  - 实时信号：支持排队，按发送顺序和编号优先级（低编号优先）返回。  
- **必须阻塞目标信号**：  
  SUSv3 规定，若 `set` 中的信号未被阻塞，`sigwaitinfo()` 行为未定义。因此，需先通过 `sigprocmask()` 阻塞 `set` 中的信号，确保信号由 `sigwaitinfo()` 处理，而非按默认处置（如终止进程）。  


#### 3. 使用流程（结合程序清单 22-6 示例）  
典型用法为：“阻塞目标信号→调用 `sigwaitinfo()` 等待→处理信号→循环”：  
```c
#include <signal.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int main(int argc, char *argv[]) {
    sigset_t waitSet;
    siginfo_t info;
    int sig, delay = 10;

    // 1. 解析命令行参数：延迟时间（给发送信号留时间）
    if (argc > 1) delay = atoi(argv[1]);

    // 2. 初始化信号集：关注 SIGINT、SIGTERM、SIGUSR1 等
    sigemptyset(&waitSet);
    sigaddset(&waitSet, SIGINT);
    sigaddset(&waitSet, SIGTERM);
    sigaddset(&waitSet, SIGUSR1);
    sigaddset(&waitSet, SIGRTMIN);  // 实时信号

    // 3. 阻塞目标信号集，确保信号由 sigwaitinfo() 处理
    if (sigprocmask(SIG_BLOCK, &waitSet, NULL) == -1) {
        perror("sigprocmask 失败");
        exit(EXIT_FAILURE);
    }

    // 4. 延迟等待，允许外部发送信号
    printf("延迟 %d 秒，可向 PID %d 发送信号...\n", delay, getpid());
    sleep(delay);

    // 5. 循环调用 sigwaitinfo() 接收信号，直至收到 SIGINT 或 SIGTERM
    printf("开始等待信号...\n");
    while (1) {
        sig = sigwaitinfo(&waitSet, &info);
        if (sig == -1) {
            perror("sigwaitinfo 失败");
            exit(EXIT_FAILURE);
        }

        // 处理信号：打印详细信息
        printf("收到信号 %d：", sig);
        if (sig == SIGINT || sig == SIGTERM) {
            printf("终止信号，退出\n");
            exit(EXIT_SUCCESS);
        } else if (sig == SIGUSR1) {
            printf("发送方 PID: %d, UID: %d\n", info.si_pid, info.si_uid);
        } else if (sig >= SIGRTMIN) {
            printf("实时信号，编号 %d，伴随数据: %d\n", 
                   sig - SIGRTMIN, info.si_value.sival_int);
        }
    }
}
```  


#### 4. 优势：简化信号处理  
相比“信号处理器 + `sigsuspend()`”的组合，`sigwaitinfo()` 的优势在于：  
- 无需编写信号处理器，避免了异步处理的复杂性（如信号安全函数限制、全局变量同步等）。  
- 直接在调用处获取信号详细信息，逻辑更线性、易调试。  
- 效率稍高（减少了信号处理器的上下文切换开销）。  


### 二、`sigtimedwait()`：带超时的同步等待  
`sigtimedwait()` 是 `sigwaitinfo()` 的变体，新增了**超时控制**，允许指定等待信号的最大时长，避免永久阻塞。  


#### 1. 函数原型与超时设置  
```c
#include <signal.h>
int sigtimedwait(const sigset_t *set, siginfo_t *info, const struct timespec *timeout);
```  
- **参数**：  
  - `timeout`：指向 `timespec` 结构体，指定最大等待时长（秒 `tv_sec` + 纳秒 `tv_nsec`）。  
    - 若 `timeout` 为 `NULL`，等价于 `sigwaitinfo()`。  
    - 若 `tv_sec` 和 `tv_nsec` 均为 0，立即返回（轮询未决信号）。  
- **返回值**：  
  - 成功：返回信号编号（同 `sigwaitinfo()`）。  
  - 超时：返回 `-1` 并设置 `errno=EAGAIN`。  
  - 失败：返回 `-1` 并设置其他 `errno`（如 `EINVAL`）。  


#### 2. 使用场景  
适用于需要限制等待时间的场景，例如：  
- 定期检查信号，同时执行其他任务（避免无限阻塞）。  
- 实现“重试机制”，若超时未收到信号则执行备选逻辑。  


#### 3. 示例：超时等待信号  
```c
struct timespec timeout = {.tv_sec = 5, .tv_nsec = 0};  // 最多等待 5 秒
int sig = sigtimedwait(&waitSet, &info, &timeout);
if (sig == -1) {
    if (errno == EAGAIN) {
        printf("超时未收到信号\n");
    } else {
        perror("sigtimedwait 失败");
    }
} else {
    printf("收到信号 %d\n", sig);
}
```  


### 三、使用注意事项  
1. **必须阻塞目标信号**：无论 `sigwaitinfo()` 还是 `sigtimedwait()`，都需先通过 `sigprocmask()` 阻塞 `set` 中的信号，否则行为未定义（可能按默认处置处理信号）。  
2. **实时信号伴随数据**：仅当信号通过 `sigqueue()` 发送时，`siginfo_t` 的 `si_value` 字段才有效；通过 `kill()` 发送的信号，`si_value` 可能未初始化。  
3. **超时精度**：`timespec` 的纳秒级精度受系统时钟限制，实际超时可能略长于指定值。  


### 总结  
`sigwaitinfo()` 和 `sigtimedwait()` 提供了**同步、简化的信号接收方案**，无需编写信号处理器，适用于对信号处理逻辑有线性化需求的场景。其中：  
- `sigwaitinfo()` 用于无超时的同步等待，简化信号接收。  
- `sigtimedwait()` 增加超时控制，避免永久阻塞。  

二者的核心是通过“阻塞信号 + 同步等待”机制，替代异步信号处理器，降低信号处理的复杂度。