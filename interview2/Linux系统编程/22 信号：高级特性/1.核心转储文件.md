这段内容详细讲解了**核心转储文件（core dump）的生成机制、限制条件以及命名控制**，是调试程序崩溃的重要知识。以下是分点解读：


### 一、核心转储文件的基本概念
核心转储文件是进程因特定信号（如 `SIGSEGV` 段错误、`SIGQUIT` 等）终止时，操作系统生成的**内存快照文件**，包含进程终止时的内存数据、寄存器状态、调用栈等信息，用于事后调试（通过 `gdb` 等工具分析）。

- **默认特性**：  
  - 默认文件名：`core`  
  - 默认位置：进程的工作目录  
  - 触发方式：如按下 `Ctrl+\` 发送 `SIGQUIT` 信号，或程序发生段错误（`SIGSEGV`）。  


### 二、不生成核心转储文件的常见情况
即使进程收到了会触发核心转储的信号，以下情况也可能导致文件无法生成：

#### 1. 权限或文件系统限制
- **无写入权限**：进程对工作目录无写权限，或同名文件不可写（如为目录、符号链接）。  
- **链接数限制**：同名文件的硬链接数超过1个。  
- **目录不存在**：工作目录已被删除。  
- **文件系统问题**：目录所在文件系统只读、空间已满、inode耗尽，或用户达到配额限制。  


#### 2. 资源限制
- **核心文件大小限制**：通过 `ulimit -c` 查看，若设置为0（`RLIMIT_CORE` 限制），则禁止生成核心文件。需执行 `ulimit -c unlimited` 临时取消限制。  
- **文件大小限制**：`RLIMIT_FSIZE` 限制设为0时，禁止创建任何文件（包括核心文件）。  


#### 3. 程序安全限制
- **无读权限**：进程对自身可执行文件无读权限（防止通过核心文件窃取代码）。  
- **Set-user-ID（SUID）/Set-group-ID（SGID）程序**：  
  非文件属主/属组执行时，默认不生成核心文件（防止敏感信息泄露，如密码）。  
  - 可通过 Linux 特有的 `prctl(PR_SET_DUMPABLE)` 或 `/proc/sys/fs/suid_dumpable` 配置例外。  


#### 4. 其他控制
- **`coredump_filter`**：Linux 2.6.23+ 中，`/proc/PID/coredump_filter` 控制哪些内存映射类型（如私有匿名映射、共享文件映射）写入核心文件，默认仅包含私有和共享匿名映射。  


### 三、核心转储文件的命名控制：`core_pattern`
Linux 2.6+ 允许通过 `/proc/sys/kernel/core_pattern` 自定义核心文件的名称和路径，特权用户可修改该文件内容（格式化字符串），支持以下占位符（表22-1）：

| 占位符 | 替换内容 |
|--------|----------|
| `%c`   | 核心文件大小的软限制（字节，2.6.24+） |
| `%e`   | 可执行文件名（不含路径） |
| `%g`   | 进程实际组ID（GID） |
| `%h`   | 主机名 |
| `%p`   | 进程ID（PID） |
| `%s`   | 触发终止的信号编号 |
| `%t`   | 转储时间（Epoch秒数） |
| `%u`   | 进程实际用户ID（UID） |
| `%%`   | 单个 `%` 字符 |


#### 示例用法
- 设置格式为 `core.%e.%p`，则生成的核心文件名为 `core.myprogram.12345`（包含程序名和PID）。  
- 包含路径如 `./cores/core.%p`，则文件会生成在 `./cores/` 目录下（需确保目录存在）。  


#### 高级用法：管道处理
若 `core_pattern` 以 `|` 开头（如 `|/usr/local/bin/core_handler %p`），则核心数据会通过管道发送给指定程序（如 `core_handler`）处理，而非写入文件。这常用于集中收集核心文件或自动分析。  


### 总结
核心转储文件是调试程序崩溃的关键工具，但其生成受权限、资源限制和安全策略影响。理解这些限制条件，并通过 `core_pattern` 自定义命名规则，能更高效地利用核心文件进行问题定位。实际调试中，需确保：  
1. 取消 `RLIMIT_CORE` 限制（`ulimit -c unlimited`）；  
2. 进程对工作目录有写权限；  
3. 必要时调整 `coredump_filter` 或 SUID 程序的转储配置。