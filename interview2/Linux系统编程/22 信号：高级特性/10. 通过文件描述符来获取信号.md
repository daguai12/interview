### `signalfd()`：通过文件描述符同步接收信号  
`signalfd()` 是 Linux 2.6.22 引入的非标准系统调用，它通过**创建特殊文件描述符**实现信号的同步接收，允许通过 `read()` 操作读取信号，且可与 I/O 多路复用机制（`select()`/`poll()`/`epoll`）结合使用，为信号处理提供了更灵活的选择。以下是详细解析：


### 一、`signalfd()` 的核心功能与设计目的  
`signalfd()` 的核心是将“信号接收”转化为“文件描述符读取”操作，使得信号可以像普通 I/O 事件一样被处理。其设计目的包括：  
- 提供同步接收信号的另一种方式，替代 `sigwaitinfo()`；  
- 支持将信号事件与其他 I/O 事件（如文件、网络套接字）通过同一机制（`epoll` 等）监控，简化事件驱动编程；  
- 避免编写信号处理器的复杂性，通过 `read()` 直接获取信号详情。  


### 二、函数原型与参数解析  
```c
#include <sys/signalfd.h>
int signalfd(int fd, const sigset_t *mask, int flags);
```  

#### 参数说明：  
1. **`fd`**：  
   - 若为 `-1`：创建新的 `signalfd` 文件描述符，关联 `mask` 中的信号集。  
   - 若为已存在的 `signalfd` 描述符：修改该描述符关联的信号集为 `mask`（动态更新监控的信号）。  

2. **`mask`**：  
   指向信号集，指定需要通过该文件描述符读取的信号（仅关注这些信号）。  

3. **`flags`**：  
   控制描述符行为的标志（Linux 2.6.27 后支持）：  
   - `SFD_CLOEXEC`：为新描述符设置 `FD_CLOEXEC` 标志，避免进程执行 `exec()` 时继承该描述符。  
   - `SFD_NONBLOCK`：为描述符设置非阻塞模式，`read()` 无信号时返回 `EAGAIN` 而非阻塞。  


#### 返回值：  
- 成功：返回新的或修改后的 `signalfd` 文件描述符（非负整数）。  
- 失败：返回 `-1` 并设置 `errno`（如 `EINVAL` 表示 `mask` 无效，`EBADF` 表示 `fd` 非法）。  


### 三、信号读取与 `signalfd_siginfo` 结构  
创建 `signalfd` 描述符后，通过 `read()` 从该描述符读取信号，每次读取返回一个或多个 `signalfd_siginfo` 结构（信号详情）。  


#### 1. `signalfd_siginfo` 结构定义  
```c
struct signalfd_siginfo {
    uint32_t ssi_signo;    // 信号编号（如 SIGINT、SIGRTMIN+1）
    int32_t  ssi_errno;    // 错误码（通常为 0）
    int32_t  ssi_code;     // 信号产生原因（如 SI_USER 表示用户发送）
    uint32_t ssi_pid;      // 发送信号的进程 PID
    uint32_t ssi_uid;      // 发送信号的进程 UID
    int32_t  ssi_fd;       // 与信号相关的文件描述符（如 SIGIO 信号）
    uint32_t ssi_tid;      // 线程 ID（多线程场景）
    uint32_t ssi_band;     // 与 I/O 相关的带宽信息
    uint32_t ssi_overrun;  // 实时信号溢出计数
    uint32_t ssi_trapno;   // 硬件陷阱编号（硬件信号）
    int64_t  ssi_addr;     // 引发信号的内存地址（如 SIGSEGV）
    uint16_t ssi_addr_lsb; // 地址的最低有效位
    uint8_t  ssi_pad[X];   // 填充字节，确保结构对齐
    union {
        uint32_t ssi_int;  // 实时信号的伴随整数
        uint64_t ssi_ptr;  // 实时信号的伴随指针
        uint64_t ssi_utime; // 子进程用户态时间（SIGCHLD）
        uint64_t ssi_stime; // 子进程内核态时间（SIGCHLD）
        uint64_t ssi_val;  // 通用值
    } ssi_value;           // 信号伴随数据
};
```  
该结构与 `siginfo_t` 类似，包含信号的详细元信息（发送方 PID、伴随数据等）。  


#### 2. 读取信号的流程  
- **缓冲区要求**：`read()` 的缓冲区必须足够大，至少能容纳一个 `signalfd_siginfo` 结构（通常为 128 字节）。  
- **读取行为**：  
  - 若有未决信号（`mask` 中的信号），`read()` 返回所有未决信号的 `signalfd_siginfo` 结构（按信号排队顺序）。  
  - 若无未决信号：  
    - 阻塞模式（默认）：`read()` 阻塞至信号到达。  
    - 非阻塞模式（`SFD_NONBLOCK`）：`read()` 返回 `-1` 并设置 `errno=EAGAIN`。  
- **信号处理**：读取后，信号从进程的未决队列中移除，不会再按默认处置处理（需提前阻塞信号）。  


### 四、使用流程（结合程序清单 22-7 示例）  
`signalfd()` 的典型使用步骤为：“阻塞目标信号→创建 `signalfd`→循环读取信号→处理信号”：  

```c
#include <sys/signalfd.h>
#include <signal.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>

int main(int argc, char *argv[]) {
    sigset_t mask;
    int sfd;
    struct signalfd_siginfo ssi;
    ssize_t s;

    // 1. 解析命令行参数，初始化信号集（关注用户指定的信号）
    if (argc < 2) {
        fprintf(stderr, "用法：%s <signal1> <signal2> ...\n", argv[0]);
        exit(EXIT_FAILURE);
    }
    sigemptyset(&mask);
    for (int i = 1; i < argc; i++) {
        int sig = atoi(argv[i]);
        sigaddset(&mask, sig);
        printf("监控信号：%d\n", sig);
    }

    // 2. 阻塞目标信号，确保信号由 signalfd 处理（而非默认处置）
    if (sigprocmask(SIG_BLOCK, &mask, NULL) == -1) {
        perror("sigprocmask 失败");
        exit(EXIT_FAILURE);
    }

    // 3. 创建 signalfd 描述符，关联信号集，设置非阻塞和 CLOEXEC 标志
    sfd = signalfd(-1, &mask, SFD_NONBLOCK | SFD_CLOEXEC);
    if (sfd == -1) {
        perror("signalfd 失败");
        exit(EXIT_FAILURE);
    }

    // 4. 循环从 signalfd 读取信号并处理
    printf("开始读取信号（PID：%d）...\n", getpid());
    while (1) {
        // 读取信号信息（缓冲区大小为 sizeof(ssi)）
        s = read(sfd, &ssi, sizeof(ssi));
        if (s == -1) {
            if (errno == EAGAIN) {
                // 非阻塞模式下无信号，短暂休眠后重试
                usleep(100000);
                continue;
            }
            perror("read 失败");
            exit(EXIT_FAILURE);
        }

        // 验证读取大小是否正确（必须是完整的 signalfd_siginfo 结构）
        if (s != sizeof(ssi)) {
            fprintf(stderr, "read 未返回完整结构\n");
            exit(EXIT_FAILURE);
        }

        // 5. 处理信号：打印信号详情
        printf("\n收到信号：%d\n", ssi.ssi_signo);
        printf("  发送方 PID：%u，UID：%u\n", ssi.ssi_pid, ssi.ssi_uid);
        if (ssi.ssi_signo >= SIGRTMIN) {
            printf("  伴随数据：%d\n", ssi.ssi_value.ssi_int);
        }
    }

    // 6. 不再需要时关闭描述符（实际中需在退出前执行）
    close(sfd);
    return 0;
}
```  


### 五、关键特性与优势  
1. **与 I/O 多路复用兼容**：  
   `signalfd` 描述符可与 `select()`、`poll()`、`epoll` 结合，将信号事件与其他 I/O 事件（如套接字可读）统一监控，适合事件驱动框架（如服务器程序）。  

2. **替代 self-pipe 技巧**：  
   传统上用“自管道”（self-pipe）将信号转化为 I/O 事件，`signalfd` 提供了更直接的替代方案，减少了管道创建和维护的开销。  

3. **动态更新监控信号**：  
   通过 `signalfd(fd, new_mask, 0)` 可动态修改描述符关联的信号集，无需关闭重建。  

4. **同步处理，无信号处理器**：  
   无需编写信号处理器，避免了异步信号处理的复杂性（如信号安全函数限制、全局变量同步），逻辑更线性。  


### 六、使用注意事项  
1. **必须阻塞目标信号**：  
   同 `sigwaitinfo()`，需通过 `sigprocmask()` 阻塞 `mask` 中的信号，否则信号可能按默认处置（如终止进程）处理，而非通过 `signalfd` 读取。  

2. **信号排队规则**：  
   标准信号不排队（多次发送仅返回一次），实时信号按发送顺序排队，与 `sigwaitinfo()` 一致。  

3. **非标准接口**：  
   `signalfd()` 是 Linux 特有，非 POSIX 标准，移植性较差，跨平台程序需谨慎使用。  

4. **关闭描述符**：  
   不再使用时需调用 `close(sfd)` 释放内核资源，避免资源泄漏。  


### 总结  
`signalfd()` 通过文件描述符实现信号的同步接收，核心优势是**与 I/O 多路复用机制兼容**，适合事件驱动场景。相比 `sigwaitinfo()`，它更适合需要统一监控多种事件（信号 + I/O）的程序；相比传统信号处理器，它避免了异步处理的复杂性。使用时需注意阻塞目标信号，并结合 `read()` 或多路复用接口处理信号事件。