这段内容聚焦于**信号传递的时机**和**多个信号解除阻塞后的传递顺序**这两个核心问题，明确了信号从“等待状态”到“实际传递”的触发条件及多信号场景的处理规则。以下是分点解读：


### 一、信号传递的时机：何时处理等待状态的信号？
信号产生后若未被立即处理（如处于阻塞状态），会进入“等待状态”。内核会在特定时机将等待状态的信号传递给进程，具体时机因信号生成方式（同步/异步）而异：  


#### 1. 同步生成的信号：立即传递  
同步信号（如硬件异常产生的`SIGSEGV`、进程自发送的`raise(SIGUSR1)`）由进程自身执行逻辑触发，满足以下条件时会**立即传递**：  
- 信号未被阻塞（或虽被阻塞，但硬件信号的阻塞可能直接导致进程终止，见22.4节）；  
- 无需等待内核态到用户态的切换，因为信号产生与进程执行同步，触发后立即处理。  


#### 2. 异步生成的信号：等待内核态→用户态切换时传递  
异步信号（如用户按`Ctrl+C`产生的`SIGINT`、其他进程发送的`SIGTERM`）的传递存在**瞬时延迟**，内核会在进程发生**内核态到用户态的切换**时传递信号。典型切换场景包括：  
- 进程从内核调度中获得时间片（重新开始执行时）；  
- 系统调用完成后（如`read()`、`sleep()`返回用户态时）；  
- 中断处理完成后（硬件中断处理结束，返回用户态进程时）。  

这一机制确保内核不会频繁中断进程执行，而是在安全的切换点处理信号。  


### 二、多个信号解除阻塞后的传递顺序
当进程通过`sigprocmask()`解除对多个等待信号的阻塞时，所有信号会被立即传递，但传递顺序有明确规则和限制：  


#### 1. Linux的实现：按信号编号升序传递  
在Linux中，多个解除阻塞的信号会**按信号编号从小到大依次传递**。例如：  
- 若等待信号为`SIGINT`（编号2）和`SIGQUIT`（编号3），无论两者产生顺序如何，`SIGINT`先传递，`SIGQUIT`后传递。  


#### 2. 标准的不确定性：不可依赖特定顺序  
SUSv3明确规定：**标准信号的传递顺序由系统实现决定，不做统一要求**。这意味着：  
- 不同UNIX系统（如Linux、BSD、Solaris）可能采用不同的顺序（如按信号产生时间、优先级等）；  
- 应用程序**不能依赖信号传递的固定顺序**，否则会导致跨平台兼容性问题。  


#### 3. 信号处理器的嵌套执行  
若多个信号在传递时触发各自的处理器函数，执行顺序遵循“中断嵌套”规则：  
- 先传递的信号处理器执行过程中，若发生内核态→用户态切换（如处理器函数执行中再次触发信号传递条件），会中断当前处理器，优先执行后传递信号的处理器；  
- 后传递的处理器执行完毕后，返回继续执行前一个处理器。  

例如：`SIGINT`处理器执行中，`SIGQUIT`信号被传递，内核会暂停`SIGINT`处理器，先执行`SIGQUIT`处理器，完成后再回到`SIGINT`处理器继续执行。  


### 三、关键结论
1. **传递时机**：同步信号立即传递，异步信号等待内核态→用户态切换时传递。  
2. **多信号顺序**：Linux按信号编号升序传递，但标准未规定，程序不应依赖特定顺序。  
3. **嵌套执行**：多个信号处理器可嵌套执行，后传递的信号处理器会中断先执行的处理器。  

这些规则是理解信号处理流程的基础，尤其在多信号并发场景中，需避免对顺序的强依赖，确保程序的健壮性和可移植性。




以下是3段代码，分别验证信号传递的3个核心结论：信号传递时机、多信号解除阻塞后的顺序、信号处理器的嵌套执行。


### 1. 验证信号传递时机（同步信号立即传递，异步信号延迟传递）
```c
#include <signal.h>
#include <stdio.h>
#include <unistd.h>

// 信号处理器：打印信号编号
void handler(int sig) {
    printf("收到信号 %d\n", sig);
}

int main() {
    // 注册SIGUSR1和SIGUSR2的处理器
    signal(SIGUSR1, handler);
    signal(SIGUSR2, handler);

    printf("开始测试：同步信号应立即传递，异步信号延迟传递\n");
    
    // 同步信号：进程自发送SIGUSR1（raise()）
    printf("发送同步信号 SIGUSR1...\n");
    raise(SIGUSR1);  // 同步信号，应立即执行处理器
    
    // 异步信号：通过子进程发送SIGUSR2（模拟外部触发）
    printf("发送异步信号 SIGUSR2...\n");
    pid_t pid = fork();
    if (pid == 0) {
        // 子进程：向父进程发送SIGUSR2
        kill(getppid(), SIGUSR2);
        _exit(0);
    }
    
    // 父进程：故意执行一个长时间系统调用（sleep），观察异步信号何时传递
    printf("进入sleep(5)，异步信号应在系统调用返回时传递\n");
    sleep(5);  // 异步信号会在此时延迟传递（系统调用结束时）
    
    printf("测试结束\n");
    return 0;
}
```

**结论验证**：  
- 同步信号（`raise(SIGUSR1)`）会在调用后立即打印“收到信号 10”；  
- 异步信号（子进程发送的`SIGUSR2`）会在`sleep(5)`结束（内核态→用户态切换）时才打印“收到信号 12”，体现延迟传递特性。


### 2. 验证多信号解除阻塞后的传递顺序（Linux按信号编号升序）
```c
#include <signal.h>
#include <stdio.h>
#include <unistd.h>

// 信号处理器：记录信号传递顺序
void handler(int sig) {
    printf("处理信号 %d\n", sig);
}

int main() {
    // 注册3个信号的处理器（编号：SIGINT=2，SIGQUIT=3，SIGUSR1=10）
    signal(SIGINT, handler);
    signal(SIGQUIT, handler);
    signal(SIGUSR1, handler);

    // 1. 阻塞所有信号
    sigset_t mask;
    sigemptyset(&mask);
    sigaddset(&mask, SIGINT);
    sigaddset(&mask, SIGQUIT);
    sigaddset(&mask, SIGUSR1);
    sigprocmask(SIG_BLOCK, &mask, NULL);
    printf("已阻塞SIGINT(2)、SIGQUIT(3)、SIGUSR1(10)\n");

    // 2. 发送3个信号（顺序故意打乱）
    printf("发送信号（顺序：SIGUSR1→SIGQUIT→SIGINT）\n");
    raise(SIGUSR1);  // 10
    raise(SIGQUIT);  // 3
    raise(SIGINT);   // 2

    // 3. 解除阻塞，观察传递顺序
    printf("解除阻塞，信号传递顺序应为：2→3→10（按编号升序）\n");
    sigprocmask(SIG_UNBLOCK, &mask, NULL);

    sleep(1);  // 等待信号处理完成
    return 0;
}
```

**结论验证**：  
- 尽管信号发送顺序是`SIGUSR1(10)→SIGQUIT(3)→SIGINT(2)`，但解除阻塞后，Linux会按编号升序传递，输出顺序为：  
  `处理信号 2` → `处理信号 3` → `处理信号 10`，验证了“按信号编号升序传递”的特性。


### 3. 验证信号处理器的嵌套执行（后传递信号中断先执行的处理器）
```c
#include <signal.h>
#include <stdio.h>
#include <unistd.h>

// SIGINT处理器（编号2）
void sigint_handler(int sig) {
    printf("→ 进入SIGINT处理器（开始执行）\n");
    sleep(2);  // 故意延迟，给其他信号触发机会
    printf("→ 离开SIGINT处理器（执行完毕）\n");
}

// SIGQUIT处理器（编号3）
void sigquit_handler(int sig) {
    printf("→→ 进入SIGQUIT处理器（开始执行）\n");
    printf("→→ 离开SIGQUIT处理器（执行完毕）\n");
}

int main() {
    // 注册处理器
    signal(SIGINT, sigint_handler);
    signal(SIGQUIT, sigquit_handler);

    // 1. 阻塞SIGQUIT，确保先执行SIGINT处理器
    sigset_t mask;
    sigemptyset(&mask);
    sigaddset(&mask, SIGQUIT);
    sigprocmask(SIG_BLOCK, &mask, NULL);
    printf("已阻塞SIGQUIT，发送SIGINT...\n");
    raise(SIGINT);  // 触发SIGINT处理器

    // 2. 在SIGINT处理器执行期间（sleep(2)时）解除SIGQUIT阻塞并发送信号
    printf("在SIGINT处理期间，发送SIGQUIT...\n");
    sigprocmask(SIG_UNBLOCK, &mask, NULL);  // 解除阻塞
    raise(SIGQUIT);  // 发送SIGQUIT

    sleep(3);  // 等待所有处理器执行完毕
    return 0;
}
```

**结论验证**：  
- `SIGINT`处理器先执行，打印“→ 进入SIGINT处理器”；  
- 执行到`sleep(2)`时，`SIGQUIT`被解除阻塞并传递，会**中断`SIGINT`处理器**，优先执行`SIGQUIT`处理器（打印“→→ 进入/离开SIGQUIT处理器”）；  
- `SIGQUIT`处理器执行完毕后，返回继续执行`SIGINT`处理器（打印“→ 离开SIGINT处理器”），验证了“信号处理器嵌套执行”的特性。


### 总结
3段代码分别验证了：  
1. 同步信号立即传递，异步信号等待内核态→用户态切换时传递；  
2. Linux中多信号解除阻塞后按编号升序传递；  
3. 信号处理器可嵌套执行，后传递的信号会中断先执行的处理器。