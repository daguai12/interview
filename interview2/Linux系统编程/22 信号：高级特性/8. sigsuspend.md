### `sigsuspend()`：原子操作解决信号等待的竞态条件  
`sigsuspend()` 是专门用于**安全等待信号**的系统调用，其核心价值在于将“解除信号阻塞”和“挂起进程等待信号”封装为**原子操作**，从而避免传统方法（`sigprocmask()`+`pause()`）中的竞态条件。以下是详细解析：


### 一、为什么需要 `sigsuspend()`？传统方法的缺陷  
在信号编程中，常需要“临时阻塞信号保护关键代码→解除阻塞→等待信号”的流程。若用 `sigprocmask()` 解除阻塞后再调用 `pause()`，会存在**竞态条件**：  

#### 问题场景（程序清单 22-4 的错误示例）：  
```c
// 错误示例：解除阻塞与等待信号分离，存在竞态
sigset_t mask, oldmask;
sigemptyset(&mask);
sigaddset(&mask, SIGINT);

// 1. 阻塞 SIGINT 保护关键代码
sigprocmask(SIG_BLOCK, &mask, &oldmask);
// ... 执行关键代码 ...

// 2. 解除阻塞 SIGINT
sigprocmask(SIG_SETMASK, &oldmask, NULL);  // 解除阻塞
// 【竞态窗口】：若 SIGINT 在此时（解除后、pause前）到达，信号被处理
pause();  // 若信号已在窗口中处理，此处会永久阻塞！
```  

**风险**：信号可能在“解除阻塞”和“`pause()` 挂起”之间到达，导致 `pause()` 永远等待未发生的信号，程序卡死。  


### 二、`sigsuspend()` 的工作原理：原子操作避免竞态  
`sigsuspend()` 的核心功能是**原子地替换信号掩码并挂起进程**，直到信号到达并处理完成。其行为等价于：  
```c
// 伪代码：sigsuspend() 的原子操作逻辑
oldmask = 进程当前信号掩码;
进程信号掩码 = new_mask;  // 临时替换为新掩码（解除阻塞目标信号）
pause();  // 挂起等待信号
进程信号掩码 = oldmask;  // 信号处理后恢复原始掩码
```  

#### 函数原型：  
```c
#include <signal.h>
int sigsuspend(const sigset_t *mask);
```  
- **参数**：`mask` 为临时替换的信号掩码（通常用于解除对目标信号的阻塞）。  
- **返回值**：信号处理后返回 `-1`，并设置 `errno=EINTR`；若 `mask` 地址无效，返回 `-1` 且 `errno=EFAULT`。  


### 三、`sigsuspend()` 的关键特性  
1. **原子性**：“替换信号掩码”和“挂起等待”不可分割，中间无时间窗口，信号无法在操作间隙到达。  
2. **自动恢复掩码**：信号处理完成后，进程信号掩码会自动恢复为调用 `sigsuspend()` 前的值，无需手动重置。  
3. **仅等待信号**：若进程已存在未决的目标信号（因之前被阻塞），`sigsuspend()` 会立即处理该信号，不会阻塞。  


### 四、使用示例：程序清单 22-5 解析  
以下是 `sigsuspend()` 的典型用法，实现“阻塞信号保护关键代码→原子解除阻塞并等待信号→恢复掩码”的安全流程：  


#### 核心代码逻辑：  
```c
#include <signal.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

static volatile sig_atomic_t gotSigquit = 0;  // 标记是否收到 SIGQUIT

// 信号处理器：处理 SIGINT 和 SIGQUIT
void handler(int sig) {
    printf("收到信号 %d\n", sig);
    if (sig == SIGQUIT) {
        gotSigquit = 1;  // 收到 SIGQUIT 后标记退出
    }
}

int main() {
    sigset_t blockMask, emptyMask, oldMask;
    struct sigaction sa;

    // 1. 初始化信号集：阻塞 SIGINT(2) 和 SIGQUIT(3)
    sigemptyset(&blockMask);
    sigaddset(&blockMask, SIGINT);
    sigaddset(&blockMask, SIGQUIT);

    // 2. 保存原始掩码，设置新掩码（阻塞目标信号）
    if (sigprocmask(SIG_BLOCK, &blockMask, &oldMask) == -1) {
        perror("sigprocmask 失败");
        exit(EXIT_FAILURE);
    }

    // 3. 注册信号处理器
    sa.sa_handler = handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;
    if (sigaction(SIGINT, &sa, NULL) == -1 || sigaction(SIGQUIT, &sa, NULL) == -1) {
        perror("sigaction 失败");
        exit(EXIT_FAILURE);
    }

    // 4. 循环：执行关键代码→用 sigsuspend() 等待信号
    while (!gotSigquit) {
        printf("\n执行关键代码（信号掩码：阻塞 SIGINT/SIGQUIT）\n");
        sleep(2);  // 模拟关键代码执行

        // 显示未决信号（若有）
        printf("检查未决信号...\n");
        sigset_t pending;
        if (sigpending(&pending) == -1) {
            perror("sigpending 失败");
            exit(EXIT_FAILURE);
        }
        printf("未决信号：%s%s\n", 
               sigismember(&pending, SIGINT) ? "SIGINT " : "",
               sigismember(&pending, SIGQUIT) ? "SIGQUIT " : "");

        // 原子操作：解除阻塞（用空掩码）并等待信号
        printf("调用 sigsuspend() 等待信号...\n");
        sigemptyset(&emptyMask);  // 临时掩码：不阻塞任何信号
        if (sigsuspend(&emptyMask) == -1 && errno != EINTR) {
            perror("sigsuspend 失败");
            exit(EXIT_FAILURE);
        }
        // sigsuspend 返回后，信号掩码自动恢复为 blockMask（阻塞 SIGINT/SIGQUIT）
    }

    // 5. 恢复原始信号掩码
    if (sigprocmask(SIG_SETMASK, &oldMask, NULL) == -1) {
        perror("sigprocmask 恢复失败");
        exit(EXIT_FAILURE);
    }

    printf("程序退出\n");
    return 0;
}
```  


#### 执行流程与效果：  
1. **关键代码阶段**：进程阻塞 `SIGINT` 和 `SIGQUIT`，确保关键代码不被中断。  
2. **等待信号阶段**：`sigsuspend(&emptyMask)` 原子地将信号掩码替换为“不阻塞任何信号”，并挂起等待。此时：  
   - 若之前有未决的 `SIGINT`/`SIGQUIT`（因被阻塞），会立即处理；  
   - 若收到新信号，处理后 `sigsuspend()` 返回，信号掩码自动恢复为“阻塞 `SIGINT`/`SIGQUIT`”。  
3. **退出条件**：收到 `SIGQUIT` 后，`gotSigquit` 置为 1，循环退出，恢复原始信号掩码。  


### 五、总结  
`sigsuspend()` 解决了“解除信号阻塞→等待信号”流程中的竞态条件，其核心是**原子操作**和**自动恢复信号掩码**。使用场景包括：  
- 保护关键代码不被特定信号中断；  
- 安全等待信号，避免信号在解除阻塞后、等待前“丢失”导致的永久阻塞。  

相比 `sigprocmask()`+`pause()`，`sigsuspend()` 是更可靠的信号等待方案，是信号编程中的核心工具。