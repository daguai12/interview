这段内容聚焦于几类特殊信号（`SIGKILL`、`SIGSTOP`、`SIGCONT` 及终端相关信号）的独特行为和处理规则，这些规则是保障系统可控性和进程状态一致性的关键。以下是详细解读：


### 一、`SIGKILL` 和 `SIGSTOP`：不可改变的“终极控制信号”
这两个信号是系统中**唯一无法被修改、阻塞或忽略的信号**，设计目的是确保对失控进程的终极控制。

#### 核心特性：
1. **默认行为不可改变**：  
   - 无论通过 `signal()` 还是 `sigaction()`，试图为 `SIGKILL`（终止进程）或 `SIGSTOP`（暂停进程）设置自定义处理器、忽略（`SIG_IGN`）或捕获，都会返回错误（`errno` 设为 `EINVAL`）。  
   - 示例：`signal(SIGKILL, SIG_IGN)` 始终失败，`SIGKILL` 始终会终止进程。

2. **不可被阻塞**：  
   即使通过 `sigprocmask()` 将其加入信号掩码，也无法阻塞这两个信号。内核会无视阻塞设置，直接传递信号并执行默认行为。

3. **设计意图**：  
   确保管理员或系统在任何情况下都能终止（`SIGKILL`）或暂停（`SIGSTOP`）失控进程。例如，当进程陷入死锁或无限循环时，`SIGKILL` 是最后的终止手段。


### 二、`SIGCONT` 与停止信号：进程状态的“开关”
`SIGCONT` 用于恢复被停止的进程，而 `SIGSTOP`、`SIGTSTP`（终端暂停，如 `Ctrl+Z`）、`SIGTTIN`、`SIGTTOU` 则用于暂停进程。它们之间的交互有严格规则：

#### 1. `SIGCONT` 的强制恢复特性：  
   - 无论进程是否阻塞或忽略 `SIGCONT`，只要收到该信号，**处于停止状态的进程必定恢复运行**。  
   - 若进程阻塞了 `SIGCONT` 且注册了处理器，恢复运行后，需等解除阻塞才会执行处理器。

#### 2. 信号传递的“优先级”：  
   - 若进程已停止（因 `SIGSTOP` 等），除 `SIGKILL` 外，其他信号会**暂存等待**，直到进程被 `SIGCONT` 恢复后才传递。  
   - `SIGKILL` 例外：即使进程停止，`SIGKILL` 也会立即终止它。

#### 3. 信号的“互斥丢弃”：  
   - 进程收到 `SIGCONT` 时，会**丢弃所有等待中的停止信号**（避免恢复后又被暂停）。  
   - 进程收到停止信号时，会**丢弃所有等待中的 `SIGCONT` 信号**（避免暂停后立即被恢复）。  
   这一规则确保状态切换的一致性，防止信号冲突导致的混乱。


### 三、终端产生的信号：忽略状态的“继承惯例”
对于终端相关信号（`SIGHUP`、`SIGINT`、`SIGQUIT`、`SIGTTIN`、`SIGTTOU`、`SIGTSTP`），若其处置已被设为 `SIG_IGN`（忽略），程序**通常不应修改其处置**。这是遵循 Unix 惯例的设计：

#### 原因：  
这些信号的忽略状态通常由父进程（如 shell）设置，反映了用户的操作意图。例如：  
- shell 可能忽略 `SIGINT` 以避免被 `Ctrl+C` 终止；  
- 若子进程擅自修改为捕获或默认行为，可能打破用户预期（如无法通过 `Ctrl+C` 终止子进程）。

#### 例外：  
若程序明确需要处理这些信号（如自定义 `Ctrl+C` 响应），可修改处置，但需谨慎考虑用户体验。


### 总结
特殊信号的规则围绕“系统可控性”和“状态一致性”设计：  
- `SIGKILL`/`SIGSTOP` 确保进程始终可被控制；  
- `SIGCONT` 与停止信号的交互保证进程状态切换的可靠性；  
- 终端信号的忽略惯例维护了用户操作的一致性。  

理解这些规则是编写健壮程序的基础，尤其在进程管理和信号处理场景中。