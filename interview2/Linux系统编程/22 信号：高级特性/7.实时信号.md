这段内容详细介绍了**POSIX实时信号（Real-Time Signals）** 的设计目标、核心特性、使用规范及系统限制，旨在弥补标准信号的诸多缺陷。以下是分点解读：


### 一、实时信号的核心优势（对比标准信号）
实时信号针对标准信号的局限性进行了优化，主要优势包括：  


#### 1. 更多自定义信号资源  
标准信号中仅有 `SIGUSR1` 和 `SIGUSR2` 可供应用程序自定义使用，数量极少。  
实时信号提供了更大的信号范围：  
- SUSv3 要求至少提供 `_POSIX_RTSIG_MAX`（8个）实时信号；  
- Linux 内核定义了 32 个实时信号，编号范围为 **32～63**（通过 `SIGRTMIN` 和 `SIGRTMAX` 标识最小值和最大值）。  


#### 2. 信号队列化管理  
标准信号存在“信号丢失”问题：若同一标准信号多次发送且处于等待状态，最终仅会传递一次。  
实时信号采用**队列化管理**：  
- 同一实时信号的多个实例会被内核排队，接收进程会按发送顺序依次处理，不会丢失；  
- 即使信号处于阻塞状态，多次发送的实例也会被逐个记录，解除阻塞后依次传递。  


#### 3. 支持伴随数据传递  
发送实时信号时可附带**额外数据**（整数或指针），接收进程的信号处理器能获取这些数据，增强了信号的信息携带能力。  
例如：可通过伴随数据传递错误码、事件ID等细节，避免标准信号仅能传递“有无事件”的局限。  


#### 4. 明确的传递顺序保障  
标准信号的传递顺序由系统实现决定（如Linux按编号升序），但标准未规范，不可依赖。  
实时信号的传递顺序严格定义：  
- **不同信号**：按编号升序传递（编号越小，优先级越高）；  
- **同一信号**：按发送顺序传递（先发送的先处理），确保事件时序一致性。  


### 二、实时信号的编号与使用规范
实时信号的编号需通过规范方式引用，避免硬编码依赖：  


#### 1. 编号范围标识  
- `SIGRTMIN`：实时信号的最小编号（Linux 中，NPTL 线程实现定义为 34，LinuxThreads 定义为 35，因内部占用部分信号）；  
- `SIGRTMAX`：实时信号的最大编号（Linux 中为 63）。  

**使用建议**：通过 `SIGRTMIN + x` 引用实时信号（如 `SIGRTMIN + 1` 表示第二个实时信号），而非直接写死编号（不同系统编号范围可能不同）。  


#### 2. 避免预处理期依赖  
`SIGRTMIN` 和 `SIGRTMAX` 可能被定义为函数（如 Linux），因此不能在预处理期（如 `#if` 条件判断）中使用，需在运行时检查。  


### 三、实时信号的排队数量限制
内核需为排队的实时信号（及伴随数据）维护数据结构，消耗内核内存，因此存在数量限制：  


#### 1. 标准与系统限制  
- SUSv3 要求每个进程的排队实时信号数量至少为 `_POSIX_SIGQUEUE_MAX`（32个）；  
- Linux 中，排队数量限制通过**资源限制 `RLIMIT_SIGPENDING`** 控制（针对同一实际用户ID的所有进程），可通过 `getrlimit()` 查看。  


#### 2. Linux 实现的历史变化  
- 内核 2.6.8 之前：通过 `/proc/sys/kernel/rtsig-max`（系统级总限制）和 `/proc/sys/kernel/rtsig-nr`（当前排队总数）控制；  
- 内核 2.6.8 之后：取消上述 `/proc` 文件，统一通过 `RLIMIT_SIGPENDING` 限制，可通过 `/proc/PID/status` 的 `SigQ` 字段查看某进程的排队信号数。  


### 四、实时信号的使用方法
使用实时信号需遵循特定接口规范，确保队列化和数据传递有效：  


#### 1. 发送实时信号：`sigqueue()`  
- 标准推荐使用 `sigqueue()` 发送实时信号，可指定伴随数据（`sival_int` 或 `sival_ptr`）：  
  ```c
  #include <signal.h>
  int sigqueue(pid_t pid, int sig, const union sigval value);
  ```  
  - `value`：包含伴随数据的联合体（`int sival_int` 或 `void *sival_ptr`）。  

- 若使用 `kill()`、`raise()` 等接口发送实时信号，Linux 会排队处理，但其他 UNIX 系统可能不支持，**可移植性差**，不推荐。  


#### 2. 接收实时信号：`sigaction()` 与 `SA_SIGINFO` 标志  
接收进程需通过 `sigaction()` 注册处理器，并设置 `SA_SIGINFO` 标志，才能获取伴随数据：  
```c
struct sigaction sa;
sa.sa_sigaction = handler;  // 带额外参数的处理器函数
sigemptyset(&sa.sa_mask);
sa.sa_flags = SA_SIGINFO;   // 启用信号信息传递
sigaction(SIGRTMIN + 1, &sa, NULL);
```  

- 处理器函数原型需支持额外参数（包含信号编号、信号信息、上下文）：  
  ```c
  void handler(int sig, siginfo_t *info, void *ucontext) {
      // info->si_value：获取发送方的伴随数据
      printf("收到实时信号 %d，伴随数据：%d\n", sig, info->si_value.sival_int);
  }
  ```  


#### 3. 可移植性注意  
Linux 中，即使未设置 `SA_SIGINFO`，实时信号仍会排队，但无法获取伴随数据。但 SUSv3 未要求此行为，其他系统可能不支持，因此**必须显式设置 `SA_SIGINFO`** 以确保可移植性。  


### 五、总结
实时信号通过**队列化管理、伴随数据、明确顺序、更多资源**等特性，弥补了标准信号的缺陷，适用于需要可靠事件通知、传递细节信息的场景（如实时系统、进程间高可靠性通信）。  

使用时需注意：  
- 通过 `SIGRTMIN + x` 引用信号，避免硬编码；  
- 用 `sigqueue()` 发送信号，`sigaction(SA_SIGINFO)` 接收，确保可移植性；  
- 关注排队数量限制，避免超出 `RLIMIT_SIGPENDING`。  

实时信号是标准信号的增强版，是复杂场景下的首选信号机制。