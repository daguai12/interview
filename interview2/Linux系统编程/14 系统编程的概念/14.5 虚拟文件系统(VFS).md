## 1. 为什么需要 VFS？

书里一开头说：

> Linux 所支持的各种文件系统，其实现细节均不相同。举例来说，这些差异包括文件块的分配方式，以及目录的组织方式。

意思是：

* ext2、ext4、NTFS、NFS、ISO9660… 每种文件系统的数据结构完全不同。
* 比如：

  * ext2 用 **inode + block group** 管理文件；
  * FAT32 用 **FAT 表** 管理链式的簇；
  * NTFS 用 **MFT（主文件表）**；
  * ISO9660（光盘）用 **目录记录 + 扇区表**。

如果应用程序要自己理解这些底层差异，那写一个 “跨文件系统的工具” 基本不可能。

---

## 2. VFS 的本质

> 虚拟文件系统（VFS，有时也称为虚拟文件交换）是一种内核特性，通过为文件系统操作创建抽象层来解决上述问题。

也就是说：

* VFS 在 **内核中** 定义了一套 **统一接口**，所有程序调用文件操作时，都只面对这套统一接口。
* 每个具体文件系统（ext2、FAT、NFS …）只需要 **实现这套接口**，就能接入 Linux 内核。
* 所以程序员只需学一次 API（open/read/write/…），不用关心 ext2 还是 NTFS。

---

## 3. VFS 的两层模型

可以这样分层来看（就是图 14-3 的核心思想）：

```
用户程序
   │
   │  POSIX 系统调用 (open, read, write, ...)
   ▼
虚拟文件系统 (VFS 层)
   │   ←—— 抽象接口（统一的数据结构和操作函数）
   ▼
具体文件系统驱动 (ext2, ext4, FAT, NTFS, NFS, ...)
   ▼
磁盘 / 网络设备
```

* 用户只会调用 `open("foo.txt")`，不会直接和 ext2 或 FAT 打交道。
* VFS 收到 `open` 调用后，去找具体挂载点所属的文件系统，然后调用对应文件系统的实现方法。

---

## 4. VFS 定义的接口

书里列了一些典型的系统调用：

* **文件操作**：`open()`, `read()`, `write()`, `lseek()`, `close()`, `truncate()`
* **文件属性**：`stat()`
* **挂载管理**：`mount()`, `umount()`
* **内存映射**：`mmap()`
* **目录与链接**：`mkdir()`, `link()`, `unlink()`, `symlink()`, `rename()`

这些都不是“直接由文件系统实现”，而是通过 VFS → 转发 → 具体文件系统的 **回调函数**。

例如：

* `open()` → VFS → `inode_operations->lookup()` （不同文件系统会有不同实现）
* `read()` → VFS → `file_operations->read()`
* `write()` → VFS → `file_operations->write()`

---

## 5. VFS 的建模方式

> VFS 的抽象层建模精确仿照传统的 UNIX 文件系统模型。

就是说，Linux 的 VFS 用的是 **inode + dentry + superblock + file** 这样的数据结构，这些概念来源于 UNIX 文件系统（ext、UFS、BSD FFS）。

典型 VFS 内核结构：

* **super\_block**：表示一个挂载的文件系统实例。
* **inode**：表示一个文件的元数据。
* **dentry（目录项）**：表示路径名和 inode 的映射关系。
* **file**：表示一个进程打开的文件（对应用户空间的文件描述符）。

程序调用 `open("a/b/c.txt")`，内核会：

* 在 VFS 中遍历路径名（查找 dentry）；
* 找到对应 inode；
* 创建一个 file 对象，返回给用户一个 fd。

---

## 6. 不同文件系统的能力差异

> 当然，还有一些文件系统，尤其是非 UNIX 文件系统，并不支持所有的 VFS 操作。比如，微软的 VFAT 就不支持使用 symlink() 创建的符号链接概念。

解释：

* UNIX 文件系统天然支持硬链接、符号链接（inode 可以指向多个路径名，或者用特殊 inode 表示符号链接）。
* 但是 FAT/VFAT 没有这种概念，它只有“短文件名/长文件名”和目录表，没有“符号链接”。
* 所以当程序在 VFAT 上调用 `symlink()`，VFAT 驱动就会返回 **错误码 ENOTSUP（Operation not supported）**。
* VFS 会把这个错误传回用户程序。

---

## 7. 总结

* **VFS 的作用**：把各种文件系统的差异屏蔽在内核层，向用户提供统一的文件操作接口。
* **核心机制**：VFS 定义了一套抽象的数据结构（inode、superblock、dentry、file）和一组操作函数（file\_operations, inode\_operations, super\_operations）。
* **优势**：用户空间程序只需调用一套 POSIX API，不用关心 ext4、FAT、NFS 的差异。
* **局限**：某些文件系统不支持全部功能时，调用会失败并返回错误码。

---

要不要我接下来帮你 **画一张 VFS 层次结构图（inode、dentry、file、superblock 之间的关系）**？这样你会更直观地理解 VFS 是怎么把“路径名 → inode → 打开的文件”串起来的。
