### **14.8 文件系统的挂载和卸载**

系统调用 `mount()` 和 `umount()` 允许特权级进程（需要 `CAP_SYS_ADMIN` 能力）以编程方式挂载或卸载文件系统。大多数 UNIX 实现都提供了这两个系统调用。不过，SUSv3 并未对其进行规范，因此其具体操作也随 UNIX 实现和文件系统的不同而不同。

在讨论这两个系统调用之前，需要先了解以下三个文件，其中包含了当前已挂载或可挂载的文件系统信息。

#### **相关信息文件**

1.  **/proc/mounts**

      * 这是一个 Linux 专有的**虚拟文件**，可查看当前已挂载文件系统的列表。
      * 它是内核数据结构的直接接口，因此**总是包含已挂载文件系统的精确信息**。
      * 随着每进程挂载命名空间的引入，现在每个进程都有一个 `/proc/PID/mounts` 文件，而 `/proc/mounts` 只是一个指向 `/proc/self/mounts` 的符号链接，显示当前进程的挂载视图。

2.  **/etc/mtab**

      * 这是一个**常规文件**，由 `mount(8)` 和 `umount(8)` **命令**自动维护。
      * 其内容与 `/proc/mounts` 类似，但有时可能包含更多细节（如文件系统专有选项）。
      * **可能不准确**：因为 `mount()` 和 `umount()` **系统调用**本身并不会更新此文件，如果某些应用程序直接调用系统调用来挂载或卸载设备而没有同步更新该文件，那么 `/etc/mtab` 的信息可能会过时或不正确。

3.  **/etc/fstab**

      * 这是一个**配置文件**，由系统管理员手工维护。
      * 它包含了系统引导时需要自动挂载，或可供日后手动挂载的所有文件系统的描述。
      * `mount(8)`、`umount(8)` 以及 `fsck(8)` 等命令会使用此文件。例如，执行 `mount /home` 时，`mount` 命令会到 `/etc/fstab` 中查找 `/home` 挂载点对应的设备和其他挂载选项。

#### **文件格式**

`/proc/mounts`、`/etc/mtab` 和 `/etc/fstab` 的格式基本相同。以下是摘自 `/proc/mounts` 中的一条记录示例：

```
proc /proc proc rw 0 0
```

这条记录包含了 6 个字段，其含义如下：

1.  **已挂载设备名**: 此处是 `proc`（一个虚拟文件系统）。
2.  **设备的挂载点**: `/proc` 目录。
3.  **文件系统类型**: `proc` 类型。
4.  **挂载标志**: `rw` 表示以可读写（read-write）方式挂载。
5.  **备份频率**: 一个数字，供 `dump(8)` 程序使用以控制备份操作。此字段仅在 `/etc/fstab` 文件中有意义，在 `/proc/mounts` 和 `/etc/mtab` 中，该字段总是为 0。
6.  **fsck 检查顺序**: 一个数字，在系统引导时，用于控制 `fsck(8)` 对文件系统的检查顺序。此字段同样仅在 `/etc/fstab` 文件中有意义，在 `/proc/mounts` 和 `/etc/mtab` 中，该字段总是为 0。

> 用于从上述文件中读取记录的库函数记录在 `getfsent(3)` 和 `getmntent(3)` 手册页中。


#### **14.8.1 挂载文件系统：mount()**

`mount()` 系统调用将由 `source` 指定设备所包含的文件系统，挂载到由 `target` 指定的目录下。

```c
#include <sys/mount.h>

int mount(const char *source, const char *target,
          const char *filesystemtype, unsigned long mountflags,
          const void *data);
```

  * **`source`**: 将要挂载的设备名（如 `"/dev/sda1"`）或目录（用于绑定挂载）。
  * **`target`**: 文件系统的挂载点目录。
  * **`filesystemtype`**: 标识文件系统类型的字符串（如 `"ext4"`, `"xfs"`）。
  * **`mountflags`**: 一个位掩码，由下表中的 0 个或多个标志进行“或”操作得出。
  * **`data`**: 一个指向文件系统专有选项的指针，通常是一个以逗号分隔的字符串。

**`mount()` 使用的 `mountflags` 值**
| 标记 | 用途 |
| :--- | :--- |
| `MS_BIND` | 建立绑定挂载（始于 Linux 2.4） |
| `MS_DIRSYNC` | 同步更新路径（始于 Linux 2.6） |
| `MS_MANDLOCK` | 允许强制锁定文件 |
| `MS_MOVE` | 以原子操作将挂载点移到新位置 |
| `MS_NOATIME` | 不更新文件的最后访问时间 |
| `MS_NODEV` | 不允许访问设备 |
| `MS_NODIRATIME` | 不更新目录的最后访问时间 |
| `MS_NOEXEC` | 不允许程序执行 |
| `MS_NOSUID` | 禁用 set-user-ID 和 set-group-ID 程序 |
| `MS_RDONLY` | 以只读方式挂载 |
| `MS_REC` | 递归挂载（始于 Linux 2.6.20） |
| `MS_RELATIME` | 只有当 atime \<= mtime/ctime 时才更新 atime（始于 Linux 2.4.11） |
| `MS_REMOUNT` | 使用新的 mountflags 和 data 重新挂载 |
| `MS_STRICTATIME` | 总是更新最后访问时间（始于 Linux 2.6.30） |
| `MS_SYNCHRONOUS`| 使得所有文件和目录同步更新 |

##### **mountflags 详解**

  * **`MS_BIND`**: 建立绑定挂载，即将一个已存在的目录树挂载到另一个位置。
  * **`MS_DIRSYNC`**: 类似于 `open()` 的 `O_SYNC` 标志，但只针对目录操作（如 `creat`, `rename`, `mkdir` 等）进行同步更新，开销小于 `MS_SYNCHRONOUS`。
  * **`MS_MANDLOCK`**: 允许在此文件系统上使用强制记录锁定。
  * **`MS_MOVE`**: 以原子操作将一个已存在的挂载点移动到新的位置。
  * **`MS_NOATIME`**: 不更新此文件系统中所有文件的最后访问时间（`atime`），可以显著提升性能。
  * **`MS_NODEV`**: 不允许访问此文件系统上的块设备和字符设备文件，是一个安全特性。
  * **`MS_NODIRATIME`**: 不更新此文件系统中目录的最后访问时间。
  * **`MS_NOEXEC`**: 不允许在此文件系统上执行任何程序。
  * **`MS_NOSUID`**: 禁用此文件系统上所有程序的 set-user-ID 和 set-group-ID 位，是一个安全特性。
  * **`MS_RDONLY`**: 以只读方式挂载文件系统。
  * **`MS_REC`**: 与 `MS_BIND` 等标志结合使用，以递归方式将挂载动作施加于子树下的所有挂载点。
  * **`MS_RELATIME`**: 只有当文件的 `atime` 早于或等于 `mtime` 或 `ctime` 时，才更新 `atime`。自 Linux 2.6.30 以来，这已成为默认行为。
  * **`MS_REMOUNT`**: 改变一个**已挂载**文件系统的标志和数据，例如将一个只读文件系统变为可写。使用此标志可以避免卸载和重新挂载的麻烦。
  * **`MS_STRICTATIME`**: 强制系统总是更新文件的访问时间，覆盖 `MS_RELATIME` 的默认行为。
  * **`MS_SYNCHRONOUS`**: 对此文件系统上的所有文件和目录的更新都进行同步。效果如同总是以 `O_SYNC` 标志打开文件一样，性能开销极大。

> **共享子树**: 从内核 2.6.15 起，Linux 还提供了 `MS_PRIVATE`、`MS_SHARED`、`MS_SLAVE`、`MS_UNBINDABLE` 等标志，用于支持共享子树（shared subtree）的概念，以在挂载命名空间之间传播挂载事件。

-----

#### **程序示例**

程序清单 14-1 提供了对 `mount()` 系统调用的命令行级接口，是 `mount(8)` 命令的简化版。

**`mount_demo.c` 文件:**

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mount.h>
#include <getopt.h>

void usage(const char *pname) {
    fprintf(stderr, "Usage: %s [options] source target\n", pname);
    fprintf(stderr, "Options:\n");
    fprintf(stderr, "    -t fstype     Filesystem type\n");
    fprintf(stderr, "    -o data       Mount options\n");
    fprintf(stderr, "    -f flags      Mount flags (numeric or symbolic, e.g., 'remount,ro')\n");
    exit(EXIT_FAILURE);
}

// 辅助函数：将字符串标志（如"ro,noatime"）转换为数值掩码
unsigned long parse_flags(char *str) {
    unsigned long flags = 0;
    char *token;
    for (token = strtok(str, ","); token != NULL; token = strtok(NULL, ",")) {
        if (strcmp(token, "ro") == 0) flags |= MS_RDONLY;
        else if (strcmp(token, "remount") == 0) flags |= MS_REMOUNT;
        else if (strcmp(token, "bind") == 0) flags |= MS_BIND;
        else if (strcmp(token, "move") == 0) flags |= MS_MOVE;
        // 添加更多标志的解析...
    }
    return flags;
}

int main(int argc, char *argv[]) {
    int opt;
    char *fstype = NULL;
    char *data = NULL;
    char *flags_str = NULL;
    unsigned long flags = 0;

    while ((opt = getopt(argc, argv, "t:o:f:")) != -1) {
        switch (opt) {
        case 't': fstype = optarg; break;
        case 'o': data = optarg; break;
        case 'f': flags_str = optarg; break;
        default: usage(argv[0]);
        }
    }

    if (optind + 2 > argc) {
        usage(argv[0]);
    }

    char *source = argv[optind];
    char *target = argv[optind + 1];

    if (flags_str) {
        flags = parse_flags(flags_str);
    }
    
    // 如果没有指定类型且不是 remount/move/bind，则默认为 "ext4"
    if (!fstype && !(flags & (MS_REMOUNT | MS_MOVE | MS_BIND))) {
        fstype = "ext4"; 
    }

    if (mount(source, target, fstype, flags, data) == -1) {
        perror("mount");
        exit(EXIT_FAILURE);
    }

    printf("Mount successful.\n");
    exit(EXIT_SUCCESS);
}
```

**编译和运行演示 (需要 root 权限):**

假设我们有一个设备 `/dev/sdb1`，文件系统类型为 `ext4`。

1.  **创建挂载点并执行挂载:**

    ```bash
    # mkdir /mnt/mydisk
    # gcc mount_demo.c -o mount_demo
    # sudo ./mount_demo -t ext4 /dev/sdb1 /mnt/mydisk
    Mount successful.
    ```

2.  **检查挂载状态 (该程序不更新 /etc/mtab):**

    ```bash
    # grep mydisk /etc/mtab
    # # (无输出)

    # grep mydisk /proc/mounts
    /dev/sdb1 /mnt/mydisk ext4 rw,relatime,data=ordered 0 0
    ```

3.  **以只读方式重新挂载:**

    ```bash
    # sudo ./mount_demo -f remount,ro /dev/sdb1 /mnt/mydisk
    Mount successful.

    # grep mydisk /proc/mounts
    /dev/sdb1 /mnt/mydisk ext4 ro,relatime,data=ordered 0 0
    ```

    (注意标志从 `rw` 变为了 `ro`)

4.  **移动挂载点:**

    ```bash
    # mkdir /tmp/new_mount_point 
    # sudo ./mount_demo -f move /mnt/mydisk /tmp/new_mount_point
    Mount successful.

    # grep sdb1 /proc/mounts
    /dev/sdb1 /tmp/new_mount_point ext4 ro,relatime,data=ordered 0 0
    ```

    (挂载点已从 `/mnt/mydisk` 移动到 `/tmp/new_mount_point`)


#### **14.8.2 卸载文件系统：umount()和 umount2()**

`umount()` 系统调用用于卸载（分离）一个已挂载的文件系统。

```c
#include <sys/mount.h>

int umount(const char *target);
```

  * **`target`**: 该参数指定待卸载文件系统的**挂载点**。

    > **历史变更**: 在内核 2.4 之前的 Linux 系统中，`target` 参数既可以是挂载点，也可以是设备名。自内核 2.4 之后，由于一个文件系统可能被挂载到多个位置（绑定挂载），使用设备名会产生歧义，因此 `target` 必须是挂载点。

  * **卸载失败**: 无法卸载一个正在使用中（busy）的文件系统。如果文件系统上有任何被打开的文件，或者有任何进程的当前工作目录位于该文件系统下，那么 `umount()` 调用将失败并返回 `EBUSY` 错误。

##### **umount2()**

系统调用 `umount2()` 是 `umount()` 的扩展版。通过 `flags` 参数，`umount2()` 可对卸载操作施以更精密的控制。

```c
#include <sys/mount.h>

int umount2(const char *target, int flags);
```

`flags` 参数是一个位掩码，由下列 0 个或多个值进行“或”（OR）运算而成：

  * **`MNT_DETACH` (懒卸载 - Lazy Unmount)**

      * 执行“懒卸载”。文件系统在文件系统层级中立即可见被分离，从而**禁止任何新进程对该挂载点的访问**。
      * 然而，对于那些在调用 `MNT_DETACH` 之前就已经在使用该文件系统的进程，它们可以**继续使用**。
      * 直到所有这些进程都不再使用该挂载点时，相应的文件系统才会被真正清理和卸载。

  * **`MNT_EXPIRE` (标记为到期)**

      * 提供一种机制，以卸载在某段时间内未被使用的文件系统。这是一个两步过程：

    <!-- end list -->

    1.  首次以 `MNT_EXPIRE` 调用 `umount2()`，如果挂载点空闲，调用会失败并返回 `EAGAIN` 错误，但同时会将挂载点**标记为到期**。
    2.  只要没有进程再访问这个到期的挂载点，它就一直保持到期状态。再次以 `MNT_EXPIRE` 调用 `umount2()` 将会成功卸载这个到期的挂载点。

    <!-- end list -->

      * 此标志不能与 `MNT_DETACH` 或 `MNT_FORCE` 一并使用。

  * **`MNT_FORCE` (强制卸载)**

      * 即便文件系统处于“忙碌”状态，依然将其强行卸载。
      * **注意**: 此选项**只对 NFS（网络文件系统）挂载有效**，并且可能会造成数据丢失。

  * **`UMOUNT_NOFOLLOW` (不跟随符号链接)**

      * 如果 `target` 是一个符号链接，则不对其进行解引用（dereference），即操作的是符号链接本身而不是它指向的目标。
      * 这是一个**安全特性**，专为某些允许非特权用户执行卸载操作的 set-user-ID-root 程序而设计，旨在避免用户通过改变符号链接指向来卸载非授权的文件系统。