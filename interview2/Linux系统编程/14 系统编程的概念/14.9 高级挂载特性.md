### **14.9 高级挂载特性**

本节介绍挂载文件系统时可采用的若干高级特性，这些特性大多始于 Linux 内核 2.4 版本。这里会使用 `mount(8)` 命令来演示，但在程序中调用 `mount(2)` 系统调用也能起到相同效果。

#### **14.9.1 在多个挂载点挂载文件系统**

从内核版本 2.4 开始，可以将一个文件系统挂载于文件系统内的多个位置。由于每个挂载点下的目录子树内容都相同，在一个挂载点下对目录子树所做的改变，同样可见于其他挂载点。

**演示:**

```bash
# 假设 /dev/sdb1 是一个文件系统设备
$ sudo mount /dev/sdb1 /testfs
$ sudo mount /dev/sdb1 /demo

# 在第一个挂载点创建一个文件
$ sudo touch /testfs/x

# 查看两个挂载点，文件 x 同时出现在两处
$ ls /testfs /demo
/demo:
x

/testfs:
x
```

> 正因为可在多点挂载一个设备，在 Linux 2.4 及其后续版本中，`umount()` 系统调用不再将设备名作为其参数，而是必须使用挂载点。

#### **14.9.2 多次挂载同一挂载点**

从内核 2.4 开始，Linux 允许针对同一个挂载点执行多次挂载。每次新挂载都会**隐藏**之前可见于挂载点下的目录子树，形成一种“堆叠”效果。卸载最上层的挂载时，其下一次的挂载内容会再次显现。

**演示:**

```bash
# 假设 /dev/sdb1 和 /dev/sdb2 是两个不同的设备
$ sudo mount /dev/sdb1 /testfs
$ sudo touch /testfs/a
$ ls /testfs
a

# 在同一个挂载点上挂载另一个设备
$ sudo mount /dev/sdb2 /testfs
$ sudo touch /testfs/b

# 此时只能看到第二次挂载的内容
$ ls /testfs
b

# 卸载最上层的挂载
$ sudo umount /testfs

# 第一次挂载的内容重新可见
$ ls /testfs
a
```

#### **14.9.3 基于每次挂载的挂载标志**

由于一个文件系统可以被挂载到多个位置，一些挂载标志（mount flags）可以基于**每一次挂载**来独立设置。这允许同一个底层文件系统在不同的挂载点拥有不同的属性。

这些标志包括 `MS_NOATIME`、`MS_NODEV`、`MS_NOEXEC`、`MS_NOSUID`、`MS_RDONLY` 等。

**演示 (使用 `MS_NOEXEC`):**

```bash
# 正常挂载
$ sudo mount /dev/sdb1 /testfs

# 以 noexec (禁止执行) 方式挂载到另一个点
$ sudo mount -o noexec /dev/sdb1 /demo

# 创建一个可执行脚本
$ echo '#!/bin/sh' | sudo tee /testfs/x > /dev/null
$ echo 'echo hello' | sudo tee -a /testfs/x > /dev/null
$ sudo chmod +x /testfs/x

# 在第一个挂载点，脚本可以成功执行
$ /testfs/x
hello

# 在第二个挂载点 (noexec)，脚本执行失败
$ /demo/x
bash: /demo/x: Permission denied
```

#### **14.9.4 绑定挂载**

始于内核版本 2.4，Linux 支持了**绑定挂载 (bind mount)**。它允许将一个已存在的文件或目录挂载到文件系统层级的另一处，使得该文件或目录在两个位置同时可见。

绑定挂载与硬链接类似，但有两点关键区别：

1.  绑定挂载可以跨越不同的文件系统。
2.  绑定挂载可以作用于**目录**。

**演示 (目录):**

```bash
$ mkdir dir1 dir2
$ sudo mount --bind dir1 dir2

# 在 dir1 中创建文件
$ touch dir1/x

# 文件 x 在 dir2 中也可见
$ ls dir1 dir2
dir1:
x

dir2:
x
```

绑定挂载的一个典型应用场景是创建 `chroot` 监禁区（jail），可以将被监禁程序所需的系统目录（如 `/lib`, `/usr`）以只读方式绑定挂载到监禁区内，而无需复制整个目录。

#### **14.9.5 递归绑定挂载**

默认情况下，绑定挂载一个目录时，并**不会**包含该目录下的子挂载点。如果需要将源目录及其内部的所有子挂载一并挂载到新位置，就需要使用**递归绑定挂载 (recursive bind mount)**，即 `mount --rbind`。

**演示:**

```bash
# 1. 准备环境
$ mkdir -p src1 src2 top/sub dir1 dir2
$ touch src1/aaa
$ touch src2/bbb
$ sudo mount src1 top         # 将 src1 挂载到 top
$ sudo mount src2 top/sub     # 在 top 内部创建一个子挂载

# 2. 执行非递归的绑定挂载
$ sudo mount --bind top dir1

# 3. 检查结果：dir1/sub 是一个空目录，子挂载没有被复制
$ ls dir1/sub
# (无输出)

# 4. 执行递归的绑定挂载
$ sudo mount --rbind top dir2

# 5. 检查结果：dir2/sub 包含了 src2 的内容，子挂载被成功复制
$ ls dir2/sub
bbb
```