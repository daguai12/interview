### **14.1 设备专用文件（设备文件）**

设备专用文件（通常简称为设备文件）与系统的某个设备相对应。

在内核中，每种设备类型都有与之相对应的**设备驱动程序（device driver）**，它是一个内核代码单元，用来处理该设备的所有 I/O 请求。设备驱动程序提供了一个固定的、标准化的 API，这些接口对应于 `open()`、`close()`、`read()`、`write()` 等系统调用。这种一致性隐藏了不同硬件设备在操作上的差异，实现了 I/O 操作的通用性。

某些设备是实际存在的物理硬件，比如鼠标、磁盘。而另一些设备则是虚拟的，即不存在相应硬件，但内核通过设备驱动程序提供了一种功能抽象（例如 `/dev/null`）。

#### **设备类型**

可将设备划分为以下两种类型：

  * **字符型设备 (Character devices)**: 基于每个字符来处理数据。终端和键盘都属于字符型设备。
  * **块设备 (Block devices)**: 每次处理一块数据。块的大小取决于设备类型，但通常为 512 字节的倍数。磁盘和磁带设备都属于块设备。

#### **创建和位置**

与其他类型的文件一样，设备文件也出现在文件系统中，通常位于 `/dev` 目录下。超级用户可使用 `mknod` 命令创建设备文件，或者由特权程序（需要 `CAP_MKNOD` 能力）通过 `mknod()` 系统调用来创建。

> `mknod()` 系统调用如今的主要用途就是创建设备文件，一般应用程序很少使用。它曾经也能用于创建 FIFO（现推荐 `mkfifo()`）和目录（现已被 `mkdir()` 取代）。

#### **现代的 /dev 目录**

在 Linux 的早期版本中，`/dev` 目录包含了系统中所有**可能**设备的静态条目，即使某些设备实际并未与系统连接。这导致 `/dev` 目录非常臃肿，并且无法通过它来判断系统中实际存在哪些设备。
从 Linux 2.6 开始，通过 **`udev`** 程序解决了上述问题。`udev` 依赖于 `sysfs` 文件系统（一个挂载于 `/sys` 下的伪文件系统），`sysfs` 将设备和其他内核对象的信息导出到用户空间。`udev` 会监测这些信息，并**动态地**在 `/dev` 目录下创建或删除相应的设备文件，从而确保 `/dev` 目录只包含当前系统中实际存在的设备。

#### **设备 ID**

每个设备文件都有**主 ID (major ID)** 和**辅 ID (minor ID)** 两个编号。

  * **主 ID 号**: 标识一般的设备等级（或类型）。内核使用主 ID 号来查找并调用与该类设备相应的**驱动程序**。
  * **辅 ID 号**: 在同一个设备驱动程序管理的设备中，唯一标识一个**特定的设备实例**。

命令 `ls –l` 可显示出设备文件的主、辅 ID。

```bash
$ ls -l /dev/sda /dev/tty
brw-rw---- 1 root disk      8,   0 Sep  9 08:30 /dev/sda
crw-rw-rw- 1 root tty       5,   0 Sep  9 11:25 /dev/tty
```

  * 在上面的输出中，`/dev/sda` (一个磁盘，块设备) 的主 ID 是 8，辅 ID 是 0。
  * `/dev/tty` (一个终端，字符设备) 的主 ID 是 5，辅 ID 是 0。

设备文件和设备驱动程序之间的关系是通过主 ID 建立的。每个设备驱动程序都会向内核注册自己与一个特定主设备号的关联关系。当操作一个设备文件时，内核查看其主 ID，就知道该调用哪个驱动程序。**内核是不会使用设备文件名来查找驱动程序的**。

**ID 位数演变**:

  * **Linux 2.4及更早版本**: 主、辅 ID 都只能用 8 位数来表示，限制了系统可以支持的设备总数。
  * **Linux 2.6及之后版本**: 采用了更多位数来存放主、辅 ID（分别为 12 位和 20 位），从而极大地扩展了系统可支持的设备数量。