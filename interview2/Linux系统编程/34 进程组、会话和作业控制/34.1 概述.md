好的，这是根据您提供的文本内容，保留原始结构和标题整理的结果。

### **34.1 概述**

本节概述了进程组、会话和控制终端等用于 shell 作业控制的核心概念。

#### **进程组 (Process Group)**

  * **定义**: 一个或多个共享同一**进程组标识符 (PGID)** 的进程组成的集合。PGID 的类型是 `pid_t`。
  * **进程组首进程**: 创建该组的进程，其**进程 ID (PID) 会成为该进程组的 ID (PGID)**。
  * **继承**: 新创建的进程会继承其父进程的 PGID。
  * **生命周期**: 从首进程创建组开始，到最后一个成员进程退出（终止或加入另一个组）结束。

#### **会话 (Session)**

  * **定义**: 一个或多个进程组的集合。
  * **会话标识符 (SID)**: 同一个会话中的所有进程共享一个 SID。SID 的类型是 `pid_t`。
  * **会话首进程**: 创建新会话的进程，其**进程 ID (PID) 会成为会话 ID (SID)**。
  * **继承**: 新创建的进程会继承其父进程的 SID。

#### **控制终端、前台与后台 (Controlling Terminal, Foreground & Background)**

  * **控制终端**: 一个会话中的所有进程共享单个**控制终端**。控制终端在会话首进程首次打开一个终端设备时建立。
  * **前台进程组**: 在任一时刻，会话中只有一个进程组是**前台进程组 (foreground process group)**。
  * **后台进程组**: 会话中所有其他的进程组都是**后台进程组 (background process groups)**。
  * **终端交互**:
      * **输入**: 只有**前台进程组**中的进程才能从控制终端读取输入。
      * **信号**: 当用户在控制终端输入信号生成字符时（如 `Ctrl-C` 对应 `SIGINT`，`Ctrl-Z` 对应 `SIGTSTP`），信号会被发送给**前台进程组中的所有成员**。

#### **控制进程 (Controlling Process)**

  * **定义**: 当控制终端被建立后，**会话首进程**会成为该终端的**控制进程**。
  * **主要作用**: 当到终端的连接断开时（例如，用户关闭终端窗口或网络断线），内核会向控制进程发送一个 `SIGHUP` 信号。

> **查看信息**: 通过检查 Linux 特有的 `/proc/PID/stat` 文件，可以确定任意进程的进程组 ID (PGID) 和会话 ID (SID)。

-----

#### **主要用途：Shell 作业控制**

会话和进程组的主要用途是实现 shell 的作业控制。以一个典型的终端窗口为例：

1.  启动的 **shell** 是**会话首进程**、**控制进程**，并且是其自身进程组的唯一成员。
2.  当你在 shell 中执行一个命令（例如 `ls -l`）或一个管道（例如 `cat file | grep key`）时，shell 会创建一个或多个新进程。
3.  shell 会将这些新进程放入一个**新的进程组**中。
4.  如果命令在前台运行，这个新进程组就是**前台进程组**。
5.  如果命令以 `&` 结尾在后台运行，这个新进程组就是一个**后台进程组**。

#### **示例关系图**

![[Pasted image 20250911104721.png]]


# 这张图在做什么（总览）

图名是 **“进程组、会话和控制终端之间的关系”**（会话 400）。
图把一个会话（SID=400）内部的几个元素画了出来：会话首进程（bash，PID=400）、该会话内的不同**进程组**（PGID=400、658、660），以及**控制终端**当前的前台进程组（前端 PGID=660）。
下面我把图中每一块、每一条箭头、每一个字段逐一解释，并给出相关的行为/系统调用、以及典型的运行时场景（比如按 Ctrl+C、后台作业读终端时会怎样）。

---

# 图中主要框与字段含义（逐项解释）

## 1. 外层虚线框：`会话 400`（SID = 400）

* 这是一个 **会话（session）**，ID 为 400（SID=400）。
* 会话是进程组的集合，表示一组由同一会话首进程管理的所有进程/进程组。
* 会话通常与一个控制终端（controlling terminal）关联，在图里控制终端的“控制SID=400”说明该终端被绑定到会话 400。

## 2. 会话首进程（左上，`bash`）

方框中列出的字段：

* `PID = 400`：bash 的进程号。
* `PPID = 399`：bash 的父进程是 PID 399（可能是终端模拟器/登录进程启动它）。
* `PGID = 400`：bash 自身所属的**进程组 ID**是 400（说明 bash 是它自己进程组的组长）。
* `SID = 400`：bash 的会话 ID 是 400；`SID == PID`说明 bash 是该会话的**会话首进程（session leader）**。

作用与地位：

* bash 是会话 leader（控制进程），负责创建/管理作业（job）、启动子进程并为它们设定进程组、把某个进程组设为前台/后台等。
* shell（bash）通过 `setsid()`（或终端模拟器在创建 pty/exec 时）来建立会话/控制终端关系（图里 bash 已是该会话的 leader）。

## 3. 中间的两个进程组：`进程组 658`（find / wc）与 `进程组 660`（sort / uniq）

每个小盒子里也写了进程各自的四元属性（PID, PPID, PGID, SID）：

举例 `进程组 658`：

* `find`：`PID=658, PPID=400, PGID=658, SID=400`（find 是该组的组长，PGID=其 PID）
* `wc`：`PID=659, PPID=400, PGID=658, SID=400`（被放到同一个组 658）

举例 `进程组 660`：

* `sort`：`PID=660, PPID=400, PGID=660, SID=400`（组长）
* `uniq`：`PID=661, PPID=400, PGID=660, SID=400`

要点：

* 这些进程都是由 shell (`PPID=400`) fork 出来的（所以 PPID=400）。
* 它们继承同一个会话（SID=400），但被分配到不同的 **进程组（PGID）**。
* 进程组通常由其中一个进程作为**组长**（组长的 PID == PGID），shell 在创建 pipeline 或作业时会把同一 pipeline 的各个子进程放到同一个进程组。

---

## 4. 控制终端（下方矩形）

内容：`前端 PGID = 660`，`控制 SID = 400`。

含义：

* 控制终端记录两个重要信息：

  * 它属于哪个会话（控制 SID = 400，即会话 400 拥有这个控制终端）。
  * 当前哪个进程组是**前台进程组**（Front PGID = 660）。前台进程组能够直接读写该终端并会接收由终端产生的控制信号（Ctrl+C、Ctrl+Z 等）。
* 这里说明：`进程组 660`（即 sort/uniq）当前是前台作业；而 `进程组 658`（find/wc）在后台运行（后台进程组）。

---

# 图中箭头/虚线的语义（行为关系）

* 虚线把属于同一会话的进程/进程组包起来（会话 400 的边界）。
* 每个进程组的虚线框表示“属于同一进程组”——同组成员共享 PGID。
* 从控制终端指向 `进程组 660` 的箭头表示：控制终端把 `PGID=660` 设为**前台进程组**（所以当用户按 Ctrl+C，内核会把 `SIGINT` 广播到 PGID=660 的所有进程）。
* 图左侧的箭头标注“控制进程 / 会话首进程”指向 bash，表示 bash 是管理这些作业/进程组的控制点（它用 job control 的系统调用管理前后台）。

---

# 典型的执行/系统调用流程（shell 如何创建这些进程组并切换前后台）

以用户在 shell 执行两条命令为例（一个在前台，一个在后台）：

1. shell 解析命令：假设 `sort | uniq`（前台），`find | wc &`（后台）。
2. shell 为每个 pipeline fork 多个子进程：

   * 对 `sort | uniq`：

     * shell fork 第一个子进程（sort），在子进程中通常会调用 `setpgid(0, leader_pid)`（或父进程在 fork 后调用 `setpgid(child_pid, leader_pid)`）把它放入新组 `PGID=660`；第一个子通常成为组长（PGID==PID）。
     * shell fork 第二个子进程（uniq），并把它的 PGID 设置为 660（与组长相同）。
     * shell 在启动完该 pipeline 后会调用 `tcsetpgrp(tty_fd, 660)` 把终端的前台进程组改为 660，这样 kernel 会把终端产生的控制信号（Ctrl+C/TSTP 等）发给 660 的所有进程。
3. 对 `find | wc &`：

   * shell 同样 fork 两个子进程并把它们置于 `PGID=658`。
   * 但因为该作业以 `&` 后台方式运行，shell **不**把前台 PGID 改为 658；终端的前台仍是 PGID=660。shell 也不会等待 658 结束，而是立即回到提示符。
4. 当前台作业结束或 shell 要回到提示符时，shell 会调用 `tcsetpgrp(tty_fd, shell_pgid)`（即把前台 PGID 重新设置为 shell 的 PGID），并继续等待/收集子进程的状态（`waitpid` 等）。

---

# 与终端相关的信号行为（重要）

* 当用户按 `Ctrl+C`：内核会把 `SIGINT` 广播给**前台进程组**（在图中为 PGID=660），sort/uniq 都会收到 SIGINT。
* 当后台进程组试图 **读** 控制终端：内核会向该后台进程组发送 `SIGTTIN`（默认行为是把进程组停止）；这保证了后台作业不会直接从终端读取输入。
* 类似地，写终端的后台进程可能触发 `SIGTTOU` 或会被简单拒绝，具体依赖终端设置。
* `Ctrl+Z`：会发送 `SIGTSTP` 给前台进程组，从而把整个作业挂起（shell 后续可用 `fg` 恢复）。

---

# 补充说明 / 常见问题

* **为什么 PGID 等于某个进程的 PID？**
  因为进程组 ID 通常取某个组长进程的 PID（该进程成为组长）。因此进程组号和组长进程 PID 相同只是约定。

* **为什么 SID = PID（会话首进程）重要？**
  如果某进程的 SID 等于它自己的 PID，说明它创建了会话（它是会话 leader）。通常这个会话 leader 会和一个控制终端关联，并启动该会话中的 shell。

* **如果会话首进程退出会怎样？**
  会话仍然存在（进程仍有 SID=400），但没有“首进程”活着（会话 leader 已退出）。控制终端的控制 SID 仍指向该会话 ID，但行为上可能变复杂（通常终端仍把信号发给当前前台 PGID）。许多实现里会话/控制终端的管理细节依赖于谁打开了 tty slave，以及进程谁调用了 `setsid()` 等。

* **如何在真实系统上查看这些字段？**
  可以用 `ps`：

  ```bash
  ps -o pid,ppid,pgrp,sid,comm
  ```

  `tty` 命令显示当前进程的终端设备；`jobs`、`fg`、`bg` 显示/管理作业。

---

# 小结（把重点再说一遍）

* **会话（SID）** 是更大的容器，包含若干进程组；会话有会话首进程（session leader），通常是 shell。
* **进程组（PGID）** 是一组进程，用于信号广播（终端信号、job-control 信号都会发送到进程组）。
* **控制终端** 记录它属于哪个会话（控制 SID）以及哪个进程组是当前**前台进程组（front PGID）**。
* 图示中：bash（PID=400）是 session leader（SID=400）；shell 启动了两组子进程（PGID=658 与 PGID=660），其中 PGID=660 当前是前台，PGID=658 在后台。

---

如果你愿意，我可以：

* 把上面的流程改成 **命令行实际示例**（演示 `ps`、`jobs`、`fg/bg`、`tcsetpgrp` 的输出与变化），或
* 画一张 **时序图**（shell fork → setpgid → tcsetpgrp → 内核信号广播）来更直观地说明前台/后台切换时的调用顺序。要哪一种？
