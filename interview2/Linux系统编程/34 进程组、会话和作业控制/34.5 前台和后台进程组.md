### **34.5 前台和后台进程组**

**控制终端 (controlling terminal)** 保留了**前台进程组 (foreground process group)** 的概念。在一个会话中，同一时刻最多只能有一个进程组成为前台进程组，该会话中的其他所有进程组都是**后台进程组 (background process groups)**。

前台进程组拥有两项特权：

1.  它是唯一能够自由地从**控制终端读取输入**的进程组。
2.  当用户在控制终端中输入信号生成字符（如 `Ctrl-C`）时，终端驱动程序会将相应的信号发送给**前台进程组的所有成员**。

理论上，一个会话可能会暂时没有前台进程组（例如，当前台任务结束后，shell 尚未将自己移至前台的短暂瞬间），但这在实践中非常少见。

#### **管理函数**

`tcgetpgrp()` 和 `tcsetpgrp()` 函数分别用于获取和修改一个终端的前台进程组。这些函数主要供作业控制 shell（如 `bash`）使用。

  * **`tcgetpgrp()`**: 获取前台进程组 ID

    ```c
    #include <unistd.h>

    pid_t tcgetpgrp(int fd);
    ```

    该函数返回文件描述符 `fd` 所指定的终端的**当前前台进程组的 PGID**。`fd` 必须是调用进程的控制终端。

      * 如果该终端没有前台进程组，`tcgetpgrp()` 会返回一个大于 1 且与所有现有进程组 ID 都不匹配的值。

  * **`tcsetpgrp()`**: 设置前台进程组 ID

    ```c
    #include <unistd.h>

    int tcsetpgrp(int fd, pid_t pgid);
    ```

    该函数将 `fd` 所引用的终端的**前台进程组设置为 `pgid`**。

      * **调用限制**: `pgid` 必须是调用进程**所属会话中**的一个现有进程组的 ID。

这两个函数在 SUSv3 中都被标准化了。在 Linux 上，它们是通过两个非标准的 `ioctl()` 操作 `TIOCGPGRP` 和 `TIOCSPGRP` 来实现的。

#### **Shell 如何使用它们？**

这两个函数是实现作业控制（Job Control）的核心。

1.  当你运行一个前台命令（如 `sleep 100`）时，你的 shell 会调用 `tcsetpgrp()`，将 `sleep` 进程所在的新进程组设置为前台进程组。此时，只有 `sleep` 进程能接收 `Ctrl-C` 等信号。
2.  当你按下 `Ctrl-Z` 挂起 `sleep` 进程时，`sleep` 进程被暂停，shell 会收到通知。
3.  shell 接着会再次调用 `tcsetpgrp()`，将**它自己所在的进程组**重新设置为前台进程组。
4.  这样，shell 就重新获得了对终端的控制权，可以接收你的下一个命令输入。