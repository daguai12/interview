### **34.2 进程组**

每个进程都拥有一个进程组 ID (PGID)，表示该进程所属的进程组。新进程会继承其父进程的 PGID。

#### **获取进程组 ID**

使用 `getpgrp()` 能够获取调用进程的进程组 ID。

```c
#include <unistd.h>

pid_t getpgrp(void);
```

如果 `getpgrp()` 的返回值与调用进程的 PID 匹配，那么该进程就是其所在进程组的**首进程 (leader)**。

#### **修改进程组 ID**

`setpgid()` 系统调用将进程 ID 为 `pid` 的进程的 PGID 修改为 `pgid`。

```c
#include <unistd.h>

int setpgid(pid_t pid, pid_t pgid);
```

  * 如果 `pid` 为 0，则使用调用进程的 PID。
  * 如果 `pgid` 为 0，则使用 `pid` 参数指定的进程的 PID 作为 PGID。

因此，以下两个调用是等价的，它们都会创建一个新进程组，并使调用进程成为该组的首进程：

```c
setpgid(0, 0);
setpgid(getpid(), getpid());
```

##### **`setpgid()` 的限制**

在调用 `setpgid()` 时存在以下限制：

  * `pid` 参数只能指定调用进程或其子进程之一。
  * 当在组之间移动进程时，相关的所有进程（调用者、目标进程）以及目标进程组必须属于**同一个会话**。
  * `pid` 参数所指定的进程**不能是会话首进程**。
  * 一个进程在其子进程已经执行 `exec()` **之后**，就**无法**再修改该子进程的进程组 ID 了（会返回 `EACCES` 错误）。

#### **在作业控制 shell 中使用 setpgid()**

“`exec()` 后无法修改 PGID”的约束条件对作业控制 shell 的设计有重要影响，因为它必须解决一个**竞争条件 (race condition)**。

  * **问题**: `fork()` 之后，父进程和子进程的调度顺序是不确定的。父进程无法保证在子进程调用 `exec()` 之前修改子进程的 PGID；子进程也无法保证在父进程向其发送信号之前修改自身的 PGID。
  * **解决方案**: 为避免竞争，父进程和子进程**都**应该尝试去设置子进程的 PGID。无论哪个先执行，都会成功设置。后一个执行的会因为 PGID 已被设置而收到 `EACCES` 错误，这个错误应该被忽略。

**程序清单 34-1：作业控制 shell 程序如何设置子进程的进程组 ID**

```c
// 在一个作业控制 shell 中
pid_t child_pid;
int status;

setpgid(0, 0); // 让 shell 成为它自己的进程组首进程

switch (child_pid = fork()) {
case -1: /* fork() failed */
    perror("fork");
    break;

case 0: /* Child */
    // 子进程和父进程都尝试设置子进程的 PGID。
    // 无论谁先运行，都能确保在 exec() 前完成设置。
    setpgid(0, 0); 
    execve(program, argv, envp);
    _exit(EXIT_FAILURE); // exec() 失败时退出

default: /* Parent */
    // 父进程和子进程都尝试设置子进程的 PGID。
    setpgid(child_pid, child_pid); 
    
    // ... 父进程的其他操作，比如将子进程置于前台 ...
    
    waitpid(child_pid, &status, 0);
    break;
}
```

> **处理管道**: 在处理由管道符连接的命令时，shell 会记录管道中第一个进程的 PID，并使用这个值作为该管道中所有进程的 PGID。

#### **获取和修改进程组 ID 的其他（过时的）接口**

历史上存在过多个功能相似但有细微差别的函数，如 `getpgrp(pid)`、`setpgrp(pid, pgid)` 等。POSIX 标准化了 `getpgrp(void)` 和 `setpgid(pid, pgid)` 作为首选接口，因为它们提供了更清晰、更安全的语义。

尽管如此，为了向后兼容，与其他大多数 UNIX 实现一样，Linux 也提供了 `getpgid(pid)` (获取任一进程的 PGID) 和 `setpgrp(void)` (等价于 `setpgid(0, 0)`)。