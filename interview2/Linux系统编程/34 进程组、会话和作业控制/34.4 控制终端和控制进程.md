### **34.4 控制终端和控制进程**

一个会话中的所有进程可能会拥有一个（且只有一个）**控制终端 (controlling terminal)**。

#### **建立控制终端**

  * **时机**: 会话在刚被创建时是没有控制终端的。当**会话首进程**首次 `open()` 一个尚未成为任何会话控制终端的终端设备时，该终端就会成为这个新会话的控制终端。
  * **阻止**: 可以在 `open()` 时指定 `O_NOCTTY` 标记来阻止上述行为的发生。
  * **唯一性**: 一个终端设备至多只能成为一个会话的控制终端。
  * **获取会话ID**: `tcgetsid(int fd)` 函数可以返回与文件描述符 `fd` 指定的控制终端相关联的会话 ID (SID)。
  * **继承**: 控制终端会被 `fork()` 创建的子进程继承，并且在 `exec()` 调用后得到保持。

当会话首进程打开一个控制终端之后，它同时也成为了该终端的**控制进程 (controlling process)**。当发生终端断开（hangup）事件时，内核会向控制进程发送一个 `SIGHUP` 信号。

##### **System V 与 BSD 的差异**

  * **System V (及 Linux)**: 建立控制终端是**隐式**的。会话首进程打开终端时自动建立（除非指定 `O_NOCTTY`）。
  * **BSD**: 建立控制终端是**显式**的。会话首进程需要先打开一个终端，然后使用 `ioctl()` 的 `TIOCSCTTY` 操作来显式地将该终端设置为控制终端。

#### **特殊文件 /dev/tty**

如果一个进程拥有一个控制终端，那么它就可以通过打开特殊文件 `/dev/tty` 来获取该终端的一个文件描述符。

  * **用途**: 这对于一个程序在标准输入和输出被重定向之后，仍需要确保自己确实在与控制终端进行通信的场景下很有用（例如，`getpass()` 函数读取密码时会打开 `/dev/tty`）。
  * **无控制终端**: 如果进程没有控制终端（例如一个守护进程），那么在打开 `/dev/tty` 时会失败，`errno` 被置为 `ENXIO`。

#### **断开与控制终端的关联**

  * **主动断开**: 使用 `ioctl(fd, TIOCNOTTY)` 操作能够删除进程与文件描述符 `fd` 指定的控制终端之间的关联关系。
  * **被动断开 (控制进程终止)**: 如果一个会话的控制进程终止，会发生下列事情：
    1.  该会话中的**所有进程**都将失去与控制终端的关联关系。
    2.  该终端不再与此会话关联，因此可以被另一个新的会话首进程获取。
    3.  内核会向前台进程组的所有成员发送一个 `SIGHUP` 信号（和一个 `SIGCONT` 信号）。

#### **获取控制终端路径名：ctermid()**

`ctermid()` 函数返回一个表示控制终端路径名的字符串。

```c
#include <stdio.h>

char *ctermid(char *ttyname);
```

  * 如果 `ttyname` 不为 `NULL`，它必须是一个大小至少为 `L_ctermid` 字节的缓冲区，路径名会被复制进这个数组中。
  * 如果 `ttyname` 为 `NULL`，`ctermid()` 返回一个指向**静态分配**的缓冲区的指针（此用法不可重入）。
  * 在 Linux 和其他多数 UNIX 实现中，`ctermid()` 通常只会生成固定的字符串 `"/dev/tty"`。这个函数的存在主要是为了程序的可移植性。