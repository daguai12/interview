### **34.6 SIGHUP 信号**

当一个**控制进程 (controlling process)** 失去其终端连接之后，内核会向其发送一个 `SIGHUP` 信号来通知它这一事实。（同时还会发送一个 `SIGCONT` 信号，以确保该进程如果之前被停止，能够被唤醒以处理 `SIGHUP`）。

这种情况通常会在以下两个场景中出现：
* 终端驱动器检测到物理连接断开，例如调制解调器（Modem）或串口线断开。
* 用户关闭了工作站上的终端窗口。这会导致与该窗口关联的伪终端的主设备文件描述符被关闭，从而被内核视作连接断开。

`SIGHUP` 信号的默认处理方式是**终止进程**。如果控制进程处理（捕获）或忽略了这个信号，那么它后续尝试从该终端读取数据的请求将会返回文件结束（EOF）的错误。

#### **SIGHUP 信号的“链式反应”**

向控制进程发送 `SIGHUP` 信号通常会引起一种链式反应，从而导致将 `SIGHUP` 信号发送给会话中的很多其他进程。这个过程主要通过以下两种方式发生：

1.  **由 Shell 转发**:
    * 控制进程通常是一个 shell（如 `bash`）。
    * Shell 会捕获 `SIGHUP` 信号。在其自己的处理器（handler）中，它会在终止之前，显式地将 `SIGHUP` 信号发送给由它所创建的各个作业（即进程组）。
    * 这样，这些子任务就知道它们的父 shell 已经终止了。

2.  **由内核发送**:
    * 当控制进程终止时（无论是被 `SIGHUP` 的默认行为终止，还是自己退出），内核会进行一系列清理工作。
    * 作为清理的一部分，内核会向该终端的**前台进程组的所有成员**发送一个 `SIGHUP` 信号，以通知它们已经失去了控制终端。

#### **SIGHUP 的其他用途**

`SIGHUP` 信号也被用于与终端断开无关的其他场景：

* 当一个进程组成为**孤儿进程组**时，内核会向其成员发送 `SIGHUP` 信号（将在 34.7.4 节介绍）。
* 按照惯例，系统管理员或脚本会**手动**向守护进程（daemon）发送 `SIGHUP` 信号，以此来触发守护进程**重新初始化自身或重新读取其配置文件**。
    > （根据定义，守护进程没有控制终端，因此它不会因为终端断开而从内核接收 `SIGHUP` 信号。这纯粹是一种广泛使用的软件约定。）

#### **34.6.1 在 shell 中处理 SIGHUP 信号**

在登录会话中，shell 通常是终端的控制进程。大多数交互式 shell 会为 `SIGHUP` 信号建立一个处理器。这个处理器的作用是：在 shell 自身终止之前，先向由它创建的**所有进程组（作业）**，包括前台和后台的，发送一个 `SIGHUP` 信号。

这样，由 shell 启动的所有任务都会得知会话已经结束。如果不采取特殊动作，这些任务会因 `SIGHUP` 的默认行为而终止。

> **避免 SIGHUP**:
>
>   * `nohup(1)` 命令可以用来使一个命令对 `SIGHUP` 信号免疫（即忽略该信号）。
>   * `bash` 内置的 `disown` 命令可以将一个后台任务从 shell 的作业列表中移除，这样 shell 终止时就不会向该任务发送 `SIGHUP` 信号了。

##### **程序示例**

程序清单 34-3 演示了 shell 接收 `SIGHUP` 并将其转发给由它创建的进程组的过程。

**程序清单 34-3：捕获 SIGHUP 信号**

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>
#include <string.h>
#include <time.h>

#define SYNC_SIG SIGUSR1 // 用于同步父子进程的信号

// SIGHUP 信号处理器
static void handler(int sig) {
    time_t t;
    time(&t);
    printf("PID %ld: caught signal %d (%s) at %s", 
           (long) getpid(), sig, strsignal(sig), ctime(&t));
    // 在实际应用中，这里应该做清理工作
}

int main(int argc, char *argv[]) {
    pid_t child_pid;
    struct sigaction sa;

    setbuf(stdout, NULL); // 关闭标准输出缓冲

    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;
    sa.sa_handler = handler;
    if (sigaction(SIGHUP, &sa, NULL) == -1) {
        perror("sigaction SIGHUP");
        exit(EXIT_FAILURE);
    }
    if (sigaction(SIGCONT, &sa, NULL) == -1) {
        perror("sigaction SIGCONT");
        exit(EXIT_FAILURE);
    }

    child_pid = fork();
    if (child_pid == -1) {
        perror("fork");
        exit(EXIT_FAILURE);
    }

    if (child_pid == 0) { // 子进程
        // 如果提供了命令行参数，子进程将自己放入一个新的进程组
        if (argc > 1) {
            if (setpgid(0, 0) == -1) {
                perror("setpgid in child");
                exit(EXIT_FAILURE);
            }
        }
        printf("Child: PID=%ld PGID=%ld\n", (long) getpid(), (long) getpgrp());
        // 循环等待信号
        for (;;) {
            pause();
        }
    } else { // 父进程
        printf("Parent: PID=%ld PGID=%ld\n", (long) getpid(), (long) getpgrp());
        // 循环等待信号
        for (;;) {
            pause();
        }
    }
}
```

**运行演示**:
假设在一个终端窗口中编译并运行该程序的两个实例，然后关闭终端窗口：

```bash
# 实例1：子进程和父进程在同一个进程组
$ ./a.out > samegroup.log &

# 实例2：子进程在不同的进程组
$ ./a.out d > diffgroup.log &
```

关闭终端窗口后，`SIGHUP` 被发送给 shell，shell 再将其转发。

  * 查看 `samegroup.log`，会发现父进程和子进程都收到了 `SIGHUP` 信号，因为它们同属于 shell 创建的进程组。
  * 查看 `diffgroup.log`，会发现**只有父进程**收到了 `SIGHUP` 信号。因为子进程创建了自己的进程组，shell 不会向它不“拥有”的进程组发送信号。

-----

#### **34.6.2 SIGHUP 和控制进程的终止**

`SIGHUP` 链式反应的第二种机制是由内核驱动的。

  * **规则**: 如果一个**控制进程**因为任何原因终止了，内核会自动向当时处于**前台的进程组**的所有成员发送一个 `SIGHUP` 信号（在 Linux 上，还会紧跟着一个 `SIGCONT` 信号）。
  * **关键点**: 这个行为是**控制进程终止**的结果，而不是终端断开的直接结果。

##### **程序示例**

程序清单 34-4 演示了这一机制。程序通过 `exec` 启动，使其自身成为控制进程。

**程序清单 34-4：在终端断开发生时捕获 SIGHUP 信号**

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>
#include <string.h>

static void handler(int sig) {
    // 不安全：在信号处理器中使用了 printf
    printf("PID %ld: caught signal %2d (%s)\n", (long) getpid(), sig, strsignal(sig));
}

int main(int argc, char *argv[]) {
    if (argc < 2 || strcmp(argv[1], "--help") == 0) {
        fprintf(stderr, "Usage: %s {s|d}...\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    setbuf(stdout, NULL);

    // 成为会话首进程（如果由 exec 启动，此步非必须，但无害）
    if (getpgrp() != getpid()) {
        if (setsid() == -1) perror("setsid");
    }

    // 设置 SIGHUP 信号处理器
    struct sigaction sa;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;
    sa.sa_handler = handler;
    if (sigaction(SIGHUP, &sa, NULL) == -1) perror("sigaction");

    printf("Parent PID=%ld, PGID=%ld, SID=%ld\n", 
           (long) getpid(), (long) getpgrp(), (long) getsid(0));

    // 根据命令行参数创建子进程
    for (int j = 1; j < argc; j++) {
        switch (fork()) {
        case -1:
            perror("fork");
            exit(EXIT_FAILURE);
        case 0: // 子进程
            printf("Child PID=%ld, PGID=%ld\n", (long) getpid(), (long) getpgrp());
            // 如果参数是 'd'，则子进程创建自己的进程组（成为后台组）
            if (argv[j][0] == 'd') {
                if (setpgid(0, 0) == -1) perror("setpgid");
            }
            // 循环等待信号
            for (;;) pause();
        default: // 父进程
            break;
        }
    }
    
    // 父进程也循环等待信号
    for (;;) pause();
}
```

**运行演示**:
在一个终端窗口中，使用 `exec` 命令运行程序。`exec` 会用新程序替换当前的 shell，从而使新程序成为该终端的**控制进程**。

```bash
# s 表示子进程与父进程在同一组（前台组）
# d 表示子进程在不同组（后台组）
$ exec ./a.out s s d > sig.log
```

执行此命令后，立即**关闭该终端窗口**。这会导致内核向控制进程（我们的父进程）发送 `SIGHUP`，使其终止。

查看 `sig.log` 文件，会看到类似下面的输出：

```
Parent PID=12345, PGID=12345, SID=12345
Child PID=12346, PGID=12345
Child PID=12347, PGID=12345
Child PID=12348, PGID=12348  <-- 不同的 PGID
PID 12345: caught signal  1 (Hangup)
PID 12346: caught signal  1 (Hangup)
PID 12347: caught signal  1 (Hangup)
```

**输出解读**:

  * 控制进程（父进程，PID 12345）收到了 `SIGHUP` 并终止。
  * 两个与父进程同组的子进程（PID 12346, 12347）也收到了 `SIGHUP`，因为它们属于**前台进程组**。
  * 位于自己进程组中的子进程（PID 12348）**没有**收到 `SIGHUP`，因为它是一个**后台进程组**。