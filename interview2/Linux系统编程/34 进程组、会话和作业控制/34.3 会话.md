### **34.3 会话**

会话是一组进程组的集合。一个进程的会-话成员关系是由其**会话 ID (SID)** 来定义的。新进程会继承其父进程的 SID。

#### **获取会话 ID**

`getsid()` 系统调用会返回 `pid` 指定的进程的会话 ID。

```c
#include <unistd.h>

pid_t getsid(pid_t pid);
```

如果 `pid` 参数的值为 0，那么 `getsid()` 会返回调用进程的 SID。在 Linux 中，一个进程可以获取系统上任意进程的 SID。

#### **创建新会话**

`setsid()` 系统调用用于创建一个新会话。

```c
#include <unistd.h>

pid_t setsid(void);
```

##### **`setsid()` 的调用限制**

`setsid()` 的调用有一个关键限制：**调用进程不能是进程组首进程**。如果违反此规则，调用会失败并返回 `EPERM` 错误。

为满足这个条件，标准的做法是：

1.  调用 `fork()` 创建一个子进程。
2.  父进程立即退出。
3.  子进程调用 `setsid()`。

这个方法之所以有效，是因为子进程继承了父进程的 PGID，但拥有一个自己唯一的 PID。因此，子进程的 PID 肯定不等于其 PGID，从而保证了子进程**不是**一个进程组首进程。

##### **`setsid()` 调用步骤**

当一个非进程组首进程的进程成功调用 `setsid()` 时，会发生以下事情：

1.  该进程成为一个**新会话的首进程**。该进程的 PID 成为新的会话 ID (SID)。
2.  该进程同时成为一个**新进程组的首进程**。该进程的 PID 成为新的进程组 ID (PGID)。
3.  该进程会**脱离其控制终端**（如果它之前有的话）。因为一个会话只能有一个控制终端，而新会话还没有终端。

这个严格的两级层次（一个进程组的所有成员必须属于同一个会话）是 `setsid()` 限制调用者的主要原因。

-----

#### **程序示例**

程序清单 34-2 演示了使用 `setsid()` 来创建一个新会话。为了验证进程已经不再拥有控制终端，程序最后会尝试打开特殊文件 `/dev/tty`。

**程序清单 34-2 创建一个新会话**

```c
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>

int main(int argc, char *argv[]) {
    // fork() 以确保我们不是进程组首进程
    switch (fork()) {
        case -1:
            perror("fork");
            exit(EXIT_FAILURE);
        case 0:
            // 子进程继续执行
            break;
        default:
            // 父进程退出
            _exit(EXIT_SUCCESS);
    }

    // 在子进程中...
    printf("Child PID=%ld, PGID=%ld, SID=%ld\n",
           (long) getpid(), (long) getpgrp(), (long) getsid(0));
    
    // 创建新会话
    if (setsid() == -1) {
        perror("setsid");
        exit(EXIT_FAILURE);
    }
    printf("Successfully created new session.\n");

    printf("Child PID=%ld, PGID=%ld, SID=%ld\n",
           (long) getpid(), (long) getpgrp(), (long) getsid(0));

    // 检查我们是否还有控制终端
    int fd = open("/dev/tty", O_RDWR);
    if (fd == -1) {
        perror("open /dev/tty");
        printf("Process has no controlling terminal.\n");
    } else {
        printf("Process has a controlling terminal.\n");
        close(fd);
    }

    // 让子进程存活一段时间，以便我们观察
    sleep(30);

    exit(EXIT_SUCCESS);
}
```

**编译和运行演示:**

```bash
$ gcc new_session.c -o new_session
$ ./new_session
[1] 12346  # shell 报告父进程已退出，子进程在后台运行
$ Child PID=12347, PGID=12345, SID=12345
Successfully created new session.
Child PID=12347, PGID=12347, SID=12347
open /dev/tty: No such device or address
Process has no controlling terminal.
```

**输出解读**:

  * 父进程（PID 12346）在 `fork()` 后立即退出，shell 马上显示了下一个提示符。
  * 子进程（PID 12347）继续运行。它最初的 PGID 和 SID 都继承自父进程（12345）。
  * 子进程成功调用 `setsid()`，它的 PGID 和 SID 都变成了它自己的 PID（12347）。
  * 最后，`open("/dev/tty")` 失败，错误为 `No such device or address`，这证明了该进程已成功脱离其控制终端。