### **34.7 作业控制**

作业控制（Job Control）是现代 shell 的一项强大特性，它允许用户在单个终端会话中同时执行多个命令（作业），并能在前台和后台之间切换它们。

#### **34.7.1 在 shell 中使用作业控制**

以下是一个简短的入门指南，介绍 shell 作业控制的常用命令和概念。

##### **后台运行作业 (`&`)**

在命令末尾添加 `&` 符号，可以使该命令作为一个后台作业运行。

```bash
$ sleep 100 &
[1] 12345
```

  * shell 会为后台的每个作业赋一个唯一的**作业号**（上例中为 `[1]`）。
  * 作业号后面的数字 `12345` 是该作业中最后一个进程的 PID。
  * 可以使用 `%num`（例如 `%1`）来引用特定的作业。`%%` 或 `%+` 指的是当前作业。

##### **列出作业 (`jobs`)**

`jobs` 是一个 shell 内置命令，它会列出所有后台作业及其状态。

```bash
$ jobs
[1] + Running                 sleep 100 &
[2] - Stopped                 vim my_file.txt
```

  * `+` 号标记的是“当前作业”，`-` 号标记的是“上一个当前作业”。

##### **将作业移至前台 (`fg`)**

`fg` 命令可以将一个后台作业移动到前台，使其可以与终端交互。

```bash
$ fg %1
sleep 100
```

  * `fg` 后面可以跟作业号，如果省略，则默认操作“当前作业”(`+`)。

##### **挂起前台作业 (`Ctrl-Z`) 与恢复 (`bg`)**

  * **挂起**: 当一个作业在前台运行时，按下\*\*`Ctrl-Z`**，终端会向前台进程组发送一个 `SIGTSTP` 信号，这会**挂起（暂停）\*\*该作业，并将其置于后台。
    ```bash
    $ sleep 100
    ^Z
    [1]+  Stopped                 sleep 100
    ```
  * **恢复**:
      * 使用 `fg` 命令可以在**前台**恢复这个被停止的作业。
      * 使用 `bg` 命令可以在**后台**恢复这个被停止的作业。
      * 无论是 `fg` 还是 `bg`，shell 都会通过向该作业发送一个 `SIGCONT` 信号来使其恢复运行。

##### **停止后台作业**

可以通过向后台作业发送 `SIGSTOP` 信号来停止（暂停）一个正在后台运行的作业。

```bash
$ kill -STOP %1
```

-----

#### **终端 I/O 与相关信号**

作业控制的核心是管理进程与控制终端的交互。

1.  **从终端读取 (Read)**

      * **规则**: 只有**前台作业**中的进程才能够从控制终端中读取输入。
      * **后果**: 如果一个**后台作业**尝试从终端读取输入，内核会向其发送一个 **`SIGTTIN`** 信号。该信号的默认处理动作是\*\*停止（暂停）\*\*该作业。

    <!-- end list -->

    ```bash
    $ cat &
    [1] 12346
    $
    [1]+  Stopped (tty input)     cat
    ```

2.  **向终端写入 (Write)**

      * **规则**: 默认情况下，**后台作业被允许**向控制终端输出内容（这就是为什么有时后台任务的输出会和你的命令混在一起）。
      * **例外**: 如果终端设置了 `TOSTOP` 标记（通过 `stty tostop` 命令），那么当后台作业尝试在终端上输出时，会导致内核向其发送 **`SIGTTOU`** 信号。该信号的默认处理动作也是\*\*停止（暂停）\*\*该作业。

-----

#### **作业控制状态图**

作业控制允许一个任务在不同状态之间迁移，其关系如下图所示：
**状态转换说明:**

![[Pasted image 20250911155839.png]]

  * **`command &`**: 启动一个新命令，直接进入**后台运行**状态。
  * **`command`**: 启动一个新命令，进入**前台运行**状态。
  * **前台运行 `-->` 后台停止**: 用户按下 `Ctrl-Z` (`SIGTSTP` 信号)。
  * **后台停止 `-->` 后台运行**: 用户执行 `bg` 命令 (`SIGCONT` 信号)。
  * **后台停止 `-->` 前台运行**: 用户执行 `fg` 命令 (`SIGCONT` 信号)。
  * **后台运行 `-->` 前台运行**: 用户执行 `fg` 命令。
  * **后台运行 `-->` 后台停止**: 用户执行 `kill -STOP` (`SIGSTOP` 信号)。
  * **任何状态 `-->` 终止**: 进程正常退出，或被 `Ctrl-C` (`SIGINT`) 等信号终止。

#### **34.7.2 实现作业控制**

要实现作业控制，需要以下三个方面的支持：

1.  **特定的作业控制信号**:

      * 实现必须要提供 `SIGTSTP` (从键盘停止), `SIGSTOP` (强制停止), `SIGCONT` (继续), `SIGTTOU` (后台写终端), 以及 `SIGTTIN` (后台读终端)。
      * `SIGCHLD` 信号也是必需的，它允许 shell (作为所有任务的父进程) 得知其子进程何时终止或被停止。

2.  **终端驱动器支持**:

      * 终端驱动器必须能够生成上述信号。例如，在用户输入特定字符（如 `Ctrl-Z`）或后台作业尝试进行终端 I/O 时，驱动器需要将恰当的信号发送到相关的进程组。
      * 为此，终端驱动器必须记录与该终端关联的会话 ID 和当前的前台进程组 ID。

3.  **Shell 支持**:

      * shell 必须提供作业控制命令（如 `fg`, `bg`, `jobs`）。
      * shell 需要使用 `tcsetpgrp()` 等系统调用来管理哪个进程组是前台进程组，并使用 `kill()` 向作业发送信号。

> **关于 SIGCONT 的特殊权限**:
> 内核允许一个进程（如 shell）向**同一会话中**的任意其他进程发送 `SIGCONT` 信号，不受用户 ID 验证的限制。这是必要的，以便 shell 能够恢复一个可能已经改变了自身用户 ID 的 set-user-ID 程序。

##### **SIGTTIN 和 SIGTTOU 信号的特殊情况**

  * 如果后台进程已经**阻塞或忽略** `SIGTTIN` 信号，那么当它尝试从控制终端 `read()` 时，系统**不会**发送 `SIGTTIN` 信号，而是让 `read()` 调用失败，并将 `errno` 置为 `EIO`。
  * 类似地，如果后台进程已经**阻塞或忽略** `SIGTTOU` 信号，那么即使终端设置了 `TOSTOP` 标记，当它尝试 `write()` 时，系统也**不会**发送 `SIGTTOU` 信号，而是允许 `write()` 调用成功。
  * 无论 `TOSTOP` 标记是否设置，当后台进程试图调用会修改终端驱动器数据结构的特定函数时（如 `tcsetattr()`），都会生成 `SIGTTOU` 信号。

-----

#### **程序示例：演示作业控制的操作**

程序清单 34-5 是一个工具，可以作为管道的一部分运行，用于观察 shell 如何将进程组织进进程组（作业），以及信号是如何传递的。

**程序清单 34-5：观察作业控制中的进程处理**

```c
#define _GNU_SOURCE
#include <string.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>

// 信号处理器
static void handler(int sig) {
    pid_t pgid;

    // ① 只有进程组首进程才打印前台 PGID 信息
    if (getpid() == getpgrp()) {
        pgid = tcgetpgrp(STDIN_FILENO);
        if (pgid == -1) {
            printf("tcgetpgrp() error\n");
        } else {
            printf("Terminal FG PGID: %ld\n", (long) pgid);
        }
    }
    
    // ② 打印接收到信号的进程信息
    printf("PID=%ld, pos=%d: caught signal %d (%s)\n",
           (long) getpid(), getenv("PROC_POS") ? atoi(getenv("PROC_POS")) : 0,
           sig, strsignal(sig));
    
    // ③ 捕获 SIGTSTP 后，必须手动发送 SIGSTOP 来停止自己
    if (sig == SIGTSTP) {
        raise(SIGSTOP);
    }
}

int main(int argc, char *argv[]) {
    struct sigaction sa;
    int proc_pos = 0;
    
    setbuf(stdout, NULL);

    // ④ 安装信号处理器
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART;
    sa.sa_handler = handler;
    if (sigaction(SIGINT, &sa, NULL) == -1) perror("sigaction SIGINT");
    if (sigaction(SIGTSTP, &sa, NULL) == -1) perror("sigaction SIGTSTP");
    if (sigaction(SIGCONT, &sa, NULL) == -1) perror("sigaction SIGCONT");

    // ⑤ 检查标准输入是否是终端，以判断自己是否是管道的第一个进程
    if (isatty(STDIN_FILENO)) {
        proc_pos = 1;
        // ⑥ 打印输出标题
        printf("Pos  PID   PPID   PGID   SID\n");
    } else {
        // ⑦ 从管道前一个进程读取自己的位置
        if (read(STDIN_FILENO, &proc_pos, sizeof(proc_pos)) <= 0) {
            perror("read from pipe");
            exit(EXIT_FAILURE);
        }
    }

    // ⑧ 位置加一
    proc_pos++; 
    char env_buf[20];
    snprintf(env_buf, sizeof(env_buf), "%d", proc_pos);
    setenv("PROC_POS", env_buf, 1); // 将位置存入环境变量，供信号处理器使用

    // ⑨ 打印自己的进程信息
    printf("%-4d %-5ld %-5ld %-5ld %-5ld\n", proc_pos, (long) getpid(),
           (long) getppid(), (long) getpgrp(), (long) getsid(0));

    // ⑩ 如果标准输出不是终端，说明不是最后一个进程，将位置传递给下一个
    if (!isatty(STDOUT_FILENO)) {
        if (write(STDOUT_FILENO, &proc_pos, sizeof(proc_pos)) == -1) {
            perror("write to pipe");
            exit(EXIT_FAILURE);
        }
    }

    // ⑪ 无限循环等待信号
    for (;;) {
        pause();
    }
}

```

**编译和运行演示**

1.  **编译程序:**

    ```bash
    $ gcc t_jctl.c -o t_jctl
    ```

2.  **运行后台作业并观察:**

    ```bash
    # 获取 shell 的 PGID
    $ ps -o pid,pgid,sid,comm
      PID  PGID   SID COMMAND
    1220 1220 1220 bash

    # 运行一个两进程的后台作业
    $ ./t_jctl | ./t_jctl &
    [1] 1222
    Pos  PID   PPID   PGID   SID
    1    1222  1220   1222   1220
    2    1223  1222   1222   1220

    # 检查终端的前台 PGID，仍然是 shell 的 PGID
    $ ps -o tty,pgrp,comm | grep $$
    pts/1    1220 bash
    ```

    > **解读**: shell (PGID 1220) 仍然是前台。两个新进程 (1222, 1223) 被放入了同一个**新的进程组 (PGID 1222)**，这是一个后台作业。

3.  **将作业移至前台并发送信号:**

    ```bash
    # 将作业 1 移至前台
    $ fg %1
    ./t_jctl | ./t_jctl

    # 按下 Ctrl-C (发送 SIGINT)
    ^CTerminal FG PGID: 1222
    PID=1222, pos=1: caught signal 2 (Interrupt)
    PID=1223, pos=2: caught signal 2 (Interrupt)

    [1]+  Interrupt               ./t_jctl | ./t_jctl
    ```

    > **解读**: `fg` 命令将作业 1 (PGID 1222) 设置为前台进程组。此时 `Ctrl-C` 发送的 `SIGINT` 信号被该组中的**所有进程**捕获。

4.  **挂起并恢复作业:**

    ```bash
    $ fg %1
    ./t_jctl | ./t_jctl

    # 按下 Ctrl-Z (发送 SIGTSTP)
    ^ZTerminal FG PGID: 1222
    PID=1222, pos=1: caught signal 20 (Stopped)
    PID=1223, pos=2: caught signal 20 (Stopped)

    [1]+  Stopped                 ./t_jctl | ./t_jctl

    # 在后台恢复作业
    $ bg %1
    [1]+ ./t_jctl | ./t_jctl &
    PID=1222, pos=1: caught signal 18 (Continued)
    PID=1223, pos=2: caught signal 18 (Continued)
    ```

    > **解读**: `Ctrl-Z` 发送 `SIGTSTP`，处理器捕获后手动发送 `SIGSTOP` 停止了进程。`bg` 命令发送 `SIGCONT` 信号，在后台恢复了所有进程的运行。



#### **34.7.4 孤儿进程组（SIGHUP 回顾）**

在 26.2 节中曾讲过，**孤儿进程**是那些在父进程终止之后被 `init` 进程（PID 为 1）收养的进程。

**孤儿进程组 (Orphaned Process Group)** 的定义更为复杂。简单来说，当一个进程组中，没有任何一个进程拥有一个“监护人”（即一个位于同一会话、但不同进程组中的父进程）时，这个进程组就变成了孤儿进程组。最常见的情况是，一个 shell 启动了一个子进程（或一个作业），然后这个 shell 自身退出了，那么这个子进程所在的进程组就成为了孤儿进程组。

##### **问题所在：被停止的孤儿进程**

孤儿进程组对于作业控制是一个重要的问题。考虑以下场景：

1.  一个子进程被**停止 (stopped)**（例如，被 `SIGSTOP` 或 `SIGTSTP` 信号暂停）。
2.  其父进程（通常是 shell）退出。
3.  此时，子进程所在的进程组变成了孤儿进程组。

**后果是**：没有任何进程（如原来的 shell）知道这个被停止的子进程的存在，因此**没有进程会向它发送 `SIGCONT` 信号来恢复它的执行**。`init` 进程只会 `wait()` 已终止的子进程，而不会管理被停止的子进程。这将导致这个被停止的子进程可能会永远地残留在系统中，占用资源。

##### **内核的解决方案**

为防止上述情况的发生，SUSv3 规定了内核必须采取的措施：

  * **规则**: 如果一个进程组变成了孤儿进程组，**并且**该组中包含一个或多个已**停止**的成员，那么内核会向该进程组中的**所有**成员发送一个 `SIGHUP` 信号（通知它们会话已断开），之后再发送一个 `SIGCONT` 信号（确保它们被唤醒以处理 `SIGHUP`）。
  * **重要条件**: 如果新成为孤儿的进程组中**不包含**被停止的成员，那么内核**不会**发送任何信号。

此外，孤儿进程组中的成员在调用 `tcsetpgrp()` 等终端控制函数时会收到 `ENOTTY` 或 `EIO` 错误。

-----

##### **程序示例**

程序清单 34-7 演示了内核对孤儿进程组的处理。

**程序清单 34-7 SIGHUP 和孤儿进程组**

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <signal.h>
#include <errno.h>

// ① 信号处理器
static void handler(int sig) {
    printf("PID=%ld: caught signal %d (%s)\n", (long) getpid(),
           sig, strsignal(sig));
}

int main(int argc, char *argv[]) {
    if (argc < 2 || strcmp(argv[1], "--help") == 0) {
        fprintf(stderr, "Usage: %s {s|p}...\n", argv[0]);
        exit(EXIT_FAILURE);
    }
    
    setbuf(stdout, NULL);

    // ② 建立 SIGHUP 和 SIGCONT 信号处理器
    struct sigaction sa;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;
    sa.sa_handler = handler;
    if (sigaction(SIGHUP, &sa, NULL) == -1) perror("sigaction SIGHUP");
    if (sigaction(SIGCONT, &sa, NULL) == -1) perror("sigaction SIGCONT");

    printf("Parent: PID=%ld, PGID=%ld, SID=%ld\n",
           (long) getpid(), (long) getpgrp(), (long) getsid(0));

    // ③ 为每个命令行参数创建一个子进程
    for (int j = 1; j < argc; j++) {
        switch (fork()) {
        case -1:
            perror("fork");
            exit(EXIT_FAILURE);
        case 0: // 子进程
            printf("Child:  PID=%ld, PGID=%ld, SID=%ld\n",
                   (long) getpid(), (long) getpgrp(), (long) getsid(0));
            
            // ④ 如果参数是 's'，子进程停止自己
            if (argv[j][0] == 's') {
                printf("PID=%ld stopping\n", (long) getpid());
                raise(SIGSTOP);
            } else { // ⑤ 否则，子进程暂停等待信号
                alarm(60); // 设置一个超时，以防万一
                printf("PID=%ld pausing\n", (long) getpid());
                pause();
            }
            _exit(EXIT_SUCCESS);
        default: // 父进程
            break;
        }
    }

    // ⑥ 父进程睡眠一会，确保子进程已经启动并停止/暂停
    sleep(3);
    
    printf("Parent exiting\n");
    // ⑦ 父进程退出，此时包含子进程的进程组将变成孤儿进程组
    exit(EXIT_SUCCESS);
}
```

**运行演示**

1.  **编译程序**: `gcc orphan_demo.c -o orphan_demo`

2.  **第一次运行 (包含一个停止的子进程):**

    ```bash
    $ ./orphan_demo s p
    Parent: PID=13001, PGID=13001, SID=12000
    Child:  PID=13002, PGID=13001, SID=12000
    PID=13002 stopping
    Child:  PID=13003, PGID=13001, SID=12000
    PID=13003 pausing
    Parent exiting
    $ PID=13002: caught signal 18 (Continued)  <-- 内核发送 SIGCONT
    PID=13003: caught signal 18 (Continued)
    PID=13002: caught signal 1 (Hangup)      <-- 内核发送 SIGHUP
    PID=13003: caught signal 1 (Hangup)
    ```

    > **解读**: 因为进程组中有一个已停止的成员（PID 13002），所以在父进程退出后，内核向组中所有成员发送了 `SIGCONT` 和 `SIGHUP`。

3.  **第二次运行 (不包含停止的子进程):**

    ```bash
    $ ./orphan_demo p p
    Parent: PID=13004, PGID=13004, SID=12000
    Child:  PID=13005, PGID=13004, SID=12000
    PID=13005 pausing
    Child:  PID=13006, PGID=13004, SID=12000
    PID=13006 pausing
    Parent exiting
    $
    ```

    > **解读**: 因为进程组中没有已停止的成员，所以在父进程退出后，内核**没有发送任何信号**。子进程会一直 `pause` 直到被 `alarm` 信号超时杀死。

-----

##### **孤儿进程组和终端 I/O 信号**

孤儿进程组对 `SIGTSTP`、`SIGTTIN`、`SIGTTOU` 信号的处理也有特殊规定。向一个孤儿进程组发送这些停止信号是毫无意义的，因为一旦被停止，它将再也无法恢复。

  * 因此，当孤儿进程组中的后台进程尝试从终端 `read()` 或向 `tostop` 终端 `write()` 时，调用会失败并返回 `EIO` 错误，而**不是**发送 `SIGTTIN` 或 `SIGTTOU` 信号。
  * 如果 `SIGTSTP`, `SIGTTIN`, 或 `SIGTTOU` 信号被发送给孤儿进程组的成员，并且该信号会导致进程停止，那么这个信号会被**毫无征兆地丢弃**。

![[Pasted image 20250911160610.png]]