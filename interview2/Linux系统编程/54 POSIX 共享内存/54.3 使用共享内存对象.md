
### **54.3 使用共享内存对象**

本节将通过两个程序演示如何使用一个共享内存对象将数据从一个进程传输到另一个进程中。

-----

#### **程序清单 54-2：将数据复制进 POSIX 共享内存对象 (写入方)**

这个程序将其第二个命令行参数中包含的字符串，复制到一个名字由其第一个命令行参数指定的、已存在的共享内存对象中。在复制之前，它会使用 `ftruncate()` 来将共享内存对象的长度设置为与待复制的字符串的长度一样。

**`pshm_write.c` 文件:**

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <sys/stat.h>

int main(int argc, char *argv[]) {
    int fd;
    size_t len;
    char *addr;

    if (argc != 3 || strcmp(argv[1], "--help") == 0) {
        fprintf(stderr, "Usage: %s shm-name string\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    // 1. 以读写模式打开已存在的共享内存对象
    fd = shm_open(argv[1], O_RDWR, 0);
    if (fd == -1) {
        perror("shm_open");
        exit(EXIT_FAILURE);
    }

    // 2. 将对象大小调整为待写入字符串的长度
    len = strlen(argv[2]);
    if (ftruncate(fd, len) == -1) {
        perror("ftruncate");
        exit(EXIT_FAILURE);
    }
    printf("Resized to %ld bytes\n", (long) len);

    // 3. 将对象映射到进程地址空间
    addr = mmap(NULL, len, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
    if (addr == MAP_FAILED) {
        perror("mmap");
        exit(EXIT_FAILURE);
    }

    // 4. 关闭文件描述符 (不影响映射)
    if (close(fd) == -1) {
        perror("close");
        exit(EXIT_FAILURE);
    }

    // 5. 将字符串复制到共享内存中
    printf("Copying %ld bytes\n", (long) len);
    memcpy(addr, argv[2], len);

    exit(EXIT_SUCCESS);
}
```

-----

#### **程序清单 54-3：从 POSIX 共享内存对象中复制数据 (读取方)**

这个程序在标准输出上显示名字由其命令行参数指定的、已存在的共享内存对象中的字符串。它使用 `fstat()` 来确定共享内存的大小，以便正确地映射和打印。

**`pshm_read.c` 文件:**

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <sys/stat.h>

int main(int argc, char *argv[]) {
    int fd;
    char *addr;
    struct stat sb;

    if (argc != 2 || strcmp(argv[1], "--help") == 0) {
        fprintf(stderr, "Usage: %s shm-name\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    // 1. 以只读模式打开已存在的共享内存对象
    fd = shm_open(argv[1], O_RDONLY, 0);
    if (fd == -1) {
        perror("shm_open");
        exit(EXIT_FAILURE);
    }

    // 2. 获取对象的大小
    if (fstat(fd, &sb) == -1) {
        perror("fstat");
        exit(EXIT_FAILURE);
    }

    // 3. 将对象映射到进程地址空间
    addr = mmap(NULL, sb.st_size, PROT_READ, MAP_SHARED, fd, 0);
    if (addr == MAP_FAILED) {
        perror("mmap");
        exit(EXIT_FAILURE);
    }

    // 4. 关闭文件描述符 (不影响映射)
    if (close(fd) == -1) {
        perror("close");
        exit(EXIT_FAILURE);
    }
    
    // 5. 将共享内存的内容写入标准输出
    write(STDOUT_FILENO, addr, sb.st_size);
    printf("\n");

    exit(EXIT_SUCCESS);
}
```

-----

#### **运行演示**

1.  **编译所有程序 (需要链接 `-lrt`)**:

    ```bash
    # (pshm_create 来自 54.2 节)
    gcc pshm_create.c -o pshm_create -lrt
    gcc pshm_write.c -o pshm_write -lrt
    gcc pshm_read.c -o pshm_read -lrt
    ```

2.  **首先，创建一个长度为零的共享内存对象**:

    ```bash
    $ ./pshm_create -c /my_shm 0
    Resized to 0 bytes
    Mapped at address 0x...

    $ ls -l /dev/shm/my_shm
    -rw------- 1 user group 0 Sep 16 15:34 /dev/shm/my_shm
    ```

3.  **然后，使用写入程序将一个字符串复制进共享内存对象**:

    ```bash
    $ ./pshm_write /my_shm "Hello world!"
    Resized to 12 bytes
    Copying 12 bytes

    # 检查对象大小，已被写入程序调整
    $ ls -l /dev/shm/my_shm
    -rw------- 1 user group 12 Sep 16 15:34 /dev/shm/my_shm
    ```

4.  **最后，使用读取程序来显示共享内存对象中的字符串**:

    ```bash
    $ ./pshm_read /my_shm
    Hello world!
    ```

> **关于同步**:
> 在这个 shell 会话中，同步是通过用户一个接一个地运行这些程序来手动完成的。在真实的应用程序中，必须使用一种同步原语（如 **POSIX 信号量**）来协调进程对共享内存的访问，以防止出现竞争条件。