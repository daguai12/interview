### **54.4 删除共享内存对象**

SUSv3 要求 POSIX 共享内存对象至少具备**内核持久性**，即它们会持续存在直到被显式删除或系统重启。当不再需要一个共享内存对象时，就应该使用 `shm_unlink()` 将其删除。

```c
#include <sys/mman.h>
#include <fcntl.h>           /* For O_* constants */

int shm_unlink(const char *name);
```

`shm_unlink()` 函数会删除由 `name` 指定的共享内存对象。其行为与文件系统中的 `unlink()` 类似，遵循**引用计数**的原则：

1.  该函数会立即删除对象的**名称**。执行成功后，后续的 `shm_open()` 调用将无法再打开这个对象。
2.  对象的实际销毁会被**推迟**，直到最后一个映射该对象的进程解除了映射（通过 `munmap()` 或进程终止）为止。
3.  在 `shm_unlink()` 调用之后，已存在的映射仍然保持有效，相关进程可以继续使用这块共享内存。

-----

#### **程序示例**

程序清单 54-4 中的程序使用 `shm_unlink()` 来删除通过程序的命令行参数指定的共享内存对象。

**程序清单 54-4：使用 `shm_unlink()` 来断开一个 POSIX 共享内存对象的链接**

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <fcntl.h>
#include <unistd.h>

int main(int argc, char *argv[]) {
    if (argc != 2 || strcmp(argv[1], "--help") == 0) {
        fprintf(stderr, "Usage: %s shm-name\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    // 调用 shm_unlink() 删除共享内存对象
    if (shm_unlink(argv[1]) == -1) {
        perror("shm_unlink");
        exit(EXIT_FAILURE);
    }

    printf("Shared memory object %s unlinked.\n", argv[1]);
    exit(EXIT_SUCCESS);
}
```

##### **编译和运行演示**

1.  **编译程序 (需要链接 `-lrt`)**:
    ```bash
    gcc pshm_unlink.c -o pshm_unlink -lrt
    ```
2.  **先用上一节的 `pshm_create` 程序创建一个共享内存对象**:
    ```bash
    $ ./pshm_create -c /my_shm 10000
    Resized to 10000 bytes
    Mapped at address 0x...

    # 确认对象已在 /dev/shm 中创建
    $ ls -l /dev/shm/my_shm
    -rw------- 1 user group 10000 Sep 16 15:55 /dev/shm/my_shm
    ```
3.  **运行程序删除该对象**:
    ```bash
    $ ./pshm_unlink /my_shm
    Shared memory object /my_shm unlinked.
    ```
4.  **再次查看 `/dev/shm` 目录，确认对象已被删除**:
    ```bash
    $ ls -l /dev/shm/my_shm
    ls: cannot access '/dev/shm/my_shm': No such file or directory
    ```