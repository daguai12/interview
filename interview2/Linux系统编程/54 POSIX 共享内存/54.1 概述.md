
### **54.1 概述**

**POSIX 共享内存** 能够让无关进程共享一个映射区域，而**无需**创建一个相应的映射文件。

#### **在 Linux 上的实现**
* **支持版本**: Linux 从内核 2.4 起开始支持 POSIX 共享内存。
* **实现方式**: SUSv3 并没有规定 POSIX 共享内存的实现细节。Linux 使用一个挂载于 `/dev/shm` 目录下的专用 **`tmpfs`** 文件系统来实现它。
* **持久性**: 这个 `tmpfs` 文件系统具有**内核持久性**。这意味着它所包含的共享内存对象将会一直存在，即使当前没有任何进程打开它。但这些对象会在**系统关闭之后丢失**。
* **大小限制**: 系统上 POSIX 共享内存区域占据的内存总量受限于底层 `tmpfs` 文件系统的大小。超级用户能够通过 `mount –o remount,size=<num-bytes>` 命令来修改它的大小。

---
#### **使用 POSIX 共享内存的步骤**
要使用一个 POSIX 共享内存对象，需要完成以下两个步骤：

1.  **`shm_open()`**:
    * **作用**: 打开一个与指定名字对应的对象。这个函数与 `open()` 系统调用非常类似，它会创建一个新共享对象或打开一个已存在的对象。
    * **返回值**: 成功时，`shm_open()` 会返回一个引用该对象的**文件描述符**。

2.  **`mmap()`**:
    * **作用**: 将上一步中获得的文件描述符传入 `mmap()` 调用，并将共享内存对象映射进进程的虚拟地址空间。
    * **关键标志**: 在 `mmap()` 的 `flags` 参数中必须指定 **`MAP_SHARED`**，以确保一个进程对内存区域的更新对其他共享该区域的进程可见。
    * **文件描述符**: 一旦成功映射了对象，就可以关闭该文件描述符而不会影响到这个映射。不过，通常需要将这个文件描述符保持在打开状态，以便后续使用 `fstat()`（获取对象信息）和 `ftruncate()`（设置对象大小）等函数。

#### **设计原理与优势**
* **历史原因**: POSIX 共享内存采用 `shm_open()` + `mmap()` 的两步式过程，而不是单个函数，是因为在设计该特性时，`mmap()` 调用已经存在。`shm_open()` 实际上是 `open()` 的一个变体，它操作的是内存中的对象，而不是磁盘上的文件。
* **优势**: 由于共享内存对象的引用是通过**文件描述符**来完成的，因此可以直接使用 UNIX 系统中已经定义好的各种文件描述符相关的系统调用（如 `ftruncate()`, `fstat()`），而无需像 System V 共享内存那样增加新的、用途特殊的控制系统调用（如 `shmctl()`）。这使得 POSIX 共享内存的 API 与传统的 UNIX 文件模型更加一致。