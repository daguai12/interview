### **54.2 创建共享内存对象**

`shm_open()` 函数用于创建和打开一个新的 POSIX 共享内存对象，或打开一个已存在的对象。其参数与 `open()` 系统调用类似。

```c
#include <sys/mman.h>
#include <sys/stat.h>        /* For mode constants */
#include <fcntl.h>           /* For O_* constants */

int shm_open(const char *name, int oflag, mode_t mode);
```

  * **`name`**: 标识共享内存对象的名称（例如 `/my_shm`）。
  * **`oflag`**: 一个改变调用行为的位掩码。
  * **`mode`**: 指定新创建对象的权限。与 `open()` 不同的是，**在调用 `shm_open()` 时总是需要 `mode` 参数**，在不创建新对象时应将此参数指定为 0。

**表 54-1：`shm_open()` `oflag` 参数的位值**
| 标记 | 描述 |
| :--- | :--- |
| `O_CREAT` | 如果对象不存在，则创建对象 |
| `O_EXCL` | 与 `O_CREAT` 结合使用，如果对象已存在则调用失败 |
| `O_RDONLY` | 以只读模式打开 |
| `O_RDWR` | 以读写模式打开 |
| `O_TRUNC` | 如果对象已存在，则在成功打开后将其长度截断为零 |

#### **所有权和权限**

  * **所有权**: 新创建的共享内存对象的所有权（用户 ID 和组 ID）将根据调用进程的有效用户和组 ID 来设定。
  * **权限**: `mode` 参数指定的权限位掩码会受到进程 `umask` 的影响。
  * **Close-on-Exec**: `shm_open()` 返回的文件描述符会自动设置 `close-on-exec` 标志，因此当程序执行 `exec()` 时，该文件描述符会被自动关闭。

#### **设置共享内存对象的大小 (`ftruncate`)**

一个新创建的共享内存对象的**初始长度为 0**。

为了能够映射和使用这块内存，必须在创建对象之后、调用 `mmap()` 之前，使用 `ftruncate()` 来设置对象的大小。

```c
#include <unistd.h>
int ftruncate(int fd, off_t length);
```

在扩展共享内存对象时，新增加的字节会自动被初始化为 0。

在获得文件描述符后，也可以随时使用 `fstat()` 来获取对象的信息（如大小、权限），或使用 `fchmod()` 和 `fchown()` 来修改其权限和所有权。

-----

#### **程序示例**

程序清单 54-1 提供了一个使用 `shm_open()`、`ftruncate()` 以及 `mmap()` 的例子。它会创建一个大小通过命令行参数指定的共享内存对象。

**程序清单 54-1：创建一个 POSIX 共享内存对象**

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <sys/stat.h>

static void usageError(const char *progName) {
    fprintf(stderr, "Usage: %s [-cx] shm-name size\n", progName);
    fprintf(stderr, "    -c   Create shared memory (O_CREAT)\n");
    fprintf(stderr, "    -x   Create exclusively (O_EXCL)\n");
    exit(EXIT_FAILURE);
}

int main(int argc, char *argv[]) {
    int flags, opt, fd;
    mode_t perms;
    size_t size;
    void *addr;

    flags = O_RDWR;
    perms = S_IRUSR | S_IWUSR; // 0600

    while ((opt = getopt(argc, argv, "cx")) != -1) {
        switch (opt) {
        case 'c': flags |= O_CREAT; break;
        case 'x': flags |= O_EXCL; break;
        default:  usageError(argv[0]);
        }
    }

    if (optind + 2 > argc)
        usageError(argv[0]);

    size = atol(argv[optind + 1]);

    // 1. 创建或打开共享内存对象
    fd = shm_open(argv[optind], flags, perms);
    if (fd == -1) {
        perror("shm_open");
        exit(EXIT_FAILURE);
    }
    
    // 2. 设置对象大小
    if (ftruncate(fd, size) == -1) {
        perror("ftruncate");
        exit(EXIT_FAILURE);
    }
    printf("Resized to %ld bytes\n", (long) size);

    // 3. 将对象映射到进程地址空间 (本例中仅为演示)
    addr = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
    if (addr == MAP_FAILED) {
        perror("mmap");
        exit(EXIT_FAILURE);
    }
    printf("Mapped at address %p\n", addr);
    
    // 此时可以关闭文件描述符而不影响映射
    // close(fd); 

    exit(EXIT_SUCCESS);
}
```

##### **编译和运行演示**

1.  **编译程序 (需要链接 `-lrt`)**:
    ```bash
    gcc pshm_create.c -o pshm_create -lrt
    ```
2.  **运行程序创建一个 10000 字节的共享内存对象**:
    ```bash
    $ ./pshm_create -c /my_shm 10000
    Resized to 10000 bytes
    Mapped at address 0x...
    ```
3.  **在 `/dev/shm` 目录中查看创建的对象**:
    ```bash
    $ ls -l /dev/shm/my_shm
    -rw------- 1 daguai daguai 10000 Sep 15 15:30 /dev/shm/my_shm
    ```
    可以看到，一个大小为 10000 字节的文件已在 `tmpfs` 文件系统中被创建。