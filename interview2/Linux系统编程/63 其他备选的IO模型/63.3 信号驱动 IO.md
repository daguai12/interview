### **63.3 信号驱动 I/O**

与 I/O 多路复用中进程主动调用 `select()` 或 `poll()` 来检查文件描述符状态不同，在**信号驱动 I/O (Signal-Driven I/O)** 模型中，是进程请求内核在文件描述符可执行 I/O 操作时，为自己**发送一个信号**。之后，进程就可以执行其他任务，直到 I/O 就绪，此时内核会发送信号来通知进程。

#### **使用步骤**

要使用信号驱动 I/O，程序需要按照如下步骤来执行：

1.  **安装信号处理器**: 为内核即将发送的通知信号（默认为 `SIGIO`）安装一个信号处理例程。
2.  **设定文件描述符属主**: 使用 `fcntl()` 的 `F_SETOWN` 操作，告知内核应该将 I/O 就绪信号发送给哪个进程或进程组。
3.  **启用非阻塞 I/O**: 通过 `fcntl()` 设置 `O_NONBLOCK` 标志。
4.  **启用信号驱动 I/O**: 通过 `fcntl()` 设置 `O_ASYNC` 标志。（步骤 3 和 4 可以合并为一次 `fcntl()` 调用）。
5.  **执行其他任务**: 调用进程现在可以执行其他任务。
6.  **处理 I/O**: 当 I/O 操作就绪时，内核向进程发送信号，调用已安装的信号处理器。在处理器或主程序中，执行 I/O 操作。

信号驱动 I/O 提供的是**边缘触发通知 (edge-triggered)**。这意味着一旦进程被通知 I/O 就绪，它就应该在一个循环中尽可能多地执行 I/O（例如，持续 `read()` 直到调用失败并返回 `EAGAIN`），以确保处理完本次就绪事件的所有数据。

> **支持范围**: 在 Linux 2.6 及以上版本，信号驱动 I/O 可应用于套接字、终端、伪终端、管道、FIFO 以及 inotify 文件描述符。

-----

#### **程序示例**

程序清单 63-3 提供了一个使用信号驱动 I/O 的简单例子。该程序在标准输入上启用信号驱动 I/O，然后进入一个无限循环。当有输入时，`SIGIO` 信号处理器会设置一个标志，主循环检测到该标志后，会读取并打印所有可用的输入。

**程序清单 63-3：在终端上使用信号驱动 I/O**

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <signal.h>
#include <fcntl.h>
#include <errno.h>
#include <termios.h>

static volatile sig_atomic_t gotSigio = 0;

// SIGIO 信号处理器
static void sigioHandler(int sig) {
    gotSigio = 1;
}

// (此处省略了设置终端为 cbreak 模式的 ttySetCbreak 和 ttyReset 函数的实现)
// 这是一个简化的概念，实际应用需要完整的 termios 设置

int main(int argc, char *argv[]) {
    int flags;
    char ch;
    struct sigaction sa;
    long cnt = 0;

    // 1. 为 SIGIO 安装信号处理器
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART;
    sa.sa_handler = sigioHandler;
    if (sigaction(SIGIO, &sa, NULL) == -1) {
        perror("sigaction"); exit(EXIT_FAILURE);
    }
    
    // 2. 设定标准输入的文件描述符属主为当前进程
    if (fcntl(STDIN_FILENO, F_SETOWN, getpid()) == -1) {
        perror("fcntl F_SETOWN"); exit(EXIT_FAILURE);
    }

    // 3 & 4. 使能非阻塞和信号驱动 I/O
    flags = fcntl(STDIN_FILENO, F_GETFL);
    if (fcntl(STDIN_FILENO, F_SETFL, flags | O_ASYNC | O_NONBLOCK) == -1) {
        perror("fcntl F_SETFL"); exit(EXIT_FAILURE);
    }
    
    // (设置终端为 cbreak 模式)

    // 5. 主程序循环，执行其他任务
    for (cnt = 0; ; cnt++) {
        // 模拟执行其他任务
        if (cnt % 10000000 == 0) {
           // write(STDOUT_FILENO, ".", 1);
        }

        // 6. 检查是否收到了信号
        if (gotSigio) {
            gotSigio = 0; // 重置标志

            // 读取所有可用的输入
            while (read(STDIN_FILENO, &ch, 1) > 0) {
                printf("cnt=%ld; read %c\n", cnt, ch);
                if (ch == '#') {
                    // (恢复终端模式)
                    exit(EXIT_SUCCESS);
                }
            }
        }
    }
}
```

**运行演示**:

```bash
$ ./sigio_demo
# (输入 xxx#)
cnt=20398494; read x
cnt=20398494; read x
cnt=20398494; read x
cnt=20398494; read #
$
```

**解读**: 主程序在后台忙于执行循环（`cnt` 在增长）。当用户输入字符时，内核发送 `SIGIO` 信号，信号处理器设置 `gotSigio` 标志。主循环检测到标志后，会一次性读取并处理所有已输入的字符。

-----

#### **实现要点**

  * **安装处理器的时机**: **必须**在启动信号驱动 I/O（即设置 `O_ASYNC` 标志）**之前**，先为 `SIGIO` 信号安装处理例程。否则，在一个极小的时间窗口内，如果 I/O 就绪，内核发送的 `SIGIO` 信号可能会导致进程因默认行为而终止。

  * **设定文件描述符属主 (`F_SETOWN`)**:

      * `fcntl(fd, F_SETOWN, pid)` 用于设定属主。
      * 如果 `pid` 是一个正整数，它被解释为**进程 ID**。
      * 如果 `pid` 是一个负数，它的绝对值被解释为**进程组 ID**，信号将被发送给该组的所有成员。
      * `fcntl(fd, F_GETOWN, 0)` 用于获取当前属主。

#### **63.3.1 何时发送“I/O 就绪”信号**

现在我们针对多种文件类型，考虑在何种情况下会发送“I/O 就绪”信号（默认为 `SIGIO`）。

* **终端和伪终端 (Terminals and Pseudo-terminals)**
    * 当**产生新的输入**时会生成一个信号，即使之前的输入还没有被读取也是如此。
    * 如果终端上出现**文件结尾 (EOF)** 的情况，此时也会发送一个“输入就绪”的信号。
    * 对于终端来说，**没有**“输出就绪”的信号。
    * （自 Linux 2.4.19 起）对于伪终端的从设备端，当主设备端读取了输入后，会为其产生一个“输出就绪”信号。

* **管道和 FIFO (Pipes and FIFOs)**
    * **对于读端**:
        * 当有**数据写入**到管道中时（即使管道中已经有未读取的数据）。
        * 当管道的**写端关闭**时。
    * **对于写端**:
        * 当对管道的读操作使得管道中的可用空间**足以原子地写入 `PIPE_BUF` 个字节**而不被阻塞时。
        * 当管道的**读端关闭**时。

* **套接字 (Sockets)**
    * **对于数据报套接字 (Datagram Sockets, e.g., UDP)**:
        * 当一个**输入数据报到达**套接字时（即使已经有未读取的数据报）。
        * 当套接字上发生了**异步错误**时。
    * **对于流式套接字 (Stream Sockets, e.g., TCP)**:
        * 当在**监听套接字**上接收到了**新的连接**时。
        * 当一个 `connect()` 请求**完成**时（即连接建立成功）。
        * 当套接字上接收到了**新的输入数据**时。
        * 当套接字对端使用 `shutdown()` **关闭了写连接**（半关闭），或者通过 `close()` 完全关闭连接时。
        * 当套接字变为**可写**时（例如，发送缓冲区中有了可用空间）。
        * 当套接字上发生了**异步错误**时。

* **inotify 文件描述符**
    * 当 inotify 文件描述符变为可读时会产生一个信号，即由该 inotify 实例所监视的某个文件或目录上**有事件发生**时。


#### **63.3.2 优化信号驱动 I/O 的使用**

在需要同时检查大量文件描述符的应用程序中，与 `select()` 和 `poll()` 相比，信号驱动 I/O 能提供显著的性能优势。这是因为内核可以“记住”进程感兴趣的文件描述符，并且仅当 I/O 事件实际发生时才会通知程序，其性能可以根据发生的 I/O 事件数量来扩展，而与被检查的文件描述符总数无关。

要想完全利用信号驱动 I/O 的优点，我们必须执行以下两个步骤（均为 Linux 专有特性）：

1.  通过 `fcntl()` 的 `F_SETSIG` 操作，指定一个**实时信号**来取代默认的 `SIGIO` 信号。
2.  使用 `sigaction()` 安装信号处理例程时，为该实时信号指定 `SA_SIGINFO` 标志。

##### **`F_SETSIG` 操作**

`fcntl()` 的 `F_SETSIG` 操作指定了一个可选的信号，当文件描述符上的 I/O 就绪时，内核会发送这个指定的信号而不是 `SIGIO`。`F_GETSIG` 操作则执行相反的功能。

使用 `F_SETSIG` 来改变通知信号有两个关键理由：

1.  **信号排队**: 默认的 `SIGIO` 是标准的**非排队**信号。如果多个 I/O 事件同时发生，程序可能只会收到一个 `SIGIO` 信号，从而导致事件通知丢失。而**实时信号是可以排队**的，这样可以确保多个通知不会被合并，从而避免丢失事件。

2.  **获取事件信息**: 如果信号处理例程是通过 `sigaction()` 安装，并且指定了 `SA_SIGINFO` 标志，那么一个 `siginfo_t` 结构体会作为第二个参数传递给信号处理器。对于 I/O 就绪信号，这个结构体包含了**哪个文件描述符发生了事件**以及**事件类型**等关键信息。

##### **`siginfo_t` 结构体中的 I/O 事件信息**

对于 I/O 就绪事件，传递给信号处理器的 `siginfo_t` 结构体中与之相关的字段如下：

  * **`si_signo`**: 信号值。
  * **`si_fd`**: **发生 I/O 事件的文件描述符**。
  * **`si_code`**: 表示发生事件类型的代码。
  * **`si_band`**: 一个位掩码，其中包含的位与 `poll()` 的 `revents` 字段中的位相同。

**表 63-7：`siginfo_t` 中 `si_code` 和 `si_band` 字段的可能值**

| `si_code`  | `si_band` 掩码值 | 描述           |              |             |
| :--------- | :------------ | :----------- | ------------ | ----------- |
| `POLL_IN`  | `POLLIN`      | `POLLRDNORM` | 存在输入；文件结尾情况  |             |
| `POLL_OUT` | `POLLOUT`     | `POLLWRNORM` | `POLLWRBAND` | 可输出         |
| `POLL_MSG` | `POLLIN`      | `POLLRDNORM` | `POLLMSG`    | 存在输入消息（不使用） |
| `POLL_ERR` | `POLLERR`     | I/O 错误       |              |             |
| `POLL_PRI` | `POLLPRI`     | `POLLRDNORM` | 存在高优先级输入     |             |
| `POLL_HUP` | `POLLHUP`     | `POLLERR`    | 出现挂断         |             |

> **使用 `sigwaitinfo()`**:
> 另一种进一步优化的方法是：程序可以阻塞 I/O 就绪信号，然后通过 `sigwaitinfo()` 或 `sigtimedwait()` 以**同步**的方式来接收排队中的信号。这种方法避免了编写信号处理器的复杂性，但仍然能高效地获知 I/O 事件。

-----

##### **信号队列溢出的处理**

可排队的实时信号数量是有限的。如果这个上限被达到（信号队列溢出），内核会**退回到发送默认的 `SIGIO` 信号**作为通知。

  * **问题**: 发生这种情况时，我们将失去关于具体哪个文件描述符发生 I/O 事件的信息，因为 `SIGIO` 信号是不排队的，并且其处理器也不接受 `siginfo_t` 参数。
  * **解决方案**: 一个设计良好的、使用实时信号通知的程序，必须**也要为 `SIGIO` 信号安装一个处理器**。如果收到了 `SIGIO` 信号，这表示可能发生了信号队列溢出。此时，应用程序应该先通过 `sigwaitinfo()` 将队列中的所有实时信号全部获取，然后**临时切换到使用 `select()` 或 `poll()`**，通过它们扫描所有被监视的文件描述符，以获取剩余的 I/O 事件。

-----

##### **在多线程程序中使用信号驱动 I/O**

从 Linux 2.6.32 内核开始，提供了两个新的 `fcntl()` 操作，可以用于设定接收 I/O 就绪信号的目标：`F_SETOWN_EX` 和 `F_GETOWN_EX`。

`F_SETOWN_EX` 操作类似于 `F_SETOWN`，但它允许将一个**特定的线程**指定为信号的目标。此时 `fcntl()` 的第三个参数是一个指向 `f_owner_ex` 结构体的指针：

```c
struct f_owner_ex {
    int type;
    pid_t pid;
};
```

`type` 字段可以是 `F_OWNER_PID` (pid 是进程ID), `F_OWNER_PGRP` (pid 是进程组ID)，或 **`F_OWNER_TID`** (pid 是线程ID)。这使得我们可以精确地将 I/O 就绪信号定向到多线程程序中的某一个特定线程。