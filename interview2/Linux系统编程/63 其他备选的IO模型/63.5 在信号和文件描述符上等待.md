好的，这是根据您提供的文本内容，保留原始结构和标题整理的结果，并附上相应的代码清单。

### **63.5 在信号和文件描述符上等待**

有时候，一个进程需要同时等待两种不同类型的事件：一组文件描述符上的 I/O 就绪，以及一个或多个信号的到来。

#### **错误的方法及其竞态条件**

一个看似可行但实际上存在问题的方法是：为信号安装一个处理器，该处理器只设置一个全局标志，然后在主程序中调用 `select()`。当 `select()` 返回时（无论是由于 I/O 就绪还是被信号中断），再检查这个全局标志。

**程序清单 63-7** 展示了这种错误的用法。

```c
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <sys/select.h>

static volatile sig_atomic_t got_signal = 0;

static void signal_handler(int sig) {
    got_signal = 1;
}

int main() {
    struct sigaction sa;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;
    sa.sa_handler = signal_handler;
    sigaction(SIGUSR1, &sa, NULL);

    // ... setup fd_set for select() ...
    fd_set readfds;
    FD_ZERO(&readfds);
    FD_SET(STDIN_FILENO, &readfds);

    printf("Waiting for signal or I/O...\n");
    
    /*
     * !!! RACE CONDITION HERE !!!
     * 如果信号在 sigaction() 之后、select() 之前到达，
     * 那么 got_signal 会被设置为 1，但 select() 将会永久阻塞。
     */

    int ready = select(STDIN_FILENO + 1, &readfds, NULL, NULL, NULL);

    if (ready == -1 && errno == EINTR) {
        printf("select() was interrupted by a signal.\n");
    }

    if (got_signal) {
        printf("Got the signal!\n");
    }
    
    // ... handle I/O if ready ...

    return 0;
}
```

**这段代码的问题在于**，如果信号（本例中是 `SIGUSR1`）到来的时机，刚好是在安装信号处理器之后、且在 `select()` 调用**之前**，那么 `select()` 依然会阻塞。`got_signal` 标志虽然被设置了，但由于 `select()` 还没有开始等待，它不会被中断，从而可能导致程序永久挂起（即“错过”了信号）。这是一种典型的**竞态条件 (race condition)**。

-----

#### **正确的解决方案 (Linux): `signalfd`**

从 2.6.27 版内核之后，Linux 提供了一种新的、健壮的技术来同时等待信号和文件描述符：**`signalfd`**。

  * **机制**: `signalfd()` 系统调用可以创建一个特殊的**文件描述符**。当一个被指定的信号发送给进程时，它**不会**被传统的信号处理器捕获，而是会被内核作为一个“可读事件”递送到这个文件描述符上。
  * **优点**:
      * 它将**处理信号**这一异步事件，转换为了**处理文件描述符上的可读事件**这一同步事件。
      * 这样，我们就可以将这个 `signalfd` 返回的文件描述符，和我们关心的其他文件描述符（如套接字、管道）一起，放入 `select()`、`poll()` 或者 `epoll_wait()` 中进行统一监视。
      * 这种方法完全消除了上述的竞态条件，是目前在 Linux 上处理这类问题的最佳实践。

#### **63.5.1 pselect()系统调用**

`pselect()` 系统调用执行的任务同 `select()` 相似，但它通过一个附加的 `sigmask` 参数，解决了在信号和文件描述符上等待时产生的竞态条件问题。

```c
#include <sys/select.h>

int pselect(int nfds, fd_set *readfds, fd_set *writefds,
            fd_set *exceptfds, const struct timespec *timeout,
            const sigset_t *sigmask);
```

##### **`pselect()` 的原子操作**

`pselect()` 的核心优势在于它能够**原子地**执行以下操作序列：

1.  保存进程当前的信号掩码。
2.  将进程的信号掩码设置为 `sigmask` 所指定的值。
3.  调用 `select()` 等待文件描述符就绪或一个**未被 `sigmask` 阻塞**的信号到来。
4.  恢复进程原始的信号掩码。

通过这种方式，`pselect()` **完全消除了**“信号在检查和等待之间到来”的竞态条件。程序可以先在主代码中阻塞目标信号，然后在调用 `pselect()` 时，通过 `sigmask` 参数临时地解除对该信号的阻塞，从而安全地等待事件的发生。

##### **与 `select()` 的其他区别**

1.  **超时精度**: `pselect()` 中的 `timeout` 参数是一个 `timespec` 结构体，允许将超时时间精度指定为**纳秒级**（而 `select()` 使用的 `timeval` 是微秒级）。
2.  **`timeout` 参数不变**: SUSv3 中明确说明，`pselect()` 在返回时**不会修改** `timeout` 参数的值。这与 `select()` 在某些实现（如 Linux）上的行为不同，使得 `pselect()` 在循环中使用时无需重新初始化超时值。

> **可用性**: `pselect()` 是在 POSIX.1g 中定义的，Linux 中也只是在 2.6.16 版内核后才加入了可靠的内核级实现。早期的 glibc 库实现存在竞态条件问题。

-----

#### **程序示例**

使用 `pselect()`，我们可以将上一节有问题的程序（程序清单 63-7）中的 `main()` 函数部分替换为程序清单 63-8 中的代码，从而解决竞态条件。

**程序清单 63-8：使用 `pselect()`**

```c
// ... 在 main() 函数中 ...
sigset_t blockMask, emptyMask;
struct sigaction sa;

// 1. 安装信号处理器
sa.sa_handler = handler;
sa.sa_flags = 0;
sigemptyset(&sa.sa_mask);
sigaction(SIGUSR1, &sa, NULL);

// 2. 在主程序中阻塞 SIGUSR1 信号
sigemptyset(&blockMask);
sigaddset(&blockMask, SIGUSR1);
sigprocmask(SIG_BLOCK, &blockMask, NULL);

// ... setup fd_set for pselect() ...
fd_set readfds;
FD_ZERO(&readfds);
FD_SET(STDIN_FILENO, &readfds);

// 3. 准备一个不阻塞任何信号的掩码，传递给 pselect()
sigemptyset(&emptyMask);

printf("Waiting for signal or I/O...\n");

// 4. 调用 pselect()
// pselect 会原子地将信号掩码替换为 emptyMask (即不阻塞任何信号)，
// 然后等待。返回前，它会自动恢复原来的 blockMask。
int ready = pselect(STDIN_FILENO + 1, &readfds, NULL, NULL, NULL, &emptyMask);

// ... 检查 ready 和 got_signal ...
```

这段代码是**无竞态条件**的，因为信号 `SIGUSR1` 只有在 `pselect()` 内部等待时才会被解除阻塞。

-----

#### **相关的 `ppoll()` 和 `epoll_pwait()` 系统调用**

Linux 也新增了 `ppoll()` 和 `epoll_pwait()`，它们与 `poll()` 和 `epoll_wait()` 的关系，类似于 `pselect()` 与 `select()` 的关系。它们都在原有功能的基础上，增加了一个 `sigmask` 参数，以提供**原子地、无竞态条件地**等待文件描述符和信号的能力。


#### **63.5.2 self-pipe 技巧**

由于 `pselect()` 并没有被广泛实现，可移植的应用程序必须采用其他手段来避免在同时等待信号和文件描述符时出现的竞态条件。**self-pipe 技巧 (self-pipe trick)** 就是一种常用且可靠的解决方案。

它的核心思想是：**将信号事件转换为 I/O 事件**。

##### **实现步骤**

1.  **创建管道**: 创建一个管道，并将管道的**读端**和**写端**都设为**非阻塞**的。
2.  **监视管道**: 在调用 `select()` (或 `poll()`) 时，将管道的**读端**文件描述符包含在待监视的集合中。
3.  **安装信号处理器**: 为感兴趣的信号安装一个处理器。这个处理器的唯一任务就是向管道的**写端**写入一个字节的数据。
      * **写端非阻塞的重要性**: 必须将管道的写端设为非阻塞。这是为了防止在信号频繁到来时，因管道被填满而导致 `write()` 调用在信号处理器中阻塞，从而使整个进程死锁。
      * **信号安全**: 在信号处理器中使用 `write()` 是安全的，因为 `write()` 是异步信号安全的函数之一。
4.  **调用 `select()`**: 在循环中调用 `select()` 等待事件。
5.  **判断信号**: `select()` 返回后，通过检查代表管道读端的文件描述符是否就绪，来判断是否有信号到来。
6.  **“抽干”管道**: 如果检测到管道可读（即信号已发生），需要在一个循环中将管道中的所有字节都读取出来（直到 `read()` 返回 `EAGAIN`），以处理多个信号被合并为一个 I/O 事件的情况。

-----

#### **程序示例**

程序清单 63-9 中的代码展示了 self-pipe 技巧的用法。该程序可以同时等待标准输入上的 I/O，以及 `SIGINT` 和 `SIGQUIT` 信号。

**程序清单 63-9：采用 self-pipe 技巧**

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <signal.h>
#include <sys/select.h>
#include <errno.h>

static int pfd[2]; // 用于 self-pipe 的文件描述符

// 信号处理器
static void handler(int sig) {
    int savedErrno = errno; // write() 可能会改变 errno
    if (write(pfd[1], "x", 1) == -1 && errno != EAGAIN) {
        // 在信号处理器中进行错误处理很困难，这里简化处理
    }
    errno = savedErrno;
}

int main(int argc, char *argv[]) {
    fd_set readfds;
    int ready, nfds;
    char ch;
    struct sigaction sa;

    // 1. 创建管道
    if (pipe(pfd) == -1) {
        perror("pipe");
        exit(EXIT_FAILURE);
    }

    // 将管道两端都设为非阻塞
    if (fcntl(pfd[0], F_SETFL, O_NONBLOCK) == -1) perror("fcntl read");
    if (fcntl(pfd[1], F_SETFL, O_NONBLOCK) == -1) perror("fcntl write");

    // 3. 安装信号处理器
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART;
    sa.sa_handler = handler;
    if (sigaction(SIGINT, &sa, NULL) == -1) perror("sigaction SIGINT");
    if (sigaction(SIGQUIT, &sa, NULL) == -1) perror("sigaction SIGQUIT");
    
    printf("Waiting for I/O or signal...\n");

    for (;;) {
        // 4. 在循环中调用 select()
        FD_ZERO(&readfds);
        FD_SET(STDIN_FILENO, &readfds);
        FD_SET(pfd[0], &readfds); // 2. 监视管道的读端
        
        nfds = (pfd[0] > STDIN_FILENO) ? (pfd[0] + 1) : (STDIN_FILENO + 1);
        
        ready = select(nfds, &readfds, NULL, NULL, NULL);
        if (ready == -1) {
            if (errno == EINTR) continue; // 被其他信号中断，重启 select
            else { perror("select"); exit(EXIT_FAILURE); }
        }
        
        // 5. 检查管道读端是否就绪，以判断信号是否到来
        if (FD_ISSET(pfd[0], &readfds)) {
            printf("A signal was caught\n");
            // 6. "抽干"管道
            while (read(pfd[0], &ch, 1) > 0)
                continue; // 丢弃读取的字节
        }

        // 检查标准输入是否就绪
        if (FD_ISSET(STDIN_FILENO, &readfds)) {
            printf("Readable: ");
            if (read(STDIN_FILENO, &ch, 1) > 0) {
                 printf("%c\n", ch);
            }
        }
    }
}
```

##### **编译和运行**

```bash
$ gcc self_pipe_demo.c -o self_pipe_demo
$ ./self_pipe_demo
Waiting for I/O or signal...
# (此时按下 Ctrl-C)
A signal was caught
# (此时输入 'a' 并按回车)
Readable: a
# (再次按下 Ctrl-C)
A signal was caught
...
```

这个程序成功地将信号事件转换为了文件描述符上的 I/O 事件，从而可以在一个 `select()` 调用中安全、可靠地同时等待这两种事件。