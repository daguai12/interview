### **63.2 I/O 多路复用**

**I/O 多路复用 (I/O Multiplexing)** 允许我们的程序同时检查多个文件描述符，看其中任意一个是否可执行 I/O 操作（即“就绪”）。`select()` 和 `poll()` 是两个功能几乎相同的、用于执行 I/O 多路复用的系统调用，它们都是 SUSv3 的标准接口。

这两个系统调用都允许进程要么一直等待文件描述符成为就绪态，要么在调用中指定一个超时时间。

-----

#### **63.2.1 select()系统调用**

`select()` 系统调用会一直阻塞，直到一个或多个被监视的文件描述符集合成为就-绪态，或超时。

```c
#include <sys/select.h>
/* Or <sys/time.h> on some systems */

int select(int nfds, fd_set *readfds, fd_set *writefds,
           fd_set *exceptfds, struct timeval *timeout);
```

##### **文件描述符集合 (`fd_set`)**

`readfds`、`writefds` 以及 `exceptfds` 都是指向 `fd_set` 类型的指针，它们分别指定了需要监视“可读”、“可写”和“异常条件”事件的文件描述符集合。

> **异常情况 (Exceptional conditions)**: 在 Linux 上，这通常指在流式套接字上接收到了带外数据，或伪终端状态发生了改变。

`fd_set` 应被视为一个不透明的数据类型，必须使用以下四个宏来操作它：

  * **`FD_ZERO(fd_set *fdset)`**: 将 `fdset` 初始化为空集合。
  * **`FD_SET(int fd, fd_set *fdset)`**: 将文件描述符 `fd` 添加到 `fdset` 集合中。
  * **`FD_CLR(int fd, fd_set *fdset)`**: 将文件描述符 `fd` 从 `fdset` 集合中移除。
  * **`FD_ISSET(int fd, fd_set *fdset)`**: 检查文件描述符 `fd` 是否是 `fdset` 集合的成员，如果是则返回 true。

**`fd_set` 的重要特性**:

  * **大小限制**: `fd_set` 的容量受常量 `FD_SETSIZE` 的限制，在 Linux 上，该值为 **1024**。
  * **值-结果参数**: `fd_set` 是一个**值-结果**参数。调用 `select()` **之前**，我们用它来告诉内核我们关心哪些文件描述符；当 `select()` **返回后**，内核会**修改**这个结构，使其只包含那些已经“就绪”的文件描述符。因此，如果在一个循环中调用 `select()`，**必须在每次调用前重新初始化** `fd_set`。

##### **`nfds` 参数**

`nfds` 参数必须被设置为所有三个集合中所包含的**最大文件描述符号加 1**。这是为了提高内核的效率，使其无需检查超出这个范围的文件描述符。

##### **`timeout` 参数**

`timeout` 参数控制着 `select()` 的阻塞行为，它是一个指向 `timeval` 结构的指针。

  * **`timeout == NULL`**: `select()` 会**一直阻塞**，直到有文件描述符就绪或被信号中断。
  * **`timeout` 指向的 `timeval` 字段全为 0**: `select()` **不阻塞**，它只是简单地轮询并立即返回。
  * **`timeout` 指向的 `timeval` 字段非零**: `select()` 会阻塞，但**最长不超过**指定的时间上限。

> **可移植性警告**: 在 Linux 上，如果 `select()` 因文件描述符就绪而返回，内核会**修改** `timeout` 结构以表示剩余的超时时间。但是，**这种行为不是可移植的**，许多 UNIX 实现并不会修改它。因此，可移植的应用程序**应该在每次循环调用 `select()` 之前都重新初始化 `timeout` 结构**。

##### **`select()` 的返回值**

  * **-1**: 发生错误（例如 `EINTR` 表示被信号中断）。
  * **0**: 在任何文件描述符就绪之前，调用已经超时。
  * **正整数**: 返回处于就绪态的文件描述符**总个数**。此时，程序需要使用 `FD_ISSET()` 遍历所有关心的文件描述符，以找出具体是哪个描述符的哪个事件就绪了。

-----

#### **程序示例**

程序清单 63-1 演示了 `select()` 的用法。它接收一个超时值和一系列“文件描述符+事件类型”作为参数。

**程序清单 63-1：使用 `select()` 来检查多个文件描述符**

```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h>
#include <sys/select.h>
#include <unistd.h>
#include <string.h>

int main(int argc, char *argv[]) {
    fd_set readfds, writefds;
    int ready, nfds, fd, numRead;
    struct timeval timeout;
    struct timeval *pto;
    char buf[10];

    if (argc < 2 || strcmp(argv[1], "--help") == 0) {
        fprintf(stderr, "Usage: %s {timeout|-} fd-num[rw]...\n", argv[0]);
        exit(EXIT_FAILURE);
    }
    
    // 设置超时
    if (strcmp(argv[1], "-") == 0) {
        pto = NULL; // 无限阻塞
    } else {
        pto = &timeout;
        timeout.tv_sec = atol(argv[1]);
        timeout.tv_usec = 0;
    }
    
    // 初始化 fd_set
    nfds = 0;
    FD_ZERO(&readfds);
    FD_ZERO(&writefds);

    for (int j = 2; j < argc; j++) {
        numRead = sscanf(argv[j], "%d", &fd);
        if (numRead != 1) exit(EXIT_FAILURE);
        if (fd >= nfds) nfds = fd + 1;
        
        if (strchr(argv[j], 'r') != NULL) FD_SET(fd, &readfds);
        if (strchr(argv[j], 'w') != NULL) FD_SET(fd, &writefds);
    }

    // 调用 select()
    ready = select(nfds, &readfds, &writefds, NULL, pto);
    if (ready == -1) {
        perror("select");
        exit(EXIT_FAILURE);
    }

    // 报告结果
    printf("ready = %d\n", ready);
    if (pto != NULL)
        printf("timeout after select(): %ld.%03ld\n", 
               (long) timeout.tv_sec, (long) timeout.tv_usec / 1000);

    for (fd = 0; fd < nfds; fd++)
        printf("%d: %s%s\n", fd, FD_ISSET(fd, &readfds) ? "r" : "",
               FD_ISSET(fd, &writefds) ? "w" : "");

    exit(EXIT_SUCCESS);
}
```

##### **运行演示**

1.  **检查标准输入的可读性，超时10秒**:
    ```bash
    $ ./t_select 10 0r
    # (立即按回车)
    ready = 1
    timeout after select(): 9.998
    0: r
    1: 
    $  <-- shell 提示符立即出现，因为 t_select 没有读取换行符
    ```
2.  **检查标准输入的可读性，超时0秒 (轮询)**:
    ```bash
    $ ./t_select 0 0r
    ready = 0
    timeout after select(): 0.000
    0:
    1:
    ```
3.  **检查标准输入(0)的可读性和标准输出(1)的可写性，无限阻塞**:
    ```bash
    $ ./t_select - 0r 1w
    ready = 1
    0:
    1: w
    ```
    > **解读**: `select()` 立即返回，因为它发现标准输出（文件描述符 1）总是可写的。

#### **63.2.2 poll()系统调用**

`poll()` 系统调用执行的任务同 `select()` 很相似。两者间主要的区别在于指定待检查的文件描述符的方式。在 `poll()` 中，我们提供一个由文件描述符和其关心事件组成的数组。

```c
#include <poll.h>

int poll(struct pollfd fds[], nfds_t nfds, int timeout);
```

  * **`fds`**: 一个 `pollfd` 结构体数组。
  * **`nfds`**: `fds` 数组中元素的个数。
  * **`timeout`**: 指定 `poll()` 的阻塞行为，单位为**毫秒**。

##### **`pollfd` 结构体**

`pollfd` 结构体的定义如下：

```c
struct pollfd {
    int   fd;         /* file descriptor */
    short events;     /* requested events (input) */
    short revents;    /* returned events (output) */
};
```

  * **`fd`**: 要监视的文件描述符。
  * **`events`**: 一个位掩码，由调用者设置，用于指定需要为 `fd` 检查的**事件**。
  * **`revents`**: 一个位掩码，当 `poll()` 返回时，由内核设置，用于表示该文件描述符上**实际发生**的事件。

> **临时忽略一个描述符**: 如果要临时忽略数组中的某个 `pollfd` 条目，可以将其 `fd` 字段设为一个负值。

##### **events 和 revents 字段的位掩码**

下表列出了可能会出现在 `events` 和 `revents` 字段中的位掩码。

**表 63-2：`pollfd` 结构体中的位掩码值**

| 位掩码          | events 中的输入 | 返回到 revents | 描述                         |
| :----------- | :---------: | :---------: | :------------------------- |
| `POLLIN`     |      ✓      |      ✓      | 有数据可读                      |
| `POLLRDNORM` |      ✓      |      ✓      | 等同于 `POLLIN`               |
| `POLLRDBAND` |      ✓      |      ✓      | 可读取优先级数据 (Linux 中不常用)      |
| `POLLPRI`    |      ✓      |      ✓      | 可读取高优先级数据                  |
| `POLLRDHUP`  |      ✓      |      ✓      | **(Linux 专有)** 对端套接字关闭或半关闭 |
| `POLLOUT`    |      ✓      |      ✓      | 写入不会阻塞                     |
| `POLLWRNORM` |      ✓      |      ✓      | 等同于 `POLLOUT`              |
| `POLLWRBAND` |      ✓      |      ✓      | 可写入优先级数据 (Linux 中不常用)      |
| `POLLERR`    |             |      ✓      | 发生错误                       |
| `POLLHUP`    |             |      ✓      | 发生挂断                       |
| `POLLNVAL`   |             |      ✓      | 文件描述符未打开                   |

> **在 Linux 上的常用标志**:
> 尽管定义了很多标志，但在 Linux 上，`poll()` 真正关心的标志位主要是 **`POLLIN`** (可读), **`POLLOUT`** (可写), **`POLLPRI`** (高优先级数据), 和 **`POLLRDHUP`** (对端关闭)。`POLLHUP` 和 `POLLERR` 则是由内核在 `revents` 中自动返回的，无需在 `events` 中请求。

##### **`timeout` 参数**

  * **`timeout = -1`**: `poll()` 会一直**阻塞**，直到有事件发生或被信号中断。
  * **`timeout = 0`**: `poll()` **不阻塞**，执行一次检查后立即返回。
  * **`timeout > 0`**: `poll()` 最多**阻塞 `timeout` 毫秒**。

##### **`poll()` 的返回值**

  * **-1**: 发生错误（例如 `EINTR`）。
  * **0**: 在超时时间耗尽前，没有任何文件描述符就绪。
  * **正整数**: 返回 `fds` 数组中 `revents` 字段非零的 `pollfd` 结构体**数量**。

-----

#### **程序示例**

程序清单 63-2 给出了一个使用 `poll()` 的简单演示。程序创建了一些管道，向其中随机写入数据，然后通过 `poll()` 来检查哪个管道中有数据可读。

**程序清单 63-2：使用 `poll()` 来检查多个文件描述符**

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <poll.h>
#include <time.h>

int main(int argc, char *argv[]) {
    int numPipes, numWrites, ready, randPipe;
    int (*pfds)[2]; // 管道文件描述符数组
    struct pollfd *pollFd;

    if (argc != 3 || strcmp(argv[1], "--help") == 0) {
        fprintf(stderr, "Usage: %s num-pipes num-writes\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    numPipes = atoi(argv[1]);
    numWrites = atoi(argv[2]);
    
    // 分配内存
    pfds = calloc(numPipes, sizeof(int[2]));
    pollFd = calloc(numPipes, sizeof(struct pollfd));
    if (pfds == NULL || pollFd == NULL) {
        perror("malloc");
        exit(EXIT_FAILURE);
    }
    
    // 创建管道并设置 pollfd 数组
    for (int j = 0; j < numPipes; j++) {
        if (pipe(pfds[j]) == -1) {
            perror("pipe");
            exit(EXIT_FAILURE);
        }
        printf("Pipe fd: %d, %d\n", pfds[j][0], pfds[j][1]);
        
        pollFd[j].fd = pfds[j][0]; // 监视管道的读端
        pollFd[j].events = POLLIN;
    }
    
    // 随机向一些管道写入数据以触发事件
    srandom((int) time(NULL));
    for (int j = 0; j < numWrites; j++) {
        randPipe = random() % numPipes;
        printf("Writing to fd: %d\n", pfds[randPipe][1]);
        if (write(pfds[randPipe][1], "a", 1) == -1) {
            perror("write");
            exit(EXIT_FAILURE);
        }
    }

    // 调用 poll()
    printf("Calling poll()...\n");
    ready = poll(pollFd, numPipes, -1); // 无限阻塞
    if (ready == -1) {
        perror("poll");
        exit(EXIT_FAILURE);
    }

    printf("poll() returned: %d\n", ready);

    // 检查哪个管道就绪了
    for (int j = 0; j < numPipes; j++) {
        if (pollFd[j].revents & POLLIN) {
            printf("Readable: %d\n", pollFd[j].fd);
        }
    }
    
    exit(EXIT_SUCCESS);
}
```

##### **编译和运行演示**

```bash
$ gcc poll_pipes.c -o poll_pipes
$ ./poll_pipes 10 3
Pipe fd: 3, 4
Pipe fd: 5, 6
...
Pipe fd: 21, 22
Writing to fd: 10
Writing to fd: 18
Writing to fd: 4
Calling poll()...
poll() returned: 3
Readable: 3
Readable: 9
Readable: 17
```

**解读**: 程序创建了 10 个管道，并随机向其中 3 个的写端写入了数据。随后 `poll()` 调用返回，报告有 3 个文件描述符（管道的读端）处于可读就绪状态。


#### **63.2.3 文件描述符何时就绪**

正确使用 `select()` 和 `poll()` 需要理解在什么情况下文件描述符会被标记为“就绪态”。SUSv3 中的核心定义是：如果对一个文件描述符（未指定 `O_NONBLOCK` 标志）的 I/O 调用**不会阻塞**，那么它就被认为是就绪的。

`select()` 和 `poll()` 只会告诉我们 I/O 操作是否会阻塞，而不会告诉我们到底能否成功传输数据。

##### **普通文件**
代表普通文件的文件描述符**总是**被 `select()` 标记为**可读和可写**。对于 `poll()` 来说，则会在 `revents` 字段中返回 `POLLIN` 和 `POLLOUT` 标志。这是因为对普通文件的 `read()` 和 `write()` 调用通常会立刻返回（得益于内核的缓冲区高速缓存），而不会阻塞。

##### **终端和伪终端**
**表 63-3：在终端和伪终端上 `select()` 和 `poll()` 所表示的意义**

| 条件或事件                     | `select()` | `poll()`              |
| :------------------------ | :--------- | :-------------------- |
| 有输入数据到达                   | `r`        | `POLLIN`              |
| 输出缓冲区有空间可写入               | `w`        | `POLLOUT`             |
| 伪终端对端调用 `close()` 后       | `rw`       | `POLLHUP` (在 Linux 上) |
| 处于信包模式下的伪终端主设备检测到从设备端状态改变 | `x`        | `POLLPRI`             |

##### **管道和 FIFO**
**表 63-4：`select()` 和 `poll()` 在管道或 FIFO **读端**上的通知

| 管道中有数据？ | 写端打开了吗？ | `select()` | `poll()`  |
| :------ | :------ | :--------- | :-------- |
| 否       | 否 (已关闭) | `r`        | `POLLHUP` |
| 否       | 是       | (不就绪)      | (不就绪)     |
| 是       | (任意)    | `r`        | `POLLIN`  |

**表 63-5：`select()` 和 `poll()` 在管道或 FIFO **写端**上的通知**

| 有 `PIPE_BUF` 个字节的空间吗？ | 读端打开了吗？ | `select()` | `poll()`  |
| :-------------------- | :------ | :--------- | :-------- |
| (任意)                  | 否 (已关闭) | `w`        | `POLLERR` |
| 否                     | 是       | (不就绪)      | (不就绪)     |
| 是                     | 是       | `w`        | `POLLOUT` |
> **注意**: Linux 判定管道写就绪的标准是管道中是否有足够的剩余空间能**以原子方式写入 `PIPE_BUF` 个字节**。其他一些 UNIX 实现的标准可能更宽松（例如，只要可以写入 1 个字节）。

##### **套接字 (Socket)**

**表 63-6：`select()` 和 `poll()` 在套接字上通知的事件**

| 条件或事件                        | `select()` | `poll()`                |
| :--------------------------- | :--------- | :---------------------- |
| 有输入数据到达                      | `r`        | `POLLIN`                |
| 输出缓冲区有空间可写入                  | `w`        | `POLLOUT`               |
| 在**监听套接字**上建立新连接             | `r`        | `POLLIN`                |
| 接收到带外数据 (仅限 TCP)             | `x`        | `POLLPRI`               |
| 流套接字的对端关闭连接 (或半关闭 `SHUT_WR`) | `r`        | `POLLIN` \| `POLLRDHUP` |

**`POLLRDHUP` 标志**: 这是一个 Linux 专有的标志，它提供了一种可靠的方式来判断流式套接字的对端是否已经关闭或半关闭了其写连接。使用这个标志可以比通过 `read()` 返回 0 来判断对端关闭更简洁。

# 简洁解释

您可以把 `select` 或 `poll` 想象成您的一个非常聪明的**秘书**。您交给他一堆正在进行中的任务（文件描述符），然后小睡一会儿。您的指示是：

**“这些任务里，哪个有进展了就叫醒我。我不想被任何一个任务卡住干等。”**

“有进展”（即“就绪态”）的意思就是：**“你现在去处理它，它会立刻给你一个结果（无论是拿到数据、成功发送，还是知道对方已离开），绝对不会让你卡在那儿干等。”**

下面我们来看看对于不同类型的任务，秘书会在什么时候叫醒您：

---
#### **普通文件 (比如桌上的书)** 📖

对于读写普通文件，情况很简单。

* **秘书会立刻告诉你**：“老板，这本书**随时都可以读**，你的笔记本**随时都可以写**。这个任务永远不会卡住。”
* **原因**: 因为内核有缓冲区（可以想象成你的短期记忆），读写文件的操作总是先和这块高速内存打交道，所以对你来说是瞬间完成的。

---
### **终端 (你的对话窗口)** 💬

这就像一个对讲机或聊天窗口。

* **什么时候可读？**
    * **秘书会叫醒你**：“对方**有新消息发过来了**，可以读了！”
* **什么时候可写？**
    * **秘书会告诉你**：“屏幕**随时可以显示**你要打的字，可以写了！” (基本上总是可写的)

---
### **管道和 FIFO (工厂的传送带)** conveyor belt

这就像两个工人之间的一条传送带。你是其中一个工人。

#### **读端 (从传送带上拿东西)**

* **什么时候可以去拿？** (可读)
    * ✅ **传送带上有东西**。
    * ✅ 传送带是空的，但**对面的工人下班了**（写端关闭）。秘书会告诉你：“对面收工了，不会再有新东西来了。” 你过去一看，就知道工作结束了 (EOF)。
* **什么时候不能去拿？** (会卡住/不就绪)
    * ❌ 传送带是空的，但对面的工人**还在岗**，只是暂时没放东西。这时你去等，就会被卡住。

#### **写端 (往传送带上放东西)**

* **什么时候可以去放？** (可写)
    * ✅ **传送带上有足够的空位**。
    * ✅ **对面的工人已经下班了**（读端关闭）。秘书会告诉你：“对面没人收东西了，别放了！” 这时你再去放，会立刻得到一个“错误”的结果，但不会卡住。
* **什么时候不能去放？** (会卡住/不就绪)
    * ❌ **传送带已经满了**，对面的工人还没来得及取走。这时你去放，就会被卡住。

---
### **套接字 (Socket，可以想成是电话)** ☎️

#### **监听套接字 (你的总机)**

* **什么时候会响？** (可读)
    * ✅ 当**有新的电话打进来**时。秘书会告诉你：“有新连接请求，快去 `accept()` 接听！”

#### **已连接的套接字 (正在通话中)**

* **什么时候可读？**
    * ✅ **对方在电话里说话了**（发来了数据）。
    * ✅ **对方挂断了电话**。秘书会告诉你：“对方挂机了。” 你再去听，就知道通话结束了 (EOF)。
* **什么时候可写？**
    * ✅ **电话线路畅通**，你可以随时说话（发送缓冲区有空间）。

希望这些比喻能让您对“就绪态”有一个更直观的理解！


#### **63.2.4 比较 select()和 poll()**

##### **API 之间的区别**
1.  **文件描述符数量限制**:
    * `select()`: 使用 `fd_set`，其大小受常量 `FD_SETSIZE` (在 Linux 上通常为 1024) 的限制。
    * `poll()`: 使用 `pollfd` 数组，对被检查的文件描述符数量**没有固定的上限**。

2.  **参数的重用**:
    * `select()`: `fd_set` 是一个**值-结果**参数，每次调用后都会被内核修改。如果在循环中使用，**必须在每次调用前重新初始化**。
    * `poll()`: 将输入的 `events` 和输出的 `revents` 分开在两个字段中，因此**无需**在每次循环调用前都重新初始化参数数组。

3.  **超时精度**:
    * `select()`: 使用 `timeval` 结构，提供**微秒**级的精度。
    * `poll()`: 使用 `int` 类型，提供**毫秒**级的精度。
    (两者的实际精度都受内核软件时钟粒度的限制。)

4.  **对已关闭文件描述符的处理**:
    * `poll()`: 如果一个文件描述符被关闭了，`poll()` 会在其对应的 `revents` 字段中设置 `POLLNVAL` 标志，从而准确地告诉我们是哪一个描述符出了问题。
    * `select()`: 只会返回 -1 并将 `errno` 设为 `EBADF`，需要我们自己去找出是哪个描述符非法。

##### **可移植性**
历史上，`select()` 比 `poll()` 使用得更加广泛。如今这两个接口都在 SUSv3 中被标准化了，且都广泛存在于现代的 UNIX 实现中。

##### **性能**
* **密集文件描述符**: 当待检查的文件描述符范围较小，或分布得很密集时，`poll()` 和 `select()` 的性能表现相似。
* **稀疏文件描述符**: 当被检查的文件描述符集合很**稀疏**时（例如，只检查文件描述符 3, 5, 999），`poll()` 的性能表现将**优于** `select()`。
    * **原因**: `select()` 的 `nfds` 参数要求内核检查从 0 到 `nfds-1` 之间的所有文件描述符位。而 `poll()` 只传递了我们感兴趣的文件描述符数组，内核只需检查这些指定的描述符。
    * **在 Linux 2.6 及之后**: 内核通过一些优化手段，这个性能差异已经被极大地缩小了。


#### **63.2.5 select()和 poll()存在的问题**

尽管 `select()` 和 `poll()` 系统调用是可移植的、长期存在且被广泛使用的，但在需要同时检查**大量**文件描述符（例如，成百上千个）时，这两个 API 都会遇到严重的性能瓶颈。

这些问题主要源于以下几点：

1.  **每次调用都需要内核进行线性扫描**:
    * 每次调用 `select()` 或 `poll()`，内核都必须**遍历所有**被指定的文件描述符，逐一检查它们的状态。当文件描述符数量巨大时，这个扫描操作本身就会消耗大量 CPU 时间。

2.  **每次调用都需要在用户空间和内核空间之间传递数据结构**:
    * 每次调用 `select()` 或 `poll()` 时，程序都必须将一个包含所有待检查文件描述符的数据结构（`fd_set` 数组或 `pollfd` 数组）从用户空间**拷贝**到内核空间。
    * 内核检查完毕后，又需要将这个被修改过的数据结构从内核空间**拷贝**回用户空间。
    * 当监视的文件描述符数量增加时，这个数据结构的大小也会随之增加（特别是对于 `poll()`），来回拷贝的开销会变得非常显著。

3.  **每次调用后都需要应用程序进行线性扫描**:
    * `select()` 或 `poll()` 调用返回后，程序本身也必须**遍历整个**返回的数据结构，使用 `FD_ISSET()` 或检查 `revents` 字段，以找出具体是哪些文件描述符处于就绪态。

##### **问题的根源：无状态 (Stateless)**

`select()` 和 `poll()` 糟糕的性能延展性，源于这些 API 的一个根本性局限：它们是**无状态的**。

这意味着，内核并**不会记录**一个进程对哪些文件描述符感兴趣。每一次调用都是一个全新的、独立的请求。应用程序必须在每次调用时都重复地将完整的文件描述符列表传递给内核，而内核也必须在每次调用时都重复地检查这个完整的列表。

##### **更优的解决方案**

我们接下来要讨论的**信号驱动 I/O** 以及 **epoll** 都可以使内核**记录（注册）**下进程感兴趣的文件描述符。

* **机制**: 通过这种“有状态”的机制，内核可以在内部建立优化的数据结构来监视这些文件描述符。
* **效果**: 当一个 I/O 事件发生时，内核可以直接知道是哪个文件描述符就绪了，并通知应用程序，而无需遍历所有被监视的描述符。
* **优势**: 这种解决方案的性能只取决于**发生 I/O 事件的数量**，而与被监视的文件描述符总数无关。因此，当需要检查大量文件描述符时，信号驱动 I/O 和 `epoll` 能提供远优于 `select()` 和 `poll()` 的性能表现。