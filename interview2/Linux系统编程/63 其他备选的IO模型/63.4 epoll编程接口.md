### **63.4 epoll 编程接口**

与 I/O 多路复用 (`select`/`poll`) 和信号驱动 I/O 一样，Linux 的 **epoll (event poll)** API 可以检查多个文件描述符上的 I/O 就绪状态。epoll API 的主要优点如下：

  * **高性能**: 当检查大量的文件描述符时，epoll 的性能延展性比 `select()` 和 `poll()` 高很多。
  * **灵活的触发模式**: epoll API **既支持水平触发 (level-triggered) 也支持边缘触发 (edge-triggered)**。与之相反，`select()` 和 `poll()` 只支持水平触发，而信号驱动 I/O 只支持边缘触发。
  * **编程更简单**: 与信号驱动 I/O 相比，epoll 可以避免复杂的信号处理流程（比如信号队列溢出时的处理），并且可以灵活地指定需要检查的事件类型（读就绪、写就绪或两者都检查）。

> epoll API 是 Linux 系统专有的，在内核 2.6 版中新增。

#### **核心概念**

epoll API 的核心数据结构被称为 **epoll 实例**，它和一个打开的文件描述符相关联。这个文件描述符本身不用于 I/O 操作，而是作为内核中一个数据结构的句柄，该数据结构实现了两个目的：

1.  **兴趣列表 (Interest List)**: 记录了进程声明感兴趣的所有文件描述符的列表。
2.  **就绪列表 (Ready List)**: 维护了兴趣列表中那些当前处于 I/O 就绪状态的文件描述符列表。

#### **API 概览**

epoll API 由以下三个核心系统调用组成：

  * **`epoll_create()`**: 创建一个 epoll 实例，并返回代表该实例的文件描述符。
  * **`epoll_ctl()`**: 操作 epoll 实例的**兴趣列表**（增加、删除、修改文件描述符及其关心的事件）。
  * **`epoll_wait()`**: 等待事件，并返回**就绪列表**中的成员。

-----

#### **63.4.1 创建 epoll 实例：epoll\_create()**

`epoll_create()` 系统调用创建一个新的 epoll 实例，其对应的兴趣列表初始化为空。

```c
#include <sys/epoll.h>

int epoll_create(int size);
```

  * **`size`**: 这个参数指定了我们期望通过 epoll 实例检查的文件描述符的大致个数。它**不是**一个硬性上限，只是给内核的一个提示，以便为内部数据结构划分初始大小。
    > **注意**: 从 Linux 2.6.8 版以来，**`size` 参数被忽略不用**。
  * **返回值**: 成功时，返回一个代表新创建的 epoll 实例的文件描述符。
  * **关闭**: 当这个文件描述符不再需要时，应该通过 `close()` 来关闭。当所有引用同一个 epoll 实例的文件描述符都被关闭时，该实例将被销毁。

##### **`epoll_create1()`**

从 2.6.27 版内核以来，Linux 支持了一个新的、更推荐使用的系统调用 `epoll_create1()`。

```c
#include <sys/epoll.h>

int epoll_create1(int flags);
```

它与 `epoll_create()` 的区别在于：

1.  去掉了无用的 `size` 参数。
2.  增加了一个 `flags` 参数。目前只支持一个标志：
      * **`EPOLL_CLOEXEC`**: 在创建 epoll 文件描述符的同时，原子地为其设置 `close-on-exec` 标志 (`FD_CLOEXEC`)，这在多线程程序中可以避免竞态条件。


#### **63.4.2 修改 epoll 的兴趣列表：epoll\_ctl()**

`epoll_ctl()` 系统调用能够修改由文件描述符 `epfd` 所代表的 epoll 实例中的**兴趣列表 (interest list)**。

```c
#include <sys/epoll.h>

int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
```

  * **`epfd`**: `epoll_create()` 返回的 epoll 实例的文件描述符。
  * **`fd`**: 要在兴趣列表中修改设定的目标文件描述符。
    > `fd` 可以是代表管道、FIFO、套接字、POSIX 消息队列、inotify 实例、终端、设备，甚至是另一个 epoll 实例的文件描述符。但是，**不能**是普通文件或目录的文件描述符。
  * **`op`**: 指定需要执行的操作，其值可以是：
      * **`EPOLL_CTL_ADD`**: 将文件描述符 `fd` **添加**到 `epfd` 的兴趣列表中。`event` 参数指定了我们对 `fd` 感兴趣的事件。如果 `fd` 已经存在于兴趣列表中，调用会失败并返回 `EEXIST` 错误。
      * **`EPOLL_CTL_MOD`**: **修改** `fd` 上已设定的事件，新的事件设置由 `event` 参数指定。如果 `fd` 不在兴趣列表中，调用会失败并返回 `ENOENT` 错误。
      * **`EPOLL_CTL_DEL`**: 将文件描述符 `fd` 从 `epfd` 的兴趣列表中**移除**。此操作会忽略 `event` 参数（可以设为 `NULL`）。
  * **`event`**: 指向一个 `epoll_event` 结构体的指针。

> **自动移除**: 关闭一个文件描述符会自动将其从**所有** epoll 实例的兴趣列表中移除。

##### **`epoll_event` 结构**

`epoll_event` 结构体用于为 `epoll_ctl()` 提供参数，并在 `epoll_wait()` 中返回事件信息。

```c
struct epoll_event {
    uint32_t      events;    /* Epoll events (位掩码) */
    epoll_data_t  data;      /* User data variable */
};

typedef union epoll_data {
    void         *ptr;
    int           fd;
    uint32_t      u32;
    uint64_t      u64;
} epoll_data_t;
```

  * **`events`**: 一个位掩码，指定了我们为 `fd` 感兴趣的事件集合（例如 `EPOLLIN` 表示可读）。
  * **`data`**: 一个联合体，这是 epoll 的一个强大特性。它允许我们将一个**自定义数据**（例如，一个指向包含客户端状态信息的结构体的指针、一个整数、或者文件描述符 `fd` 自身）与被监视的文件描述符关联起来。当 `epoll_wait()` 稍后报告 `fd` 已就绪时，这个 `data` 联合体会原样返回，使我们能够立即获得与该事件相关的上下文信息。

-----

##### **`max_user_watches` 上限**

因为每个注册到 epoll 实例上的文件描述符都需要占用一小段不可被交换的内核内存空间，所以内核提供了一个接口，用于限制每个用户可以注册到所有 epoll 实例上的文件描述符总数。

这个上限值可以通过读取和修改 Linux 特有的文件 `/proc/sys/fs/epoll/max_user_watches` 来进行调整。

-----

#### **程序示例**

程序清单 63-4 展示了如何使用 `epoll_create()` 和 `epoll_ctl()` 的 `EPOLL_CTL_ADD` 操作来将一组文件描述符添加到 epoll 实例的兴趣列表中。

**程序清单 63-4：使用 `epoll_create()` 和 `epoll_ctl()`**

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/epoll.h>

int main(int argc, char *argv[]) {
    int epfd;
    struct epoll_event ev;

    if (argc < 2) {
        fprintf(stderr, "Usage: %s fd1 fd2...\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    // 1. 创建 epoll 实例
    epfd = epoll_create1(0);
    if (epfd == -1) {
        perror("epoll_create1");
        exit(EXIT_FAILURE);
    }

    // 2. 循环遍历命令行参数，将文件描述符添加到兴趣列表
    for (int j = 1; j < argc; j++) {
        int fd = atoi(argv[j]);
        
        ev.events = EPOLLIN; // 我们关心输入(可读)事件
        ev.data.fd = fd;     // 将 fd 自身作为关联数据
        
        // 使用 EPOLL_CTL_ADD 将 fd 添加到 epfd 的兴趣列表
        if (epoll_ctl(epfd, EPOLL_CTL_ADD, fd, &ev) == -1) {
            fprintf(stderr, "Failed to add fd %d to epoll instance", fd);
            perror("");
            exit(EXIT_FAILURE);
        }
    }
    
    printf("Successfully added all file descriptors to epoll instance %d\n", epfd);
    
    // ... 此时可以调用 epoll_wait() 等待事件 ...
    
    close(epfd);
    exit(EXIT_SUCCESS);
}
```

#### **63.4.3 事件等待：epoll\_wait()**

`epoll_wait()` 系统调用返回 epoll 实例中处于**就绪态**的文件描述符信息。单个 `epoll_wait()` 调用能返回多个就绪态文件描述符的信息。

```c
#include <sys/epoll.h>

int epoll_wait(int epfd, struct epoll_event *events,
               int maxevents, int timeout);
```

  * **`epfd`**: `epoll_create()` 返回的 epoll 实例的文件描述符。
  * **`events`**: 一个指向 `epoll_event` 结构体数组的指针。调用者负责申请这块内存区域，内核会将就绪事件的信息填充到这个数组中返回。
  * **`maxevents`**: `events` 数组中元素的个数。
  * **`timeout`**: 确定 `epoll_wait()` 的阻塞行为，单位为毫秒：
      * **-1**: 一直阻塞，直到有事件产生或被信号中断。
      * **0**: 执行一次非阻塞式的检查后立即返回。
      * **\> 0**: 最多阻塞 `timeout` 毫秒。
  * **返回值**:
      * **\> 0**: 成功，返回 `events` 数组中有效元素的个数。
      * **0**: 超时，在指定时间内没有任何文件描述符处于就绪态。
      * **-1**: 发生错误。

当 `epoll_wait()` 成功返回时，`events` 数组中的每个元素都包含了单个就绪文件描述符的信息。

  * `events[i].events` 字段返回了在该描述符上已经发生的事件掩码。
  * `events[i].data` 字段返回的是我们在 `epoll_ctl()` 中与该描述符关联的 `ev.data` 的值。**这是获知哪个文件描述符就绪了的唯一途径**。因此，在 `epoll_ctl()` 中，通常应该将 `ev.data.fd` 设为文件描述符本身，或者将 `ev.data.ptr` 设为指向包含文件描述符及其他上下文信息的结构体。

##### **epoll 事件**

下表列出了可以在 `epoll_ctl()` 的 `events` 字段中指定的，以及由 `epoll_wait()` 在 `events` 字段中返回的位掩码。

**表 63-8：epoll `events` 字段的位掩码值**


| 位掩码            | `epoll_ctl()` 输入 | `epoll_wait()` 返回 | 描述                               |
| :------------- | :--------------: | :---------------: | :------------------------------- |
| `EPOLLIN`      |        ✓         |         ✓         | 可读取数据                            |
| `EPOLLPRI`     |        ✓         |         ✓         | 可读取高优先级数据 (带外数据)                 |
| `EPOLLRDHUP`   |        ✓         |         ✓         | (Linux 2.6.17+) 套接字对端关闭或半关闭      |
| `EPOLLOUT`     |        ✓         |         ✓         | 可写入数据                            |
| `EPOLLET`      |        ✓         |                   | 采用**边缘触发 (Edge-Triggered)** 事件通知 |
| `EPOLLONESHOT` |        ✓         |                   | 在完成一次事件通知之后禁用检查                  |
| `EPOLLERR`     |                  |         ✓         | 发生错误                             |
| `EPOLLHUP`     |                  |         ✓         | 出现挂断                             |

##### **`EPOLLONESHOT` 标志**

默认情况下，一旦将文件描述符添加到兴趣列表中，它会持续保持激活状态。如果使用 `EPOLLONESHOT` 标志，那么在 `epoll_wait()` 通知我们该文件描述符就绪**一次**之后，这个描述符就会在兴趣列表中被标记为**非激活**。之后的 `epoll_wait()` 调用都不会再通知我们有关这个描述符的状态了，直到我们通过 `epoll_ctl()` 的 `EPOLL_CTL_MOD` 操作将其重新激活。

-----

#### **程序示例**

程序清单 63-5 展示了如何结合使用 `epoll` API 的三个核心函数来监视多个 FIFO 的输入。

**程序清单 63-5：使用 epoll API**

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/epoll.h>
#include <errno.h>

#define MAX_EVENTS 5

int main(int argc, char *argv[]) {
    int epfd, ready, fd, j, numOpenFds;
    struct epoll_event ev;
    struct epoll_event evlist[MAX_EVENTS];
    char buf[10];

    if (argc < 2 || strcmp(argv[1], "--help") == 0) {
        fprintf(stderr, "Usage: %s file...\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    // ① 创建 epoll 实例
    epfd = epoll_create(argc - 1);
    if (epfd == -1) {
        perror("epoll_create");
        exit(EXIT_FAILURE);
    }
    
    // ② 打开由命令行参数指定的每个文件
    for (j = 1; j < argc; j++) {
        fd = open(argv[j], O_RDONLY);
        if (fd == -1) {
            perror("open");
            exit(EXIT_FAILURE);
        }
        printf("Opened \"%s\" on fd %d\n", argv[j], fd);
        
        // ③ 将文件描述符添加到 epoll 实例的兴趣列表
        ev.events = EPOLLIN; // 我们关心输入(可读)事件
        ev.data.fd = fd;
        if (epoll_ctl(epfd, EPOLL_CTL_ADD, fd, &ev) == -1) {
            perror("epoll_ctl");
            exit(EXIT_FAILURE);
        }
    }

    numOpenFds = argc - 1;

    // ④ 执行主循环
    while (numOpenFds > 0) {
        // ⑤ 调用 epoll_wait()
        printf("About to epoll_wait()\n");
        ready = epoll_wait(epfd, evlist, MAX_EVENTS, -1);
        if (ready == -1) {
            // ⑥ 如果被信号中断，则重启调用
            if (errno == EINTR)
                continue;
            else {
                perror("epoll_wait");
                exit(EXIT_FAILURE);
            }
        }
        printf("Ready: %d\n", ready);

        // ⑦ 遍历就绪的文件描述符
        for (j = 0; j < ready; j++) {
            printf("  fd=%d; events: %s%s%s\n", evlist[j].data.fd,
                   (evlist[j].events & EPOLLIN) ? "EPOLLIN " : "",
                   (evlist[j].events & EPOLLHUP) ? "EPOLLHUP " : "",
                   (evlist[j].events & EPOLLERR) ? "EPOLLERR " : "");
            
            // ⑧⑨ 如果是可读或挂断/错误事件
            if (evlist[j].events & (EPOLLIN | EPOLLHUP | EPOLLERR)) {
                // 读取数据
                if (read(evlist[j].data.fd, buf, sizeof(buf)) > 0) {
                    // 简单打印
                    printf("    read some bytes\n");
                } else {
                    // 如果 read 返回 0 (EOF) 或错误，说明对端已关闭
                    printf("    closing fd %d\n", evlist[j].data.fd);
                    // ⑩ 关闭对应的文件描述符
                    if (close(evlist[j].data.fd) == -1) {
                        perror("close");
                        exit(EXIT_FAILURE);
                    }
                    numOpenFds--;
                }
            }
        }
    }
    
    printf("All FDs closed; bye\n");
    close(epfd);
    exit(EXIT_SUCCESS);
}

```

##### **编译和运行演示**

1.  **编译程序**: `gcc epoll_demo.c -o epoll_demo`
2.  **在终端 1 中，创建 FIFO 并启动程序监视它们**:
    ```bash
    $ mkfifo fifo1 fifo2
    $ ./epoll_demo fifo1 fifo2
    Opened "fifo1" on fd 3
    Opened "fifo2" on fd 4
    About to epoll_wait() 
    ```
    (程序会阻塞在 `epoll_wait`)
3.  **在终端 2 中，向 FIFO 写入数据**:
    ```bash
    # 打开 fifo1，写入数据，然后关闭 (Ctrl-D)
    $ cat > fifo1
    hello
    ^D

    # 打开 fifo2，写入数据，但不关闭
    $ cat > fifo2
    world
    ```
4.  **回到终端 1，查看程序输出**:
    ```bash
    # (在终端2中输入hello后)
    Ready: 1
      fd=3; events: EPOLLIN 
        read some bytes
    About to epoll_wait()
    # (在终端2中关闭fifo1后)
    Ready: 1
      fd=3; events: EPOLLHUP 
        closing fd 3
    About to epoll_wait()
    # (在终端2中输入world后)
    Ready: 1
      fd=4; events: EPOLLIN 
        read some bytes
    About to epoll_wait()
    ```
    **解读**: `epoll_wait` 精确地报告了 `EPOLLIN`（数据到达）和 `EPOLLHUP`（对端关闭）事件，程序据此进行相应的读或关闭操作。

#### **63.4.4 深入探究 epoll 的语义**

本节将深入探究 `epoll` 与打开文件、文件描述符之间交互的一些细微之处。理解这些语义的关键在于回顾一下**文件描述符 (file descriptor)** 和**打开的文件描述 (open file description)** 之间的关系（见 5.4 节）：

  * **文件描述符**: 是一个进程级的整数，是访问文件的句柄。
  * **打开的文件描述**: 是内核中系统级的一个结构体，包含了文件的状态（如 `O_NONBLOCK` 标志）、当前文件偏移量等信息。多个文件描述符（例如，通过 `dup()` 或 `fork()` 复制的）可以指向同一个“打开的文件描述”。

##### **`epoll` 兴趣列表与“打开的文件描述”**

1.  **epoll 实例自身**:

      * 当我们通过 `epoll_create()` 创建一个 epoll 实例时，内核会创建一个新的“打开的文件描述”，并返回一个与之关联的文件描述符 `epfd`。
      * epoll 的**兴趣列表**是与这个\*\*“打开的文件描述”\*\*相关联的。
      * **后果**: 如果我们使用 `dup()` 或 `fork()` 复制一个 `epfd`，那么新的文件描述符将指向与原始描述符**相同**的“打开的文件描述”，因此它们也共享**同一个**兴趣列表。通过任一描述符对兴趣列表的修改（`epoll_ctl()`）对另一个都是可见的。

2.  **被监视的文件**:

      * 当我们执行 `epoll_ctl(epfd, EPOLL_CTL_ADD, fd, ...)` 操作时，内核在 epoll 实例的兴趣列表中添加的，并不仅仅是 `fd` 这个数字，而是 `fd` 所对应的\*\*“打开的文件描述”\*\*的一个引用。
      * **后果**: 这对“关闭文件描述符会自动将其从兴趣列表中移除”这条规则进行了深化。更准确的说法是：**只有当所有指向同一个“打开的文件描述”的文件描述符都被关闭后，这个条目才会从 epoll 的兴趣列表中被移除**。

##### **令人惊讶的行为**

上述语义可导致一个看似令人惊讶的行为。假设我们执行以下操作：

1.  `fd1 = open(...)`
2.  `epoll_ctl(epfd, EPOLL_CTL_ADD, fd1, ...)` 将 `fd1` 加入兴趣列表。
3.  `fd2 = dup(fd1)` 创建一个 `fd1` 的副本。
4.  `close(fd1)` 关闭原始的文件描述符。

此时，尽管 `fd1` 已经被关闭，但由于 `fd2` 仍然打开着，并且它指向的是**同一个**“打开的文件描述”，所以内核**仍然会继续监视**这个“打开的文件描述”。如果此时该文件变为就绪态，`epoll_wait()` **仍然会返回一个事件**，并且返回的 `epoll_event` 结构中的 `data.fd` 字段的值**仍然是 `fd1`**（即我们当初注册时的那个值），即使 `fd1` 这个描述符在当前进程中已经不再有效。

-----

#### **程序示例**

程序清单 63-6 中的代码明确地演示了这种行为。

**程序清单 63-6：epoll 在文件描述符副本下的语义**

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/epoll.h>

#define MAX_EVENTS 5

int main(int argc, char *argv[]) {
    int pfd[2]; // Pipe file descriptors
    int fd1, fd2;
    int epfd;
    struct epoll_event ev, evlist[MAX_EVENTS];

    // 创建一个管道
    if (pipe(pfd) == -1) {
        perror("pipe");
        exit(EXIT_FAILURE);
    }
    
    fd1 = pfd[0]; // 管道的读端

    // 创建 epoll 实例
    epfd = epoll_create(1);
    if (epfd == -1) {
        perror("epoll_create");
        exit(EXIT_FAILURE);
    }
    
    // 将 fd1 添加到兴趣列表
    ev.events = EPOLLIN;
    ev.data.fd = fd1;
    if (epoll_ctl(epfd, EPOLL_CTL_ADD, fd1, &ev) == -1) {
        perror("epoll_ctl");
        exit(EXIT_FAILURE);
    }

    // 创建 fd1 的副本
    fd2 = dup(fd1);
    if (fd2 == -1) {
        perror("dup");
        exit(EXIT_FAILURE);
    }

    // 关闭 fd1
    if (close(fd1) == -1) {
        perror("close fd1");
        exit(EXIT_FAILURE);
    }
    printf("Closed fd %d\n", fd1);

    // 向管道的写端写入数据，使其读端变为就绪
    printf("Writing a byte to pipe's write end (%d)\n", pfd[1]);
    if (write(pfd[1], "a", 1) != 1) {
        perror("write");
        exit(EXIT_FAILURE);
    }

    // 调用 epoll_wait()
    printf("About to epoll_wait()\n");
    int ready = epoll_wait(epfd, evlist, MAX_EVENTS, -1);
    if (ready == -1) {
        perror("epoll_wait");
        exit(EXIT_FAILURE);
    }
    
    printf("epoll_wait() returned %d\n", ready);
    if (ready > 0) {
        // 检查返回的事件关联的文件描述符
        printf("Returned event reports fd = %d\n", evlist[0].data.fd);
    }
    
    exit(EXIT_SUCCESS);
}
```

##### **编译和运行**

```bash
$gcc epoll_dup_demo.c -o epoll_dup_demo$ ./epoll_dup_demo
Closed fd 3
Writing a byte to pipe's write end (4)
About to epoll_wait()
epoll_wait() returned 1
Returned event reports fd = 3
```

**解读**:
程序关闭了文件描述符 `3` (`fd1`)，但由于它的副本 `fd2` 仍然存在，内核继续监视与之关联的“打开的文件描述”。当管道中有数据可读时，`epoll_wait()` 成功返回，并且报告的就绪事件仍然与我们最初注册的 `fd` 值 `3` 相关联，即使这个描述符对当前进程来说已经关闭了。


#### **63.4.5 epoll 同 I/O 多路复用（select/poll）的性能对比**

下表展示了使用 `poll()`、`select()` 以及 `epoll` 监视 N 个连续文件描述符时的性能测试结果。该测试设定为在每次监视中，只有一个随机选择的文件描述符处于就绪态。

**表 63-9：poll()、select() 以及 epoll 进行 100,000 次监视操作所花费的 CPU 时间 (秒)**


| 被监视的文件描述符数量 (N) | `poll()` | `select()` | `epoll` |
| :-------------- | :------- | :--------- | :------ |
| **10**          | 0.61     | 0.73       | 0.41    |
| **100**         | 2.9      | 3.0        | 0.42    |
| **1000**        | 35       | 35         | 0.53    |
| **10000**       | 990      | 930        | 0.66    |

从这个表格中可以清晰地发现，随着被监视的文件描述符数量的急剧上升，`poll()` 和 `select()` 的性能表现**越来越差**。与之相反，当 N 增长到很大的值时，`epoll` 的性能表现**几乎不会降低**。

---
##### **epoll 高性能的原因**

`epoll` 的性能之所以远优于 `select()` 和 `poll()`，主要源于其设计避免了后两者的核心性能瓶颈：

1.  **避免内核线性扫描**:
    * **`select()` / `poll()`**: 每一次调用，内核都必须**遍历所有**被指定的文件描述符，逐一检查它们的状态。当描述符数量巨大时，这个线性扫描的开销非常大。
    * **`epoll`**: 内核通过 `epoll_ctl()` **只在第一次**注册时建立起对文件描述符的监视。当某个文件描述符因 I/O 操作而变为就绪态时，内核会通过一种类似回调的机制，**主动地**在该 epoll 实例的**就绪列表**中添加一个条目。`epoll_wait()` 调用只需简单地检查这个就绪列表是否为空，并返回其中的内容即可，完全无需遍历所有被监视的描述符。

2.  **避免重复的数据拷贝**:
    * **`select()` / `poll()`**: 每一次调用，程序都必须将一个包含了所有待监视文件描述符的数据结构，从**用户空间拷贝到内核空间**，调用返回时，内核又将修改后的整个数据结构**拷贝回用户空间**。
    * **`epoll`**: 我们使用 `epoll_ctl()` 在内核空间中建立一个持久的数据结构（兴趣列表）。一旦建立完成，后续每次调用 `epoll_wait()` 时，就**不再需要**传递任何与文件描述符有关的信息给内核了。调用返回时，内核也**只拷贝**那些已经处于就绪态的、数量相对较少的描述符的信息。

**结论**:
* `select()` 和 `poll()` 的性能会随着**被监视的文件描述符数量 (N)** 的增大而线性（甚至更差地）下降。
* `epoll` 的性能则只根据**发生 I/O 事件的数量**而扩展。

因此，`epoll` API 的一个典型且高效的应用场景就是需要同时处理成千上万个客户端连接的服务器：在这种场景下，需要监视大量的套接字文件描述符，但其中大部分在任意时刻都处于空闲状态，只有少数文件描述符是活跃（就绪）的。

#### **63.4.6 边缘触发通知**

默认情况下，`epoll` 提供的是**水平触发 (Level-Triggered, LT)** 通知。这表示 `epoll` 会告诉我们文件描述符何时**处于**可进行 I/O 的状态。这同 `select()` 和 `poll()` 所提供的通知类型相同。

`epoll` API 还能以**边缘触发 (Edge-Triggered, ET)** 方式进行通知。这意味着，`epoll` 只会告诉我们文件描述符**是否**自上一次调用 `epoll_wait()` 以来**有了新的 I/O 活动**。

要使用边缘触发通知，需要在调用 `epoll_ctl()` 时，在 `ev.events` 字段中指定 **`EPOLLET`** 标志。

##### **水平触发 (LT) vs. 边缘触发 (ET)**
我们通过一个例子来说明二者的区别。假设我们使用 `epoll` 来监视一个套接字上的输入：
1.  套接字上有输入数据到来。
2.  我们调用一次 `epoll_wait()`。无论采用 LT 还是 ET 模式，该调用都会返回，告诉我们套接字已就绪。
3.  我们**不读取**这些数据，然后再次调用 `epoll_wait()`。

此时，结果就不同了：
* **水平触发 (LT)**: 第二次 `epoll_wait()` 调用将**立即返回**，再次告诉我们套接字处于就绪态（因为“可读”这个状态仍然存在）。
* **边缘触发 (ET)**: 第二次 `epoll_wait()` 调用将**阻塞**，因为它不会再次通知我们同一个事件。只有当**新的**输入数据再次到达套接字时，它才会返回。

---
##### **边缘触发的编程框架**

边缘触发通知通常和**非阻塞的文件描述符**结合使用。采用 `epoll` 的边缘触发通知机制的程序，其基本框架如下：
1.  让所有待监视的文件描述符都成为**非阻塞的**。
2.  通过 `epoll_ctl()` 构建 epoll 的兴趣列表，并在 `events` 字段中包含 `EPOLLET` 标志。
3.  通过如下的循环处理 I/O 事件：
    a. 调用 `epoll_wait()` 取得处于就绪态的描述符列表。
    b. 针对每一个处于就绪态的文件描述符，**在一个循环中持续进行 I/O 处理**（例如 `read()` 或 `write()`），直到相关的系统调用失败，并返回 `EAGAIN` 或 `EWOULDBLOCK` 错误为止。

**第 3(b) 步至关重要**。因为 `epoll` 只通知一次事件的发生，我们必须一次性将该事件关联的数据全部处理完，否则剩余的数据将不会再有任何通知，从而导致数据丢失或程序阻塞。

---
##### **当采用边缘触发通知时避免出现文件描述符饥饿现象**

* **问题**:
    假设一个就绪的文件描述符上有大量的输入存在（例如一个不间断的输入流）。如果程序严格遵循“尽可能多地执行 I/O”的原则，就可能会一直在这个文件描述符上进行读操作，从而导致其他已就绪的文件描述符得不到处理，出现**饥饿 (starvation)** 现象。

* **解决方案**:
    一种解决方案是让应用程序维护一个自己的“就绪列表”，并采用轮转调度的方式处理。
    1.  调用 `epoll_wait()` 监视文件描述符，并将新近就绪的描述符添加到应用程序自己维护的列表中。
    2.  在一个循环中**遍历**这个由应用程序维护的列表，对列表中的**每一个**文件描述符都进行**一定限度**的 I/O 操作（例如，只读取固定大小的数据）。
    3.  当某个文件描述符上的非阻塞 I/O 操作返回 `EAGAIN` 或 `EWOULDBLOCK` 错误时，就认为它暂时处理完毕，可以从应用程序的列表中移除了。

这种方法虽然增加了编程的复杂性，但能确保所有就绪的文件描述符都能得到公平的处理机会，避免了饥饿现象。