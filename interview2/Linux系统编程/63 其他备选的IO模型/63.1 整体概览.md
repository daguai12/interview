### **63.1 备选 I/O 模型概述**

到目前为止，本书中大部分程序使用的都是传统的**阻塞式 I/O (blocking I/O)** 模型，即单个进程在单个文件描述符上执行 `read()` 或 `write()`，并且调用会阻塞直到 I/O 操作完成。

对于许多应用来说，这个模型已经足够了。但有些应用需要处理更复杂的任务，例如：
* 以非阻塞的方式检查文件描述符上是否可进行 I/O 操作。
* **同时检查多个文件描述符**，看它们中的任何一个是否可以执行 I/O 操作。

#### **初步的解决方案及其局限性**

* **非阻塞 I/O (`O_NONBLOCK`)**:
    * **优点**: 允许我们检查（“轮询”）一个文件描述符的状态而不会被阻塞。
    * **局限性**: 如果要同时检查多个文件描述符，就需要在一个循环中依次轮询它们。这种“忙等待”式的轮询要么会浪费大量 CPU 资源，要么会因轮询间隔过长而导致响应延迟过高。

* **多进程或多线程**:
    * **优点**: 可以为每个需要处理的文件描述符创建一个单独的进程或线程，从而并发地处理 I/O。
    * **局限性**: 开销昂贵且复杂。创建和维护大量进程/线程会消耗大量系统资源，并且它们之间需要通过 IPC 等机制进行通信，增加了编程的复杂性。

#### **更优的 I/O 模型**

由于上述方案的局限性，通常会采用以下几种更优的 I/O 模型：

1.  **I/O 多路复用 (I/O Multiplexing)**:
    * **功能**: 允许单个进程**同时监视多个文件描述符**，以找出其中任何一个是否已准备好执行 I/O 操作。
    * **实现**: 通过 `select()` 和 `poll()` 系统调用。

2.  **信号驱动 I/O (Signal-Driven I/O)**:
    * **功能**: 内核在文件描述符准备好执行 I/O 时，会向请求进程**发送一个信号**以作通知。
    * **优点**: 在监视大量文件描述符时，性能通常优于 `select()` 和 `poll()`。

3.  **epoll API**:
    * **功能**: 与 I/O 多路复用类似，允许进程同时监视多个文件描述符。
    * **优点**: 这是 Linux 专有的特性（始于内核 2.6），在监视大量文件描述符时，它能提供比 `select()` 和 `poll()` **更好的性能和延展性**。

> **共同点**:
> 这三种技术的目标都是相同的：**同时检查多个文件描述符，看它们是否已“就绪”**，即相应的 I/O 系统调用（如 `read`, `write`, `accept`）是否可以非阻塞地执行。它们只负责**通知**，而不执行实际的 I/O 操作。

> **POSIX 异步 I/O (AIO)**:
> 还有一种不同的模型是 POSIX AIO。它允许进程将一个 I/O 操作**入队**，然后立即返回继续执行其他任务。当 I/O 操作**完成**后，进程会收到通知。这实现了 I/O 操作与程序处理的真正并行。

---
#### **选择哪种技术**
在上述几种技术之间如何选择，可以参考以下要点。

| 技术 (Technology)           | 优点 (Pros)                  | 缺点 (Cons)                                       |
| :------------------------ | :------------------------- | :---------------------------------------------- |
| **`select()` / `poll()`** | **可移植性好** (所有 UNIX 系统都支持)  | **性能延展性差** (处理大量描述符时效率低下)                       |
| **`epoll` API**           | **性能延展性极佳** (高效处理成千上万的描述符) | **Linux 专有** (不具备可移植性)                          |
| **信号驱动 I/O**              | 性能延展性好                     | **编程复杂** (需要处理信号)；功能上不如 `epoll`；其高级功能同样不具备可移植性。 |
|                           |                            |                                                 |

**结论与建议**:
* `select()` 和 `poll()` 的主要优势在于**可移植性**。
* `epoll` 和信号驱动 I/O 的主要优势在于**性能表现**。

对于需要高性能和高并发的服务器程序，并且主要部署在 Linux 平台上，`epoll` 无疑是最佳选择。

对于需要跨平台的可移植程序，一个很好的策略是使用一个**软件抽象层**，例如 **`libevent`** 库。这类库提供了一套统一的事件通知 API，它会在底层自动选择目标系统上最高效的可用机制（在 Linux 上使用 `epoll`，在 BSD 上使用 `kqueue`，在其他系统上则回退到使用 `select()` 或 `poll()`）。


#### **63.1.1 水平触发和边缘触发**

在讨论备选的 I/O 机制时，我们需要先区分两种文件描述符准备就绪的通知模式。

* **水平触发通知 (Level-Triggered, LT)**:
    * **定义**: 只要文件描述符上**可以**非阻塞地执行 I/O 系统调用，就认为它已经就绪。
    * **比喻**: 就像一个**电平传感器**。只要水位高于某个阈值（例如，缓冲区里有数据），警报就**一直响着**。

* **边缘触发通知 (Edge-Triggered, ET)**:
    * **定义**: 只有当文件描述符自上次状态检查以来**有了新的 I/O 活动**（例如，新数据到达），才会触发一次通知。
    * **比喻**: 就像一个**门铃**。有人按门铃时（新数据到达），铃声**只响一次**。即使客人还在门口等，只要他不再次按铃，门铃就不会再响。

**表 63-1：各种 I/O 模型使用的通知模式**

| I/O 模式               | 水平触发 (LT) | 边缘触发 (ET) |
| :------------------- | :-------: | :-------: |
| `select()`, `poll()` |     ✓     |           |
| 信号驱动 I/O             |           |     ✓     |
| `epoll`              |  ✓ (默认)   |  ✓ (可选项)  |

##### **编程模型的差异**

* **水平触发 (LT)**:
    * **特点**: 允许我们在任意时刻重复检查 I/O 状态。
    * **编程方式**: 当收到就绪通知后，我们可以只处理一部分数据（例如，只 `read()` 一些字节）。如果缓冲区中还有剩余数据，下一次调用 `select()` 或 `poll()` **仍然会**立即返回，通知我们文件描述符是就绪的。这种模式允许“偷懒”，不必一次性将所有数据处理完。

* **边缘触发 (ET)**:
    * **特点**: 只有在状态发生**变化**时才通知一次。
    * **编程方式**: 当收到一个 I/O 事件通知后，程序**必须**在相应的文件描述符上**尽可能多地执行 I/O**（例如，在一个循环中持续 `read()` 直到返回 `EAGAIN` 错误），以确保将本次事件关联的数据全部处理完。
    * **原因**: 如果程序没有这么做，那么就可能**失去**处理剩余数据的机会，因为在下一个**新的** I/O 事件到来之前，程序将**不会再收到任何通知**。这可能导致数据丢失或程序阻塞。
    * **关键要求**: 正因为需要在一个循环中将数据“抽干”，所以每个被边缘触发模式监视的文件描述符**通常都应该被设置为非阻塞模式**。否则，当数据被读完后，最后一次 I/O 系统调用将会无限期地阻塞。

---
#### **63.1.2 在备选的 I/O 模型中采用非阻塞 I/O**
非阻塞 I/O (`O_NONBLOCK` 标志) 经常和本章所描述的 I/O 模型一起使用。这么做主要有以下几个原因：

1.  **边缘触发的必要条件**: 如上一节所述，非阻塞 I/O 通常是和提供边缘触发通知机制的 I/O 模型（如 `epoll` 的 ET 模式）一起使用的。
2.  **多进程/线程的竞态条件**: 如果多个进程或线程在同一个文件描述符上执行 I/O，那么从收到就绪通知到执行后续 I/O 调用之间，文件描述符的状态可能已经被其他进程/线程改变（例如，数据已被读走）。如果此时 I/O 调用是阻塞式的，那么进程就会被卡住。
3.  **大块数据的写入**: 即使 `select()` 或 `poll()`（水平触发）通知我们一个流式套接字可写，如果我们在单个 `write()` 调用中写入非常大的数据块，该调用仍有可能因为填满了内核发送缓冲区而阻塞。
4.  **虚假的就绪通知**: 在非常罕见的情况下，`select()` 和 `poll()` 可能会返回“虚假”的就绪通知（可能由内核 bug 或非普通情况下的设计所致）。如果 I/O 调用是阻塞的，程序就会被挂起。

综上所述，将文件描述符设置为**非阻塞模式**是使用 I/O 多路复用、信号驱动 I/O 或 `epoll` 时的通用最佳实践。