# 32.1 取消一个线程

* **pthread\_cancel()**：向指定线程发送一个取消请求。
* **立即返回**：调用 pthread\_cancel() 后立即返回，不等待目标线程退出。
* **结果取决于线程状态**：目标线程是否真的被取消、何时被取消，取决于线程的取消状态（state）和取消类型（type）。

---

# 32.2 取消状态及类型

### 1. 取消状态（pthread\_setcancelstate）

* **PTHREAD\_CANCEL\_DISABLE**

  * 线程不可取消。
  * 收到取消请求时挂起请求，直到重新启用取消状态才会生效。
* **PTHREAD\_CANCEL\_ENABLE**（默认值）

  * 线程可取消。
  * 收到取消请求后，根据取消类型的不同进行处理。
* **oldstate**：用于保存之前的状态，便于恢复。

  * 虽然 Linux 允许传 NULL，但 **SUSv3 并未规定**，为了可移植性，最好总是传非 NULL 值。

👉 **应用场景**：当某段代码必须“一气呵成”时，可以临时禁用取消功能。

---

### 2. 取消类型（pthread\_setcanceltype）

* **PTHREAD\_CANCEL\_ASYNCHRONOUS**

  * 异步取消，线程可能在任意时刻被取消。
  * **风险大**，很少用，可能导致资源状态不一致。
* **PTHREAD\_CANCEL\_DEFERRED**（默认值）

  * 延迟取消：只有当线程运行到 **取消点（cancellation point）** 时，取消请求才会生效。
* **oldtype**：保存原有取消类型，建议非 NULL。

👉 **系统调用继承性**：

* **fork()**：子进程继承父线程的取消状态与类型。
* **exec()**：新程序的主线程重置为 `ENABLE + DEFERRED`。

---

# 32.3 取消点

* **定义**：线程在执行某些函数时会检查取消请求，这些函数就是“取消点”。
* **默认行为**：如果线程的状态是 *ENABLE* 且类型是 *DEFERRED*，那么线程只有在到达取消点时才会被取消。
* **SUSv3 必须定义为取消点的函数**：

  * **IO / 阻塞相关函数**：如 `read()`、`write()`、`accept()`、`connect()`、`select()`、`poll()`
  * **线程相关函数**：如 `pthread_cond_wait()`、`pthread_cond_timedwait()`、`pthread_join()`、`pthread_testcancel()`
  * **定时/等待函数**：如 `sleep()`、`nanosleep()`、`waitpid()`
* **可移植性要求**：某些实现会把更多函数设为取消点（如 stdio、syslog、dlopen 等），程序应当能正确处理。
* **注意**：非表内函数不得成为取消点。

👉 **结果处理**：

* 如果线程在取消点被终止，且该线程不是 *detached*，需要其他线程执行 `pthread_join()`。
* join 后返回值是 **PTHREAD\_CANCELED**。

---

# 32.4 线程可取消性的检测

* **问题场景**：

  * 如果线程在执行计算密集型循环（没有取消点），那么它不会响应取消请求。
* **解决方法：pthread\_testcancel()**

  * 主动制造一个取消点。
  * 如果线程已有挂起的取消请求，调用时线程会立即终止。
* **应用场景**：

  * 在计算密集型任务中周期性调用 `pthread_testcancel()`，确保线程能及时响应取消请求。

---

# 总结

1. **pthread\_cancel()** 只是发出请求，真正的取消取决于 **取消状态（ENABLE/DISABLE）** 和 **取消类型（ASYNC/DEFERRED）**。
2. **默认行为**：`ENABLE + DEFERRED`，即线程只会在到达取消点时响应取消。
3. **取消点函数** 多为阻塞或等待操作（IO、锁、条件变量、sleep 等）。
4. **计算型线程** 需要显式调用 `pthread_testcancel()`，否则可能永远无法被取消。
5. **可移植性建议**：

   * 不依赖 oldstate/oldtype 可为 NULL 的特性。
   * 正确处理 pthread\_join() 返回的 PTHREAD\_CANCELED。


# 32.5 清理函数（cleanup handler）

一旦有处于挂起状态的取消请求，线程在执行到取消点时如果只是草草收场，这会将共享变量以及 Pthreads 对象（例如互斥量）置于一种不一致状态，可能导致进程中其他线程产生错误结果、死锁，甚至造成程序崩溃。为规避这一问题，线程可以设置一个或多个清理函数，当线程遭取消时会自动运行这些函数，在线程终止之前可执行诸如修改全局变量，解锁互斥量等动作。

每个线程都可以拥有一个清理函数栈。当线程遭取消时，会沿该栈自顶向下依次执行清理函数，首先会执行最近设置的函数，接着是次新的函数，以此类推。当执行完所有清理函数后，线程终止。

函数 `pthread_cleanup_push()` 和 `pthread_cleanup_pop()` 分别负责向调用线程的清理函数栈添加和移除清理函数。

`pthread_cleanup_push()` 会将参数 `routine` 所含的函数地址添加到调用线程的清理函数栈顶。参数 `routine` 是一个函数指针，格式如下：

```c
void routine(void *arg);
```

执行 `pthread_cleanup_push()` 时给定的 `arg` 值，会作为调用清理函数时的参数。其参数类型为 `void*`，如果强制装换使用得当，那么通过该参数可以传入各种类型的数据。

通常，线程如在执行一段特殊代码时遭到取消，才需要执行清理动作。如果线程顺利执行完这段代码而未遭取消，那么就不再需要清理。所以，每个对 `pthread_cleanup_push()` 的调用都会伴随着对 `pthread_cleanup_pop()` 的调用。此函数从清理函数栈中移除最顶层的函数。如果参数 `execute` 非零，那么无论如何都会执行清理函数。在函数未遭取消而又希望执行清理动作的情况下，这会非常方便。

尽管这里把 `pthread_cleanup_push()` 和 `pthread_cleanup_pop()` 描述为函数，SUSv3 却允许将它们实现为宏（macro），可展开为分别由 `{` 和 `}` 所包裹的语句序列。并非所有的 UNIX 都这样做，不过包括 Linux 在内的很多系统都是使用宏来实现的。这意味着，`pthread_cleanup_push()` 和与其配对的 `pthread_cleanup_pop()` 属于同一个语法块，必须一一对应。（一旦以此方式来实现 `pthread_cleanup_push()` 和 `pthread_cleanup_pop()`，在对两者的调用间所声明的变量，其作用域将受限于这一语法块。）例如，以下代码就不正确：

```c
if (some_condition)
    pthread_cleanup_push(cleanup_func, arg);
/* Do some work */
if (some_condition)
    pthread_cleanup_pop(1);
```

为便于编码，若线程因调用 `pthread_exit()` 而终止，则也会自动执行尚未从清理函数栈中弹出（pop）的清理函数。线程正常返回（return）时不会执行清理函数。

#### 示例程序

程序清单 32-2 提供了一个使用清理函数的简单例子。主程序创建线程⑧，线程首先分配一块内存③，并将其地址存储于 `buf` 中，接着锁定互斥量 `mtx`④。因为线程可能会遭到取消，所以调用 `pthread_cleanup_push()`⑤设置清理函数，并将存储于 `buf` 中的地址作为参数传入。如果执行到清理函数，那么清理函数会释放内存①并解锁互斥量②。

线程接着进入循环，等待对条件变量 `cond` 的通知⑥。取决于可执行程序是否带有命令行参数，此循环会以以下两种方式结束。

  * 若无命令行参数，则由 `main()`⑨ 函数取消线程。此时，取消操作发生在对 `pthread_cond_wait()`⑥的调用中，此函数可见于程序清单 32-1 中，属于取消点。作为取消动作的一部分，会自动调用由 `pthread_cleanup_push()` 设置的清理函数。
  * 如果指定了命令行参数，那么在将全局变量 `glob` 设置为非零后，通知条件变量⑩。此时，线程会一直执行到 `pthread_cleanup_pop()`⑦，因为向此函数传入了非零参数，所以依然会调用清理函数。

**程序清单 32-2：使用清理函数**

```c
#include <pthread.h>
#include <sys/types.h>
#include "tlpi_hdr.h"

static pthread_cond_t cond = PTHREAD_COND_INITIALIZER;
static pthread_mutex_t mtx = PTHREAD_MUTEX_INITIALIZER;
static int glob = 0;

static void
cleanupHandler(void *arg) /* Cleanup handler */
{
    int s;

    printf("cleanup: freeing buffer at %p\n", arg);
    free(arg);
    printf("cleanup: unlocking mutex\n");
    s = pthread_mutex_unlock(&mtx); /* Unlock mutex */       // ②
    if (s != 0)
        errExitEN(s, "pthread_mutex_unlock");
}

static void *
threadFunc(void *arg)
{
    int s;
    void *buf = NULL; /* Buffer allocated by thread */

    buf = malloc(0x10000); /* Allocate a buffer */       // ③
    printf("thread: allocated memory at %p\n", buf);

    s = pthread_mutex_lock(&mtx); /* Lock mutex */          // ④
    if (s != 0)
        errExitEN(s, "pthread_mutex_lock");

    pthread_cleanup_push(cleanupHandler, buf); /* Establish cleanup handler */ // ⑤

    while (glob == 0) {
        s = pthread_cond_wait(&cond, &mtx); /* Wait for condition */      // ⑥
        if (s != 0)
            errExitEN(s, "pthread_cond_wait");
    }

    printf("thread: condition wait loop completed\n");
    pthread_cleanup_pop(1); /* Execute cleanup handler */       // ⑦
    return NULL;
}

int
main(int argc, char *argv[])
{
    pthread_t thr;
    void *res;
    int s;

    s = pthread_create(&thr, NULL, threadFunc, NULL); /* Create a thread */ // ⑧
    if (s != 0)
        errExitEN(s, "pthread_create");

    sleep(2); /* Give thread a chance to start */

    if (argc == 1) { /* Cancel thread */
        printf("main: canceling thread\n");
        s = pthread_cancel(thr); // ⑨
        if (s != 0)
            errExitEN(s, "pthread_cancel");
    } else { /* Signal condition variable */
        printf("main: signaling condition\n");
        glob = 1;
        s = pthread_cond_signal(&cond); // ⑩
        if (s != 0)
            errExitEN(s, "pthread_cond_signal");
    }

    s = pthread_join(thr, &res);
    if (s != 0)
        errExitEN(s, "pthread_join");

    if (res == PTHREAD_CANCELED)
        printf("main: thread was canceled\n");
    else
        printf("main: thread terminated normally\n");

    exit(EXIT_SUCCESS);
}
```

主程序与遭终止线程建立连接，并报告线程是遭到取消还是正常终止。

如果执行程序清单 32-2 中程序且不带任何命令行参数，那么 `main()` 函数会调用 `pthread_cancel()`，清理函数也会得以自动执行。输出如下：

```shell
$ ./t_cleanup
thread: allocated memory at 0x804a008
main: canceling thread
cleanup: freeing buffer at 0x804a008
cleanup: unlocking mutex
main: thread was canceled
```

如果运行该程序且带有命令行参数，那么 `main()` 将 `glob` 设置为 1 并通知条件变量，清理函数则通过 `pthread_cleanup_pop()` 的调用执行，可以看到如下结果：

```shell
$ ./t_cleanup x
thread: allocated memory at 0x804a008
main: signaling condition
thread: condition wait loop completed
cleanup: freeing buffer at 0x804a008
cleanup: unlocking mutex
main: thread terminated normally
```

# 32.6 异步取消

如果设定线程为可异步取消时（取消性类型为 `PTHREAD_CANCEL_ASYNCHRONOUS`），可以在任何时点将其取消（亦即，执行任何机器指令时），取消动作不会拖延到下一个取消点才执行。

异步取消的问题在于，尽管清理函数依然会得以执行，但处理函数却无从得知线程的具体状态。程序清单 32-2 采用了延时取消类型，只有在执行到 `pthread_cond_wait()` 这一唯一的取消点时，线程才会遭到取消。此时可知，已将 `buf` 初始化为指向新分配的内存块，并且锁定了互斥量 `mtx`。不过，要是采用异步取消，就可以在任意点取消线程（例如，调用 `malloc()` 之前，调用 `malloc()` 与锁定互斥量之间，或者锁定互斥量之后）。清理函数无法知道将在哪里发生取消动作，或者准确地来说，清理函数不清楚需要执行哪些清理步骤。此外，线程也很可能在对 `malloc()` 的调用期间被取消，这极有可能造成后续的混乱（见 7.1.3 节）。

作为一般性原则，可异步取消的线程不应该分配任何资源，也不能获取互斥量或锁。这导致大量库函数无法使用，其中就包括 Pthreads 函数的大部分。（SUSv3 中有 3 处例外 `pthread_cancel()`、`pthread_setcancelstate()` 以及 `pthread_setcanceltype()`，规范明确要求将它们实现为“异步取消安全（async-cancel-safe）”，亦即，实现必须确保在可异步取消的线程中可以安全调用它们。）换言之，异步取消功能鲜有应用场景，其中之一就是：取消在执行计算密集型循环的线程。

# 代码案例

1. **案例一：使用取消点函数（如 `sleep()`）触发取消**
2. **案例二：计算密集型线程，使用 `pthread_testcancel()` 主动检测取消请求**

---

## 案例一：取消点函数触发线程取消

```cpp
#include <pthread.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

// 线程函数：包含 sleep()，它是一个取消点
void* worker_with_cancellation_point(void* arg) {
    int count = 0;

    while (1) {
        // sleep() 是一个取消点，如果有挂起的取消请求，会在这里终止线程
        sleep(1);

        printf("Worker with cancellation point: count = %d\n", ++count);
        fflush(stdout);
    }

    return NULL;
}

int main() {
    pthread_t tid;
    pthread_create(&tid, NULL, worker_with_cancellation_point, NULL);

    // 主线程休眠 3 秒，然后发出取消请求
    sleep(3);
    printf("Main: sending cancel request...\n");
    pthread_cancel(tid);

    void* res;
    pthread_join(tid, &res);

    if (res == PTHREAD_CANCELED) {
        printf("Thread was canceled at a cancellation point.\n");
    }

    return 0;
}
```

### 输出示例

```
Worker with cancellation point: count = 1
Worker with cancellation point: count = 2
Worker with cancellation point: count = 3
Main: sending cancel request...
Thread was canceled at a cancellation point.
```

---

## 案例二：计算密集型循环 + `pthread_testcancel()`

```cpp
#include <pthread.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

// 线程函数：计算密集型循环，没有天然的取消点
void* worker_with_testcancel(void* arg) {
    unsigned long long sum = 0;
    int iteration = 0;

    while (1) {
        // 模拟计算
        for (int i = 0; i < 1000000; ++i) {
            sum += i;
        }
        iteration++;

        // 在计算过程中显式检查取消请求
        pthread_testcancel();

        if (iteration % 10 == 0) {
            printf("Worker with testcancel: iteration = %d\n", iteration);
            fflush(stdout);
        }
    }

    return NULL;
}

int main() {
    pthread_t tid;
    pthread_create(&tid, NULL, worker_with_testcancel, NULL);

    // 主线程休眠 2 秒，然后发出取消请求
    sleep(2);
    printf("Main: sending cancel request...\n");
    pthread_cancel(tid);

    void* res;
    pthread_join(tid, &res);

    if (res == PTHREAD_CANCELED) {
        printf("Thread was canceled via pthread_testcancel().\n");
    }

    return 0;
}
```

### 输出示例

```
Worker with testcancel: iteration = 10
Worker with testcancel: iteration = 20
Main: sending cancel request...
Thread was canceled via pthread_testcancel().
```

---

✅ 对比总结：

* **案例一**：线程因为 `sleep()` 这样的 **取消点函数** 被取消。
* **案例二**：线程是计算密集型任务，没有天然取消点，需要显式调用 `pthread_testcancel()` 来产生取消点，否则线程永远不会响应取消请求。

---

要不要我帮你写一个 **混合案例**（既有取消点函数，又在计算逻辑里加 `pthread_testcancel()`），展示更健壮的线程取消方式？
