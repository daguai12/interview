好的，这是根据您提供的文本内容，保留原始结构和标题整理的结果，并附上一个完整的代码案例来演示相关函数。

### **10.7 进程时间**

进程时间是进程自创建后所使用的 CPU 时间总量。出于记录的目的，内核将 CPU 时间分为以下两部分：

  * **用户 CPU 时间 (User CPU Time)**: 是在用户模式下执行代码所花费的时间。
  * **系统 CPU 时间 (System CPU Time)**: 是在内核模式中执行代码所花费的时间，例如内核为进程执行系统调用或处理页错误等任务。

当我们运行一个 shell 程序时，可以使用 `time(1)` 命令来获取这两个时间值，以及程序运行所需的实际墙上时间（real time）。

#### **times()**

系统调用 `times()` 用于检索进程时间信息，并将结果通过 `buf` 指向的结构体返回。

```c
#include <sys/times.h>

clock_t times(struct tms *buf);
```

`buf` 指向的 `tms` 结构体格式如下：

```c
struct tms {
    clock_t tms_utime;  /* 调用进程的用户CPU时间 */
    clock_t tms_stime;  /* 调用进程的系统CPU时间 */
    clock_t tms_cutime; /* 所有已终止的子进程的用户CPU时间 */
    clock_t tms_cstime; /* 所有已终止的子进程的系统CPU时间 */
};
```

  * **单位**: `tms` 结构体中所有字段的单位都是**时钟计时单元（clock ticks）**。我们可以通过调用 `sysconf(_SC_CLK_TCK)` 来获得每秒的时钟计时单元数，然后用这个值作除数，将 clock ticks 转换为秒。在大多数 Linux 系统上，`sysconf(_SC_CLK_TCK)` 返回 100。
  * **返回值**: `times()` 的返回值是自过去某个任意时间点以来流逝的真实时间（以 clock ticks 为单位）。SUSv3 指出，这个返回值**并不可靠**，因为它可能会溢出并回绕到零。测量经过的真实时间，更可靠的方法是使用 `gettimeofday()`。

#### **clock()**

函数 `clock()` 提供了一个更简单的接口用于获取进程时间。它返回一个值，描述了调用进程使用的**总 CPU 时间**（包括用户和系统时间）。

```c
#include <time.h>

clock_t clock(void);
```

  * **单位**: `clock()` 返回值的单位是 `CLOCKS_PER_SEC`。我们必须用返回值除以这个常量来获得以秒为单位的 CPU 时间。在 POSIX.1 标准中，`CLOCKS_PER_SEC` 是常量 **1,000,000**。
  * **精度**: `clock()` 的精度最终仍然受限于软件时钟（jiffies）的分辨率。
  * **子进程**: 在 Linux 上，`clock()` 返回的时间**不包含**已等待的子进程所使用的 CPU 时间。

**注意**: 即使 `clock()` 和 `times()` 都返回 `clock_t` 类型，但由于历史原因，它们使用的测量单位是不同的 (`CLOCKS_PER_SEC` vs. `sysconf(_SC_CLK_TCK)`)。

-----

#### **示例程序**

下面的程序演示了如何使用 `clock()` 和 `times()` 来获取和显示进程时间。程序首先显示初始时间，然后执行一个消耗 CPU 的循环，最后再次显示时间，以展示循环所消耗的 CPU 时间。

**`process_time_demo.c` 文件:**

```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/times.h>
#include <time.h>
#include <unistd.h>

// 打印当前进程时间的函数
static void displayProcessTimes(const char *msg) {
    struct tms t;
    clock_t clockTime;
    static long clockTicks = 0;

    printf("%s\n", msg);

    // 首次调用时，获取每秒的 clock ticks 数量
    if (clockTicks == 0) {
        clockTicks = sysconf(_SC_CLK_TCK);
        if (clockTicks == -1) {
            perror("sysconf");
            exit(EXIT_FAILURE);
        }
    }

    // --- 使用 clock() ---
    clockTime = clock();
    if (clockTime == -1) {
        perror("clock");
        exit(EXIT_FAILURE);
    }
    printf("    clock() returns: %ld clocks-per-sec (%.2f secs)\n",
           (long)clockTime, (double)clockTime / CLOCKS_PER_SEC);

    // --- 使用 times() ---
    if (times(&t) == -1) {
        perror("times");
        exit(EXIT_FAILURE);
    }
    printf("    times() yields: user CPU=%.2f; system CPU=%.2f\n",
           (double)t.tms_utime / clockTicks,
           (double)t.tms_stime / clockTicks);
}

int main(int argc, char *argv[]) {
    int numCalls = (argc > 1) ? atoi(argv[1]) : 100000000;
    
    printf("CLOCKS_PER_SEC=%ld  sysconf(_SC_CLK_TCK)=%ld\n\n",
           (long)CLOCKS_PER_SEC, sysconf(_SC_CLK_TCK));

    displayProcessTimes("At program start:");

    // 执行一个消耗 CPU 时间的循环
    for (int j = 0; j < numCalls; j++) {
        (void)getppid();
    }

    displayProcessTimes("After loop:");

    exit(EXIT_SUCCESS);
}

```

**编译和运行:**

1.  **编译程序:**
    ```bash
    gcc process_time_demo.c -o process_time_demo
    ```
2.  **运行程序:**
    ```bash
    ./process_time_demo
    ```

**预期输出:**

```
CLOCKS_PER_SEC=1000000  sysconf(_SC_CLK_TCK)=100

At program start:
    clock() returns: 2043 clocks-per-sec (0.00 secs)
    times() yields: user CPU=0.00; system CPU=0.00

After loop:
    clock() returns: 410185 clocks-per-sec (0.41 secs)
    times() yields: user CPU=0.41; system CPU=0.00
```

**输出解读:**

  * 程序启动时，消耗的 CPU 时间几乎为零。
  * 经过一个执行了上亿次 `getppid()` 的循环后，`clock()` 和 `times()` 都显示程序消耗了大约 0.41 秒的 CPU 时间。
  * 由于 `getppid()` 是一个非常轻量的系统调用，它的大部分开销来自于循环本身（在用户空间执行），所以消耗的时间几乎全部计入了**用户CPU时间 (user CPU)**。