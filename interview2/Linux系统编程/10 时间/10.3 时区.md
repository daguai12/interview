### **10.3 时区**

不同的国家（有时甚至是同一国家内的不同地区）使用不同的时区和夏时制。对于要输入和输出时间的程序来说，必须对系统所处的时区和夏时制加以考虑。所幸的是，所有这些细节都已经由 C 语言函数库包办了。

#### **时区定义**

时区信息往往是既浩繁又多变的。出于这一原因，系统没有将其直接编码于程序或函数库中，而是以标准格式保存于文件中，并加以维护。

  * **时区文件位置**: 这些文件位于目录 `/usr/share/zoneinfo` 中。该目录下的每个文件都包含了一个特定国家或地区内时区制度的相关信息，且往往根据其所描述的时区来加以命名，例如 `EST`、`CET`、`UTC`、`Asia/Singapore`。
  * **系统本地时间**: 系统的本地时间由 `/etc/localtime` 文件定义，该文件通常是一个链接，指向 `/usr/share/zoneinfo` 目录下的一个具体时区文件。
  * **相关工具**:
      * `tzfile(5)`: 描述时区文件格式的手册页。
      * `zic(8)`: 时区信息编译器（zone information compiler），用于创建时区文件。
      * `zdump(8)`: 根据指定的时区文件来显示当前时间。

#### **为程序指定时区**

为运行中的程序指定一个时区，需要将 `TZ` 环境变量设置为时区文件的相对路径名。设置时区会自动影响到 `ctime()`、`localtime()`、`mktime()` 和 `strftime()` 等函数。

为了获取当前的时区设置，上述函数都会调用 `tzset(3)`，该函数会初始化以下三个全局变量：

  * `char *tzname[2]`: 包含两个字符串的数组，分别用于标准时间（如 "SGT"）和夏令时（如 "EDT"）的名称。
  * `long timezone`: 本地时区与UTC时间相差的秒数。注意，这是一个正值，表示**西**边的时间，例如美国东部标准时间（UTC-5）的值为 `5 * 3600`。
  * `int daylight`: 如果该时区包含夏令时规则，则此值为非零。

`tzset()` 函数会首先检查环境变量 `TZ`。如果尚未设置该变量，那么就采用 `/etc/localtime` 中定义的默认时区。如果 `TZ` 环境变量的值为空或无法与时区文件名相匹配，那么就使用 UTC。

#### **设置 TZ 环境变量的格式**

SUSv3（Single UNIX Specification, version 3）为设置 `TZ` 环境变量定义了两个通用方法。

1.  **路径名格式 (Linux 常用)**
    可将 `TZ` 设置为时区文件的路径名，前面可选择性地加一个冒号(`:`)。例如，要将时区设置为日本东京时间，可以这样设置：
    `export TZ='Asia/Tokyo'`
    或 `export TZ=':Asia/Tokyo'`
    为了保证代码的可移植性，应当始终包含冒号。

2.  **POSIX 格式**
    此方法使用一个详细的字符串来定义时区、与UTC的偏移以及夏令时规则。格式如下：

    ```
    std offset[dst[offset][,start[/time],end[/time]]]
    ```

      * **std**: 标准时区名称 (如 `CET`)。
      * **offset**: 欲转换为UTC，需要叠加在本地时间上的调整值。例如，欧洲中部时间（UTC+1）的 offset 为 `-1`。
      * **dst**: 夏令时名称 (如 `CEST`)。
      * **start/end**: 夏令时的开始和结束规则。
        例如，以下 `TZ` 定义了欧洲中部时间，其标准时间比 UTC 提前1小时，夏令时比 UTC 提前2小时，夏令时从3月的最后一个周日开始，到10月的最后一个周日结束：
        `TZ='CET-1CEST,M3.5.0,M10.5.0'`

-----

#### **代码案例：演示 `TZ` 环境变量的效果**

以下是一个简单的C程序，它只打印当前时间。我们将通过在运行它之前设置不同的 `TZ` 环境变量来观察其输出的变化。

**`show_time.c` 文件:**

```c
#include <stdio.h>
#include <time.h>
#include <stdlib.h> // For tzset()

int main() {
    time_t now;
    struct tm *local_time;

    // 获取当前日历时间
    time(&now);

    // tzset() 会根据 TZ 环境变量设置时区信息
    // localtime() 会隐式调用它，但显式调用是好习惯
    tzset();

    // 转换为本地时间
    local_time = localtime(&now);

    // 打印时间和时区名称
    printf("当前时间: %s", asctime(local_time));
    printf("时区: %s\n", local_time->tm_zone);

    return 0;
}
```

**编译和运行:**

1.  **编译程序:**

    ```bash
    gcc show_time.c -o show_time
    ```

2.  **在默认时区下运行 (新加坡):**

    ```bash
    ./show_time
    ```

    **输出:**

    ```
    当前时间: Tue Sep  9 09:57:02 2025
    时区: +08
    ```

3.  **设置 `TZ`为东京时间 (UTC+9) 并运行:**

    ```bash
    TZ='Asia/Tokyo' ./show_time
    ```

    **输出:**

    ```
    当前时间: Tue Sep  9 10:57:02 2025
    时区: JST
    ```

    (注意：时间比新加坡快了1小时)

4.  **设置 `TZ`为纽约时间 (UTC-4, 夏令时期间) 并运行:**

    ```bash
    TZ='America/New_York' ./show_time
    ```

    **输出:**

    ```
    当前时间: Mon Sep  8 21:57:02 2025
    时区: EDT
    ```

    (注意：日期是前一天，时区是 `EDT` - 东部夏令时)

这个案例清晰地展示了同一个程序，在不修改任何代码的情况下，仅通过改变 `TZ` 环境变量，就能使其输出适应于全球任何一个时区的时间。