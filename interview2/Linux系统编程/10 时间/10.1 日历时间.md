### **10.1 日历时间（Calendar Time）**

无论地理位置如何，UNIX 系统内部对时间的表示方式均是以自 **Epoch** 以来的秒数来度量的，Epoch 亦即通用协调时间（**UTC**，以前也称为格林威治标准时间，或 GMT）的 **1970 年 1 月 1 日早晨零点**。这也是 UNIX 系统问世的大致日期。日历时间存储于类型为 `time_t` 的变量中，此类型是由 SUSv3 定义的整数类型。

在 32 位 Linux 系统，`time_t` 是一个有符号整数，可以表示的日期范围从 1901 年 12 月 13 日 20 时 45 分 52 秒至 **2038 年 1 月 19 号 03:14:07**。（SUSv3 未定义 `time_t` 值为负数时的含义。）因此，当前许多 32 位 UNIX 系统都面临一个 **2038 年问题**。如果执行的计算工作涉及未来日期，那么在 2038 年之前就会与之遭遇。

事实上，到了 2038 年，可能所有的 UNIX 系统都早已升级为 64 位或更多位数的系统，这一问题也许会随之而大为缓解。然而，32 位嵌入式系统，由于其寿命较之台式机硬件更长，故而仍然会受此问题的困扰。此外，对于依然以 32 位 `time_t` 格式保存时间的历史数据和应用程序，这个问题将依然存在。

#### **gettimeofday()**

系统调用 `gettimeofday()` 可于 `tv` 指向的缓冲区中返回日历时间。

```c
#include <sys/time.h>

int gettimeofday(struct timeval *tv, struct timezone *tz);
```

参数 `tv` 是指向如下数据结构的一个指针：

```c
struct timeval {
    time_t      tv_sec;     /* Seconds since the Epoch */
    suseconds_t tv_usec;    /* Microseconds */
};
```

  * 虽然 `tv_usec` 字段能提供微秒级精度，但其返回值的准确性则由依赖于构架的具体实现来决定。`tv_usec` 中的 `u` 源于与之形似的希腊字母 μ（读音“mu”），在公制系统中表示百万分之一。在现代 X86-32 系统上，`gettimeofday()`的确可以提供微秒级的准确度。

  * `gettimeofday()` 的参数 `tz` 是个历史产物。早期的 UNIX 实现用其来获取系统的时区信息，**目前已遭废弃，应始终将其置为 NULL**。如果提供了 `tz` 参数，那么将返回一个 `timezone` 的结构体，该结构包含两个字段 `tz_minuteswest` 和 `tz_dsttime`。正由于夏令时（DST）制度无法用一个简单算法加以表达，故而 `tz` 参数已遭废弃。

#### **time()**

`time()` 系统调用返回自 Epoch 以来的秒数（和函数 `gettimeofday()` 所返回的 `tv` 参数中 `tv_sec` 字段的数值相同）。

```c
#include <time.h>

time_t time(time_t *timep);
```

  * 如果 `timep` 参数不为 NULL，那么还会将自 Epoch 以来的秒数置于 `timep` 所指向的位置。
  * 由于 `time()` 会以两种方式返回相同的值，而使用时唯一可能出错的地方是赋予 `timep` 参数一个无效地址（`EFAULT`），因此往往会简单地采用如下调用（不做错误检查）：
    ```c
    time_t current_seconds;
    current_seconds = time(NULL);
    ```

之所以存在两个本质上目的相同的系统调用（`time()` 和 `gettimeofday()`），自有其历史原因。早期的 UNIX 实现提供了 `time()`。而 4.3BSD 又补充了更为精确的 `gettimeofday()` 系统调用。这时，再将 `time()` 作为系统调用就显得多余，可以将其实现为一个调用 `gettimeofday()` 的库函数。


# 案例

好的，这是一个简单的C语言代码案例，用于演示如何使用 `time()` 和 `gettimeofday()` 函数，并展示它们之间的关系。

该程序会：

1.  使用 `time()` 获取自 Epoch 以来的秒数。
2.  使用 `gettimeofday()` 获取自 Epoch 以来的秒数和微秒数。
3.  使用 `ctime()` 将 `time_t` 类型的秒数转换为人类可读的本地时间字符串。

#### **代码示例: `time_demo.c`**

```c
#include <stdio.h>
#include <time.h>
#include <sys/time.h> // for gettimeofday()

int main() {
    // --- 1. 演示 time() 函数 ---
    printf("--- 1. 使用 time() ---\n");

    // 调用 time(NULL) 获取自 Epoch 以来的秒数
    time_t seconds_from_epoch = time(NULL);

    printf("从 Epoch 到现在的秒数: %ld\n", seconds_from_epoch);

    // 使用 ctime() 将秒数转换为本地时间字符串
    // 注意: ctime() 返回的字符串自带一个换行符 \n
    printf("当前本地时间: %s", ctime(&seconds_from_epoch));


    printf("\n----------------------------------------\n\n");


    // --- 2. 演示 gettimeofday() 函数 ---
    printf("--- 2. 使用 gettimeofday() ---\n");

    struct timeval tv;
    
    // 调用 gettimeofday()，注意第二个参数为 NULL
    // 最好进行错误检查
    if (gettimeofday(&tv, NULL) == -1) {
        perror("gettimeofday error");
        return 1;
    }

    printf("从 Epoch 到现在的秒数 (tv.tv_sec):      %ld\n", tv.tv_sec);
    printf("额外的微秒数 (tv.tv_usec):               %ld\n", (long)tv.tv_usec);

    // gettimeofday() 返回的 tv.tv_sec 与 time() 的结果是相同的
    // 我们同样可以用它来获取人类可读的时间
    printf("当前本地时间 (来自 tv.tv_sec): %s", ctime(&tv.tv_sec));

    return 0;
}
```

#### **如何编译和运行**

1.  将以上代码保存为 `time_demo.c`。
2.  打开终端，使用GCC编译器进行编译：
    ```bash
    gcc time_demo.c -o time_demo
    ```
3.  运行生成的可执行文件：
    ```bash
    ./time_demo
    ```

#### **预期输出**

您将会看到类似下面的输出（具体数值会根据您运行代码的时间而变化）：

```
--- 1. 使用 time() ---
从 Epoch 到现在的秒数: 1725846151
当前本地时间: Tue Sep  9 09:42:31 2025

----------------------------------------

--- 2. 使用 gettimeofday() ---
从 Epoch 到现在的秒数 (tv.tv_sec):      1725846151
额外的微秒数 (tv.tv_usec):               543210
当前本地时间 (来自 tv.tv_sec): Tue Sep  9 09:42:31 2025
```

#### **代码解读**

  * **`time()`** 直接返回一个 `time_t` 类型的值，它代表了整数秒。这是获取日历时间最简单、最常用的方法。
  * **`gettimeofday()`** 提供了更高的精度。它填充一个 `struct timeval` 结构体，其中 `tv.tv_sec` 字段与 `time()` 的返回值完全相同，而 `tv.tv_usec` 字段则提供了额外的微秒级精度，适用于需要更高精度计时（例如性能测量）的场景。
  * 如输出所示，两个函数获取的秒数部分是完全一致的，这印证了`time()`可以被看作是`gettimeofday()`的一个简化版本。