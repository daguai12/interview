好的，这是根据您提供的文本内容，保留原始结构和标题整理的结果，并附上一个代码案例来演示 `setlocale()` 和相关环境变量的用法。

### **10.4 地区（Locale）**

世界各地在使用数千种语言。此外，在显示诸如数字、货币金额、日期和时间之类的信息时，不同国家的习俗也不同。SUSv3 对 locale 的定义为：**用户环境中依赖于语言和文化习俗的一个子集**。

意欲在多个地理区位运行的任何程序都应处理地区（locales）概念，以用户的语言和格式来显示和输入信息。这构成了**国际化（internationalization, 简称 I18N）**。程序库（如 glibc）提供了工具来帮助程序支持国际化。

#### **地区定义**

和时区信息一样，地区信息同样是既浩繁且多变的，因此系统按标准格式将地区信息存储于文件中。

  * **位置**: 地区信息维护于 `/usr/share/locale` 目录（在一些发行版本中为 `/usr/lib/locale`）之下的目录层次结构中。

  * **命名约定**: 每个地区的目录命名约定如下：
    `language[_territory][.codeset][@modifier]`

      * **language**: 双字母的 ISO 语言代码 (如 `en`, `de`, `fr`)。
      * **territory**: 双字母的 ISO 国家代码 (如 `US`, `DE`, `CH`)。
      * **codeset**: 字符编码集 (如 `utf-8`)。
      * **modifier**: 可选的修饰符 (如 `@euro`)。
      * **示例**: `de_DE.utf-8@euro` (德国的德语，UTF-8编码，使用欧元)；`en_US` (美国的英语)；`fr_CH` (瑞士的法语区)。

  * **匹配规则**: 如果程序指定的地区（如 `fr_CH.utf-8`）不存在，C 语言函数库将按顺序剥离 `codeset`、`territory` 等部分，以寻求更通用的匹配（如先尝试 `fr_CH`，再尝试 `fr`）。

  * **地区类别**: 每个地区子目录中包含一套标准文件，指定了此地区的约定设置，如下表所示。

| 文件名           | 目的                              |
| :------------ | :------------------------------ |
| `LC_CTYPE`    | 包含字符分类（如判断是否为字母）以及大小写转换规则。      |
| `LC_COLLATE`  | 包含针对字符集的排序（collation）规则。        |
| `LC_MONETARY` | 包含对币值的格式化规则。                    |
| `LC_NUMERIC`  | 包含对币值以外数字的格式化规则（如小数点符号）。        |
| `LC_TIME`     | 包含对日期和时间的格式化规则。                 |
| `LC_MESSAGES` | 规定了肯定和否定响应的格式及数值（如 "yes"/"no"）。 |

  * **系统可用地区**: `locale -a` 命令可以列出系统上定义的所有地区。`POSIX`（或 `C`）是一个必须被定义的标准地区，它基于 ASCII 字符集和英文习俗。

#### **为程序设置地区**

函数 `setlocale()` 既可设置也可查询程序的当前地区。

```c
#include <locale.h>

char *setlocale(int category, const char *locale);
```

  * **`category`**: 用于选择设置或查询地区的哪一部分，可以使用 `LC_TIME`、`LC_MONETARY` 等常量，或者使用 `LC_ALL` 来指定所有部分。
  * **`locale`**:
      * 可以是一个具体的地区字符串，如 `"de_DE.UTF-8"`。
      * 可以是一个**空字符串 `""`**。这会使程序从环境变量中取得地区的设置。**这是让程序支持本地化的关键调用**。如果程序没有这个调用，相关的环境变量将不会生效。
      * 可以是 `NULL`，用于查询当前设置而不做改变。

当程序调用 `setlocale(LC_ALL, "");` 后，就可以使用一系列环境变量来控制地区：

  * **`LANG`**: 为所有地区类别设置一个默认值，优先级最低。
  * **`LC_*`** (如 `LC_TIME`, `LC_NUMERIC`): 覆盖由 `LANG` 设置的特定类别的值。
  * **`LC_ALL`**: 覆盖所有其他的 `LC_*` 和 `LANG` 设置，优先级最高。

**优先级顺序**: `LC_ALL` \> `LC_TIME` (或其他 `LC_*` 变量) \> `LANG`

-----

#### **代码案例：演示地区对日期时间格式的影响**

以下程序演示了 `setlocale()` 如何使程序响应 `LANG`, `LC_TIME` 和 `LC_ALL` 环境变量。

**`locale_time_demo.c` 文件:**

```c
#include <stdio.h>
#include <time.h>
#include <locale.h>

int main() {
    time_t now;
    struct tm *local_time;
    char buffer[100];

    // 关键步骤：设置 locale 为环境变量中定义的值。
    // 如果没有这一行，程序将始终使用默认的 "C" locale。
    if (setlocale(LC_ALL, "") == NULL) {
        fprintf(stderr, "无法设置 locale\n");
        return 1;
    }

    // 获取当前时间
    time(&now);
    local_time = localtime(&now);

    // 使用 strftime 配合 %c 格式化字符串
    // %c 会根据当前的 locale 输出推荐的日期和时间表示法
    strftime(buffer, sizeof(buffer), "%c", local_time);

    printf("根据当前 locale 格式化的时间: %s\n", buffer);

    return 0;
}
```

**编译和运行:**

1.  **编译程序:**

    ```bash
    gcc locale_time_demo.c -o locale_demo
    ```

2.  **默认 "C" 地区 (如果未设置环境变量):**

    ```bash
    ./locale_demo
    ```

    **输出:**

    ```
    根据当前 locale 格式化的时间: Tue Sep  9 09:58:20 2025
    ```

3.  **使用 `LANG` 设置为德国德语地区:**

    ```bash
    LANG=de_DE.UTF-8 ./locale_demo
    ```

    **输出:**

    ```
    根据当前 locale 格式化的时间: Di 09 Sep 2025 09:58:20 +08
    ```

    (注意：星期二变成了 "Di"，月份变成了 "Sep"，格式也发生了变化)

4.  **演示 `LC_TIME` 覆盖 `LANG`:**

    ```bash
    LANG=de_DE.UTF-8 LC_TIME=fr_FR.UTF-8 ./locale_demo
    ```

    **输出:**

    ```
    根据当前 locale 格式化的时间: mar. 09 sept. 2025 09:58:20 +08
    ```

    (尽管 `LANG` 是德语，但由于 `LC_TIME` 被设置为法语，所以时间格式遵循了法国的习惯)

5.  **演示 `LC_ALL` 覆盖所有其他设置:**

    ```bash
    LANG=de_DE.UTF-8 LC_TIME=fr_FR.UTF-8 LC_ALL=ja_JP.UTF-8 ./locale_demo
    ```

    **输出:**

    ```
    根据当前 locale 格式化的时间: 2025年09月09日 09時58分20秒
    ```

    (尽管 `LANG` 和 `LC_TIME` 都被设置，但拥有最高优先级的 `LC_ALL` 将地区设置为日语，所以输出为日文格式)

这个案例清晰地展示了，只需在程序开头调用一次 `setlocale(LC_ALL, "")`，就可以使其具备国际化能力，响应不同的地区设置，从而以用户期望的格式显示信息。