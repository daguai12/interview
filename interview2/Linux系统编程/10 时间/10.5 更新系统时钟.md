### **10.5 更新系统时钟**

我们现在来看两个更新系统时钟的接口：`settimeofday()` 和 `adjtime()`。这些接口都很少被应用程序使用，因为系统时间通常是由 `ntpd` 等网络时间协议（Network Time Protocol）守护进程来维护的，并且它们需要调用者拥有特殊权限（`CAP_SYS_TIME`）。

#### **settimeofday()**

系统调用 `settimeofday()` 是 `gettimeofday()` 的逆向操作。它将 `tv` 指向的 `timeval` 结构体里的秒数和微秒数，设置到系统的日历时间。

```c
#include <sys/time.h>

int settimeofday(const struct timeval *tv, const struct timezone *tz);
```

  * 和 `gettimeofday()` 一样，`tz` 参数已被废弃，这个参数应该始终指定为 `NULL`。
  * `tv.tv_usec` 字段的微秒精度并不意味着我们能以微秒精度来设置系统时钟，因为硬件时钟的实际精度可能会低于微秒。
  * 虽然 SUSv3 没有定义 `settimeofday()`，但它在其他 UNIX 实现中被广泛使用。
  * **相关函数**: Linux 还提供了 `stime()` 系统调用来设置系统时钟，但它只支持秒级精度。`settimeofday()` 的存在是历史原因造成的，它由 4.3BSD 添加，提供了更高的精度。

`settimeofday()` 调用会造成系统时间的**突然变化**（跳变），这可能会对依赖于系统时钟单调递增的应用造成有害的影响（例如，`make` 命令、数据库系统的时间戳或包含时间戳的日志文件）。

#### **adjtime()**

出于避免时间跳变的原因，当对时间做微小调整时（通常是几秒钟的误差），推荐使用库函数 `adjtime()`，它将系统时钟**逐步（gradually）调整到正确的时间。这个过程也称为时钟扭摆（clock slewing）**。

```c
#include <sys/time.h>

int adjtime(const struct timeval *delta, struct timeval *olddelta);
```

  * **`delta`**: 指向一个 `timeval` 结构体，指定需要改变时间的总秒数和微秒数。
      * 如果这个值为**正数**，那么系统时钟会以一个稍快的速率运行，直到完全弥补 `delta` 指定的时间差。
      * 如果 `delta` 值为**负数**，时钟则会以类似的方式减慢。
      * 在 Linux/x86-32 上，调整速率约为每天 43.2 秒。
  * **`olddelta`**: 如果在上一次调用 `adjtime()` 还未完成调整时再次调用它，那么剩余未调整的时间会存放在 `olddelta` 指向的 `timeval` 结构体内。如果不关心这个值，可以将其指定为 `NULL`。
  * **查询模式**: 如果我们只想查询当前还剩多少时间未完成校正，而不想发起新的调整，可以将 `delta` 参数指定为 `NULL`。

虽然 SUSv3 未定义 `adjtime()`，但大多数 UNIX 实现都提供了这个函数。在 Linux 上，`adjtime()` 是基于一个更通用和复杂的、特定于 Linux 的系统调用 `adjtimex()` 来实现的，这个系统调用也同时被网络时间协议（NTP）守护进程调用。