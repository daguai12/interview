### **60.5 inetd（Internet 超级服务器）守护进程**

在一个系统中，可能会配置数百个不同的网络服务，但其中大部分服务在绝大多数时间里都处于空闲状态，等待偶尔的连接请求。如果为每个服务都运行一个单独的守护进程，将会占用大量的系统资源。

**`inetd`** 守护进程被设计用来解决这个问题，它有时也被称为 **Internet 超级服务器**。`inetd` 可提供两个主要的好处：

1.  **降低系统负载**: 只需运行 `inetd` 这一个进程，由它来监视一组服务的端口，并按需启动相应的服务程序。这大大减少了系统中长期运行的进程数量。
2.  **简化服务器编程**: `inetd` 承担了所有网络服务在启动时都需要执行的一系列通用步骤（如创建 socket、绑定、监听、接受连接、`fork` 等），极大地简化了服务程序的编写工作。

> **`xinetd`**: 在一些 Linux 发行版中，提供了 `inetd` 的扩展版本 `xinetd`，它在安全性等方面做了一些增强。

-----

#### **`inetd` 守护进程所做的操作**

`inetd` 守护进程通常在系统启动时运行，其工作流程如下：

1.  **读取配置**: 读取 `/etc/inetd.conf` 文件。对于其中指定的每项服务，`inetd` 都会创建一个相应类型的 socket，将其 `bind()` 到指定的端口，并且（对于 TCP）调用 `listen()`。
2.  **等待活动**: 通过 `select()` 调用，`inetd` 同时监视所有已创建的 socket，等待数据报或连接请求的到来。
3.  **处理活动**: 当某个 socket 上有活动时，`select()` 返回。对于 TCP 连接，`inetd` 会先 `accept()` 这个连接。
4.  **启动服务**: `inetd` 调用 `fork()` 创建一个子进程，该子进程将执行以下操作：
    a. 关闭所有不需要的文件描述符。
    b. 使用 `dup2()` 将服务对应的 socket 复制到标准输入(0)、标准输出(1)和标准错误(2)上，然后关闭原始的 socket 描述符。
    c. （可选）根据配置，调用 `setuid()` 和 `setgid()` 切换到指定的用户和组。
    d. 调用 `exec()` 启动真正的服务器程序。
5.  **父进程清理**: 对于 TCP 连接，`inetd`（父进程）会关闭由 `accept()` 返回的已连接 socket（因为它现在已由子进程接管）。
6.  **循环**: `inetd` 返回第 2 步，继续等待下一个网络活动。

-----

#### **/etc/inetd.conf 文件**

`inetd` 的操作由配置文件 `/etc/inetd.conf` 控制。文件中的每一行都描述了一项由 `inetd` 处理的服务。

**示例行**:

```
#<service_name> <sock_type> <proto> <flags> <user> <server_path> <args>
#echo          stream      tcp       nowait  root    internal
#echo          dgram       udp       wait    root    internal
ftp            stream      tcp       nowait  root    /usr/sbin/tcpd  in.ftpd -l -a
telnet         stream      tcp       nowait  root    /usr/sbin/tcpd  in.telnetd
```

每一行都由以下字段组成：

  * **`service name` (服务名称)**: 对应于 `/etc/services` 文件中的服务名。
  * **`socket type` (套接字类型)**: `stream` (TCP) 或 `dgram` (UDP)。
  * **`protocol` (协议)**: 通常是 `tcp` 或 `udp`。
  * **`flags` (标记)**: `wait` 或 `nowait`。
      * **`nowait` (TCP 常用)**: 告知 `inetd` 在启动服务后可以立即继续监听，处理下一个连接请求。适用于“每个连接一个进程”模式的 TCP 服务器。
      * **`wait` (UDP 常用)**: 告知 `inetd` 必须等待刚刚启动的服务程序退出后，才能继续监听该端口。这可以防止 `inetd` 因快速收到多个数据报而启动多个服务实例。
  * **`login name` (登录名)**: 运行服务器程序的用户和组。
  * **`server program` (服务器程序)**: 被执行的服务器程序的路径名。
  * **`server program arguments` (服务器程序参数)**: 传递给服务器程序的命令行参数。

> **内部服务**: 像 `echo` 这样简单的服务，可以由 `inetd` **内部 (internal)** 实现，无需启动一个单独的进程。
> **重新加载配置**: 修改 `/etc/inetd.conf` 文件后，需要向 `inetd` 进程发送一个 `SIGHUP` 信号，以使其重新读取配置文件。

-----

#### **示例：通过 inetd 调用一个 TCP echo 服务**

`inetd` 极大地简化了服务器程序的编程工作，因为它已经帮我们完成了：

1.  `socket()`, `bind()`, `listen()` 等初始化工作。
2.  对 TCP 新连接的 `accept()` 操作。
3.  `fork()` 新进程以及对 `SIGCHLD` 的处理（避免僵尸进程）。
4.  将连接好的 socket 复制到标准输入、输出和错误描述符上。
5.  `exec()` 服务器程序。

因此，一个由 `inetd` 调用的服务程序，其核心逻辑可以变得非常简单：**它只需要从标准输入读取数据，处理后写入标准输出即可**。

**程序清单 60-6：通过 inetd 调用的 TCP echo 服务**

```c
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>

#define BUF_SIZE 500

int main(int argc, char *argv[]) {
    ssize_t numRead;
    char buf[BUF_SIZE];

    // 从标准输入读取数据 (这实际上是从 socket 读取)
    while ((numRead = read(STDIN_FILENO, buf, BUF_SIZE)) > 0) {
        // 将读取到的数据写回标准输出 (这实际上是写入 socket)
        if (write(STDOUT_FILENO, buf, numRead) != numRead) {
            // 写入错误，可以记录到 syslog
            exit(EXIT_FAILURE);
        }
    }

    if (numRead == -1) {
        // 读取错误
        exit(EXIT_FAILURE);
    }
    
    exit(EXIT_SUCCESS); // 客户端关闭连接，read() 返回 0，程序退出
}
```

要使用这个程序，只需将其编译后，在 `/etc/inetd.conf` 中添加类似下面的一行配置，然后向 `inetd` 发送 `SIGHUP` 信号即可：

```
echo    stream  tcp     nowait  root    /path/to/your/program   echo_server
```