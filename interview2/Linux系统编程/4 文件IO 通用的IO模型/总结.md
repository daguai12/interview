好的，这是您提供文本的概述，并保留了所有的标题。

### 4.1 概述

所有执行I/O操作的系统调用都通过一个非负整数——**文件描述符**——来指代打开的文件。文件描述符可以表示所有类型的文件，包括管道（pipe）、FIFO、socket、终端、设备和普通文件。每个进程都维护着自己的一套文件描述符。

按照惯例，程序启动时会继承shell为其打开的三个标准文件描述符：

| 文件描述符 | POSIX 名称 | stdio 流 | 用途 |
| :--- | :--- | :--- | :--- |
| 0 | `STDIN_FILENO` | `stdin` | 标准输入 |
| 1 | `STDOUT_FILENO` | `stdout` | 标准输出 |
| 2 | `STDERR_FILENO` | `stderr` | 标准错误 |

主要的四个文件I/O系统调用是：

  * `fd = open(pathname, flags, mode)`: 打开或创建由 `pathname` 指定的文件，并返回一个文件描述符。`flags` 参数控制打开方式（如只读、只写、创建等），`mode` 参数指定新创建文件的权限。
  * `numread = read(fd, buffer, count)`: 从文件描述符 `fd` 指向的文件中读取最多 `count` 字节的数据到 `buffer` 中，并返回实际读取的字节数。
  * `numwritten = write(fd, buffer, count)`: 将 `buffer` 中的最多 `count` 字节数据写入到文件描述符 `fd` 指向的文件中，并返回实际写入的字节数。
  * `status = close(fd)`: 在I/O操作完成后，关闭文件描述符 `fd`，释放相关内核资源。

### 4.2 通用 I/O

UNIX I/O模型的一个显著特点是其**通用性**。这意味着程序员可以使用同一套系统调用（`open()`, `read()`, `write()`, `close()`）来对所有类型的文件（包括普通文件、设备、socket等）执行操作。这种通用性之所以能够实现，是因为文件系统和设备驱动程序的具体操作细节都由内核处理。对于需要访问设备专有功能的情况，可以使用 `ioctl()` 系统调用作为补充。

### 4.3 打开一个文件：open()

`open()` 系统调用用于打开一个已存在的文件，或者创建一个新文件并打开它。

```c
int open(const char *pathname, int flags, mode_t mode);
```

  * **`pathname`**: 要打开或创建的文件的路径。如果 `pathname` 是符号链接，默认会对其进行解引用。
  * **`flags`**: 一个位掩码，用于指定文件的访问模式（`O_RDONLY`, `O_WRONLY`, `O_RDWR`三者必选其一）以及其他选项。
  * **`mode`**: 当使用 `O_CREAT` 标志创建新文件时，此参数指定新文件的访问权限。如果未指定 `O_CREAT`，则可以省略此参数。

调用成功时，`open()` 返回一个进程未使用的、数值最小的文件描述符。若发生错误，则返回 -1。

### 4.3.1 open()调用中的 flags 参数

`flags` 参数是通过对多个常量进行“或”(`|`)运算来构建的。这些常量可以分为三类：

1.  **文件访问模式标志**: `O_RDONLY`（只读）、`O_WRONLY`（只写）、`O_RDWR`（读写）。
2.  **文件创建标志**: 控制 `open()` 调用的行为，如 `O_CREAT`、`O_EXCL`、`O_TRUNC` 等。
3.  **已打开文件的状态标志**: `open()` 返回后，这些标志会影响后续的I/O操作，如 `O_APPEND`、`O_ASYNC`、`O_NONBLOCK` 等。这些标志可以使用 `fcntl()` 进行检索和修改。

一些重要的 `flags` 标志包括：

  * **`O_APPEND`**: 每次写入时都将数据追加到文件末尾。
  * **`O_CREAT`**: 如果文件不存在，则创建它。
  * **`O_EXCL`**: 与 `O_CREAT` 结合使用，如果文件已存在，则 `open()` 调用失败。这确保了调用的原子性，即检查和创建文件在一步内完成。
  * **`O_TRUNC`**: 如果文件已存在并且是普通文件，则将其内容清空，长度截断为0。
  * **`O_CLOEXEC`**: 在打开文件时原子地设置 "close-on-exec" 标志，防止文件描述符泄露给由 `exec()` 执行的新程序。
  * **`O_NOFOLLOW`**: 如果 `pathname` 是一个符号链接，则不进行解引用，`open()` 直接失败。
  * **`O_SYNC`**: 使每次 `write` 操作都以同步I/O方式进行，即等待数据和元数据都写入磁盘。

### 4.3.2 open()函数的错误

如果 `open()` 调用失败，它会返回 -1 并设置 `errno` 来指明错误原因。一些常见的错误包括：

  * **`EACCES`**: 权限不足，无法以 `flags` 指定的方式访问文件。
  * **`EISDIR`**: 尝试以写入方式打开一个目录。
  * **`EMFILE`**: 进程打开的文件描述符数量已达到其上限。
  * **`ENFILE`**: 系统中打开的文件总数已达到系统上限。
  * **`ENOENT`**: 文件不存在且未指定 `O_CREAT`，或者路径中的某个目录不存在。
  * **`EROFS`**: 试图以写入方式打开一个位于只读文件系统上的文件。
  * **`ETXTBSY`**: 试图以写入方式打开一个正在运行的可执行文件。

### 4.3.3 creat()系统调用

在早期的UNIX系统中，`open()` 无法创建文件，需要使用 `creat()` 系统调用。

```c
int creat(const char *pathname, mode_t mode);
```

`creat()` 的功能相当于以下 `open()` 调用：

```c
open(pathname, O_WRONLY | O_CREAT | O_TRUNC, mode);
```

由于 `open()` 函数提供了更丰富的 `flags` 选项（例如可以同时读写 `O_RDWR`），`creat()` 现在已经很少使用了。

### 4.4 读取文件内容：read()

`read()` 系统调用从一个已打开的文件中读取数据。

```c
ssize_t read(int fd, void *buffer, size_t count);
```

  * **`fd`**: 要读取文件的文件描述符。
  * **`buffer`**: 用于存放读取数据的内存缓冲区地址。此缓冲区必须由程序员预先分配。
  * **`count`**: 指定最多能读取的字节数。

**返回值**：

  * **成功**：返回实际读取的字节数。这个数值可能小于请求的 `count` 值（例如，已到达文件末尾）。
  * **文件结尾 (EOF)**：返回 0。
  * **错误**：返回 -1，并设置 `errno`。

一个关键点是 `read()` **不会**在读入的数据末尾自动添加空字符（`\0`）。如果读取的是文本数据，并希望将其作为C语言字符串处理（例如使用 `printf()`），程序员必须手动在缓冲区末尾添加空字符。

### 4.5 数据写入文件：write()

`write()` 系统调用将数据从内存缓冲区写入一个已打开的文件。

```c
ssize_t write(int fd, const void *buffer, size_t count);
```

  * **`fd`**: 要写入文件的文件描述符。
  * **`buffer`**: 存放待写入数据的内存缓冲区地址。
  * **`count`**: 想要写入的字节数。

**返回值**：

  * **成功**：返回实际写入的字节数。
  * **错误**：返回 -1，并设置 `errno`。

返回的写入字节数可能小于请求的 `count` 值，这种情况被称为“**部分写**”。对于磁盘文件，这可能是因为磁盘空间已满或达到了进程的文件大小资源限制。

**注意**：`write()` 调用成功返回，并不保证数据已经物理写入磁盘。为了提高效率，内核会对磁盘I/O进行缓冲。

### 4.6 关闭文件：close()

`close()` 系统调用用于关闭一个打开的文件描述符，并将其释放回进程，以便后续重用。

```c
int close(int fd);
```

当一个进程终止时，内核会自动关闭其所有打开的文件描述符。尽管如此，显式关闭不再需要的文件描述符是一个良好的编程习惯，这可以避免在长期运行的程序（如服务器）中耗尽文件描述符这一有限资源。

应当对 `close()` 的返回值进行错误检查。例如，对于NFS（网络文件系统），如果在写入数据到远程磁盘时发生错误，这个错误可能直到调用 `close()` 时才会被报告。

### 4.7 改变文件偏移量：lseek()

对于每个打开的文件，内核会记录一个**文件偏移量**（也称读写指针）。它表示下一次 `read()` 或 `write()` 操作的起始位置，以相对于文件开头的字节数来度量。

`lseek()` 系统调用可以显式地调整这个文件偏移量。

```c
off_t lseek(int fd, off_t offset, int whence);
```

  * **`fd`**: 文件描述符。
  * **`offset`**: 偏移的字节数。
  * **`whence`**: 指定 `offset` 的基准点：
      * **`SEEK_SET`**: 从文件开头开始计算。
      * **`SEEK_CUR`**: 从当前文件偏移量开始计算。
      * **`SEEK_END`**: 从文件末尾开始计算。

**返回值**：

  * **成功**：返回调整后，距离文件开头的新偏移量（单位为字节）。
  * **错误**：返回 -1，并设置 `errno`。

`lseek()` 仅仅修改内核中的一个记录，并**不涉及任何物理I/O操作**。此调用不能用于管道、FIFO、socket或终端。

#### 文件空洞

如果使用 `lseek()` 将文件偏移量移动到文件末尾之后，然后再执行 `write()` 操作，那么从原文件末尾到新写入数据之间的区域就形成了一个“**文件空洞**”。

  * **读取**：从文件空洞中读取数据，会得到全为0（空字节）的缓冲区。
  * **存储**：文件空洞**不占用任何实际的磁盘空间**。只有当数据被真实地写入空洞区域时，文件系统才会为其分配磁盘块。

这个特性使得稀疏文件（包含大片空数据的文件，如核心转储文件）可以高效地存储，其名义上的文件大小可能远大于其实际占用的磁盘空间。并非所有文件系统都支持文件空洞。