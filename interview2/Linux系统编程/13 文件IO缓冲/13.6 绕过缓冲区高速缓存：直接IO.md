### **13.6 绕过缓冲区高速缓存：直接 I/O**

始于内核 2.4，Linux 允许应用程序在执行磁盘 I/O 时绕过缓冲区高速缓存，从用户空间直接将数据传递到文件或磁盘设备。这通常被称为**直接 I/O (direct I/O)** 或**裸 I/O (raw I/O)**。

此处的描述细节为 Linux 所特有，SUSv3 并未对其进行规范。

有时会将直接 I/O 误认为获取快速 I/O 性能的一种手段。然而，**对于大多数应用而言，使用直接 I/O 可能会大大降低性能**。这是因为应用程序将无法受益于内核为缓冲区高速缓存所做的各种优化（如预读、I/O 合并等）。

直接 I/O 只适用于有特定 I/O 需求的、高度优化的应用程序。例如，数据库系统，其高速缓存和 I/O 优化机制均自成一体，使用直接 I/O 可以避免内核执行重复的缓存工作。

要使用直接 I/O，需要在调用 `open()` 打开文件或设备时指定 `O_DIRECT` 标志。

> **注意**：`O_DIRECT` 标志自内核 2.4.10 开始有效，并非所有文件系统都支持。如果一个进程以 `O_DIRECT` 标志打开某文件，而另一进程以普通方式（使用缓存）打开同一文件，则两者之间的数据可能存在不一致性，应尽量避免这种场景。

#### **直接 I/O 的对齐限制**

因为直接 I/O 涉及对磁盘的直接访问，所以在执行 I/O 时，必须遵守一些严格的对齐限制。否则，`read()` 或 `write()` 调用将失败并返回错误号 `EINVAL`。

1.  **内存对齐**: 用于传递数据的用户空间缓冲区，其起始内存地址必须是设备物理块大小的整数倍。
2.  **偏移量对齐**: 数据传输的文件或设备偏移量，必须是设备物理块大小的整数倍。
3.  **长度对齐**: 待传递数据的长度必须是设备物理块大小的整数倍。

在上述列表中，**块大小（block size）** 指设备的**物理块大小**（通常为 512 字节）。

-----

#### **示例程序**

程序清单 13-1 提供了一个使用 `O_DIRECT` 标志打开文件并读取数据的简单例子。该程序使用 `posix_memalign()` 函数来分配一块地址对齐的内存缓冲区。

**`direct_io_demo.c` 文件:**

```c
#define _GNU_SOURCE  // 为了得到 O_DIRECT 定义
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <errno.h>

int main(int argc, char *argv[]) {
    int fd;
    ssize_t numRead;
    size_t length, alignment;
    off_t offset;
    char *buf;

    if (argc < 3 || strcmp(argv[1], "--help") == 0) {
        fprintf(stderr, "Usage: %s file length [offset [alignment]]\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    length = atol(argv[2]);
    offset = (argc > 3) ? atol(argv[3]) : 0;
    alignment = (argc > 4) ? atol(argv[4]) : 4096;

    // --- 打开文件 ---
    fd = open(argv[1], O_RDONLY | O_DIRECT);
    if (fd == -1) {
        perror("open");
        exit(EXIT_FAILURE);
    }

    // --- 分配对齐的内存缓冲区 ---
    // posix_memalign 是比 memalign() 更标准化的函数
    if (posix_memalign((void **)&buf, alignment, length) != 0) {
        perror("posix_memalign");
        exit(EXIT_FAILURE);
    }

    printf("Allocated buffer at address %p\n", buf);

    // --- 定位文件偏移量 ---
    if (lseek(fd, offset, SEEK_SET) == -1) {
        perror("lseek");
        exit(EXIT_FAILURE);
    }

    // --- 读取数据 ---
    numRead = read(fd, buf, length);
    if (numRead == -1) {
        perror("read");
        if (errno == EINVAL) {
            fprintf(stderr, "read failed with EINVAL. Check alignment constraints:\n");
            fprintf(stderr, "  - offset: %ld\n  - length: %ld\n  - alignment: %ld\n  - buffer address: %p\n",
                    (long)offset, (long)length, (long)alignment, buf);
        }
        exit(EXIT_FAILURE);
    }

    printf("Read %ld bytes\n", (long)numRead);

    free(buf);
    close(fd);
    exit(EXIT_SUCCESS);
}
```

**编译和运行**

1.  **准备一个测试文件** (例如，一个 1MB 大小, 内容为'a'的文件):

    ```bash
    # dd if=/dev/zero of=testfile bs=1M count=1
    # 或者用其他方式创建一个足够大的文件
    dd if=/dev/urandom of=testfile bs=1024 count=1024
    ```

2.  **编译程序:**

    ```bash
    gcc direct_io_demo.c -o direct_io_demo
    ```

3.  **运行示例:**

      * **成功示例** (所有参数都是 512 的倍数):
        ```bash
        # ./direct_io_demo testfile 1024 512 512
        Allocated buffer at address 0x55...
        Read 1024 bytes
        ```
      * **失败示例** (读取长度不是 512 的倍数):
        ```bash
        # ./direct_io_demo testfile 1000
        Allocated buffer at address 0x55...
        read: Invalid argument
        read failed with EINVAL. Check alignment constraints:
          - offset: 0
          - length: 1000
          - alignment: 4096
          - buffer address: 0x55...
        ```
      * **失败示例** (文件偏移量不是 512 的倍数):
        ```bash
        # ./direct_io_demo testfile 1024 100
        Allocated buffer at address 0x55...
        read: Invalid argument
        read failed with EINVAL. Check alignment constraints:
          - offset: 100
          - length: 1024
          - alignment: 4096
          - buffer address: 0x55...
        ```

这个案例清晰地展示了使用 `O_DIRECT` 时必须严格遵守对齐限制，否则操作将直接失败。