好的，这是根据您提供的文本内容，保留原始结构和标题整理的结果。

### **13.5 就 I/O 模式向内核提出建议**

`posix_fadvise()` 系统调用允许进程就自身访问文件数据时可能采取的模式通知内核。内核可以（但不必非要）根据这些信息来优化对缓冲区高速缓存的使用，进而提高进程和整个系统的性能。调用 `posix_fadvise()` 对程序的语义并无影响。

```c
#include <fcntl.h>

int posix_fadvise(int fd, off_t offset, off_t len, int advice);
```

  * **`fd`**: 指代目标文件的文件描述符。
  * **`offset` 和 `len`**: 确定建议所适用的文件区域。`offset` 是区域的起始偏移量，`len` 是区域的大小（字节）。若 `len` 为 0，则表示从 `offset` 开始直至文件结尾。
  * **`advice`**: 表示进程期望对文件采取的访问模式，具体为下列常量之一：

#### **advice 参数**

  * **`POSIX_FADV_NORMAL`**
    进程对访问模式并无特别建议，这是默认行为。在 Linux 中，该操作将文件预读（read-ahead）窗口大小置为默认值（如 128KB）。

  * **`POSIX_FADV_SEQUENTIAL`**
    进程预计会从低偏移量到高偏移量**顺序读取**数据。在 Linux 中，该操作会将文件预读窗口大小置为默认值的两倍，以提高顺序读的性能。

  * **`POSIX_FADV_RANDOM`**
    进程预计以**随机顺序**访问数据。在 Linux 中，该选项会禁用文件预读，避免因预读不必要的数据块而浪费缓存和 I/O 带宽。

  * **`POSIX_FADV_WILLNEED`**
    进程预计会在不久的将来访问指定的文件区域。这是一个\*\*预取（prefetch）\*\*建议，内核会将指定区域的文件数据预先加载到缓冲区高速缓存中。后续对该文件的 `read()` 调用将不会阻塞于磁盘 I/O，而是直接从缓存中获取数据。

    > 注意：内核不保证这些预取的数据能在缓存中保留多长时间，在高内存压力下它们可能会被回收。Linux 特有的 `readahead()` 系统调用提供了等效功能。

  * **`POSIX_FADV_DONTNEED`**
    进程预计在不久的将来将**不会**访问指定的文件区域。这是一个建议内核**释放相关缓存页面**的操作。在 Linux 中，该操作分两步执行：

    1.  首先，如果底层设备不繁忙，内核会尝试将指定区域中已修改（"脏"）的页面刷新到磁盘。
    2.  之后，内核会尝试释放该区域的高速缓存页面。

    > 因为应用程序无法控制设备的繁忙状态，为确保能成功释放缓存，一个变通方法是在调用此操作前，先对文件描述符 `fd` 调用 `sync()` 或 `fdatasync()`。

  * **`POSIX_FADV_NOREUSE`**
    进程预计会**一次性地**访问指定文件区域，不再复用。这等于提示内核在指定区域被访问一次后即可释放其缓存页面。在 Linux 中，该操作目前不起作用。

#### **可用性**

对 `posix_fadvise()` 的规范是 SUSv3 中的新增内容，并非所有 UNIX 实现都支持该接口。Linux 内核从 2.6 版本开始提供 `posix_fadvise()`。