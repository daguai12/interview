### **13.2 stdio 库的缓冲**

当操作磁盘文件时，为了减少系统调用，C 语言函数库的 I/O 函数（如 `fprintf()`、`fscanf()`、`fgets()`、`fputs()`）也实现了缓冲机制。因此，使用 `stdio` 库可以使编程者免于自行处理对数据的缓冲。

#### **设置一个 stdio 流的缓冲模式**

调用 `setvbuf()` 函数，可以控制 `stdio` 库使用缓冲的形式。

```c
#include <stdio.h>

int setvbuf(FILE *stream, char *buf, int mode, size_t size);
```

  * **调用时机**: 打开流（`fopen`）后，必须在调用任何其他 `stdio` 函数之前先调用 `setvbuf()`。
  * **`stream`**: 标识将要修改哪个文件流的缓冲。
  * **`buf` 和 `size`**:
      * 若 `buf` 不为 `NULL`，那么它指向一个大小为 `size` 的内存块，用作 `stream` 的缓冲区。**注意**：该缓冲区应该是动态（`malloc`）或静态分配的，而不应是分配在栈上的函数局部变量，否则函数返回时缓冲区会被销毁。
      * 若 `buf` 为 `NULL`，那么 `stdio` 库会为 `stream` 自动分配一个缓冲区。`glibc` 实现在此场景下会忽略 `size` 参数。
  * **`mode`**: 指定了缓冲类型，具有下列值之一：
      * `_IONBF` (No Buffering): 不对 I/O 进行缓冲。每个 `stdio` 函数将立即调用 `write()` 或 `read()`。`stderr` 默认属于这一类型，以保证错误能立即输出。
      * `_IOLBF` (Line Buffering): 采用行缓冲 I/O。对于输出流，在输出一个换行符前将缓冲数据；对于输入流，每次读取一行数据。指代终端设备的流默认属于这一类型。
      * `_IOFBF` (Full Buffering): 采用全缓冲 I/O。只有当缓冲区满时，才会执行实际的 `read()` 或 `write()` 系统调用。指代磁盘的流默认采用此模式。

下面的代码演示了 `setvbuf()` 函数的用法：

```c
// 设置为全缓冲，使用一个 4096 字节的、由库自动分配的缓冲区
setvbuf(fp, NULL, _IOFBF, 4096);

// 设置为行缓冲，使用一个由调用者提供的 1024 字节大小的缓冲区
char mybuf[1024];
setvbuf(fp, mybuf, _IOLBF, 1024);
```

**相关的简化函数:**

  * **`setbuf(fp, buf)`**:
      * 如果 `buf` 指向一个大小为 `BUFSIZ` 的缓冲区，则流设置为全缓冲。
      * 如果 `buf` 为 `NULL`，则流设置为不缓冲。
      * 它相当于 `setvbuf()` 的一个简化版本。
  * **`setbuffer(fp, buf, size)`**:
      * 类似于 `setbuf()`，但允许调用者指定缓冲区 `buf` 的大小 `size`。
      * 这是一个非标准的、但被广泛支持的函数。

#### **刷新 stdio 缓冲区**

无论当前采用何种缓冲区模式，在任何时候，都可以使用 `fflush()` 库函数强制将 `stdio` 输出流中的数据（通过 `write()`）刷新到内核缓冲区中。

```c
#include <stdio.h>

int fflush(FILE *stream);
```

  * 此函数会刷新指定 `stream` 的输出缓冲区。
  * 若参数 `stream` 为 `NULL`，则 `fflush()` 将刷新**所有**打开的 `stdio` 输出流的缓冲区。
  * 也能将 `fflush()` 函数应用于**输入流**，这将丢弃已经从内核读入 `stdio` 缓冲区的但尚未被程序处理的输入数据。

**自动刷新**:

  * 当关闭流（`fclose()`）时，其 `stdio` 缓冲区会被自动刷新。
  * 在许多实现中（包括 glibc），当 `stdin` 和 `stdout` 都连接到终端时，从 `stdin` 读取输入会隐式地刷新 `stdout`。这确保了 `printf("Enter name: ");` 这样的提示语能在程序等待输入前显示出来。**但此行为并非标准规定，为保证可移植性，应使用显式的 `fflush(stdout)` 调用**。

**读写交替规则 (C99 标准)**:
若打开一个流同时用于输入和输出（例如，模式 "r+"），则：

1.  一个输出操作不能紧跟一个输入操作，必须在二者之间调用 `fflush()` 或文件定位函数（如 `fseek()`）。
2.  一个输入操作不能紧跟一个输出操作，必须在二者之间调用一个文件定位函数，除非输入操作遇到了文件结尾（EOF）。

# 案例
### 核心原因

首先，理解核心原因很重要：当一个文件流 (`FILE*`) 以读写模式打开时，C语言的 `stdio` 库在内部只使用**一个缓冲区**。这个缓冲区要么处于“读模式”（里面是从文件中读取的数据），要么处于“写模式”（里面是准备写入文件的数据）。这两条规则就是为了避免在缓冲区模式切换时产生混乱。

-----

### 示例代码

我们将创建一个名为 `test_rw.txt` 的文件，内容为 "1234567890"，然后用一个C程序来演示这两条规则。

**`rw_rules_demo.c` 文件:**

```c
#include <stdio.h>
#include <stdlib.h>

// 辅助函数，用于显示文件当前内容
void show_file_content(const char* filename) {
    FILE* f = fopen(filename, "r");
    if (f == NULL) {
        printf("  (无法打开文件查看内容)\n");
        return;
    }
    char buffer[32];
    fgets(buffer, sizeof(buffer), f);
    printf("  >> 文件当前内容: %s\n", buffer);
    fclose(f);
}

int main() {
    const char* filename = "test_rw.txt";

    // 准备一个测试文件
    FILE* fp = fopen(filename, "w");
    if (fp == NULL) {
        perror("无法创建文件");
        return 1;
    }
    fputs("1234567890\n", fp);
    fclose(fp);

    printf("初始文件已创建。\n");
    show_file_content(filename);
    printf("----------------------------------------\n");

    // =================================================================
    // 演示规则 1: 输出后不能直接输入
    // =================================================================
    printf("### 演示规则 1: 输出(write)后立即输入(read) ###\n");
    
    fp = fopen(filename, "r+");
    if (fp == NULL) return 1;

    // 1. 输出操作: 写入 "ABC" 到文件开头
    fputs("ABC", fp);
    printf("1. 已执行 fputs(\"ABC\"), 但未刷新缓冲区。\n");

    // 2. 紧接着输入操作 (违反规则)
    // 此时缓冲区处于"写模式"，直接读取会导致未定义行为
    char read_buffer[4] = {0};
    fseek(fp, 0, SEEK_SET); // 定位回文件开头
    fread(read_buffer, 1, 3, fp);
    // fread 的结果是未定义的，因为它前面没有 fflush()
    
    printf("2. (错误演示) 紧接着 fread, 读到的内容是: \"%s\"\n", read_buffer);
    fclose(fp);
    
    // 我们来看一下文件实际内容，很可能 "ABC" 根本没被写入
    printf("   操作后检查文件：\n");
    show_file_content(filename);

    printf("\n--- 现在使用正确的方式 ---\n");
    fp = fopen(filename, "r+");
    fputs("ABC", fp);
    printf("1. 已执行 fputs(\"ABC\").\n");

    // 2. 在输入前，先调用 fflush() (遵守规则)
    fflush(fp);
    printf("2. (正确演示) 执行 fflush() 同步文件。\n");

    // 3. 现在可以安全地进行输入操作了
    fseek(fp, 0, SEEK_SET); // 定位回文件开头
    fread(read_buffer, 1, 3, fp);
    printf("3. 接着执行 fread, 读到的内容是: \"%s\"\n", read_buffer);
    fclose(fp);
    printf("   操作后检查文件：\n");
    show_file_content(filename);
    printf("----------------------------------------\n");


    // =================================================================
    // 演示规则 2: 输入后不能直接输出
    // =================================================================
    printf("\n### 演示规则 2: 输入(read)后立即输出(write) ###\n");

    fp = fopen(filename, "r+");
    // 文件当前内容是 "ABC4567890"
    
    // 1. 输入操作: 读取 "ABC"
    fread(read_buffer, 1, 3, fp); // 文件指针现在在 '4' 的位置
    printf("1. 已执行 fread, 读到 \"%s\". 指针现在指向第4个字符。\n", read_buffer);

    // 2. 紧接着输出操作 (违反规则)
    // 此时缓冲区是"读模式"，直接写入会导致未定义行为
    fputs("X", fp);
    printf("2. (错误演示) 紧接着 fputs(\"X\").\n");
    fclose(fp);
    printf("   操作后检查文件 (结果可能是不可预测的):\n");
    show_file_content(filename);


    printf("\n--- 现在使用正确的方式 ---\n");
    fp = fopen(filename, "r+");
    fread(read_buffer, 1, 3, fp);
    printf("1. 已执行 fread, 读到 \"%s\".\n", read_buffer);

    // 2. 在输出前，先调用文件定位函数 (遵守规则)
    fseek(fp, 0, SEEK_CUR); // 即使不移动指针，这个调用也是必须的
    printf("2. (正确演示) 执行 fseek() 清空读缓冲区。\n");

    // 3. 现在可以安全地进行输出操作了
    fputs("X", fp); // 会在 '4' 的位置写入 'X'
    fclose(fp);
    printf("3. 接着执行 fputs(\"X\").\n");
    printf("   操作后检查文件：\n");
    show_file_content(filename);

    return 0;
}
```

### 编译和运行

```bash
gcc rw_rules_demo.c -o demo
./demo
```

### 预期输出与解读

```
初始文件已创建。
  >> 文件当前内容: 1234567890

----------------------------------------
### 演示规则 1: 输出(write)后立即输入(read) ###
1. 已执行 fputs("ABC"), 但未刷新缓冲区。
2. (错误演示) 紧接着 fread, 读到的内容是: ""
   操作后检查文件：
  >> 文件当前内容: 1234567890
  
--- 现在使用正确的方式 ---
1. 已执行 fputs("ABC").
2. (正确演示) 执行 fflush() 同步文件。
3. 接着执行 fread, 读到的内容是: "ABC"
   操作后检查文件：
  >> 文件当前内容: ABC4567890

----------------------------------------

### 演示规则 2: 输入(read)后立即输出(write) ###
1. 已执行 fread, 读到 "ABC". 指针现在指向第4个字符。
2. (错误演示) 紧接着 fputs("X").
   操作后检查文件 (结果可能是不可预测的):
  >> 文件当前内容: ABC4567890

--- 现在使用正确的方式 ---
1. 已执行 fread, 读到 "ABC".
2. (正确演示) 执行 fseek() 清空读缓冲区。
3. 接着执行 fputs("X").
   操作后检查文件：
  >> 文件当前内容: ABCX567890
```

#### 规则 1 解读 (Output -\> Input)

  * **错误演示**: 我们先 `fputs("ABC", fp)`，数据进入了 `stdio` 的写缓冲区，但**并未立即写入文件**。紧接着我们 `fread()`，由于没有 `fflush()`，缓冲区仍处于“写模式”，`fread()` 无法执行，因此什么也读不到。当 `fclose()` 被隐式调用时，"ABC" 才可能被写入，但为时已晚。最终文件内容没有改变。
  * **正确演示**: 在 `fputs()` 之后，我们调用 `fflush(fp)`。这会强制将写缓冲区的内容（"ABC"）写入文件。此时文件内容变为 "ABC4567890"。然后我们再 `fseek()` 回文件头并 `fread()`，就能成功读到刚刚写入的数据。

#### 规则 2 解读 (Input -\> Output)

  * **错误演示**: 我们先 `fread()` 读取了 "ABC"。`stdio` 库为了效率，可能已经把整个文件 "ABC4567890" 都读入了它的读缓冲区。此时，文件指针在程序看来在第4个字符处，但内部状态很复杂。紧接着我们 `fputs("X", fp)`，由于没有文件定位操作，缓冲区仍处于“读模式”，这次写入操作是未定义的，很可能失败，所以文件内容没有改变。
  * **正确演示**: 在 `fread()` 之后，我们调用了 `fseek(fp, 0, SEEK_CUR)`。这个调用的作用不是移动指针，而是**清空内部的读缓冲区，并同步程序的文件指针位置**，让流准备好接收写操作。之后再调用 `fputs("X", fp)`，它就能准确地在第4个字符的位置写入 'X'，文件内容变为 "ABCX567890"。