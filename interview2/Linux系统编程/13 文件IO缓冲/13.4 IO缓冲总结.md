### **13.4 I/O 缓冲小结**

下图概括了 `stdio` 函数库和内核所采用的两层缓冲机制（针对输出文件），以及对各种缓冲类型的控制方法。

#### **数据流路径**

从上至下，数据流经以下层次：
1.  **用户数据** (位于用户态内存)
    `↓` *(通过 `fprintf()` 等 `stdio` 函数调用)*
2.  **`stdio` 缓冲区** (位于用户态内存)
    `↓` *(当缓冲区满或被刷新时，`stdio` 库调用 `write()`)*
3.  **内核高速缓冲区 (页面缓存)** (位于内核态内存)
    `↓` *(由内核最终发起磁盘操作)*
4.  **磁盘**

---

#### **缓冲控制机制**

##### **显式强制刷新 (Explicit Flushing)**

在任何时候，都可以通过以下调用显式地强制将数据推送到下一层缓冲区：
* **`fflush(FILE *stream)`**: 将指定 `stdio` 流的用户态**`stdio` 缓冲区**中的数据，通过 `write()` 系统调用刷新到**内核高速缓冲区**。
* **`fsync(int fd)` / `fdatasync(int fd)`**: 将指定文件描述符的**内核高速缓冲区**中的数据刷新到**磁盘**。

##### **自动化刷新 (Automatic Flushing)**

可以通过在操作开始时进行设置，使每一笔 I/O 操作都自动刷新，从而绕过缓冲机制：
* **禁用 `stdio` 缓冲**: 通过调用 `setvbuf(fp, NULL, _IONBF, 0)`，可以禁用 `stdio` 层的缓冲。这样，每一次 `stdio` 函数调用（如 `fprintf`）都会直接触发一次 `write()` 系统调用，将数据送入内核高速缓冲区。
* **启用内核同步 I/O**: 通过在 `open()` 文件时使用 `O_SYNC` 标志，可以使每一次 `write()` 系统调用都将数据同步刷新到磁盘，从而绕过内核层的缓冲。

![[Pasted image 20250909110007.png]]