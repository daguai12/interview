### **13.7 混合使用库函数和系统调用进行文件 I/O**

在同一文件上执行 I/O 操作时，可以将系统调用（如 `read()`, `write()`）和标准 C 语言库函数（如 `printf()`, `fgets()`）混合使用。`fileno()` 和 `fdopen()` 函数有助于完成这一工作。

#### **fileno()**

`fileno()` 函数给定一个 `stdio` 文件流 (`FILE *`)，将返回其底层对应的文件描述符 (`int`)。

```c
#include <stdio.h>

int fileno(FILE *stream);
```

这个返回的文件描述符随后可以在诸如 `read()`、`write()`、`dup()` 和 `fcntl()` 之类的 I/O 系统调用中正常使用。

#### **fdopen()**

`fdopen()` 函数与 `fileno()` 的功能相反。给定一个文件描述符，该函数将创建一个使用该描述符进行文件 I/O 的相应 `stdio` 文件流。

```c
#include <stdio.h>

FILE *fdopen(int fd, const char *mode);
```

  * `mode` 参数与 `fopen()` 函数中的 `mode` 参数含义相同（例如，`"r"` 为读，`"w"` 为写）。
  * 若该参数与文件描述符 `fd` 的原始访问模式不一致，则 `fdopen()` 的调用将失败。
  * `fdopen()` 对由 `socket()`、`pipe()` 等系统调用返回的非常规文件描述符特别有用，它允许我们在这些描述符上使用便捷的 `stdio` 库函数。

#### **缓冲问题与解决方案**

当混合使用 `stdio` 库函数和 I/O 系统调用时，必须将**缓冲问题**牢记于心。

  * I/O 系统调用 (`write()`) 会直接将数据传递到**内核缓冲区**。
  * `stdio` 库函数 (`printf()`) 会先将数据传递到**用户空间的 `stdio` 缓冲区**，等到该缓冲区填满或被刷新时，才会调用 `write()` 将数据传递到内核缓冲区。

请考虑如下向标准输出写入的代码：

```c
printf("And the next prize goes to ");
write(STDOUT_FILENO, "Henry\n", 6);
```

由于 `write()` 直接将数据送入内核，而 `printf()` 的数据（因没有换行符）仍停留在 `stdio` 缓冲区中，所以这段代码**通常会产生如下混乱的输出**：

```
Henry
And the next prize goes to 
```

`printf()` 的输出在 `write()` 的输出之后才出现，因为 `stdout` 的 `stdio` 缓冲区可能在程序即将退出时才被刷新。

**解决方案**

为避免这一问题，明智之举是在混合使用 I/O 系统调用和 `stdio` 函数时，**显式地使用 `fflush()`** 来刷新 `stdio` 缓冲区。

**修正后的代码:**

```c
printf("And the next prize goes to ");
fflush(stdout); // 在调用 write() 前刷新 stdout 的 stdio 缓冲区
write(STDOUT_FILENO, "Henry\n", 6);
```

**修正后的正确输出:**

```
And the next prize goes to Henry
```

虽然也可以使用 `setvbuf()` 或 `setbuf()` 来禁用 `stdio` 缓冲，但这样做可能会影响应用的 I/O 性能，因为每个 `stdio` 输出操作都将引起一次 `write()` 系统调用。