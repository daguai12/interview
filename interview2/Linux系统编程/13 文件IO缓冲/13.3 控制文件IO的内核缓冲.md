### **13.3 控制文件 I/O 的内核缓冲**

强制刷新内核缓冲区到输出文件是可能的。这有时很有必要，例如，当数据库的日志进程等应用程序要确保在继续操作前将输出真正写入磁盘（或者至少写入磁盘的硬件高速缓存中）。

在描述用于控制内核缓冲的系统调用之前，有必要先熟悉一下 SUSv3 中的相关定义。

#### **同步 I/O 数据完整性和同步 I/O 文件完整性**

SUSv3 将**同步 I/O 完成 (synchronized I/O completion)** 定义为：某一 I/O 操作，要么已成功完成到磁盘的数据传递，要么被诊断为不成功。

SUSv3 定义了两种不同类型的同步 I/O 完成，二者之间的区别涉及文件的**元数据（metadata）**——即内核为文件存储的相关数据，如文件属主、权限、大小、时间戳、数据块指针等。

1.  **Synchronized I/O Data Integrity Completion**
    这种同步 I/O 完成旨在确保传递了足够的信息到磁盘，以便于之后能成功获取数据。
    * 对于**写操作**，这意味着用户请求写入的数据已传递至磁盘，并且**所有用于获取这些数据的元数据**（例如，如果文件大小改变了，文件大小这个元数据必须被更新）也已传递至磁盘。非必需的元数据（如文件修改时间戳）则无需立即传递。
2.  **Synchronized I/O File Integrity Completion**
    这是上述数据完整性的一个超集。
    * 对于**写操作**，除了传递数据和必需的元数据外，**所有发生更新的文件元数据**都必须被传递到磁盘上，即使这些元数据对于后续读取文件数据并非必需（例如文件访问时间戳）。

#### **用于控制文件 I/O 内核缓冲的系统调用**

* **`fsync(int fd)`**
    此系统调用将与文件描述符 `fd` 相关的所有缓冲数据和元数据都刷新到磁盘上。它强制使文件处于 **Synchronized I/O File Integrity Completion** 状态。仅在数据传递到磁盘设备（或其硬件缓存）后，`fsync()` 调用才会返回。

* **`fdatasync(int fd)`**
    此系统调用的运作类似于 `fsync()`，但它只强制文件处于 **Synchronized I/O Data Integrity Completion** 状态。因为它可能不必刷新所有元数据（如时间戳），所以 `fdatasync()` 可能会比 `fsync()` 减少一次磁盘操作，从而在特定场景下获得更好的性能。

* **`sync(void)`**
    此系统调用会使**所有**内核缓冲区中被修改过的文件信息（数据块、元数据等）刷新到磁盘上。在 Linux 实现中，`sync()` 调用会等待所有数据传递到磁盘后才返回。

**自动刷新**:
为避免系统崩溃时丢失数据，一条内核线程（在 Linux 2.6+ 中为 `pdflush`）会定期（通常是每30秒左右）将“脏”的（即被修改过的）缓冲区刷新到磁盘上。

#### **使所有写入同步：O_SYNC**

在调用 `open()` 函数时如指定 `O_SYNC` 标志，则会使所有后续的写操作变为同步的。每一个 `write()` 调用都会自动将文件数据和元数据刷新到磁盘上，其效果等同于 **Synchronized I/O File Integrity Completion**。

#### **O_SYNC 对性能的影响**

采用 `O_SYNC` 标志（或者频繁调用 `fsync()`）对性能的影响极大。下表展示了在有、无 `O_SYNC` 标志的情况下，向一个新文件写入 1MB 数据所需的时间。

**表 13-3：O_SYNC 标志对写入 1MB 速度的影响**
| BUF_SIZE | 无 O_SYNC | 有 O_SYNC |
| :--- | :--- | :--- |
| | **运行总用时(s)** | **总 CPU 时间(s)** | **运行总用时(s)** | **总 CPU 时间(s)** |
| 1 | 0.73 | 0.73 | 1030 | 98.8 |
| 16 | 0.05 | 0.05 | 65.0 | 0.40 |
| 256 | 0.02 | 0.02 | 4.07 | 0.03 |
| 4096 | 0.01 | 0.01 | 0.34 | 0.03 |

从表中可以看出，`O_SYNC` 标志使运行总用时（墙上时间）大为增加。运行总用时和 CPU 时间之间的巨大差异表明，在使用 `O_SYNC` 时，程序被长时间阻塞，以等待缓慢的磁盘 I/O 完成。

**结论**: 如果需要强制刷新内核缓冲区，在设计应用程序时应考虑使用大尺寸的 `write()` 缓冲区，并审慎地在必要时调用 `fsync()` 或 `fdatasync()`，而不是在打开文件时就使用 `O_SYNC` 标志。

#### **O_DSYNC 和 O_RSYNC 标志**

SUSv3 规定了两个与同步 I/O 有关的、更为细化的打开文件状态标志：

* **`O_DSYNC`**: 要求写操作按照 **Synchronized I/O Data Integrity Completion** 来执行（类似于 `fdatasync()`）。
* **`O_RSYNC`**: 与 `O_SYNC` 或 `O_DSYNC` 标志配合使用，将同步要求也应用于读操作。即在执行读操作之前，必须完成所有待处理的同步写操作。

**Linux 实现**:
* 在 2.6.33 版本之前的 Linux 内核并未完全实现 `O_SYNC` 的语义，而是将其实现为 `O_DSYNC` 的效果。
* 始于 2.6.33 版本，Linux 内核正确地实现了 `O_DSYNC` 标志的功能。为保证向后兼容，与老版本 glibc 链接的应用程序会继续获得 `O_DSYNC` 的语义，即使是在新内核上。