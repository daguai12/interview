这段文字详细阐述了在Linux环境下，特别是基于NPTL（Native POSIX Thread Library）实现的线程栈相关知识。

#### 1. 基本特性
* **独立与固定大小**: 每个新创建的线程都拥有一个自己独立的、大小固定的栈空间。
* **主线程 vs. 普通线程**: 主线程的栈空间通常比其他线程大得多，以应对更复杂的调用和栈增长需求。
* **默认大小**:
    * 在 **Linux/x86-32** 架构下，普通线程的默认栈大小为 **2MB**。
    * 在64位架构下（如 IA-64），默认值会更大，例如 **32MB**。

#### 2. 修改线程栈大小的原因
* **增大栈空间**: 当线程需要处理大型的自动变量（在栈上分配的变量）或存在深度函数调用（尤其是递归）时，可能需要比默认值更大的栈以防止栈溢出（stack overflow）。
* **减小栈空间**: 当应用程序需要创建大量线程时，减小每个线程的栈大小可以节省虚拟内存空间，从而创建更多线程。
    * **示例**: 在一个用户空间为3GB的x86-32系统中，如果每个线程栈为2MB，理论上最多只能创建约1500个线程 ($3 \text{GB} / 2 \text{MB} \approx 1500$)。实际数量还会因代码段、数据段等的内存占用而更少。

#### 3. 修改线程栈大小的方法

##### 方法一：通过线程属性（编程方式）
* **`pthread_attr_setstacksize()`**: 在创建线程时，通过线程属性对象（`pthread_attr_t`）来精确设置新线程的栈大小。这是最常用且可移植性好的方法。
* **`pthread_attr_setstack()`**: 这个函数可以同时设置栈的大小和**位置**（地址）。但手动指定栈地址会大大降低程序的可移植性，不推荐常规使用。
* **最小栈大小**: 可以通过 `sysconf(_SC_THREAD_STACK_MIN)` 调用来获取系统允许的线程栈最小尺寸。在Linux/x86-32的NPTL实现中，这个值是 **16384** 字节（16KB）。

##### 方法二：通过资源限制（环境方式）
* **`RLIMIT_STACK`**: 在NPTL实现中，如果进程的 `RLIMIT_STACK` 资源限制被设置（不是 `unlimited`），那么新创建线程的默认栈大小将以此限制为准。
* **`ulimit -s` 命令**: 这个设置**必须在程序运行前完成**，通常通过shell的内建命令 `ulimit -s <size_in_kib>` (bash/ksh) 或 `limit stacksize <size_in_kib>` (csh) 来设定。
* **`setrlimit()` 的局限性**: 试图在程序 `main()` 函数中通过 `setrlimit()` 系统调用来修改栈大小限制**可能不会生效**。因为NPTL库在调用 `main()` 之前的运行时初始化阶段，就已经读取并确定了默认的线程栈大小。