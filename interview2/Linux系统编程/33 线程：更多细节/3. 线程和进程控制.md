### **线程与 `exec()`**
* **进程替换**：一旦任何一个线程调用了 `exec()` 系列函数，整个进程的内存空间都会被新程序完全替换。
* **线程终止**：所有其他线程都会立即、突然地终止。
* **无清理操作**：系统**不会**为这些被终止的线程调用其线程特有数据的析构函数（destructor）或清理函数（cleanup handler）。所有属于该进程的互斥量（mutex）和条件变量（condition variable）都会消失。

### **线程与 `fork()`** * **子进程仅含单线程**：当调用 `fork()` 时，只有发起调用的那个线程会被复制到新的子进程中。父进程中的所有其他线程在子进程中都会消失。
* **主要问题**：
    * **状态不一致**：子进程继承了父进程完整的内存副本，这包括了互斥锁和全局数据的状态。如果父进程中另一个线程在 `fork()` 调用时锁定了某个互斥量并且正在修改某个数据结构，那么子进程会继承一个“已锁定”的互斥量和一个可能处于不一致状态的数据。子进程中的单个线程无法解锁这个互斥量（因为它不是锁的持有者），如果它尝试获取该锁，就会立即陷入**死锁**。
    * **资源泄漏**：由于其他线程在没有执行清理函数或析构函数的情况下就被终结，它们所持有的资源（如动态分配的内存）会在子进程中造成泄漏。
* **推荐用法**：鉴于上述严重问题，唯一安全且被推荐的使用模式是：在 `fork()` 调用之后，子进程**立即调用 `exec()`**。`exec()` 会替换掉整个有问题的内存空间，从而避免死锁和资源泄漏。
* **`pthread_atfork()`**：对于极少数必须使用 `fork()` 但之后不调用 `exec()` 的场景，Pthreads 提供了 `pthread_atfork()` 函数。它允许你注册一些处理函数（handler），这些函数会在 `fork()` 操作之前和之后分别在父、子进程中执行。通常用这个机制来确保在 `fork()` 之前锁住所有必要的互斥量，然后在父、子进程中分别将它们解锁，以防止死锁。

### **线程与 `exit()`**
* **进程终止**：如果程序中任何一个线程调用了 `exit()`，或者主线程从 `main` 函数返回，整个进程都会终止。
* **无清理操作**：与 `exec()` 类似，所有线程都会被销毁，而系统不会为它们执行线程特有数据的析构函数或清理函数。