### 33.2.1 UNIX 信号模型如何映射到线程中

这部分的核心在于区分信号模型的哪些方面是**进程层面（所有线程共享）**的，哪些是**线程层面（各线程独有）**的。

#### 进程层面属性 (所有线程共享)

1.  **信号动作 (Signal Actions)**
    * 一个信号的默认动作（如终止进程、停止进程）是针对整个进程的。
    * 如果任一线程收到了一个未处理的、其默认动作是终止或停止的信号，那么**整个进程（所有线程）都会被终止或停止**。

2.  **信号处置 (Signal Disposition)**
    * 信号处理函数的设置（通过 `sigaction()`）是进程范围的。
    * 如果一个线程为某个信号（如 `SIGINT`）设置了处理函数，那么这个设置对所有线程都有效。
    * 同样，如果一个线程将某个信号设置为忽略，那么所有线程都会忽略该信号。

3.  **面向进程的信号发送**
    * 大多数信号是发送给整个进程的。例如：
        * 由其他进程通过 `kill()` 或 `sigqueue()` 发送的信号。
        * 用户在终端输入特殊字符产生的信号（如 `SIGINT`, `SIGTSTP`）。
        * 由软件事件产生的信号（如窗口大小改变 `SIGWINCH`，定时器到期 `SIGALRM`）。
    * 当一个面向进程的信号被发送，且已设置了处理函数时，内核会**任选一个未阻塞该信号的线程**来执行信号处理函数。一个信号事件只会被处理一次。

#### 线程层面属性 (各线程独有)

1.  **信号掩码 (Signal Mask)**
    * **这是最关键的区别**：信号掩码是**每个线程私有的**。不存在作用于整个进程的信号掩码。
    * 每个线程都可以使用 `pthread_sigmask()` 独立地设置自己的信号掩码，来阻塞或允许某些信号。
    * 通过精心设置各线程的信号掩码，可以实现**将特定信号定向到特定线程**进行处理的目的（例如，让一个专门的线程不阻塞某个信号，而其他所有线程都阻塞它）。

2.  **面向线程的信号发送**
    * 某些特定情况产生的信号是直接发送给特定线程的：
        * **硬件异常**：执行特定硬件指令出错（`SIGBUS`, `SIGFPE`, `SIGILL`, `SIGSEGV`）。
        * **管道错误**：线程向一个已断开的管道写入时产生的 `SIGPIPE`。
        * **明确指定**：由 `pthread_kill()` 或 `pthread_sigqueue()` 函数发送的、明确指向某个线程的信号。

3.  **挂起的信号 (Pending Signals)**
    * 内核会同时维护一个**进程级别**的挂起信号集和**每个线程私有**的挂起信号集。
    * 调用 `sigpending()` 返回的是“进程挂起的信号”与“当前线程挂起的信号”的并集。
    * 新创建的线程其挂起信号集初始为空。

4.  **备选信号栈 (Alternate Signal Stacks)**
    * 通过 `sigaltstack()` 设置的备选信号栈是**每个线程独有的**。
    * 新创建的线程**不会**从其创建者那里继承备选信号栈。

#### 信号处理与系统调用中断

* 如果信号处理函数中断了 `pthread_mutex_lock()` 调用，该调用总是会自动重启。
* 如果中断了 `pthread_cond_wait()` 调用，它要么自动重启（如Linux），要么返回0（表示“假唤醒”）。设计良好的程序在这两种情况下都能正确工作。


### 33.2.2 操作线程信号掩码

这部分聚焦于如何在线程中管理信号掩码。

1.  **掩码的继承**
    * 一个新创建的线程会**继承其创建者线程信号掩码的一份拷贝**。
 2.  **修改掩码的函数**
    * 在多线程程序中，应使用 `pthread_sigmask()` 来获取或改变当前线程的信号掩码。
    * 它的用法和参数与单线程环境下的 `sigprocmask()` 完全相同。

3.  **`pthread_sigmask()` vs. `sigprocmask()`**
    * **可移植性警告**：SUSv3（Single UNIX Specification v3）标准明确指出，在多线程程序中使用 `sigprocmask()` 的**行为是未定义的**，不保证可移植性。
    * **实际情况**：尽管在很多系统（包括Linux）的实现中，`pthread_sigmask()` 和 `sigprocmask()` 可能就是同一个函数，但为了编写可移植和规范的代码，**在多线程环境中必须使用 `pthread_sigmask()`**。

### 33.2.3 向线程发送信号

这部分介绍了在同一进程内，向特定线程发送信号的专用函数。

1.  **`pthread_kill()`**
    * **功能**: 向**同一进程中**由 `thread` 标识的目标线程发送信号 `sig`。
    * **限制**: 无法向其他进程中的线程发送信号，因为线程ID（`pthread_t`）仅在所属进程内保证唯一。
    * **Linux实现**: 该函数底层使用了Linux特有的 `tgkill()` 系统调用，它能将信号精确地发送给指定线程组（进程）中的指定线程（由内核线程ID `tid` 标识）。

2.  **`pthread_sigqueue()`**
    * **功能**: 这是 `pthread_kill()` 和 `sigqueue()` 的功能结合体。它允许向同一进程中的目标线程发送一个信号，并**附带一个数据值**（`value`）。
    * **适用场景**: 当你不仅需要通知一个线程有事件发生，还需要传递少量与该事件相关的数据时。
    * **依赖**: 这个函数需要较新的库和内核支持（glibc >= 2.11, Linux Kernel >= 2.6.31），底层由 `rt_tgsigqueueinfo()` 系统调用支持。

---

### 33.2.4 妥善处理异步信号

这部分阐述了在多线程程序中处理异步信号（如 `SIGINT`, `SIGTERM`）的复杂性，并给出了**推荐的最佳实践**。

#### 1. 传统信号处理函数的问题

在多线程环境中使用传统的信号处理函数（Signal Handler）会带来诸多问题：
* **复杂性**: 容易引入可重入性问题、被中断的系统调用以及竞争条件。
* **安全性**: **没有任何 Pthreads API 函数是“异步信号安全”的**。这意味着在信号处理函数内部，调用任何 `pthread_` 函数（如 `pthread_mutex_lock`）都是不安全的，其行为未定义。

#### 2. 推荐的解决方案：专用线程同步处理模型

为了规避上述问题，推荐采用一种将异步信号**同步化处理**的模式。该模式分为两步：

* **步骤一：所有线程阻塞信号**
    * 在程序启动时，由主线程**首先设置信号掩码，阻塞所有需要处理的异步信号**。
    * 由于后续创建的新线程会继承主线程的信号掩码，因此所有线程都会自动阻塞这些信号，确保它们不会被意外的线程中断。

* **步骤二：创建一个专用线程等待信号**
    * 创建一个专门的线程，它的唯一任务就是等待并处理这些被阻塞的信号。
    * 这个专用线程会调用 `sigwait()`, `sigwaitinfo()` 或 `sigtimedwait()` 函数。这些函数会使线程**同步地等待**，直到一个被阻塞的信号到达。

#### 3. 这种模式的优势

* **变异步为同步**: 将信号的异步到达转变为同步的函数返回事件，代码逻辑更清晰简单。
* **安全性高**: 信号处理逻辑在正常的线程上下文中执行，而不是在受限的信号处理函数中。因此，这个专用线程可以**安全地**：
    * 调用任何非异步信号安全的函数（包括所有Pthreads函数）。
    * 访问共享数据（在互斥锁的保护下）。
    * 使用条件变量等复杂的同步机制与其他线程通信。

#### 4. `sigwait()` 函数说明

* **功能**: 等待 `set` 集合中指定的任一信号到达。当信号到达时，函数会从等待中返回，并将信号编号通过参数 `sig` 传出。
* **与 `sigwaitinfo()` 的区别**: `sigwait()` 只返回信号编号，而 `sigwaitinfo()` 返回一个包含更详细信息的 `siginfo_t` 结构体。
* **并发问题**: 如果有多个线程同时调用 `sigwait()` 等待同一个信号，当信号到达时，**只有一个线程**会接收到该信号并从调用中返回，具体是哪个线程则是不确定的。这也是推荐使用**单一专用线程**来处理信号的原因。