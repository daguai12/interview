好的，这是根据您提供的文本内容，保留原始结构和标题整理的结果。

### **12.1 /proc 文件系统**

在较老的 UNIX 实现中，通常并无简单方法来获取或修改内核属性，例如：

  * 系统中有多少进程正在运行，其属主是谁？
  * 一个进程已经打开了什么文件？
  * 目前锁定了什么文件，哪些进程持有这些锁？
  * 系统正在使用什么套接字（socket）?

一些老版 UNIX 实现的解决方法是允许特权级程序深入内核内存中的数据结构。然而，这要求对内核数据结构具有专业知识，并且这些结构可能因内核版本的演进而发生改变，导致程序需要重写。

为了提供更为简便的方法来访问内核信息，许多现代 UNIX 实现提供了一个 **/proc 虚拟文件系统**。该文件系统驻留于 `/proc` 目录中，包含了各种用于展示内核信息的文件。进程可以通过常规文件 I/O 系统调用来方便地读取，有时还可以修改这些信息。之所以将 `/proc` 文件系统称为虚拟，是因为其包含的文件和子目录并未存储于磁盘上，而是由内核在进程访问此类信息时动态创建而成。

本节展示了 `/proc` 文件系统的概况。虽然许多 UNIX 实现提供了 `/proc` 文件系统，但 SUSv3 并未对其进行规范，**本书所述细节是 Linux 专有的**。

#### **12.1.1 获取与进程有关的信息：/proc/PID**

对于系统中每个进程，内核都提供了相应的目录，命名为 `/proc/PID`，其中 `PID` 是进程的 ID。在此目录中的各种文件和子目录包含了进程的相关信息。例如，通过查看 `/proc/1` 目录下的文件，可以获取 `init` 进程（其 ID 总是为 1）的信息。

每个 `/proc/PID` 目录中都存在一个名为 `status` 的文件，提供了有关该进程的一系列信息。

```
$ cat /proc/self/status
Name:   bash
State:  S (sleeping)
Tgid:   1968
Pid:    1968
PPid:   1967
...
VmSize:    8716 kB
...
Threads:   1
...
```

该文件内容随着内核版本而改变，这一事实揭示出关于 `/proc` 文件使用的要点所在：当解析这些文件时，应当**查找包含特殊字符串（如 `PPid:`）的匹配行记录，而非按照固定的行号来处理文件**，这样可以使程序更加健壮。

下表列举了在每个 `/proc/PID` 目录中的部分其他文件。

| 文件        | 描述（进程属性）                              |
| :-------- | :------------------------------------ |
| `cmdline` | 以 `\0` 分隔的命令行参数                       |
| `cwd`     | 指向当前工作目录的符号链接                         |
| `environ` | `NAME=value` 键值对环境列表，以 `\0` 分隔        |
| `exe`     | 指向正在执行文件的符号链接                         |
| `fd`      | 目录，包含了指向由进程打开文件的符号链接                  |
| `maps`    | 内存映射                                  |
| `mem`     | 进程虚拟内存（在I/O操作前必须调用 `lseek()` 移至有效偏移量） |
| `mounts`  | 进程的安装点                                |
| `root`    | 指向根目录的符号链接                            |
| `status`  | 各种信息（比如，进程ID、凭证、内存使用量、信号）             |
| `task`    | 为进程中的每个线程均包含一个子目录（始自 Linux 2.6）       |

**`/proc/PID/fd` 目录**

`/proc/PID/fd` 目录为进程打开的每个文件描述符都包含了一个符号链接，每个符号链接的名称都与描述符的数值相匹配。例如，`/proc/1968/fd/1` 是 PID 为 1968 的进程中指向标准输出的符号链接。

**`/proc/self`**

为方便起见，任何进程都可使用符号链接 `/proc/self` 来访问其自己的 `/proc/PID` 目录。

**线程：`/proc/PID/task` 目录**

Linux 2.4 增加了线程组概念以支持 POSIX 线程模型。针对进程中的每个线程，内核在 `/proc/PID/task/` 目录下提供了一个名为 `TID` 的子目录，即 `/proc/PID/task/TID`，其中 `TID` 是该线程的线程 ID（等同于调用 `gettid()` 的返回值）。

每个 `/proc/PID/task/TID` 子目录中都有一套类似于 `/proc/PID` 目录内容的文件和目录。因为线程共享了多个属性（如内存空间），所以这些文件中的许多信息对进程中各个线程而言都是相同的。然而，这些文件也显示了每个线程的独特信息。例如，在 `/proc/PID/task/TID/status` 文件中，以下字段的内容对每个线程而言都可能不同：

  * `State` (状态)
  * `Pid` (在此上下文中是线程ID)
  * `SigPnd`, `SigBlk` (信号相关)
  * `CapInh`, `CapPrm`, `CapEff`, `CapBnd` (能力相关)

#### **12.1.2 /proc 目录下的系统信息**

`/proc` 目录下的各种文件和子目录提供了对系统级信息的访问。例如，`/proc/cpuinfo` 提供了关于系统 CPU 的详细信息，而 `/proc/meminfo` 则包含了内存使用情况的统计。

下表总结了 `/proc` 中一些重要子目录的一般用途。

![[Pasted image 20250909102259.png]]

| 目录                 | 目录中文件表达的信息                                 |
| :----------------- | :----------------------------------------- |
| `/proc`            | 各种系统信息 (如 `cpuinfo`, `meminfo`, `version`) |
| `/proc/net`        | 有关网络和套接字的状态信息                              |
| `/proc/sys/fs`     | 文件系统相关设置                                   |
| `/proc/sys/kernel` | 各种常规的内核设置                                  |
| `/proc/sys/net`    | 网络和套接字的设置                                  |
| `/proc/sys/vm`     | 内存管理设置                                     |
| `/proc/sysvipc`    | 有关 System V IPC 对象的信息                      |

-----

##### **简单探索**

您可以通过命令行工具轻松查看这些信息：

  * **查看CPU信息**:
    ```bash
    cat /proc/cpuinfo
    ```
  * **查看内存信息**:
    ```bash
    cat /proc/meminfo
    ```
  * **列出常规内核设置**:
    ```bash
    ls /proc/sys/kernel
    ```

#### **12.1.3 访问/proc 文件**

通常使用 shell 脚本来访问 `/proc` 目录下的文件（使用诸如 Python 或者 Perl 之类的脚本语言，可以很容易地解析大多数 `/proc` 目录下包含有多个值的文件）。例如，使用如下 shell 命令，就可以修改和查看 `/proc` 目录下的文件内容：

```bash
# 查看文件内容
$ cat /proc/sys/kernel/pid_max
32768

# 修改文件内容 (需要特权)
$ echo "40000" > /proc/sys/kernel/pid_max
```

也可以从程序中使用常规 I/O 系统调用来访问 `/proc` 目录下的文件。但在访问这些文件时，有如下一些限制。

  * **只读文件**: `/proc` 目录下的一些文件是只读的，即这些文件仅用于显示内核信息，但无法对其进行修改。`/proc/PID` 目录下的大多数文件就属于此类型。
  * **文件权限**: `/proc` 目录下的一些文件仅能由文件拥有者（或特权级进程）读取。例如，`/proc/PID` 目录下的所有文件都属于拥有相应进程的用户，而且即使是对文件的属主，其中的部分文件（如 `/proc/PID/environ` 文件）也仅仅授予了读权限。
  * **Root 用户**: 除了 `/proc/PID` 子目录中的文件，`/proc` 目录的其他文件大多属于 root 用户，并且也仅有 root 用户能够修改那些可修改的文件。

##### **访问/proc/PID 目录中的文件**

`/proc/PID` 目录内容变化不定。每个目录随着含有相应进程 ID 的进程创建而生，又随进程的终止而灭。这意味着在访问此目录下的文件时，需要干净利落地处理一种可能性：**当程序尝试打开文件时，目标进程可能已经终止，其对应的 `/proc/PID` 目录也已经被删除了**。

-----

#### **示例程序**

程序清单 12-1 展示了如何从 C 程序中读取和修改一个 `/proc` 文件。该程序读取并显示 `/proc/sys/kernel/pid_max` 文件的内容。若提供了命令行参数，则程序将使用此参数对文件进行更新。该文件规定了进程 ID 的上限。

**`proc_pidmax.c` 文件:**

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>

#define MAX_LINE 100
#define PROC_FILE "/proc/sys/kernel/pid_max"

int main(int argc, char *argv[]) {
    int fd;
    char line[MAX_LINE];
    ssize_t n;

    // --- 1. 读取并显示当前值 ---
    fd = open(PROC_FILE, O_RDONLY);
    if (fd == -1) {
        perror("open - read");
        exit(EXIT_FAILURE);
    }

    n = read(fd, line, MAX_LINE);
    if (n == -1) {
        perror("read");
        exit(EXIT_FAILURE);
    }

    // read 不会自动添加空终止符，所以我们手动添加
    if (n < MAX_LINE) {
        line[n] = '\0';
    } else {
        line[MAX_LINE - 1] = '\0';
    }
    
    // 文件内容可能包含换行符，我们先打印原始的
    printf("Current value of %s: %s", PROC_FILE, line);

    close(fd);

    // --- 2. 如果提供了命令行参数，则更新文件 ---
    if (argc > 1) {
        printf("Attempting to set new value: %s\n", argv[1]);

        // 打开文件进行写操作，需要特权
        fd = open(PROC_FILE, O_WRONLY);
        if (fd == -1) {
            perror("open - write (do you have root privileges?)");
            exit(EXIT_FAILURE);
        }

        if (write(fd, argv[1], strlen(argv[1])) != strlen(argv[1])) {
            fprintf(stderr, "Error writing to %s\n", PROC_FILE);
            exit(EXIT_FAILURE);
        }

        printf("Successfully updated %s.\n", PROC_FILE);
        close(fd);
    }

    exit(EXIT_SUCCESS);
}
```

**编译和运行:**

1.  **编译程序:**
    ```bash
    gcc proc_pidmax.c -o proc_pidmax
    ```
2.  **运行程序以查看当前值:**
    ```bash
    ./proc_pidmax
    ```
    **输出:**
    ```
    Current value of /proc/sys/kernel/pid_max: 32768
    ```
3.  **尝试更新值（作为普通用户，将会失败）:**
    ```bash
    ./proc_pidmax 40000
    ```
    **输出:**
    ```
    Current value of /proc/sys/kernel/pid_max: 32768
    Attempting to set new value: 40000
    open - write (do you have root privileges?): Permission denied
    ```
4.  **使用 `sudo` 以 root 权限更新值:**
    ```bash
    sudo ./proc_pidmax 40000
    ```
    **输出:**
    ```
    Current value of /proc/sys/kernel/pid_max: 32768
    Attempting to set new value: 40000
    Successfully updated /proc/sys/kernel/pid_max.
    ```
5.  **再次查看以确认更改:**
    ```bash
    ./proc_pidmax
    ```
    **输出:**
    ```
    Current value of /proc/sys/kernel/pid_max: 40000
    ```