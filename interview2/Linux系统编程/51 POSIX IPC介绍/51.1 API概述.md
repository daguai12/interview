好的，这是根据您提供的文本内容，保留原始结构和标题整理的结果。

### **POSIX IPC 介绍**

POSIX.1b 实时扩展定义了一组 IPC（Inter-Process Communication, 进程间通信）机制，它们旨在弥补 System V IPC 工具的不足之处。这三种 POSIX IPC 机制具体如下：

* **消息队列 (Message Queues)**:
    * 允许进程间以**消息**的形式交换数据，保留了消息边界。
    * 允许为每个消息赋予一个**优先级**，队列中优先级较高的消息会排在优先级较低的消息前面。

* **信号量 (Semaphores)**:
    * 允许多个进程同步各自的动作。
    * 与 System V 信号量相比，POSIX 信号量在用法上要简单一些：它们是**逐个分配**的（而不是集合），并且在单个信号量上只能执行**加 1** 或**减 1** 的操作。

* **共享内存 (Shared Memory)**:
    * 使得多个进程能够共享同一块内存区域，是一种非常快速的 IPC 方式。
    * 一个进程更新了共享内存后，所发生的变更立即对共享同一区域的其他进程可见。

---

### **51.1 API 概述**

三种 POSIX IPC 机制拥有很多共有的特性。下表对它们的 API 进行了总结。

**表 51-1：POSIX IPC 对象编程接口总结**

| 接口 | 消息队列 | 信号量 | 共享内存 |
| :--- | :--- | :--- | :--- |
| **头文件** | `<mqueue.h>` | `<semaphore.h>` | `<sys/mman.h>` |
| **对象句柄** | `mqd_t` | `sem_t *` | `int` (文件描述符) |
| **创建/打开** | `mq_open()` | `sem_open()` | `shm_open()` + `mmap()` |
| **关闭** | `mq_close()` | `sem_close()` | `munmap()` |
| **断开链接** | `mq_unlink()`| `sem_unlink()`| `shm_unlink()` |
| **执行 IPC** | `mq_send()`, `mq_receive()`|`sem_post()`, `sem_wait()`| 在共享区域中操作 |
| **其他操作** | `mq_getattr()`, `mq_setattr()`, `mq_notify()` | `sem_init()`, `sem_destroy()` | `ftruncate()` |

#### **IPC 对象名字**
* **命名规范**: 在 SUSv3 中，一个可移植的 POSIX IPC 对象名是以**斜线 (`/`)** 开头，后面跟着一个或多个非斜线字符的字符串，例如 `/myobject`。
* **可移植性**: 不同的 UNIX 系统对命名规则的实现可能不同。为保证可移植性，应用程序应将 IPC 对象名的生成工作放在一个可根据目标系统进行裁剪的单独函数或头文件中。

#### **创建或打开 IPC 对象**
每种机制都有一个 `open` 调用 (`mq_open()`, `sem_open()`, `shm_open()`)，它们与传统的文件 `open()` 系统调用非常类似。
* **句柄 (Handle)**: 调用成功后会返回一个句柄（消息队列描述符、信号量指针或文件描述符），用于在后续调用中引用该对象。
* **`oflag` 参数**: 一个位掩码，用于控制操作，主要包含：
    * **`O_CREAT`**: 如果对象不存在，则创建它。
    * **`O_EXCL`**: 与 `O_CREAT` 一同使用，如果对象已存在，则调用失败。
    * **`O_RDONLY`**, **`O_WRONLY`**, **`O_RDWR`**: 指定访问模式。
* **`mode` 参数**: 指定新创建对象的权限，其规则与文件权限相同，并会受到进程 `umask` 的影响。

#### **关闭 IPC 对象**
每种机制都有一个对应的 `close` 调用或动作（`mq_close`, `sem_close`, `munmap`），用于告知系统调用进程已使用完该对象。对象在进程终止或执行 `exec()` 时也会被自动关闭。

#### **IPC 对象权限**
IPC 对象的权限掩码与文件上的权限掩码是一样的，访问规则也类似，但**执行权限 (`x`)** 对 POSIX IPC 对象没有意义。

#### **IPC 对象删除和对象持久性**
* **内核持久性**: 与 System V IPC 一样，POSIX IPC 对象也拥有**内核持久性**。对象一旦被创建，就会一直存在，直到被显式地断开链接（unlink）或系统被关闭。
* **引用计数**: 与 System V IPC 的一个关键区别是，POSIX IPC 对象是**引用计数的**。内核会维护对象上的打开引用计数。
* **`unlink` 调用**:
    * 每个对象都有一个对应的 `unlink` 调用 (`mq_unlink`, `sem_unlink`, `shm_unlink`)。
    * `unlink` 调用会立即删除对象的**名字**。
    * 对象本身则会被标记为“待删除”，直到其**引用计数等于 0** 时（即所有进程都关闭了该对象），才会被真正地销毁。
    * 这种机制使得应用程序能够更容易地确定何时可以安全地删除一个对象。

#### **通过命令行列出和删除 POSIX IPC 对象**
* **无标准命令**: POSIX IPC 没有像 `ipcs` 和 `ipcrm` 这样的标准管理命令。
* **在 Linux 上**: POSIX IPC 对象是在一个虚拟文件系统中实现的（通常挂载在 `/dev/shm` 或 `/dev/mqueue`）。因此，可以使用标准的 `ls` 和 `rm` 命令来列出和删除这些对象。
* **粘滞位 (Sticky Bit)**: 在 Linux 上，这些 IPC 所在的目录通常设置了粘滞位，这意味着非特权进程只能删除它自己拥有的 IPC 对象。

#### **在 Linux 上编译**
在 Linux 上，使用 POSIX IPC 机制的程序必须与**实时库 `librt`** 链接起来，这可以通过在编译命令中指定 `–lrt` 选项来完成。