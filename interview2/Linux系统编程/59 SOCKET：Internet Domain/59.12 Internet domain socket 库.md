### **59.12 Internet domain socket 库**

本节将使用 `getaddrinfo()` 和 `getnameinfo()` 等协议独立的函数来实现一个函数库，该库封装了使用 Internet domain socket 时碰到的常见任务。由于这些函数是协议独立的，因此它们既可以用于 IPv4 也可以用于 IPv6。

#### **头文件**

程序清单 59-8 是这个库的头文件，它声明了库提供的函数。

**程序清单 59-8：`inet_sockets.h`**

```c
#ifndef INET_SOCKETS_H
#define INET_SOCKETS_H

#include <sys/socket.h>
#include <netdb.h>

int inetConnect(const char *host, const char *service, int type);

int inetListen(const char *service, int backlog, socklen_t *addrlen);

int inetBind(const char *service, int type, socklen_t *addrlen);

char *inetAddressStr(const struct sockaddr *addr, socklen_t addrlen,
                     char *addrStr, int addrStrLen);

#define IS_ADDR_STR_LEN (NI_MAXHOST + NI_MAXSERV + 4)

#endif
```

#### **库函数说明**

  * **`inetConnect(host, service, type)`**:

      * **用途**: 供 TCP 或 UDP **客户端**使用。
      * **功能**: 创建一个 socket 并将其连接到由 `host` 和 `service` 指定的服务器地址。
      * **返回**: 返回新的、已连接的 socket 文件描述符。

  * **`inetListen(service, backlog, addrlen)`**:

      * **用途**: 供 **TCP 服务器**使用。
      * **功能**: 创建一个监听流 (`SOCK_STREAM`) socket，该 socket 会被绑定到由 `service` 指定的 TCP 端口的通配 IP 地址上。
      * **返回**: 返回新的监听 socket 文件描述符。

  * **`inetBind(service, type, addrlen)`**:

      * **用途**: 主要供 **UDP 服务器**使用。
      * **功能**: 创建一个 socket 并将其绑定到由 `service` 和 `type` 指定的端口的通配 IP 地址上。
      * **返回**: 返回新的、已绑定的 socket 文件描述符。

  * **`inetAddressStr(addr, addrlen, addrStr, addrStrLen)`**:

      * **用途**: 一个工具函数。
      * **功能**: 将一个 `sockaddr` 地址结构转换为一个格式为 `(hostname, port)` 的人类可读字符串。
      * **返回**: 返回一个指向 `addrStr` 缓冲区的指针。

-----

#### **实现**

程序清单 59-9 是这个库中函数的实现代码。

**程序清单 59-9：`inet_sockets.c` (一个 Internet domain socket 库)**

```c
#define _GNU_SOURCE
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include "inet_sockets.h"

// inetListen 和 inetBind 的内部辅助函数
static int inetPassiveSocket(const char *service, int type, socklen_t *addrlen,
                             int doListen, int backlog) {
    struct addrinfo hints;
    struct addrinfo *result, *rp;
    int sfd = -1;

    memset(&hints, 0, sizeof(struct addrinfo));
    hints.ai_canonname = NULL;
    hints.ai_addr = NULL;
    hints.ai_next = NULL;
    hints.ai_socktype = type;
    hints.ai_family = AF_UNSPEC; // Allow IPv4 or IPv6
    hints.ai_flags = AI_PASSIVE | AI_NUMERICSERV; // For wildcard IP address

    if (getaddrinfo(NULL, service, &hints, &result) != 0)
        return -1;

    // 遍历 getaddrinfo 返回的地址列表，尝试绑定
    for (rp = result; rp != NULL; rp = rp->ai_next) {
        sfd = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);
        if (sfd == -1)
            continue; // On error, try next address

        if (doListen) {
            int optval = 1;
            if (setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)) == -1) {
                close(sfd);
                freeaddrinfo(result);
                return -1;
            }
        }
        
        if (bind(sfd, rp->ai_addr, rp->ai_addrlen) == 0)
            break; // Success

        // bind() failed, close this socket and try next address
        close(sfd);
        sfd = -1;
    }
    
    if (sfd != -1) {
        if (doListen) {
            if (listen(sfd, backlog) == -1) {
                freeaddrinfo(result);
                return -1;
            }
        }
        if (addrlen != NULL)
            *addrlen = rp->ai_addrlen; // Return address structure size
    }

    freeaddrinfo(result);
    return sfd;
}

// 公开的库函数
int inetListen(const char *service, int backlog, socklen_t *addrlen) {
    return inetPassiveSocket(service, SOCK_STREAM, addrlen, 1, backlog);
}

int inetBind(const char *service, int type, socklen_t *addrlen) {
    return inetPassiveSocket(service, type, addrlen, 0, 0);
}

int inetConnect(const char *host, const char *service, int type) {
    struct addrinfo hints;
    struct addrinfo *result, *rp;
    int sfd = -1;

    memset(&hints, 0, sizeof(struct addrinfo));
    hints.ai_canonname = NULL;
    hints.ai_addr = NULL;
    hints.ai_next = NULL;
    hints.ai_socktype = type;
    hints.ai_family = AF_UNSPEC; // Allow IPv4 or IPv6
    hints.ai_flags = AI_NUMERICSERV;
    
    if (getaddrinfo(host, service, &hints, &result) != 0)
        return -1;

    // 遍历 getaddrinfo 返回的地址列表，尝试连接
    for (rp = result; rp != NULL; rp = rp->ai_next) {
        sfd = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);
        if (sfd == -1)
            continue; // On error, try next address
        
        if (connect(sfd, rp->ai_addr, rp->ai_addrlen) != -1)
            break; // Success

        // connect() failed, close this socket and try next address
        close(sfd);
        sfd = -1;
    }
    
    freeaddrinfo(result);
    return sfd;
}

char *inetAddressStr(const struct sockaddr *addr, socklen_t addrlen,
                     char *addrStr, int addrStrLen) {
    char host[NI_MAXHOST], service[NI_MAXSERV];

    if (getnameinfo(addr, addrlen, host, NI_MAXHOST, service, NI_MAXSERV, NI_NUMERICSERV) == 0)
        snprintf(addrStr, addrStrLen, "(%s, %s)", host, service);
    else
        snprintf(addrStr, addrStrLen, "(?UNKNOWN?)");
    
    return addrStr;
}
```