### **59.11 客户端/服务器示例（流式 socket）**

本节将介绍一个简单的使用 TCP socket 的客户端/服务器应用程序，其功能是为客户端分配唯一的序号。

为处理服务器和客户端主机可能以不同的格式来表示整数的情况（字节序问题），所有传输的整数都将被编码成以换行符结尾的字符串，并使用 `readLine()` 函数来读取。

-----

#### **公共头文件**

服务器和客户端都需要包含程序清单 59-5 给出的头文件。

**程序清单 59-5：`inet_seqnum.h`**

```c
#include <netinet/in.h>
#include <sys/socket.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <netdb.h>
#include <errno.h>

#define PORT_NUM "50000" // 服务器端口号
#define BUF_SIZE 500
```

*(为了使后续代码可编译，此处补充了书中假设存在的 `readLine()` 和地址转换函数的简单实现)*

```c
// 从 fd 读取一行
ssize_t readLine(int fd, void *buffer, size_t n) {
    ssize_t numRead; size_t totRead; char *buf; char ch;
    if (n <= 0 || buffer == NULL) { errno = EINVAL; return -1; }
    buf = buffer; totRead = 0;
    for (;;) {
        numRead = read(fd, &ch, 1);
        if (numRead == -1) {
            if (errno == EINTR) continue;
            else return -1;
        } else if (numRead == 0) {
            if (totRead == 0) return 0;
            else break;
        } else {
            if (totRead < n - 1) { totRead++; *buf++ = ch; }
            if (ch == '\n') break;
        }
    }
    *buf = '\0';
    return totRead;
}

// 将 socket 地址转换为可打印的字符串
char *inetAddressStr(const struct sockaddr *addr, socklen_t addrlen,
                     char *addrStr, int addrStrLen) {
    char host[NI_MAXHOST], service[NI_MAXSERV];
    if (getnameinfo(addr, addrlen, host, NI_MAXHOST, service, NI_MAXSERV, NI_NUMERICSERV) == 0)
        snprintf(addrStr, addrStrLen, "(%s, %s)", host, service);
    else
        snprintf(addrStr, addrStrLen, "(?UNKNOWN?)");
    return addrStr;
}
```

-----

#### **服务器程序**

程序清单 59-6 是一个迭代式服务器，它一次处理一个客户端请求。

**程序清单 59-6：`is_seqnum_sv.c` (迭代式服务器)**

```c
#include "inet_seqnum.h"

int main(int argc, char *argv[]) {
    int lfd, cfd, optval;
    socklen_t addrlen;
    struct sockaddr_storage claddr;
    char addrStr[1024], reqLenStr[50], seqNumStr[50];
    
    // ① 初始化序号
    int seqNum = (argc > 1) ? atoi(argv[1]) : 1;

    // ② 忽略 SIGPIPE 信号
    if (signal(SIGPIPE, SIG_IGN) == SIG_ERR) {
        perror("signal"); exit(EXIT_FAILURE);
    }
    
    // ③④ 使用 getaddrinfo() 获取监听地址结构
    struct addrinfo hints, *res, *rp;
    memset(&hints, 0, sizeof(struct addrinfo));
    hints.ai_canonname = NULL;
    hints.ai_addr = NULL;
    hints.ai_next = NULL;
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_family = AF_UNSPEC; // IPv4 or IPv6
    hints.ai_flags = AI_PASSIVE | AI_NUMERICSERV; // For wildcard IP address

    if (getaddrinfo(NULL, PORT_NUM, &hints, &res) != 0) {
        perror("getaddrinfo"); exit(EXIT_FAILURE);
    }

    // ⑤ 循环尝试创建、绑定和监听
    for (rp = res; rp != NULL; rp = rp->ai_next) {
        lfd = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);
        if (lfd == -1) continue;
        
        // ⑥ 设置 SO_REUSEADDR 选项
        optval = 1;
        if (setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)) == -1) {
            perror("setsockopt"); exit(EXIT_FAILURE);
        }
        
        if (bind(lfd, rp->ai_addr, rp->ai_addrlen) == 0) break; // 成功
        close(lfd);
    }
    if (rp == NULL) {
        fprintf(stderr, "Could not bind socket to any address\n"); exit(EXIT_FAILURE);
    }
    
    // ⑧ 将 socket 标记为监听
    if (listen(lfd, 10) == -1) {
        perror("listen"); exit(EXIT_FAILURE);
    }
    freeaddrinfo(res);

    // ⑨ 无限循环处理客户端
    for (;;) {
        addrlen = sizeof(struct sockaddr_storage);
        // ⑩ 接受一个新连接
        cfd = accept(lfd, (struct sockaddr *) &claddr, &addrlen);
        if (cfd == -1) {
            perror("accept"); continue;
        }

        printf("Connection from %s\n", inetAddressStr((struct sockaddr *) &claddr,
                                                     addrlen, addrStr, sizeof(addrStr)));
        
        // ⑪ 读取客户端请求
        if (readLine(cfd, reqLenStr, sizeof(reqLenStr)) <= 0) {
            close(cfd);
            continue;
        }
        int reqLen = atoi(reqLenStr);
        if (reqLen <= 0) {
            close(cfd);
            continue;
        }
        
        // ⑫ 将序号发回给客户端
        snprintf(seqNumStr, sizeof(seqNumStr), "%d\n", seqNum);
        if (write(cfd, seqNumStr, strlen(seqNumStr)) != strlen(seqNumStr))
            fprintf(stderr, "Error on write\n");
            
        // ⑬ 更新序号
        seqNum += reqLen;
        
        // ⑭ 关闭连接
        if (close(cfd) == -1) perror("close");
    }
}
```

-----

#### **客户端程序**

程序清单 59-7 是客户端的代码。

**程序清单 59-7：`is_seqnum_cl.c` (客户端)**

```c
#include "inet_seqnum.h"

int main(int argc, char *argv[]) {
    char *reqLenStr;
    char seqNumStr[50];
    int cfd;

    if (argc < 2 || strcmp(argv[1], "--help") == 0) {
        fprintf(stderr, "Usage: %s server-host [sequence-len]\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    reqLenStr = (argc > 2) ? argv[2] : "1";

    // ① 使用 getaddrinfo() 获取服务器地址结构
    struct addrinfo hints, *res, *rp;
    memset(&hints, 0, sizeof(struct addrinfo));
    hints.ai_canonname = NULL;
    hints.ai_addr = NULL;
    hints.ai_next = NULL;
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_family = AF_UNSPEC;
    hints.ai_flags = AI_NUMERICSERV;
    
    if (getaddrinfo(argv[1], PORT_NUM, &hints, &res) != 0) {
        perror("getaddrinfo"); exit(EXIT_FAILURE);
    }

    // ② 循环尝试创建和连接
    for (rp = res; rp != NULL; rp = rp->ai_next) {
        // ③
        cfd = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);
        if (cfd == -1) continue;

        // ④
        if (connect(cfd, rp->ai_addr, rp->ai_addrlen) != -1) break; // 成功
        close(cfd);
    }
    if (rp == NULL) {
        fprintf(stderr, "Could not connect socket to any address\n"); exit(EXIT_FAILURE);
    }
    freeaddrinfo(res);

    // ⑤ 发送请求
    if (write(cfd, reqLenStr, strlen(reqLenStr)) != strlen(reqLenStr))
        fprintf(stderr, "Partial/failed write (reqLenStr)\n");
    if (write(cfd, "\n", 1) != 1)
        fprintf(stderr, "Partial/failed write (newline)\n");

    // ⑥ 读取服务器响应
    if (readLine(cfd, seqNumStr, sizeof(seqNumStr)) <= 0) {
        fprintf(stderr, "readLine: Failed to read response from server\n");
        exit(EXIT_FAILURE);
    }

    // ⑦ 打印响应
    printf("Sequence number: %s", seqNumStr); // readLine includes newline

    exit(EXIT_SUCCESS); //
}
```

-----

#### **运行演示**

1.  **编译程序**:
    ```bash
    $ gcc is_seqnum_sv.c -o is_seqnum_sv
    $ gcc is_seqnum_cl.c -o is_seqnum_cl
    ```
2.  **在一个终端中启动服务器 (后台运行)**:
    ```bash
    $ ./is_seqnum_sv &
    [1] 12348
    ```
3.  **在另一个终端中运行客户端**:
    ```bash
    # 请求默认长度 1
    $ ./is_seqnum_cl localhost
    Sequence number: 1

    # 请求长度 5
    $ ./is_seqnum_cl localhost 5
    Sequence number: 2

    # 再次请求默认长度 1
    $ ./is_seqnum_cl localhost
    Sequence number: 7
    ```
4.  **使用 `telnet` 调试服务器**:
    ```bash
    $ telnet localhost 50000
    Trying 127.0.0.1...
    Connected to localhost.
    Escape character is '^]'.
    5  <-- 手动输入 5 并按回车
    8  <-- 服务器返回序号 8
    Connection closed by foreign host.
    ```