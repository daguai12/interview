### **59.4 Internet socket 地址**

Internet domain socket 地址有两种：IPv4 和 IPv6。

#### **IPv4 socket 地址：`struct sockaddr_in`**

一个 IPv4 socket 地址会被存储在一个 `sockaddr_in` 结构中，该结构在 `<netinet/in.h>` 中定义，具体如下：

```c
#include <netinet/in.h>

struct sockaddr_in {
    sa_family_t    sin_family; /* Address family (AF_INET) */
    in_port_t      sin_port;   /* Port number */
    struct in_addr sin_addr;   /* IPv4 address */
};

struct in_addr {
    in_addr_t      s_addr;     /* Address in network byte order */
};
```

  * **`sin_family`**: 对于 IPv4，其值总为 `AF_INET`。
  * **`sin_port`**: 16 位的端口号。
  * **`sin_addr`**: 32 位的 IPv4 地址。
  * **字节序**: `sin_port` 和 `sin_addr` 字段都必须以**网络字节序 (network byte order)** 存储。

#### **IPv6 socket 地址：`struct sockaddr_in6`**

一个 IPv6 socket 地址包含一个 128 位的 IP 地址和一个 16 位的端口号，存储在一个 `sockaddr_in6` 结构中，定义如下：

```c
#include <netinet/in.h>

struct sockaddr_in6 {
    sa_family_t     sin6_family;    /* AF_INET6 */
    in_port_t       sin6_port;      /* Port number */
    uint32_t        sin6_flowinfo;  /* IPv6 flow information */
    struct in6_addr sin6_addr;      /* IPv6 address */
    uint32_t        sin6_scope_id;  /* Scope ID (new in 2.4) */
};

struct in6_addr {
    unsigned char   s6_addr[16];    /* IPv6 address */
};
```

  * **`sin6_family`**: 对于 IPv6，其值总为 `AF_INET6`。
  * **`sin6_port`** 和 **`sin6_addr`**: 分别是端口号和 128 位的 IPv6 地址。
  * **字节序**: `sockaddr_in6` 结构中的所有字段都是以**网络字节序**存储的。

##### **IPv6 通配地址和环回地址**

由于 IPv6 地址是一个结构体数组，不能像 IPv4 那样直接赋一个 `INADDR_ANY` 整数常量。必须使用系统定义的常量和变量：

  * **初始化时**: 在变量声明时，可以使用 `IN6ADDR_ANY_INIT` (通配地址 `0::0`) 和 `IN6ADDR_LOOPBACK_INIT` (环回地址 `::1`) 宏来初始化。
  * **赋值时**: 在赋值语句中，必须使用预先定义的全局变量 `in6addr_any` 和 `in6addr_loopback`。

**示例**:

```c
struct sockaddr_in6 svaddr;

svaddr.sin6_family = AF_INET6;
svaddr.sin6_addr = in6addr_any; // 使用预定义的通配地址变量
svaddr.sin6_port = htons(PORT_NUM); // 端口号仍需转换为主机字节序
```

> **端口空间共享**: 在一台主机上，IPv4 和 IPv6 **共享同一个端口号空间**。这意味着，如果一个应用程序将一个 IPv6 socket 绑定到了 TCP 端口 2000 上，那么其他 IPv4 TCP socket 将无法再绑定到同一个端口上。

#### **`sockaddr_storage` 结构**

在 IPv6 socket API 中新引入了一个通用的 `sockaddr_storage` 结构。

  * **作用**: 这个结构的空间足够大，足以存储**任意类型**的 socket 地址（包括 `sockaddr_in`, `sockaddr_in6`, `sockaddr_un` 等）。
  * **优点**: 它允许编写 IP 版本无关的代码。例如，`accept()` 可以接受一个 `sockaddr_storage` 结构体来接收客户端的地址，而无需提前知道客户端使用的是 IPv4 还是 IPv6。程序可以随后检查其 `ss_family` 字段来确定实际的地址类型。

`sockaddr_storage` 结构在 Linux 上的定义如下所示：

```c
#include <netinet/in.h>

struct sockaddr_storage {
    sa_family_t  ss_family;     /* Address family */
    /* ... some fields to force alignment */
    char __ss_padding[_SS_PADSIZE];
};
```