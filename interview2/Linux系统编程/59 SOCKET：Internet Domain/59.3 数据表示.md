### **59.3 数据表示**

在编写网络程序时，需要清楚不同的计算机架构使用不同的规则来表示各种数据类型。例如：

  * **字节序 (Endianness)**: 多字节整数可以以大端或小端的形式存储。
  * **类型大小**: C 语言的 `long` 数据类型在一些系统上可能是 32 位的，但在其他系统上可能是 64 位的。
  * **结构体填充 (Struct Padding)**: 不同的编译器会采用不同的对齐规则，在结构体字段之间插入不同数量的填充字节。

由于存在这些差异，在网络中的异构系统（不同架构的计算机）之间交换数据的应用程序，必须要采用一些公共的规则来编码数据。

#### **通用解决方案：信号编集 (Marshalling)**

将数据转换成一个标准格式以便在网络上传输的过程被称为**信号编集 (marshalling)**。目前，存在多种信号编集标准，例如：

  * **XDR** (External Data Representation)
  * **ASN.1-BER** (Abstract Syntax Notation 1)
  * **CORBA**
  * **XML**

一般来讲，这些标准会为每一种数据类型都定义一个固定的格式（如定义了字节序和使用的位数）。

#### **更简单的方法：基于文本的协议**

一种比信号编集更简单且常用的方法是：**将所有要传输的数据都编码成文本形式**，并使用特定的字符（通常是**换行符 `\n`**）来分隔数据项。

  * **优点**: 这种方法的一个巨大优点是易于调试。我们可以使用 `telnet` 等简单的工具直接连接到服务器的端口，手动输入文本命令并查看服务器返回的文本响应。
    ```bash
    $ telnet host port
    ```

-----

#### **程序示例：`readLine()` 函数**

如果将在流 socket 上传输的数据编码成使用换行符分隔的文本，那么定义一个如下 `readLine()` 之类的辅助函数将非常便捷。

**程序清单 59-1：一次读取一行数据**

```c
#include <unistd.h>
#include <errno.h>

/*
 * 从文件描述符 fd 中一次读取一行 (以换行符 '\n' 结尾)。
 * 将读取的内容 (包括换行符) 存入 buffer, 并以空字符 ('\0') 结尾。
 * buffer 的大小为 n 字节。
 *
 * 返回值:
 * > 0: 成功，返回读取的字节数 (不包括末尾的 '\0')
 * 0: 读到文件结尾 (EOF)
 * -1: 发生错误
 */
ssize_t readLine(int fd, void *buffer, size_t n) {
    ssize_t numRead;
    size_t totRead;
    char *buf;
    char ch;

    if (n <= 0 || buffer == NULL) {
        errno = EINVAL;
        return -1;
    }
    
    buf = buffer;
    totRead = 0;

    for (;;) {
        numRead = read(fd, &ch, 1);

        if (numRead == -1) { // 发生错误
            if (errno == EINTR) // 被信号中断，继续读取
                continue;
            else
                return -1;      // 其他错误
        
        } else if (numRead == 0) { // 遇到 EOF
            if (totRead == 0) // 如果还没读到任何字节，就返回 0
                return 0;
            else // 否则，在已读数据后添加 '\0' 并返回
                break;

        } else { // numRead 为 1
            if (totRead < n - 1) { // 如果缓冲区还有空间
                totRead++;
                *buf++ = ch;
            }
            if (ch == '\n') {
                break;
            }
        }
    }
    
    *buf = '\0'; // 添加 null 终止符
    return totRead;
}
```

**`readLine()` 的行为**:

  * 该函数从文件描述符 `fd` 中逐字节地读取数据，直到遇到换行符 (`\n`) 或文件结尾 (EOF)。
  * 它将读取的字符串（**包含**换行符）放入 `buffer` 中，并确保字符串总是以空字符 `\0` 结尾。
  * **处理长行**: 如果在遇到换行符之前读取的字节数已经等于或超过了 `n-1`，那么 `readLine()` 函数会将已读取的部分存入缓冲区，然后**丢弃**这一行中剩余的、直到下一个换行符为止的所有多余字节。