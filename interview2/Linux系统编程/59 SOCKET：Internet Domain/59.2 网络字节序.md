### **59.2 网络字节序**

IP 地址和端口号本质上都是整数。在网络中传递这些值时，一个关键问题是：不同的硬件架构（CPU）会以不同的顺序来存储一个多字节整数的各个字节。

  * **大端序 (Big-Endian)**: 指一个整数的**最高有效位** (Most Significant Byte, MSB) 存储在内存的最低地址处。可以记为“高位在前”。
  * **小端序 (Little-Endian)**: 指一个整数的**最低有效位** (Least Significant Byte, LSB) 存储在内存的最低地址处。可以记为“低位在前”。
  * **主机字节序 (Host Byte Order)**: 指当前运行程序的计算机所使用的字节序。x86 架构（如 Intel, AMD CPU）是典型的小端序。

**字节序示意图 (对应原文图 59-1)**

以 32 位整数 `0x0A0B0C0D` 为例 (其中 `0A` 是最高有效位):

![[Pasted image 20250918155710.png]]

| 字节序     | 低地址 -\>             | -\> 高地址 |
| :------ | :------------------ | :------ |
| **大端序** | `0A` `0B` `0C` `0D` |         |
| **小端序** | `0D` `0C` `0B` `0A` |         |
|         |                     |         |

#### **网络字节序**

为了解决不同主机间字节序不一致的问题，TCP/IP 协议规定了一个标准的字节序，称为**网络字节序 (Network Byte Order)**。

**规定**: 网络字节序**总是大端序**。

这意味着，无论一台主机的本地字节序是什么，当它需要将一个整数（如端口号或 IP 地址）发送到网络时，都**必须**先将其转换成大端序。同样，当它从网络接收到一个整数时，也需要将其从大端序转换回自己的主机字节序。

#### **转换函数**

系统提供了一组标准的函数（通常是宏）来在这两种字节序之间进行转换。

```c
#include <arpa/inet.h>

uint32_t htonl(uint32_t hostlong); // Host to Network Long (32-bit)
uint16_t htons(uint16_t hostshort); // Host to Network Short (16-bit)
uint32_t ntohl(uint32_t netlong);   // Network to Host Long (32-bit)
uint16_t ntohs(uint16_t netshort);  // Network to Host Short (16-bit)
```

  * **h**: 代表 host (主机)
  * **n**: 代表 network (网络)
  * **s**: 代表 short (16位，用于端口号)
  * **l**: 代表 long (32位，用于 IPv4 地址)

#### **何时需要转换？(重要)**

1.  **需要转换时**:
    当你在程序中直接使用一个整数值来表示端口号或 IP 地址时，这个值是以**主机字节序**存在的，**必须**使用转换函数。

      * 硬编码的端口号: `addr.sin_port = htons(8080);`
      * 从命令行或配置文件读取的端口号: `addr.sin_port = htons(atoi(port_str));`
      * 使用 `INADDR_ANY` 等常量: `addr.sin_addr.s_addr = htonl(INADDR_ANY);`

2.  **不需要转换时**:
    当使用 `getaddrinfo()`、`gethostbyname()` 等地址解析函数时，这些函数返回的地址结构中的 IP 地址和端口号字段**已经**是网络字节序了，可以直接使用，**无需再次转换**。

> **可移植性**:
> 程序员**应该总是使用**这些转换函数。在字节序与网络字节序相同的主机（大端序）上，这些函数通常被实现为空操作的宏，不会带来任何性能开销。而在字节序不同的主机（小端序）上，它们能确保数据被正确转换，从而保证了程序的可移植性。