### **59.10 独立于协议的主机和服务转换**

`getaddrinfo()` 函数将主机名和服务名转换成 IP 地址和端口号。它是对过时的 `gethostbyname()` 和 `getservbyname()` 函数的现代、可重入的替代品，其最大优势是能够透明地处理 IPv4 和 IPv6，从而帮助编写独立于 IP 协议版本的程序。

`getnameinfo()` 函数执行逆向转换，即将一个 socket 地址结构转换成对应的主机名和服务名。

-----

#### **59.10.1 getaddrinfo()函数**

### `getaddrinfo()` 函数核心概要

`getaddrinfo()` 是现代网络编程中用于**替代 `gethostbyname()` 和 `getservbyname()`** 的核心函数。它的主要任务是：将一个人类可读的**主机名**（如 "[www.google.com](https://www.google.com)"）和**服务名**（如 "http"）转换成一个或多个操作系统可以直接使用的**套接字地址结构（`sockaddr`）**。

这个函数最大的优点是**协议无关性**，能够无缝地处理 IPv4 和 IPv6，让你的代码更具健壮性和未来适应性。

#### 函数原型与参数解析

```c
#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>

int getaddrinfo(const char *host, const char *service,
                const struct addrinfo *hints,
                struct addrinfo **result);
```

  * **`host`**: 一个字符串，可以是：

      * 主机名 (e.g., `"www.example.com"`)
      * IPv4 点分十进制地址 (e.g., `"192.168.1.1"`)
      * IPv6 十六进制地址 (e.g., `"2001:db8::1234"`)
      * `NULL` (通常与 `AI_PASSIVE` 标志配合用于服务器)

  * **`service`**: 一个字符串，可以是：

      * 服务名 (e.g., `"http"`, `"ftp"`)
      * 十进制端口号 (e.g., `"80"`, `"21"`)
      * `NULL`

  * **`hints`**: 一个指向 `addrinfo` 结构的指针，用于**过滤和指定**你期望返回的结果类型。你可以把它看作一个“筛选条件”。如果设为 `NULL`，系统会使用默认值。

  * **`result`**: 一个**二级指针**。如果函数调用成功，`*result` 将指向一个动态分配的 `addrinfo` 结构**链表**的头部。这个链表包含了所有符合条件的地址信息。

  * **返回值**:

      * `0`: 成功。
      * 非零值: 失败（可以通过 `gai_strerror()` 函数将错误码转换为可读的错误信息）。

-----

### `hints` 参数：指定你的需求

`hints` 结构是你与 `getaddrinfo()` 沟通意图的关键。通过设置它的字段，你可以精确控制返回结果的类型。

| `hints` 字段        | 说明          | 常用设置                                                                                                       |      |
| :---------------- | :---------- | :--------------------------------------------------------------------------------------------------------- | ---- |
| **`ai_family`**   | 指定地址族（协议族）。 | **`AF_UNSPEC`**: IPv4 或 IPv6 都可以，实现协议无关的关键。<br>**`AF_INET`**: 只返回 IPv4 地址。<br>**`AF_INET6`**: 只返回 IPv6 地址。 |      |
| **`ai_socktype`** | 指定套接字类型。    | **`SOCK_STREAM`**: 用于 TCP。<br>**`SOCK_DGRAM`**: 用于 UDP。<br>**`0`**: 任意类型都可以。                               |      |
| **`ai_protocol`** | 指定协议。       | 通常设为 **`0`**，表示任意协议。                                                                                       |      |
| **`ai_flags`**    | 一组用 `       | ` (OR) 连接的位掩码标志，用于改变函数行为。                                                                                  | 见下表。 |

#### `hints.ai_flags` 核心标志解析

这些标志是 `getaddrinfo()` 强大功能的体现：

| 标志                   | 作用和目的                                                                                                                                       | 典型应用场景                                                    |
| :------------------- | :------------------------------------------------------------------------------------------------------------------------------------------ | :-------------------------------------------------------- |
| **`AI_PASSIVE`**     | **（服务器专用）** 用于被动打开（监听）。如果设置此标志且 `host` 为 `NULL`，返回的地址结构中 IP 地址部分将被设为**通配地址** (`0.0.0.0` for IPv4, `::` for IPv6)，适用于 `bind()` 和 `listen()`。 | 编写一个需要在本机所有网络接口上接受连接的服务器程序。                               |
| **`AI_NUMERICHOST`** | 强制将 `host` 参数作为数字 IP 地址字符串进行解析，**禁止任何 DNS 域名解析**。                                                                                           | 当你确定 `host` 已经是 IP 地址时使用，可以避免耗时的 DNS 查询，提升性能。             |
| **`AI_NUMERICSERV`** | 强制将 `service` 参数作为数字端口号字符串进行解析，**禁止服务名解析**。                                                                                                 | 当你确定 `service` 已经是端口号时使用，可以避免查询 `/etc/services` 等文件，提升性能。 |
| **`AI_CANONNAME`**   | 请求返回主机的**规范名称 (Canonical Name)**。该名称会存储在返回链表的第一个节点的 `ai_canonname` 字段中。                                                                     | 需要获取主机官方全名（FQDN）的场景。                                      |
| **`AI_ADDRCONFIG`**  | 仅当本地系统配置了相应协议的地址时，才返回该协议的地址。                                                                                                                | 在一个只有 IPv4 的机器上，避免 `getaddrinfo()` 返回一个你根本无法使用的 IPv6 地址。  |
| **`AI_V4MAPPED`**    | （与 `ai_family = AF_INET6` 配合）如果没有找到 IPv6 地址，则返回 IPv4 映射的 IPv6 地址。                                                                           | 用于 IPv6 过渡技术，让一个只支持 IPv6 的套接字也能处理 IPv4 的通信。               |

-----

### `result` 结果：可直接使用的地址信息链表

`getaddrinfo()` 成功后，`result` 指向一个 `addrinfo` 结构链表。你需要遍历这个链表，尝试使用其中的每一个地址，直到成功为止。

`addrinfo` 结构中的关键字段：

| `result` 字段        | 说明                                          | 后续如何使用                             |
| :----------------- | :------------------------------------------ | :--------------------------------- |
| **`ai_family`**    | 地址族 (`AF_INET` or `AF_INET6`)               | 直接作为 `socket()` 的第一个参数             |
| **`ai_socktype`**  | 套接字类型 (`SOCK_STREAM` or `SOCK_DGRAM`)       | 直接作为 `socket()` 的第二个参数             |
| **`ai_protocol`**  | 协议 (通常是 `0`)                                | 直接作为 `socket()` 的第三个参数             |
| **`ai_addr`**      | 指向一个实际的 `sockaddr` 结构 (e.g., `sockaddr_in`) | 直接作为 `bind()` 或 `connect()` 的第二个参数 |
| **`ai_addrlen`**   | `ai_addr` 指向的结构的大小                          | 直接作为 `bind()` 或 `connect()` 的第三个参数 |
| **`ai_next`**      | 指向链表中的下一个 `addrinfo` 结构                     | 用于 `for` 循环遍历整个结果列表                |
| **`ai_canonname`** | 指向主机的规范名称字符串（仅当 `AI_CANONNAME` 标志被设置时有效）    | -                                  |

**重要提示**：这个链表是动态分配的，使用完毕后**必须调用 `freeaddrinfo()` 来释放内存**，否则会造成内存泄漏。

```c
// 使用完毕后释放链表
freeaddrinfo(result);
```

**`getaddrinfo()` 返回结果示意图 (对应原文图 59-3)**

![[Pasted image 20250918163128.png]]


#### **59.10.2 释放 addrinfo 列表：freeaddrinfo()**

`getaddrinfo()` 函数会动态地为其返回的 `addrinfo` 结构链表分配内存。因此，调用者**必须**在不再需要这些结构时，调用 `freeaddrinfo()` 来释放它们，以避免内存泄漏。

```c
#include <netdb.h>

void freeaddrinfo(struct addrinfo *res);
```

`freeaddrinfo()` 函数会遍历 `res` 指向的整个链表，并释放所有相关的内存。

**使用模式**:

```c
struct addrinfo *result;
int s;

// 1. 调用 getaddrinfo() 获取链表
s = getaddrinfo(host, service, &hints, &result);
if (s != 0) { /* handle error */ }

// 2. 遍历和使用链表中的结果
// for (rp = result; rp != NULL; rp = rp->ai_next) {
//     ... do something with rp->ai_addr ...
// }

// 3. 使用完毕后，必须释放整个链表
freeaddrinfo(result);
```


#### **59.10.3 错误诊断：gai\_strerror()**

与许多传统的网络函数不同，`getaddrinfo()` 在发生错误时**不会**设置全局变量 `errno`。相反，它会直接**返回**一个非零的错误码。

`gai_strerror()` 函数用于将这些 `getaddrinfo()` 特有的错误码转换成人类可读的错误信息字符串。

```c
#include <netdb.h>

const char *gai_strerror(int errcode);
```

**错误处理模式**:

```c
int s = getaddrinfo(host, service, &hints, &result);
if (s != 0) {
    fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(s));
    exit(EXIT_FAILURE);
}
```

**表 59-1：`getaddrinfo()` 和 `getnameinfo()` 返回的错误码**

| 错误常量             | 描述                                   |
| :--------------- | :----------------------------------- |
| `EAI_ADDRFAMILY` | `host` 不存在 `hints.ai_family` 中指定的地址  |
| `EAI_AGAIN`      | 名字解析过程中发生临时性错误（稍后重试可能成功）             |
| `EAI_BADFLAGS`   | 在 `hints.ai_flags` 中指定了一个无效的标记       |
| `EAI_FAIL`       | 访问名字服务器时发生了无法恢复的故障                   |
| `EAI_FAMILY`     | 不支持 `hints.ai_family` 中指定的地址族        |
| `EAI_MEMORY`     | 内存分配失败                               |
| `EAI_NODATA`     | `host` 存在，但没有与其关联的地址                 |
| `EAI_NONAME`     | 未知的 `host` 或 `service`               |
| `EAI_OVERFLOW`   | 参数缓冲区溢出 (用于 `getnameinfo()`)         |
| `EAI_SERVICE`    | `hints.ai_socktype` 不支持指定的 `service` |
| `EAI_SOCKTYPE`   | 不支持指定的 `hints.ai_socktype`           |
| `EAI_SYSTEM`     | 发生了其他系统错误，应检查 `errno` 的值             |

#### **59.10.4 getnameinfo()函数**


### `getnameinfo()` 函数核心概要

`getnameinfo()` 的核心功能是将一个二进制的**套接字地址结构 (`sockaddr`)** 转换回人类可读的**主机名**和**服务名**字符串。例如，它可以将一个包含 IP 地址 `127.0.0.1` 和端口 `80` 的 `sockaddr_in` 结构，转换为 `"localhost"` 和 `"http"` 这两个字符串。

它是 `getaddrinfo()` 的逆函数，在服务器接收到客户端连接后，常用于记录日志或显示客户端信息。

#### 函数原型与参数解析

```c
#include <sys/socket.h>
#include <netdb.h>

int getnameinfo(const struct sockaddr *addr, socklen_t addrlen,
                char *host, socklen_t hostlen,
                char *service, socklen_t servlen,
                int flags);
```

  * **`addr` & `addrlen`**:

      * 这是**输入参数**，指向需要被转换的套接字地址结构及其长度。
      * 这些值通常来自 `accept()`、`recvfrom()`、`getsockname()` 或 `getpeername()` 等函数的返回结果。

  * **`host` & `hostlen`**:

      * 这是**输出参数**，`host` 指向一个由调用者预先分配好的缓冲区，用于存放解析出的主机名。`hostlen` 是这个缓冲区的大小。
      * **安全实践**：为了防止缓冲区溢出，`hostlen` 应该使用系统定义的常量 **`NI_MAXHOST`** (值为 1025)。

  * **`service` & `servlen`**:

      * 这也是**输出参数**，`service` 指向一个缓冲区，用于存放解析出的服务名。`servlen` 是其大小。
      * **安全实践**：`servlen` 应该使用常量 **`NI_MAXSERV`** (值为 32)。

  * **`flags`**:

      * 一个位掩码，通过 `|` (OR) 组合多个标志，用于控制函数的具体行为。

  * **返回值**:

      * `0`: 成功。
      * 非零值: 失败（错误码，可以通过 `gai_strerror()` 转换）。

**注意**：你可以将 `host` 或 `service` 设为 `NULL` (对应的长度设为0)，来告诉函数你不需要解析主机名或服务名。但两者不能同时为 `NULL`。

-----

### `flags` 参数：精确控制解析行为

`flags` 参数是 `getnameinfo()` 的精髓所在，它允许你根据不同需求调整解析行为。

| 标志                   | 作用和目的                 | 详细说明                                                                                      |
| :------------------- | :-------------------- | :---------------------------------------------------------------------------------------- |
| **`NI_NUMERICHOST`** | **（性能优化）** 禁止主机名解析。   | 强制函数在 `host` 缓冲区中返回**数字形式的 IP 地址字符串**，而不是进行可能耗时的反向 DNS 查询。**在编写服务器日志时强烈推荐使用**。            |
| **`NI_NUMERICSERV`** | **（性能优化）** 禁止服务名解析。   | 强制函数在 `service` 缓冲区中返回**十进制的端口号字符串**，而不是去查找 `/etc/services` 文件。对于临时端口或非标准端口，这是一个高效的选择。    |
| **`NI_NAMEREQD`**    | **（严格模式）** 要求必须解析出名字。 | 如果无法通过 DNS 解析出主机名，函数将返回一个错误（`EAI_NONAME`），而不是返回数字 IP 地址。用于必须要有主机名的场景。                     |
| **`NI_NOFQDN`**      | **（简化输出）** 不返回完全限定域名。 | 如果主机在局域网内，只返回主机名部分（如 "my-computer"），而不是全名（如 "my-computer.localdomain"）。                   |
| **`NI_DGRAM`**       | 用于区分 UDP 服务。          | 默认情况下，`getnameinfo` 假定是流服务 (TCP)。如果一个端口同时用于 TCP 和 UDP 但服务名不同，此标志会强制查找 UDP 对应的服务名。这种情况很少见。 |

-----

### 核心要点总结

1.  **功能**：`sockaddr` -\> 主机名/服务名字符串，是 `getaddrinfo()` 的逆操作。
2.  **来源**：其输入 `sockaddr` 通常来自 `accept()` (获取客户端地址) 或 `getsockname()` (获取本地绑定地址) 等函数。
3.  **安全**：**必须**使用 `NI_MAXHOST` 和 `NI_MAXSERV` 来定义接收结果的缓冲区大小，这是防止缓冲区溢出漏洞的关键。
4.  **性能**：在不需要人类可读名称的场景（如服务器后台日志），应始终使用 `NI_NUMERICHOST` 和 `NI_NUMERICSERV` 标志，以避免不必要的、可能很慢的 DNS 和文件查找操作，从而提升程序性能和稳定性。
5.  **灵活性**：通过组合不同的 `flags`，可以精确控制函数的输出，满足从用户界面显示到后台日志记录等多种不同需求。