### **45.3 关联数据结构和对象权限**

内核为 System V IPC 对象的每个实例都维护着一个关联数据结构。这个数据结构的形式因 IPC 机制的不同而不同（`msqid_ds`, `semid_ds`, `shmid_ds`）。

  * **获取**: 程序可以通过 `ctl` 系列系统调用（`msgctl`, `semctl`, `shmctl`）并指定 `IPC_STAT` 操作，来获取这个数据结构的一个副本。
  * **修改**: 可以通过指定 `IPC_SET` 操作来修改这个数据结构中的部分数据。

#### **`ipc_perm` 结构**

所有三种 IPC 机制的关联数据结构都包含一个名为 `ipc_perm` 的子结构，它保存了用于确定对象权限的信息。

```c
struct ipc_perm {
    uid_t          cuid;   /* Creator user ID */
    gid_t          cgid;   /* Creator group ID */
    uid_t          uid;    /* Owner user ID */
    gid_t          gid;    /* Owner group ID */
    unsigned short mode;   /* Read/write permissions */
    // ... other fields
};
```

  * **`cuid`, `cgid`**: 创建该对象的进程的有效 UID 和 GID，这两个字段是**不可变**的。
  * **`uid`, `gid`**: 对象当前的所有者 UID 和 GID。这两个字段可以**通过 `IPC_SET` 操作进行修改**。
  * **`mode`**: 对象的权限掩码（低 9 位），在创建时由 `get` 调用指定，后续可通过 `IPC_SET` 修改。

下面的代码演示了如何修改一个共享内存段的所有者 `uid` 字段：

```c
struct shmid_ds ds;

shmctl(shmid, IPC_STAT, &ds); // 获取当前数据结构
ds.shm_perm.uid = new_uid;   // 修改 uid 字段
shmctl(shmid, IPC_SET, &ds);  // 设置回内核
```

#### **权限模型与文件模型的区别**

  * IPC 对象只有**读**和**写**权限有意义（对于信号量，写权限被称为\*\*修改(alter)\*\*权限），执行权限没有意义。
  * 权限检测会根据进程的**有效用户 ID (effective UID)** 和**有效组 ID (effective GID)** 来进行。

#### **权限检查算法**

内核按以下顺序检查进程对 IPC 对象的权限：

1.  如果进程是特权进程（拥有 `CAP_IPC_OWNER` 能力），则授予所有权限。
2.  如果进程的有效 UID 与 IPC 对象的**所有者 `uid`** 或**创建者 `cuid`** 匹配，则应用对象的**属主 (owner)** 权限。检查到此为止。
3.  如果进程的有效 GID 或任一辅助组 ID 与 IPC 对象的**所有者 `gid`** 或**创建者 `cgid`** 匹配，则应用对象的**属组 (group)** 权限。检查到此为止。
4.  否则，应用对象的**其他用户 (other)** 权限。

-----

#### **各种操作所需的权限**

  * **获取对象标识符 (`get` 调用)**:

      * `get` 调用会进行初次权限检测。如果在 `flags` 参数中请求的权限（如 `0666`）超出了既有对象的权限，那么 `get` 调用会失败并返回 `EACCES` 错误。
      * **技巧**: 一个进程可以通过在 `get` 调用中将权限 `flags` 指定为 `0` 来绕过这种检测，从而成功获取标识符。真正的权限检查会被推迟到执行具体操作（如 `msgsnd`）时。

  * **读操作**:

      * 从消息队列中读取消息 (`msgrcv`)、获取一个信号量的值、或为读取而附加一个共享内存段 (`shmat`)，需要对象的**读权限**。

  * **写/修改操作**:

      * 向消息队列写入消息 (`msgsnd`)、修改一个信号量的值 (`semop`)、或为写入而附加一个共享内存段 (`shmat`)，需要对象的**写/修改权限**。

  * **控制操作 (`ctl`)**:

      * **`IPC_STAT` (获取信息)**: 需要对象的**读权限**。
      * **`IPC_RMID` (删除对象)** 和 **`IPC_SET` (修改所有权/权限)**: **不检查**读写权限位。相反，调用进程必须满足以下条件之一：
        1.  是特权进程 (`CAP_SYS_ADMIN`)。
        2.  其有效用户 ID 与对象的**所有者 `uid`** 或**创建者 `cuid`** 匹配。




✅ 一句话总结：

读写操作 → 检查 r/w 权限位

管理操作（删除/改权限） → 需要“对象所有者”身份或特权

获取标识符 → 可以用 flags=0 绕过权限检查



# 案例解释

好 👍，我来给你写一个**简单的例子**，展示 `get` 调用里的 **权限检测**和 **flags=0 绕过技巧**。

我们用 **消息队列** (`msgget`) 做演示，信号量/共享内存的逻辑是一样的。

---

### 场景

1. 进程 A 创建一个消息队列，权限设为 **只读 (0400)**。

   * 只有所有者能读，其他进程不能写。
2. 进程 B 想要获取这个队列：

   * 如果用 `0666`（读写），会失败 (`EACCES`)。
   * 如果用 `0`，就能成功拿到 **标识符**，但后续写消息时会再失败。

---

### 示例代码

```c
// msgget_flags_demo.c
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <stdio.h>
#include <errno.h>
#include <string.h>
#include <unistd.h>

int main() {
    key_t key = 1234;

    // 1. 父进程创建一个只读的消息队列（0400）
    int msqid = msgget(key, IPC_CREAT | 0400);
    if (msqid == -1) {
        perror("msgget create");
        return 1;
    }
    printf("Created message queue with id=%d (perm=0400)\n", msqid);

    // 2. fork 一个子进程模拟另一个用户进程
    pid_t pid = fork();
    if (pid == 0) {
        // 子进程：尝试获取这个队列
        printf("\n[Child] Trying msgget(key, 0666)...\n");
        int id_rw = msgget(key, 0666); // 请求读写
        if (id_rw == -1) {
            printf("[Child] msgget(0666) failed: %s\n", strerror(errno));
        } else {
            printf("[Child] msgget(0666) success: id=%d\n", id_rw);
        }

        printf("\n[Child] Trying msgget(key, 0)...\n");
        int id_0 = msgget(key, 0); // 请求 0，绕过权限检查
        if (id_0 == -1) {
            printf("[Child] msgget(0) failed: %s\n", strerror(errno));
        } else {
            printf("[Child] msgget(0) success: id=%d\n", id_0);
        }
        _exit(0);
    }

    wait(NULL);
    // 清理消息队列
    msgctl(msqid, IPC_RMID, NULL);
    return 0;
}
```

---

### 运行结果（假设子进程不是创建者/所有者）

```bash
Created message queue with id=0 (perm=0400)

[Child] Trying msgget(key, 0666)...
[Child] msgget(0666) failed: Permission denied

[Child] Trying msgget(key, 0)...
[Child] msgget(0) success: id=0
```

---

### 解释

* `msgget(key, 0666)` → 失败，因为这个队列的权限是 `0400`（只读），而请求了读写。
* `msgget(key, 0)` → 成功，拿到 **标识符**，但如果之后调用 `msgsnd()` 发送消息，还是会因为 **没有写权限**而失败。

📌 **重点**：

* `get` 里的权限检查只发生一次，且是“创建时权限 VS 请求权限”的比较。
* 传 `0` 可以绕过，先拿到标识符，再在具体操作时按实际权限检查。

---

要不要我帮你把后续 **`msgsnd` 写失败**也补上，让你更直观看到“拿到标识符 ≠ 拥有权限”？
