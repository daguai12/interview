### **45.4 IPC 标识符和客户端/服务器应用程序**

在客户端/服务器应用程序中，服务器通常负责创建 System V IPC 对象（使用 `IPC_CREAT` 标志），而客户端则只是打开这些已存在的对象。

这里存在一个重要的问题：如果服务器进程崩溃后重启，会发生什么？

  * **问题**: 由于 System V IPC 对象的**内核持久性**，由前一个（已崩溃的）服务器实例创建的 IPC 对象可能仍然存在于系统中。这个旧对象可能包含过时的、不完整的状态（例如，消息队列中可能残留着旧的客户端请求）。
  * **后果**: 新启动的服务器进程不了解这些历史信息，如果盲目地重用这个旧的 IPC 对象，将会导致状态混乱和不可预测的行为。

#### **服务器的清理与重建策略**

为解决这个问题，一个健壮的服务器在启动时应该执行清理和重建的逻辑，以确保它总是从一个干净的状态开始。

1.  服务器首先尝试使用 `IPC_CREAT` 和 `IPC_EXCL` 标志来创建一个新的 IPC 对象。`IPC_EXCL` 标志的作用是：如果对象已存在，则调用失败。
2.  如果上一步的 `get` 调用因对象已存在而失败（`errno` 为 `EEXIST`），那么服务器就认为这是一个由旧实例留下的陈旧对象。
3.  服务器接着会使用 `ctl` 系统调用的 `IPC_RMID` 操作来**显式地删除**这个陈旧的对象。
4.  删除成功后，服务器再次执行 `get` 调用（这次可以只用 `IPC_CREAT`），创建一个全新的、干净的 IPC 对象。

**程序清单 45-1** 给出了一个消息队列可能需要执行的清理步骤。

```c
#include <sys/msg.h>
// ...

int msqid;
key_t key;

// ... generate key ...

// 1. 尝试以独占方式创建，测试对象是否已存在
msqid = msgget(key, IPC_CREAT | IPC_EXCL | 0666);

if (msqid == -1) {
    if (errno == EEXIST) { // 如果对象已存在
        // 2. 获取旧对象的 ID
        msqid = msgget(key, 0);
        if (msqid == -1) {
            perror("msgget failed to retrieve old msqid");
            exit(EXIT_FAILURE);
        }
        
        // 3. 删除旧对象
        if (msgctl(msqid, IPC_RMID, NULL) == -1) {
            perror("msgctl IPC_RMID failed");
            exit(EXIT_FAILURE);
        }
        
        // 4. 再次尝试创建新对象
        printf("Removed old message queue (ID=%d), creating new one.\n", msqid);
        msqid = msgget(key, IPC_CREAT | IPC_EXCL | 0666);
        if (msqid == -1) {
            perror("msgget failed after removing old queue");
            exit(EXIT_FAILURE);
        }
    } else { // 其他错误
        perror("msgget initial create failed");
        exit(EXIT_FAILURE);
    }
}
```

#### **客户端如何感知服务器重启**

即使服务器重建了 IPC 对象，如果新对象和旧对象使用了相同的 `key`，它们可能会得到相同的**标识符**。这样客户端就无法知道服务器已经重启，IPC 对象的状态也已经被重置了。

为了解决这个问题，内核采用了一个算法，**通常能够确保在创建新 IPC 对象时，对象会得到一个与之前被删除的同 `key` 对象不同的标识符**。

  * **效果**: 所有与旧服务器连接的客户端在继续使用**旧的标识符**时，会从相关的 IPC 系统调用中收到一个错误。这个错误就是通知客户端“服务器已重启”的信号，客户端可以据此进行清理和重新连接。

##### **共享内存的特殊情况**

上述清理策略对**共享内存**不完全适用，因为对共享内存的 `IPC_RMID` 操作是**延迟的**（只有当所有进程都与之分离后才会被真正删除）。

但在实际应用中，共享内存通常与 **System V 信号量**组合使用。信号量是**立即被删除**的。因此，当服务器重启并删除关联的信号量对象时，旧的客户端在下一次尝试操作信号量时就会收到错误，从而得知服务器已经重启。