### **45.1 概述**

System V IPC 提供了三种进程间通信机制：消息队列、信号量和共享内存。下表对使用这些对象所需用到的头文件和核心系统调用进行了总结。

**表 45-1：System V IPC 对象编程接口总结**

| 接口          | 消息队列 (Message Queues)   | 信号量 (Semaphores) | 共享内存 (Shared Memory)   |
| :---------- | :---------------------- | :--------------- | :--------------------- |
| **头文件**     | `<sys/msg.h>`           | `<sys/sem.h>`    | `<sys/shm.h>`          |
| **关联数据结构**  | `msqid_ds`              | `semid_ds`       | `shmid_ds`             |
| **创建/打开对象** | `msgget()`              | `semget()`       | `shmget()` + `shmat()` |
| **关闭对象**    | (无)                     | (无)              | `shmdt()`              |
| **控制操作**    | `msgctl()`              | `semctl()`       | `shmctl()`             |
| **执行 IPC**  | `msgsnd()` / `msgrcv()` | `semop()`        | 访问共享区域中的内存             |

> **`ipc(2)` 系统调用**: 在大多数 Linux 硬件架构上，上表中列出的所有函数实际上都是 C 库函数，它们都是对一个名为 `ipc()` 的底层系统调用的封装。

-----

#### **创建和打开一个 System V IPC 对象**

每种 System V IPC 机制都有一个相关的 `get` 系统调用（`msgget()`, `semget()` 或 `shmget()`），其作用与文件操作中的 `open()` 系统调用类似。给定一个整数 **key**（类似于文件名），`get` 调用会完成以下操作之一：

  * 创建一个与 `key` 关联的新 IPC 对象，并返回一个唯一的**标识符**。
  * 返回一个已存在的、与 `key` 关联的 IPC 对象的**标识符**。

**Key 与 Identifier 的区别**:

  * **Key (键)**: 是一个**系统范围**的、用于**命名** IPC 对象的整数。所有希望访问同一个对象的进程都需要使用相同的 key。
  * **Identifier (标识符)**: 是 `get` 调用返回的、用于**操作** IPC 对象的整数，类似于文件描述符。

一个重要的语义差别是：文件描述符是**进程级**的属性，而 IPC 标识符是对象本身的属性，对**系统全局可见**。所有访问同一对象的进程都使用相同的标识符。

**创建示例**:
下面的例子展示了如何创建一个 System V 消息队列，并设置权限为只有所有者可读写。

```c
key_t key;
int msqid;
...
key = ...;
msqid = msgget(key, IPC_CREAT | 0600);
```

  * `IPC_CREAT`: 类似于 `open()` 的 `O_CREAT` 标志，如果与 `key` 对应的对象不存在，则创建它。
  * `IPC_EXCL`: 与 `IPC_CREAT` 结合使用，类似于 `O_EXCL`。如果对象已存在，则调用失败并返回 `EEXIST` 错误，这可以确保调用者是创建该对象的进程。
  * **注意**: 进程的 `umask` 对新创建的 IPC 对象的权限**不适用**。

-----

#### **IPC 对象删除和对象持久性**

各种 System V IPC 机制的 `ctl` 系统调用（`msgctl()`, `semctl()`, `shmctl()`）可以对对象执行一组控制操作，其中 `IPC_RMID` 操作用于删除一个对象。

```c
// 删除一个共享内存对象
shmctl(shmid, IPC_RMID, NULL);
```

**删除语义**:

  * **消息队列和信号量**: 删除是**立即生效**的。对象及其包含的所有信息都会被销毁，**不管是否有其他进程仍然在使用该对象**。
  * **共享内存**: 删除操作是**延迟的**。对象被标记为“待删除”，但只有当所有使用该内存段的进程都与之**分离 (detach)** 之后，该共享内存段才会被真正删除。

**内核持久性 (Kernel Persistence)**:

  * **属性**: System V IPC 对象具备**内核持久性**。一旦被创建，一个对象就一直存在，直到它被显式地删除或系统被关闭。
  * **优点**: 一个进程可以创建一个对象、修改其状态、然后退出，后续启动的其他进程仍然可以访问这个对象和它的状态。
  * **缺点**:
    1.  **资源泄露**: 如果应用程序没有删除不再使用的对象，这些对象会一直占用系统资源，最终可能导致因达到系统对 IPC 对象的数量限制而发生错误。
    2.  **删除时机难以确定**: 由于对象是无连接的（内核不记录哪个进程打开了对象），对于消息队列和信号量，多进程应用很难确定哪个进程是最后一个使用者，从而难以决定何时可以安全地删除对象。