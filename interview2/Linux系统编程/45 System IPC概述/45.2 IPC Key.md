### **45.2 IPC Key**

System V IPC **key** 是一个 `key_t` 类型的整数值。IPC 的 `get` 系列调用（如 `msgget()`）负责将一个 `key` 转换成一个相应的 IPC **标识符**。

这里的核心问题是：如何产生一个唯一的 `key`，以确保不会与系统中其他应用程序正在使用的 IPC 对象发生冲突？主要有三种解决方案：

1.  **硬编码一个随机值**: 这种方法很简单，但存在风险，可能会无意中选取一个已被其他应用使用的 `key`。
2.  **使用 `IPC_PRIVATE`**: 这种方法可以保证总是创建一个全新的、唯一的 IPC 对象。
3.  **使用 `ftok()` 函数**: 这种方法可以根据一个文件路径和一个项目 ID 生成一个（近乎）唯一的 `key`。

后两种是实际开发中通常采用的技术。

-----

#### **使用 `IPC_PRIVATE` 产生一个唯一的 key**

在创建新 IPC 对象时，可以将 `key` 参数指定为常量 `IPC_PRIVATE`。

```c
// 使用 IPC_PRIVATE 总是会创建一个新的消息队列
msqid = msgget(IPC_PRIVATE, 0600);
```

  * **效果**: 每次调用都会创建一个全新的 IPC 对象，从而保证了唯一性。此时无需指定 `IPC_CREAT` 标志。
  * **用途**:
      * **相关进程**: 对于父子进程，父进程可以在 `fork()` 之前创建 IPC 对象，子进程会继承该对象的**标识符**，从而实现共享。
      * **非相关进程**: 在客户端-服务器模型中，服务器可以用 `IPC_PRIVATE` 创建一个对象，然后必须通过某种其他机制（例如，将返回的**标识符**写入一个众所周知的文件中）来告知客户端如何访问这个对象。

-----

#### **使用 `ftok()` 产生一个唯一的 key**

`ftok()` (file to key) 函数根据一个文件路径和一个项目 ID 来生成一个 `key_t` 值。这使得多个非相关的、但“知晓”同一个文件路径和项目 ID 的进程，可以获取到同一个 `key`，进而访问同一个 IPC 对象。

```c
#include <sys/ipc.h>

key_t ftok(const char *pathname, int proj_id);
```

  * **`pathname`**: 必须引用一个**已存在**的文件。
  * **`proj_id`**: 一个整数（只使用其最低 8 位），用于允许从同一个 `pathname` 生成多个不同的 `key`。

**`ftok()` 的工作原理**:

  * `ftok()` 使用 `pathname` 对应文件的 **i-node 号**和**设备号**，结合 `proj_id`，通过一个确定性的算法来生成 `key`。
  * 因为它依赖于 i-node，所以不同的路径名（硬链接）只要指向同一个文件，用相同的 `proj_id` 调用 `ftok()`，就**必定会返回相同的 `key` 值**。
  * **风险**: 理论上存在极小的可能性，即两个不同文件系统上的不同文件，其 i-node 号的低位和设备号的低位恰好相同，从而导致 `key` 冲突。但在实践中，`ftok()` 已被证明是一项相当可靠的技术。

**`ftok()` 的典型用法**:

```c
key_t key;

// 1. 使用 ftok() 生成一个 key
key = ftok("/tmp/somefile", 1);
if (key == -1) {
    perror("ftok");
    exit(EXIT_FAILURE);
}

// 2. 使用生成的 key 来获取或创建 IPC 对象
msqid = msgget(key, IPC_CREAT | 0666);
if (msqid == -1) {
    perror("msgget");
    exit(EXIT_FAILURE);
}
```