
## 1. 历史背景

* **20 世纪 80 年代末、90 年代初**：各家系统有不同的线程接口（互不兼容）。
* **1995 年**：POSIX.1c 标准对线程 API 进行标准化。
* 后来这个标准被 **SUSv3** 接纳（Single UNIX Specification, Version 3）。

👉 从那时起，POSIX 线程 API（即 Pthreads）成为了跨平台的统一接口。

---

## 2. Pthreads 数据类型

Pthreads API 定义了一系列关键数据类型，用于标识线程、管理同步等。

**表 29-1（常见类型）**：

* `pthread_t` → 线程 ID
* `pthread_mutex_t` → 互斥锁对象
* `pthread_mutexattr_t` → 互斥锁的属性
* `pthread_cond_t` → 条件变量
* `pthread_condattr_t` → 条件变量的属性
* `pthread_key_t` → 线程特有数据的 key（TLS）
* `pthread_once_t` → 一次性初始化的控制上下文（保证某个函数只执行一次）
* `pthread_attr_t` → 线程属性对象

⚠️ **注意点**：

* SUSv3 并没有规定这些类型的实现方式 → 不透明（opaque）类型。
* 程序不能依赖它们的内部结构（不同实现方式可能不同）。
* 不能直接用 `==` 比较这些对象。

---

## 3. 线程与 errno

* **传统 UNIX**：`errno` 是一个全局整型变量。

  * 多线程下会出问题 → 不同线程同时修改/检查 errno 会互相干扰（竞争条件）。
* **POSIX 多线程方案**：

  * 每个线程都有 **独立的 errno**。
  * 在 Linux 中，`errno` 实际上是一个 **宏**，展开成一个函数调用，返回当前线程特有的 errno 左值。
  * 所以依然能写 `errno = value;`，但它修改的是“当前线程自己的 errno”。

⚠️ 历史演变：

* 旧 POSIX.1（K\&R C 风格）：允许 `extern int errno;`
* **POSIX.1c（1995）之后**：**不允许**这种写法。
  → 必须 `#include <errno.h>`，由系统定义线程安全的 errno。

---

## 4. Pthreads 函数返回值

这里和 UNIX 系统调用的习惯 **相反**：

* **传统系统调用**：

  * 返回 `0` 表示成功。
  * 返回 `-1` 表示失败，并设置 `errno`。

* **Pthreads API**：

  * 返回 `0` 表示成功。
  * 返回 **正值** 表示失败。
  * 这个返回值本身就是错误码（和传统 errno 值相同的语义）。

⚠️ 实际编程习惯：

* 因为 errno 在多线程下不是全局的，而是函数调用封装后的变量 → 每次引用都有函数调用开销。
* 所以，**不要**直接写 `errno = pthread_xxx(...)`。
* 本书建议做法：用一个局部变量存返回值，再调用诊断函数（例如书里自定义的 `errExitEN()`）。

例子：

```c
int s;
s = pthread_create(&t1, NULL, threadFunc, &arg);
if (s != 0)
    errExitEN(s, "pthread_create");
```

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h> // 需要包含 string.h 用于 strerror_r
#include <pthread.h>

// 定义一个足够大的缓冲区来存储错误信息
#define BUF_SIZE 256

/**
 * @brief 处理 Pthread 错误码并退出程序
 * * @param en Pthread 函数返回的错误码
 * @param msg 自定义的错误消息前缀
 */
void errExitEN(int en, const char *msg) {
    char buf[BUF_SIZE];

    // strerror_r 是 strerror 的线程安全版本。
    // 它将错误码 'en' 对应的错误信息字符串写入 'buf'。
    // 我们使用 POSIX 版本的 strerror_r，它在成功时返回 0。
    if (strerror_r(en, buf, BUF_SIZE) == 0) {
        // 格式化输出到标准错误流 (stderr)
        fprintf(stderr, "%s: %s\n", msg, buf);
    } else {
        // 如果 strerror_r 本身失败，则打印一个通用消息
        fprintf(stderr, "%s: Unknown error %d\n", msg, en);
    }
    
    // 以失败状态退出程序
    exit(EXIT_FAILURE);
}
```

---

## 5. 编译 Pthreads 程序

在 Linux 上，编译带 Pthreads API 的程序时：

* 需要使用编译选项：`cc -pthread`

作用：

1. 定义 `_REENTRANT` 宏 → 启用某些函数的可重入版本。
2. 自动链接 `libpthread` 库（等价于 `-lpthread`）。

👉 但在不同系统上选项不同：

* Linux / Tru64：`-pthread`
* Solaris / HP-UX：`-mt`

---

✅ **小结**

* POSIX.1c 统一了线程 API（Pthreads），成为跨平台标准。
* Pthreads 定义了一些关键 **数据类型**（线程、互斥锁、条件变量、线程私有数据等），它们是不透明的。
* errno 在多线程环境下是 **每线程独立** 的宏。
* Pthreads 函数返回值规则：**0 成功，正值错误码**（而不是 `-1` + errno）。
* 编译时记得加 `-pthread`。

---

要不要我接下来帮你做一个 **“常见 Pthreads 类型及用途的对照表”**，方便你记忆？
