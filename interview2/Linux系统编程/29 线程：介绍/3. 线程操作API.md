## **29.3 创建线程**

### pthread\_create()

* **作用**：创建新线程。
* **原型**：

  ```c
  int pthread_create(pthread_t *thread, const pthread_attr_t *attr,
                     void *(*start)(void *), void *arg);
  ```
* **执行流程**：

  1. 新线程从 `start(arg)` 开始执行。
  2. 调用 `pthread_create()` 的线程继续执行，不会等待新线程。

### 参数详解

* `start`：新线程的入口函数，原型为 `void* start(void *arg)`.

* `arg`：传给 `start()` 的参数，类型为 `void*`。

  * 一般传递全局变量或堆变量的指针。
  * 需要传多个参数时，通常定义一个结构体，然后传指针。
  * 也可传 `NULL`。
  * 技巧：有时会把整数强转成 `void*` 传递。但要注意：

    * C 标准不保证 `int ↔ void*` 转换合法（实现相关）。
    * 大多数编译器允许，并能正确工作。
    * **危险点**：线程取消返回值是 `PTHREAD_CANCELED`（void\* 型，但实际是某个实现定义的整型值），若 start 返回值和它冲突，会导致 join 误判。

* `thread`：输出参数，`pthread_t` 类型。保存新线程的 ID。

* `attr`：线程属性（栈大小、调度策略等）。常用 `NULL` → 使用默认属性。

### 调度不确定性

* 新线程可能在 `pthread_create()` 返回前就开始运行。
* **因此 thread ID 缓冲区无需预先初始化。**
* 如果新线程想获取自己的 ID，应该调用 `pthread_self()`。
* **注意**：创建线程后，不确定哪个线程会先执行，不能依赖执行顺序。若有强制顺序需求 → 必须用 **同步机制**（第 30 章）。

---
### **29.4 终止线程 (Terminating a Thread)**

线程可以通过以下几种方式终止其运行：

* **从启动函数返回**: 线程的启动函数（start function）正常执行完毕，并执行 `return` 语句返回一个值。
* **调用 `pthread_exit()`**: 线程在执行过程中的任何地方调用 `pthread_exit()` 函数来主动退出。
* **被其他线程取消**: 同一进程中的其他线程调用 `pthread_cancel()` 来请求取消该线程的运行。
* **进程终止**: 进程中的**任意线程**调用了 `exit()` 函数，或者**主线程**从 `main()` 函数返回，这会导致**整个进程以及其中的所有线程**立即终止。

---

#### **深入理解 `pthread_exit()`**

`pthread_exit()` 是一个专门用于终止单个线程的函数。

* **函数原型**: `void pthread_exit(void *retval);`

* **核心功能**:
    * 该函数会立即终止调用它的线程。
    * 它可以通过 `retval` 参数向其他线程传递一个返回值。这个返回值是一个指针 (`void *`)。
    * 其他线程可以通过调用 `pthread_join()` 来等待该线程结束，并获取这个 `retval` 指针。

* **与 `return` 的区别**:
    * 在线程启动函数中 `return retval;` 的效果等同于 `pthread_exit(retval);`。
    * `pthread_exit()` 的优势在于，它可以在线程启动函数所调用的**任何深度的子函数中被调用**，并直接终止整个线程。

* **重要的内存警告**:
    * `pthread_exit()` 的 `retval` 参数（以及线程启动函数的 `return` 值）所指向的**内存绝对不能分配在已终止线程自身的栈上**。
    * **原因**：线程一旦终止，其栈空间会立即失效，可能被系统回收或重用。如果返回一个指向线程栈的指针，那么接收该指针的线程访问它时，会遇到无效的内存（悬挂指针），导致未定义行为。

* **主线程的特殊行为**:
    * 如果**主线程**调用 `pthread_exit()`，那么只有主线程会终止。
    * **整个进程以及进程中的其他线程会继续运行**，直到所有线程都结束。
    * 这与主线程执行 `return` 或调用 `exit()` 的行为截然不同，后两者会导致整个进程被销-毁。这个特性常用于让主线程等待所有工作线程完成后再退出。

---
### **29.5 线程 ID (Thread ID)**

#### 获取和使用线程ID

在同一进程中，每个线程都有一个唯一的标识符，称为线程ID，其类型为 `pthread_t`。

  * **获取方式**:

    1.  **创建时获取**: 调用 `pthread_create()` 创建新线程时，其线程ID会通过参数返回给调用者。
    2.  **自我获取**: 线程可以随时调用 `pthread_self()` 来获取自身的线程ID。

  * **主要用途**:

    1.  **函数参数**: 许多pthreads函数（如 `pthread_join()`, `pthread_detach()`, `pthread_cancel()`）使用线程ID来指定操作的目标线程。
    2.  **数据关联**: 在应用程序中可用于标记数据结构，以识别其所有者或创建者线程。

#### 比较线程ID

  * **正确方式**: **必须使用 `pthread_equal()` 函数**来比较两个线程ID是否相等。
    ```c
    if (pthread_equal(tid1, tid2)) {
        // 两个线程ID相同
    }
    ```
  * **错误方式**: 直接使用 `==` 进行比较是**不可移植的**。
  * **原因**: `pthread_t` 被设计为一种**不透明数据类型** (opaque data type)。在Linux上它可能是一个整数，但在其他UNIX系统上可能是一个结构体或指针。`pthread_equal()` 封装了这种底层差异，保证了代码的可移植性。

#### 线程ID的重要特性和区别

  * **可移植性警告**:

      * 不应假定 `pthread_t` 是一个数字类型并直接用 `%lu` 等格式化占位符打印它。尽管这在Linux上通常可行，但会导致代码在其他系统上无法工作。

  * **唯一性和复用**:

      * POSIX标准仅保证线程ID在**其所属的进程内是唯一的**。
      * 一个线程ID在其对应的线程终止并被回收（例如通过 `pthread_join()`）后，可能会被系统**重新使用** (reused) 分配给新的线程。

  * **POSIX线程ID vs 内核线程ID (重点)**:

      * **POSIX线程ID (`pthread_t`)** 与Linux特有的**内核线程ID**（由 `gettid()` 系统调用返回）是**两个不同的概念**。
      * **POSIX ID**: 由C库中的线程库（如 NPTL）管理，是程序员在调用 `pthread_*` 系列函数时使用的ID。
      * **内核 ID**: 由操作系统内核分配和管理，用于内核内部的调度。
      * 尽管在现代Linux的NPTL实现中，每个POSIX线程都与一个唯一的内核线程一一对应，但应用程序应**始终使用可移植的POSIX线程ID**，避免依赖于Linux特有的 `gettid()`，以保证代码的可移植性。
	  
好的，这是对您提供的关于 "连接（joining）已终止的线程" 这部分内容的整理和总结。

### **29.6 连接（Joining）已终止的线程**

---

#### **核心函数: `pthread_join()`**

* **函数原型**: `int pthread_join(pthread_t thread, void **retval);`

* **核心功能**:
    * 调用 `pthread_join()` 的线程会被**阻塞**，直到由 `thread` 参数指定的线程终止。
    * 如果目标线程在调用 `pthread_join()` 之前**已经终止**，那么 `pthread_join()` 会立即返回，不会阻塞。
    * 这个过程类似于进程中的 `waitpid()` 调用。

* **获取返回值**:
    * 如果 `retval` 参数不是 `NULL`，它会指向一个指针，用于存储被连接线程的返回值（即该线程从启动函数 `return` 或调用 `pthread_exit()` 时传递的值）。

---

#### **为什么要进行连接？**

* **防止僵尸线程 (Zombie Threads)**:
    * 对于一个**非分离 (non-detached)** 的线程，它在终止后其资源（如线程ID和退出状态）不会被立即回收，直到有其他线程对其调用 `pthread_join()`。
    * 如果一个非分离线程终止后**没有被连接**，它就会变成一个**僵尸线程**。
    * 僵尸线程会持续占用系统资源，如果大量累积，最终会导致程序无法创建新的线程。

---

#### **`pthread_join()` 与 `waitpid()` 的显著区别**

尽管功能相似，但两者在设计哲学上有本质不同：

1.  **关系对等 vs. 层次关系**:
    * **线程是对等的 (Peers)**: 进程中的**任何线程**都可以连接**任何其他线程**。没有父子关系限制。
    * **进程是分层的 (Hierarchical)**: 只有**父进程**才能 `wait()` 其直接创建的**子进程**。

2.  **目标特定 vs. 目标任意**:
    * `pthread_join()` **必须**指定一个**明确的线程ID**进行连接。
    * `waitpid()` 可以通过传递 `-1` 来等待**任意一个**子进程。`pthread_join()` 没有这个功能。

3.  **阻塞 vs. 非阻塞**:
    * `pthread_join()` **总是阻塞的**。
    * `waitpid()` 可以通过 `WNOHANG` 选项实现**非阻塞**等待。

#### **设计意图**

`pthread_join()` 的这些限制（特别是必须指定目标ID）是**有意为之**的。它强制程序员只去连接那些他们“知道”并且需要同步的线程，这符合模块化程序设计的理念，避免了意外连接到由第三方库内部创建和管理的线程，从而引发混乱。

---

#### **使用警告**

* 对一个已经被连接过的线程ID再次调用 `pthread_join()` 会导致**不可预知的行为**，因为该线程ID可能已经被系统回收并重新分配给了一个全新的线程。
好的，这是对您提供的关于 "线程的分离" 这部分内容的整理和总结。

---
### **29.7 线程的分离 (Detaching a Thread)**

#### 核心概念

默认情况下，线程被创建为 **可连接的 (joinable)**。这意味着当它终止时，必须有另一个线程调用 `pthread_join()` 来回收其资源并获取其退出状态。否则，该线程将成为 **僵尸线程**，持续占用系统资源。

然而，在某些“发后不理”(fire and forget)的场景下，我们不关心线程的返回值，只希望它在结束后能 **自动清理**。这就是“分离”状态的用途。

#### 核心函数: `pthread_detach()`

* **函数原型**: `int pthread_detach(pthread_t thread);`
* **功能**: 调用此函数可以将一个指定的线程标记为 **分离状态 (detached)**。
* **使用方式**:
    * 一个线程可以被**其他线程**通过传入其线程ID来分离。
    * 线程也可以通过调用 `pthread_detach(pthread_self());` 来 **自我分离**。

#### 分离状态的特性

一旦线程被置为分离状态：

1.  **自动回收**: 当该线程终止时，其所有资源将由系统 **自动回收**，无需其他线程干预，也不会产生僵尸线程。
2.  **不可连接**: **不能再** 对该线程使用 `pthread_join()`。尝试这样做是错误的，也无法获取其退出状态。
3.  **不可逆**: 这是一个 **单向操作**，分离后的线程无法再变回可连接状态。

#### 重要说明

需要强调的是，`pthread_detach()` **只影响线程终止后的资源回收方式**。

它 **不会** 使线程独立于进程的生命周期。如果进程中的任何线程调用 `exit()` 或主线程从 `main()` 返回，那么包括分离线程在内的 **所有线程都会被立即终止**。
好的，这是对您提供的关于 "线程属性" 这部分内容的整理和总结。

---
## **29.8 线程属性 (Thread Attributes)**

#### 核心概念

在调用 `pthread_create()` 创建新线程时，可以通过一个 `pthread_attr_t` 类型的属性对象（`attr` 参数）来定制新线程的各种行为和特性，而不是全部使用默认值。

可配置的属性主要包括：
* **线程栈**: 栈的位置和大小。
* **调度策略**: 线程的调度策略和优先级（类似于进程的实时调度）。
* **分离状态**: 线程是**可连接的 (joinable)** 还是**分离的 (detached)**。

#### 标准使用流程

使用线程属性对象通常遵循一个标准的四步流程：

1.  **初始化 (Initialize)**:
    * 首先，声明一个 `pthread_attr_t` 类型的变量。
    * 然后，使用 `pthread_attr_init()` 函数以系统默认值对其进行初始化。

2.  **设置属性 (Set Attributes)**:
    * 调用一个或多个 `pthread_attr_set*()` 系列函数来修改特定的属性。
    * 例如，文中的示例就使用了 `pthread_attr_setdetachstate()` 来将线程的默认“可连接”状态修改为“分离”状态。

3.  **创建线程 (Create Thread)**:
    * 在调用 `pthread_create()` 时，将修改后的属性对象作为参数传入。
    * 新创建的线程便会拥有这些指定的属性。

4.  **销毁属性对象 (Destroy Attribute Object)**:
    * 一旦 `pthread_create()` 调用完成，该属性对象就不再需要了（它的信息已经被用于创建线程）。
    * 应立即使用 `pthread_attr_destroy()` 将其销-毁，以释放相关资源。
