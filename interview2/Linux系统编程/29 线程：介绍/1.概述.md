## 本章的目标

* 介绍 **POSIX 线程（Pthreads）** 的基本概念与操作。
* 并不会覆盖所有 API，只会重点讲解常用和标准化的部分。
* 后续章节会逐步展开 Pthreads 的各种功能。
* **第 33.5 节** 会讲 Linux 的两大线程实现（LinuxThreads、NPTL）和标准之间的差异。
* 本章的末尾还会讨论：在应用设计时，选择多进程还是多线程更合适。

---

## 29.1 概述

### 线程与进程的关系

* **进程（process）**：传统 UNIX 的执行单位，一个进程就是一份程序的独立运行实例。
* **线程（thread）**：允许一个进程内部同时执行多个任务。

  * 一个进程可以包含多个线程。
  * 这些线程运行同一份程序代码。
  * **共享**同一份全局内存（包括已初始化数据段、未初始化数据段、堆）。
  * **独立**的运行栈（每个线程有自己的调用栈、本地变量）。

👉 可以理解为：**进程是资源容器，线程是执行单位**。
传统的 UNIX 进程（单线程）其实就是多线程进程的特例。

---

### 图 29-1 的说明

* 图中展示了一个含有 4 个线程的进程。
* 线程栈的分布可能与共享库、共享内存区域交错，具体位置由线程创建、库加载、内存映射等顺序决定。
* 不同发行版下线程栈地址也可能不同。
![[Pasted image 20250829093350.png]]

---

### 线程的执行

* 在 **单 CPU** 系统上，线程是并发的（操作系统调度）。
* 在 **多 CPU** 系统上，线程可以真正并行运行。
* 一个线程阻塞（如等待 I/O）时，其他线程仍然可以继续执行。

（→ 这点使得线程特别适合 **I/O 密集型** 程序。）

---

### 与多进程的对比

传统方式：网络服务器在 `accept()` 后调用 `fork()`，生成子进程来处理每个客户端。

* **优点**：逻辑清晰、进程间隔离。
* **缺点**：

  1. **进程间通信麻烦** → 需要 IPC。
  2. **`fork()` 代价高** → 即使有 COW 技术，仍然要复制页表、文件描述符表等，开销不小。

线程方式解决了这些问题：

1. **共享内存** → 信息交换快，只需写入全局变量/堆。
   （缺点是需要小心同步，避免并发修改冲突。）
2. **创建速度快** → `clone()` 系统调用创建线程比 `fork()` 快一个数量级（10 倍+）。

---

### 线程共享的属性

所有线程共享进程级别的全局属性，包括：

* 进程 ID / 父进程 ID
* 进程组 ID、会话 ID
* 控制终端
* 用户 ID / 组 ID
* 打开的文件描述符
* 文件锁
* 信号处理方式
* 文件系统相关信息（umask、cwd、root）
* 定时器、System V 信号量撤销值
* 资源限制、CPU 时间统计、资源消耗统计
* nice 值（优先级调整）

---

### 线程私有的属性

每个线程独有的内容：

* 线程 ID
* 信号掩码
* 线程特有数据（TLS）
* 备用信号栈
* `errno` 变量
* 浮点环境
* 实时调度策略和优先级
* CPU 亲和性（Linux 特有）
* 权限能力（Linux 特有）
* **调用栈、本地变量、函数调用链接信息**

---

### 注意点：线程栈

* 所有线程栈都在同一虚拟地址空间中。
* 理论上可以用指针访问别的线程栈上的数据，但风险很大。

  * 栈帧生命周期有限，函数返回后内存可能被重用。
  * 线程结束后，其栈空间可能被新线程接管。
* 因此，如果错误访问，可能会导致极难捕获的 **bug**。

---

✅ 总结下来，这一节（29.1 概述）主要强调了几点：

1. 线程 = 轻量级执行单元，进程 = 资源容器。
2. 相比多进程，多线程在 **共享数据** 和 **创建速度** 上有明显优势。
3. 线程有共享属性和私有属性，要理解哪些是进程级别共享的，哪些是线程独立的。
4. 编程时要小心 **栈和局部变量** 的生命周期问题，避免悬挂引用。

---

要不要我帮你画一个 **对比表格（多进程 vs 多线程）**，方便记忆共享/私有的属性？
