要理解“即使有 COW 技术，仍然要复制页表、文件描述符表等，开销不小”这句话，需要先明确 **COW 的核心作用**，再拆解 **页表、文件描述符表为何必须复制** 及其 **实际开销来源**，最终建立“COW 优化的局限性”认知。


### 第一步：先搞懂 COW 技术的“初衷”——解决“物理内存复制”的痛点
COW 是 **Copy-On-Write（写时复制）** 的缩写，是操作系统（如 Linux）在 `fork()`（创建子进程）时的核心优化技术，其目标是 **避免“创建子进程时立即复制父进程全部物理内存”的巨大开销**。

在没有 COW 之前，`fork()` 的逻辑是“全量复制”：
- 父进程有 1GB 物理内存，子进程创建时会直接复制这 1GB 内存到新的物理页框；
- 无论子进程后续是否修改这些内存，复制操作都会执行，导致 **内存占用翻倍、创建速度极慢**（比如复制 1GB 内存需要毫秒级时间，远超进程控制块的初始化时间）。

COW 的优化逻辑是“延迟复制”：
1. **创建子进程时，不复制物理内存**：父进程和子进程共享同一份物理内存页；
2. **标记内存页为“只读”+“COW 标记”**：通过页表项的权限位（只读）和标志位（COW）实现；
3. **仅当“父/子进程修改内存页”时，才复制该页**：触发缺页异常后，操作系统为修改方分配新的物理页，复制原页数据，再更新页表映射——**只复制“被修改的页”，未修改的页始终共享**。

简言之，COW 解决的是“物理内存复制”的开销，但 **没有解决“进程独立运行必须的控制结构复制”的开销**——这就是“仍需复制页表、文件描述符表”的核心背景。


### 第二步：为什么必须复制“页表”？——进程地址空间独立的刚需
页表是操作系统实现“虚拟地址到物理地址映射”的核心数据结构，**每个进程必须拥有独立的页表**（因为进程的虚拟地址空间是隔离的：比如父进程的 0x1000 虚拟地址和子进程的 0x1000 虚拟地址，可映射到不同物理地址）。

COW 虽然让父/子进程共享物理内存，但 **页表本身无法共享**，必须复制，原因如下：
- 若共享页表：子进程修改页表项（比如标记某页为“已复制”、或更新映射到新物理页）时，会直接修改父进程的页表，破坏父进程的地址映射，导致进程崩溃；
- 页表需承载 COW 逻辑：复制后的子进程页表，需要将所有页表项的权限设为“只读”并打上“COW 标记”（父进程的页表也需同步修改这些标记）——这一步必须基于独立的页表完成。

#### 复制页表的“实际开销”在哪里？
页表并非单张表，而是 **多级结构**（如 x86-64 的 4 级页表：PML4→PDPT→PD→PT），复制时需要：
1. **遍历多级页表**：从顶级页表（PML4）到末级页表（PT），逐个复制所有页表项（即使物理页共享，页表项的“权限位”“COW 标记”也需单独设置）；
2. **分配新的页表页**：页表本身也需要物理内存存储（比如每个 PT 页可存 512 个页表项，占 4KB 物理内存），若进程虚拟地址空间大（如 1TB），需要分配大量页表页来存储复制后的页表项；
3. **处理大量页表项**：以 4KB 物理页、64 位系统为例，1GB 虚拟地址空间需要 262144 个页表项（1GB / 4KB），复制这些项需要大量 CPU 周期。

比如一个进程有 100GB 虚拟地址空间（即使实际使用的物理内存只有 1GB），其页表可能占用几十 MB 物理内存，复制这些页表的时间和内存开销都非常显著。


### 第三步：为什么必须复制“文件描述符表”？——文件操作隔离的刚需
文件描述符（FD）是进程操作文件的“句柄”，每个进程都有一张 **文件描述符表**（如 Linux 中的 `files_struct` 结构），表中每个条目对应一个“打开的文件”（指向内核的 `file` 结构体，存储文件偏移量、权限等元数据）。

复制文件描述符表的核心原因是 **进程的文件操作必须隔离**：
- 若父/子进程共享同一张文件描述符表：父进程关闭 FD=3，子进程的 FD=3 也会失效；父进程修改 FD=2 的文件偏移量，子进程的偏移量也会同步变化——这不符合“进程独立”的语义；
- 复制的本质是“表独立，文件元数据共享”：复制后的子进程文件描述符表，每个条目都与父进程的条目 **指向同一个内核 `file` 结构体**（保证文件偏移量、打开状态共享），但表本身是独立的——父进程修改自己的表（如关闭 FD），不会影响子进程的表。

#### 复制文件描述符表的“实际开销”在哪里？
1. **表结构复制**：文件描述符表本身是一个动态数组（如 Linux 中的 `fd_array`），若进程打开了大量文件（如 1000 个 FD），需要复制 1000 个表条目，分配新的数组空间；
2. **引用计数更新**：每个内核 `file` 结构体有“引用计数”（`f_count`），复制文件描述符表时，需要将每个 `file` 的引用计数加 1（表示“又多一个进程引用该文件”）——这一步需要原子操作，有 CPU 开销；
3. **关联结构复制**：文件描述符表还关联其他结构（如当前工作目录 `pwd`、根目录 `root` 的 `vfsmount` 结构体），这些结构的引用计数也需要同步更新，进一步增加开销。

比如一个 Web 服务器进程（如 Nginx）打开了 10000 个网络连接（每个连接对应一个 FD），复制其文件描述符表时需要处理 10000 个条目，开销远超“少量 FD 进程”。


### 第四步：总结——COW 优化的“边界”与“未解决的开销”
这句话的核心逻辑是：**COW 只优化了“物理内存复制”这一项最大开销，但进程创建时还有其他“必须复制的控制结构”（页表、文件描述符表等），这些结构的复制开销依然存在，且在特定场景下（大地址空间、多打开文件）非常显著**。

可以用一个对比表更清晰地理解：

| 操作       | 无 COW 时的开销       | 有 COW 时的开销      | 核心差异       |
| -------- | ---------------- | --------------- | ---------- |
| 物理内存复制   | 全量复制（如 1GB 内存）   | 延迟复制（仅修改时复制少量页） | COW 解决了此开销 |
| 页表复制     | 全量复制（多级页表+页表页）   | 全量复制（同左，无优化）    | 必须复制，开销仍在  |
| 文件描述符表复制 | 全量复制（FD 条目+引用计数） | 全量复制（同左，无优化）    | 必须复制，开销仍在  |
| 其他控制结构复制 | PCB、信号掩码等复制      | PCB、信号掩码等复制     | 必须复制，开销仍在  |

简言之：COW 是“减负”，不是“零开销”——它去掉了“物理内存全量复制”这个最重的包袱，但“页表、文件描述符表复制”这些“必要包袱”还在，因此整体开销依然不小。


### 延伸：如何进一步降低这些开销？——Linux 的后续优化
为了缓解页表、文件描述符表复制的开销，操作系统又推出了新的技术，比如：
- **vfork()**：子进程完全共享父进程的地址空间（不复制页表），但父进程会阻塞直到子进程退出或执行 `exec()`——适用于“子进程创建后立即执行新程序”的场景（如 `bash` 执行命令），避免页表复制；
- **clone() 系统调用**：允许进程按需共享资源（如 `CLONE_VM` 共享页表、`CLONE_FILES` 共享文件描述符），灵活控制复制开销（如线程就是通过 `clone()` 共享大部分资源，仅复制少量私有结构）。

这也从侧面印证了：页表、文件描述符表的复制开销确实是一个需要针对性优化的问题。