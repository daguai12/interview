### **61.13 高级功能**

UNIX 和 Internet 域套接字还有许多高级功能，本节对其中一些进行总结。

---
#### **61.13.1 带外数据 (Out-of-Band Data)**
带外数据是**流式套接字**的一种特性，允许发送端将传送的数据标记为**高优先级**。接收端可以被通知有可用的带外数据，而无需先读取字节流中所有在它之前的普通数据。

* **用途**: 这个特性在 `telnet`、`rlogin` 以及 `ftp` 等传统协议中被用于紧急中止一个之前发送的命令。
* **API**:
    * 在 `send()` 和 `recv()` 中指定 `MSG_OOB` 标记来发送和接收。
    * 内核会为套接字的属主生成 `SIGURG` 信号，以通知带外数据的到达。

##### **TCP 的限制与现代建议**
* **限制**: 当在 TCP 套接字上使用时，任意时刻**最多只有 1 字节**的数据可被标记为带外数据。如果在接收端处理完前一个带外数据字节之前，发送端发送了额外的带外数据，那么之前对带外数据的通知就会丢失。
* **原因**: 这是由于套接字 API 的通用带外模型和 TCP 协议自身的“紧急模式”在具体实现上的不匹配造成的。
* **建议**: 现如今**不提倡**使用带外数据，因为它在某些情况下可能是不可靠的。
* **替代方案**: 维护**两个流式套接字**连接。一个用于普通通信，另一个专门用于高优先级通信。应用程序可以使用 I/O 多路复用技术（如 `select()`, `poll()`）来同时监视这两个通道。

> **Linux 支持**: Linux 不支持在 UNIX 域流式套接字上使用带外数据。

---
#### **61.13.2 sendmsg()和 recvmsg()系统调用**

`sendmsg()` 和 `recvmsg()` 是套接字 I/O 系统调用中最为通用的两种。它们是其他所有 I/O 函数（`read`/`write`, `send`/`recv`, `sendto`/`recvfrom`）的超集。

除了具备其他函数的所有功能外，这两个系统调用还有如下独有的高级功能：

1.  **分散-聚合 I/O (Scatter-Gather I/O)**:
    * 类似于 `readv()` 和 `writev()`，这两个函数可以操作一个由多个缓冲区组成的数组。
    * **`sendmsg()`**: 可以将多个分散在不同缓冲区中的数据，“聚合”起来，作为**一个**数据报发送出去。
    * **`recvmsg()`**: 可以将接收到的**一个**数据报，“分散”到多个不同的缓冲区中。

2.  **传送辅助数据 (Ancillary Data)**:
    * 这是它们最强大的功能。除了正常的数据之外，它们还可以在进程间传送特定于域的**辅助数据**（也称为**控制信息**）。
    * 典型的例子包括：通过 UNIX domain socket 在进程间**传递打开的文件描述符**，或**发送进程凭证**（用户ID、组ID等）用于身份验证。

> **Linux 新增调用**:
> Linux 2.6.33 版新增了一个系统调用 `recvmmsg()`。该调用类似于 `recvmsg()`，但允许在**单个系统调用中接收多个数据报**。当应用程序需要处理非常高的网络流量时，这可以显著减小系统调用的开销。


#### **61.13.3 传递文件描述符 (Passing File Descriptors)**
* **功能**: 通过 `sendmsg()` 和 `recvmsg()`，我们可以在**同一台主机**上，通过 **UNIX 域套接字**将一个**打开的文件描述符**从一个进程传递到另一个无关的进程上。
* **机制**: 这种技术传递的不是文件描述符的数字本身，而是一个对内核中“打开文件描述 (open file description)”的引用。接收进程会得到一个**新的**文件描述符数字，但它指向的是与发送方完全相同的内核文件表项。
* **用途**: 一个常见的应用场景是：主服务器进程 `accept()` 一个新的客户端 TCP 连接，然后将返回的已连接套接字的文件描述符，传递给一个子进程池中的某个成员去处理。

#### **61.13.4 接收发送端的凭据 (Receiving Sender Credentials)**
* **功能**: 同样使用 `sendmsg()` 和 `recvmsg()` 的辅助数据功能，可以在 **UNIX 域套接字**上接收发送端进程的凭证。
* **凭证内容**: 这些凭证通常由发送端进程的用户 ID (UID)、组 ID (GID) 以及进程 ID (PID) 组成。
* **用途**: 这使得接收端进程可以在同一台主机上可靠地**验证 (authenticate)** 发送端的身份。
* **可移植性**: 这个特性没有在 SUSv3 中规定，除了 Linux 和一些现代 BSD 系统之外，很少有其他的 UNIX 实现支持它。

#### **61.13.5 顺序数据包套接字 (Sequenced-Packet Sockets)**
顺序数据包套接字 (`SOCK_SEQPACKET`) 结合了流式套接字和数据报套接字的功能，是一种混合型套接字。
* **面向连接 (像流式套接字)**: 使用前需要通过 `connect()` 建立连接，并通过 `accept()` 接受连接。
* **保留消息边界 (像数据报套接字)**: `read()` 调用一次只会返回一条完整的消息。如果消息比提供的缓冲区还要长，那么多余的字节会被丢弃。
* **可靠传输 (像流式套接字)**: 通信是可靠的。消息会以无错误、按顺序、不重复的方式传递。

**在 Linux 上的支持**:
* 从 2.6.4 版内核开始，Linux 在 **UNIX 域套接字**上支持了 `SOCK_SEQPACKET`。
* 在 Internet 域上，TCP 和 UDP 协议都不支持 `SOCK_SEQPACKET`，但 SCTP 协议支持。

#### **61.13.6 SCTP 以及 DCCP 传输层协议**

SCTP 和 DCCP 是两个较新的传输层协议。

* **SCTP (流控制传输协议 - Stream Control Transmission Protocol)**:
    * **特性**: 提供了**可靠的、双向的、面向连接的**传输（像 TCP）。
    * **与 TCP 的关键区别**: SCTP **保留了消息边界**（像 UDP）。
    * **其他功能**: 支持在一条单独的连接上传递多个逻辑上的**数据流 (multi-streaming)**。
    * **Linux 支持**: 自 2.6 内核以来，Linux 也开始支持 SCTP。

* **DCCP (数据报拥塞控制协议 - Datagram Congestion Control Protocol)**:
    * **特性**:
        1.  提供了**拥塞控制**能力（像 TCP），可以防止应用程序因发送过快而使网络过载。
        2.  对于可靠性或按序传递**不做任何保证**（像 UDP）。
    * **用途**: 适用于那些不需要 TCP 的可靠性所带来的重传延时，但又希望避免网络拥塞的应用程序（例如，实时流媒体、在线游戏）。
    * **Linux 支持**: 从 2.6.14 版内核开始，Linux 支持 DCCP。