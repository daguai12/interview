### **61.1 流式套接字上的部分读和部分写**

当在流式套接字（如 TCP socket）上执行 I/O 操作时，`read()` 和 `write()` 系统调用传输的数据可能会比请求的要少。这种现象被称为**部分传输 (partial transfer)**。

#### **部分读 (Partial Reads)**

当 socket 的接收缓冲区中可用的数据字节数，少于 `read()` 调用中请求读取的字节数时，就会出现部分读。在这种情况下，`read()` **不会**阻塞等待更多数据，而是简单地返回当前可用的字节数。

#### **部分写 (Partial Writes)**

当 socket 的发送缓冲区没有足够的空间来一次性容纳所有请求写入的字节时，就可能会出现部分写。这通常发生在以下几种情况：

  * `write()` 调用在传输了部分字节后被**信号处理例程中断**。
  * 套接字工作在**非阻塞模式 (`O_NONBLOCK`)** 下，当前只能传输一部分请求的字节。
  * 在部分请求的字节已经完成传输后，发生了一个**异步错误**（例如，TCP 连接因对端崩溃而中断）。

在上述所有情况中，只要缓冲区空间至少能传输 1 字节数据，`write()` 调用就会成功，并返回实际传输到输出缓冲区中的字节数。

-----

#### **解决方案：`readn()` 和 `writen()`**

如果发生了部分 I/O，应用程序通常需要重新调用系统调用来完成剩余数据的传输。在程序清单 61-1 中，我们提供了两个可以透明地处理这个问题的辅助函数：`readn()` 和 `writen()`。

这两个函数使用循环来反复调用 `read()` 或 `write()`，直到请求的字节数全部传输完毕（或遇到错误/文件结尾）。

**程序清单 61-1：实现 `readn()` 和 `writen()`**

```c
#include <unistd.h>
#include <errno.h>

/*
 * 从文件描述符 fd 中读取 'n' 个字节到 'buf'。
 * 该函数会处理 read() 可能返回的值小于请求字节数的情况（部分读）。
 */
ssize_t readn(int fd, void *buffer, size_t n) {
    ssize_t numRead;
    size_t totRead;
    char *buf;

    buf = buffer;
    totRead = 0;
    while (totRead < n) {
        numRead = read(fd, buf, n - totRead);

        if (numRead == 0)             // 遇到 EOF
            return totRead;           // 返回已读取的字节数

        if (numRead == -1) {
            if (errno == EINTR)       // 被信号中断，继续读取
                continue;
            else
                return -1;            // 发生其他错误
        }

        totRead += numRead;
        buf += numRead;
    }
    return totRead; // 返回成功读取的总字节数
}


/*
 * 将 'n' 个字节从 'buf' 写入到文件描述符 fd。
 * 该函数会处理 write() 可能写入的字节数小于请求字节数的情况（部分写）。
 */
ssize_t writen(int fd, const void *buffer, size_t n) {
    ssize_t numWritten;
    size_t totWritten;
    const char *buf;

    buf = buffer;
    totWritten = 0;
    while (totWritten < n) {
        numWritten = write(fd, buf, n - totWritten);

        if (numWritten <= 0) {
            if (numWritten == -1 && errno == EINTR) // 被信号中断，继续写入
                continue;
            else
                return -1;                      // 发生其他错误
        }
        
        totWritten += numWritten;
        buf += numWritten;
    }
    return totWritten; // 返回成功写入的总字节数
}
```