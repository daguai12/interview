### **61.10 SO\_REUSEADDR 套接字选项**

`SO_REUSEADDR` 套接字选项用途广泛，但其最常见的用途是：**避免当 TCP 服务器重启时，因端口仍被占用而导致 `bind()` 失败的问题**。

#### **问题：`EADDRINUSE` (Address already in use)**

一个快速重启的 TCP 服务器在尝试 `bind()` 到它之前使用的端口时，常常会失败，并收到 `EADDRINUSE`（地址已使用）错误。这个问题通常在以下两种情况中出现：

1.  **`TIME_WAIT` 状态**:

      * 服务器上一个实例与客户端的连接正常关闭，并且是服务器端主动关闭的。这会导致该连接的套接字进入 `TIME_WAIT` 状态，并持续一段时间（通常是几分钟）。
      * 在此期间，尽管这个 `TIME_WAIT` 状态的连接无法再接受新连接，但默认情况下，操作系统会阻止任何**新的**监听套接字绑定到这个已被占用的端口上。

2.  **残留的子进程**:

      * 一个并发服务器 `fork()` 出子进程来处理客户端连接。
      * 随后，主服务器进程终止，但某个子进程可能仍在服务一个长时间连接的客户端。
      * 这个子进程仍然占用了服务器的知名端口号，导致新启动的服务器实例无法 `bind()` 到该端口。

#### **问题根源：TCP 连接的标识**

一个已连接的 TCP 套接字是由一个 **4 元组 (4-tuple)** 来唯一标识的：
`{ 本地 IP, 本地端口, 远端 IP, 远端端口 }`

TCP 规范本身只要求每个 4 元组是唯一的。然而，大多数操作系统（包括 Linux）都强制施加了一个更严格的约束：**如果主机上有任何 TCP 连接（包括处于 `TIME_WAIT` 状态的）正在使用某个本地端口，则不允许新的监听套接字再绑定到该端口上**。

#### **解决方案：启用 `SO_REUSEADDR`**

启用 `SO_REUSEADDR` 套接字选项可以放宽这个严格的约束，使其行为更接近 TCP 规范的原始要求。

  * **作用**: 当在监听套接字上设置了 `SO_REUSEADDR` 选项后，即使有其他连接正处于 `TIME_WAIT` 状态并占用了同一个端口，`bind()` 调用也**仍然可以成功**。
  * **建议**: **大多数 TCP 服务器都应该在调用 `bind()` 之前开启这个选项**，以确保服务器在崩溃或重启后能够立即成功绑定到其知名端口，而无需等待 `TIME_WAIT` 状态结束。

-----

#### **程序示例**

程序清单 61-4 展示了如何在套接字上设定 `SO_REUSEADDR` 选项。这个调用应该在 `socket()` 之后、`bind()` 之前执行。

**程序清单 61-4：设定 `SO_REUSEADDR` 套接字选项**

```c
#include <sys/socket.h>

int listenFd;
int optval;

// ... a call to socket() to create listenFd ...

// 启用 SO_REUSEADDR 选项
optval = 1;
if (setsockopt(listenFd, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)) == -1) {
    perror("setsockopt");
    // handle error
}

// ... now we can call bind() on listenFd ...
```