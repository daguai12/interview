好的，这是根据您提供的文本内容，保留原始结构和标题整理的结果，并附上相应的代码清单。

### **61.2 shutdown()系统调用**

在套接字上调用 `close()` 会将双向通信通道的**两端都关闭**。有时候，只关闭连接的一端也是有用的，`shutdown()` 系统调用提供了这种功能。

```c
#include <sys/socket.h>

int shutdown(int sockfd, int how);
```

`shutdown()` 可以根据参数 `how` 的值选择关闭套接字通道的一端或两端。

#### **`how` 参数**

`how` 的值可以指定为如下几种：

  * **`SHUT_RD`**:
    关闭连接的**读端**。此后，对该套接字的读操作将返回文件结尾 (EOF)。数据仍然可以写入到套接字上。

  * **`SHUT_WR`**:
    关闭连接的**写端**。这通常被称为\*\*“半关闭 (half-close)”\*\*。

      * 本地进程后续对套接字的写操作将产生 `SIGPIPE` 信号以及 `EPIPE` 错误。
      * 对端应用程序在读取完所有剩余数据后，将会检测到文件结尾。
      * 本地进程仍然可以在套接字上**读取**由对端写入的数据。
      * 这是一个非常有用的操作，它允许我们通过发送文件结尾 (EOF) 信号来通知对端应用程序“我已经发送完所有数据了”，但同时仍然能接收对端发回的响应。

  * **`SHUT_RDWR`**:
    将连接的读端和写端都关闭。这等同于先执行 `SHUT_RD`，再执行 `SHUT_WR` 操作。

-----

#### **`shutdown()` 与 `close()` 的关键区别**

`shutdown()` 与 `close()` 之间的一个重要区别是：**`shutdown()` 会立即关闭套接字通道，无论该套接字上是否还关联有其他的文件描述符**。而 `close()` 只是递减文件描述符的引用计数，只有当引用计数为 0 时才会真正关闭连接。

  * **示例 1: `dup()`**
    ```c
    fd2 = dup(sockfd);
    close(sockfd); // 连接依然保持打开，可以通过 fd2 进行 I/O
    ```
    ```c
    fd2 = dup(sockfd);
    shutdown(sockfd, SHUT_RDWR); // 连接立即关闭，fd2 也无法再进行 I/O
    ```
  * **示例 2: `fork()`**
    如果父进程 `fork()` 后，其中一个进程在描述符副本上执行 `shutdown()`，那么另一个进程也无法再在该文件描述符上执行 I/O。

另外需要注意的是，`shutdown()` **并不会关闭文件描述符本身**。即使 `how` 指定为 `SHUT_RDWR`，仍然必须另外调用 `close()` 来释放文件描述符资源。

-----

#### **程序示例**

程序清单 61-2 中的程序说明了如何使用 `shutdown()` 的 `SHUT_WR` 操作。这是一个 echo 服务的 TCP 客户端，它 `fork()` 一个父子进程：父进程负责从标准输入读取并发送数据，子进程负责从 socket 读取响应并打印到标准输出。

**程序清单 61-2：echo 服务的客户端程序**

```c
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <netdb.h>

// inetConnect() 是一个来自 59.12 节的辅助函数，这里提供一个简单实现
int inetConnect(const char *host, const char *service, int type) {
    struct addrinfo hints, *res, *rp; int sfd = -1;
    memset(&hints, 0, sizeof(struct addrinfo));
    hints.ai_canonname = NULL; hints.ai_addr = NULL; hints.ai_next = NULL;
    hints.ai_socktype = type; hints.ai_family = AF_UNSPEC;
    if (getaddrinfo(host, service, &hints, &res) != 0) return -1;
    for (rp = res; rp != NULL; rp = rp->ai_next) {
        sfd = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);
        if (sfd == -1) continue;
        if (connect(sfd, rp->ai_addr, rp->ai_addrlen) != -1) break;
        close(sfd); sfd = -1;
    }
    freeaddrinfo(res); return sfd;
}

int main(int argc, char *argv[]) {
    int cfd;
    ssize_t numRead;
    char buf[BUFSIZ];

    if (argc != 2 || strcmp(argv[1], "--help") == 0) {
        fprintf(stderr, "Usage: %s host\n", argv[0]);
        exit(EXIT_FAILURE);
    }
    
    // 连接到 echo 服务器 (通常在端口 7)
    cfd = inetConnect(argv[1], "echo", SOCK_STREAM);
    if (cfd == -1) {
        perror("inetConnect");
        exit(EXIT_FAILURE);
    }

    switch (fork()) {
    case -1:
        perror("fork");
        exit(EXIT_FAILURE);

    case 0: // 子进程: 从 socket 读取响应并打印到标准输出
        for (;;) {
            numRead = read(cfd, buf, BUFSIZ);
            if (numRead <= 0) // 遇到 EOF 或错误
                break;
            if (write(STDOUT_FILENO, buf, numRead) != numRead) {
                fprintf(stderr, "partial/failed write\n");
                exit(EXIT_FAILURE);
            }
        }
        exit(EXIT_SUCCESS);

    default: // 父进程: 从标准输入读取并写入 socket
        while ((numRead = read(STDIN_FILENO, buf, BUFSIZ)) > 0) {
            if (write(cfd, buf, numRead) != numRead) {
                fprintf(stderr, "partial/failed write\n");
                exit(EXIT_FAILURE);
            }
        }
        
        // 当标准输入遇到 EOF 时，关闭 socket 的写端
        if (shutdown(cfd, SHUT_WR) == -1) {
            perror("shutdown");
            exit(EXIT_FAILURE);
        }

        // 父进程退出
        exit(EXIT_SUCCESS);
    }
}
```

##### **编译和运行演示**

假设已有一个 echo 服务器在 `localhost` 上运行。

1.  **编译程序**: `gcc shutdown_client.c -o shutdown_client`
2.  **运行客户端**:
    ```bash
    $ ./shutdown_client localhost
    Hello, world!  <-- 输入这一行
    Hello, world!  <-- 子进程从服务器接收到回显并打印
    Goodbye        <-- 输入这一行
    Goodbye        <-- 子进程接收到回显并打印
    ^D             <-- 在新的一行按下 Ctrl-D，表示标准输入结束
    ```

**解读**:

  * 父进程从标准输入读取数据并发送给服务器。
  * 子进程从服务器接收回显的数据并打印到标准输出。
  * 当用户按下 `Ctrl-D`，父进程的 `read()` 返回 0 (EOF)。
  * 父进程随后调用 `shutdown(cfd, SHUT_WR)`。这会关闭连接的写端，导致服务器端的 `read()` 也返回 0 (EOF)。
  * echo 服务器在看到 EOF 后，会关闭它那一端的连接。
  * 服务器关闭连接导致客户端子进程的 `read()` 也返回 0 (EOF)，于是子进程正常退出。
  * 这个过程清晰地展示了如何使用“半关闭”来优雅地通知对端数据传输已结束。