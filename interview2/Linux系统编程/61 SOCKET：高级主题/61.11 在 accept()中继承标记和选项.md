### **61.11 在 accept()中继承标记和选项**

一个监听套接字可以设置多种标记（如 `O_NONBLOCK`）和选项（如 `SO_REUSEADDR`）。那么，当 `accept()` 在这个监听套接字上返回一个新的已连接套接字时，这些属性会被继承吗？本节将描述其中的细节。

#### **Linux 上的继承规则**

在 Linux 上，如下这些与文件描述符相关的属性**不会**被 `accept()` 返回的新的已连接套接字所继承：

* **打开的文件状态标记 (Open File Status Flags)**:
    * 指那些通过 `fcntl()` 的 `F_SETFL` 操作所修改的标记。
    * 典型的例子包括 **`O_NONBLOCK`** 和 **`O_ASYNC`**。
    * 这意味着，即使你将监听套接字设置为了非阻塞，由 `accept()` 返回的新套接字**默认仍然是阻塞的**。

* **文件描述符标记 (File Descriptor Flags)**:
    * 指那些通过 `fcntl()` 的 `F_SETFD` 操作来修改的标记。
    * 唯一的例子是**执行中关闭 (`close-on-exec`)** 标记 (`FD_CLOEXEC`)。

* **与信号驱动 I/O 相关的属性**:
    * 指那些通过 `fcntl()` 的 `F_SETOWN` 和 `F_SETSIG` 操作设置的属性。

换句话说，由 `accept()` 返回的新描述符主要继承了**套接字选项**，即那些通过 `setsockopt()` 来设定的选项（例如 `SO_REUSEADDR`, `SO_KEEPALIVE` 等）。

#### **可移植性注意事项**

本节描述的继承规则在 SUSv3 中并没有进行规定，因此在不同的 UNIX 实现中会有所区别。

* **最需要注意的区别**: 在一些 UNIX 实现中，像 **`O_NONBLOCK`** 和 `O_ASYNC` 这样的打开文件状态标记，**会被** `accept()` 返回的新套接字所继承。

* **建议**: 为了编写可移植的程序，**不应该**依赖于任何特定的继承行为。如果你希望由 `accept()` 返回的新套接字具有某些属性（例如，非阻塞），那么应该在 `accept()` 调用成功返回后，**显式地**在该新的文件描述符上重新设置这些属性。