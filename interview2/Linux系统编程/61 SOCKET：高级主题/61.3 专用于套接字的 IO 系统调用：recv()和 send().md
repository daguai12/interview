好的，这是根据您提供的文本内容，保留原始结构和标题整理的结果。

### **61.3 专用于套接字的 I/O 系统调用：recv()和 send()**

`recv()` 和 `send()` 系统调用可在**已连接**的套接字上执行 I/O 操作。它们提供了专属于套接字的功能，而这些功能在传统的 `read()` 和 `write()` 系统调用中是没有的。

这两个函数的返回值以及前三个参数（套接字描述符、缓冲区指针、长度）与 `read()` 和 `write()` 相同。它们的核心区别在于最后一个 `flags` 参数，它是一个位掩码，用于修改 I/O 操作的行为。

-----

#### **`recv()` 函数**

```c
#include <sys/socket.h>

ssize_t recv(int sockfd, void *buffer, size_t length, int flags);
```

`flags` 参数可以是下列一个或多个值的“或”运算结果：

  * **`MSG_DONTWAIT`**:

      * **作用**: 让本次 `recv()` 调用以**非阻塞**方式执行。
      * **行为**: 如果接收缓冲区中没有数据可用，`recv()` 不会阻塞，而是立刻失败并返回 `EAGAIN` 错误。这提供了对单次调用的非阻塞控制，与使用 `fcntl()` 设置 `O_NONBLOCK` 标志（影响所有后续调用）不同。

  * **`MSG_PEEK`**:

      * **作用**: “窥探”套接字接收缓冲区中的数据。
      * **行为**: `recv()` 会将请求的字节复制到用户的 `buffer` 中，但**不会**将这些字节从内核的接收缓冲区中实际移除。这意味着，后续的 `read()` 或 `recv()` 调用可以**再次读取**同样的数据。

  * **`MSG_WAITALL`**:

      * **作用**: 告诉系统调用阻塞，直到成功接收到 `length` 参数所指定的**全部**字节数。
      * **行为**: 这是一个内置的 `readn()` 实现。但是，即使指定了这个标记，当捕获到信号、对端关闭连接、或从数据报套接字接收到的消息长度小于 `length` 时，该调用返回的字节数可能还是会少于请求的字节数。

  * **`MSG_OOB`**:

      * **作用**: 在套接字上接收**带外数据 (out-of-band data)**。

-----

#### **`send()` 函数**

```c
#include <sys/socket.h>

ssize_t send(int sockfd, const void *buffer, size_t length, int flags);
```

`flags` 参数可以是下列一个或多个值的“或”运算结果：

  * **`MSG_DONTWAIT`**:

      * **作用**: 让本次 `send()` 调用以**非阻塞**方式执行。
      * **行为**: 如果数据不能立刻传输（因为套接字发送缓冲区已满），`send()` 不会阻塞，而是会失败并返回 `EAGAIN` 错误。

  * **`MSG_MORE`** (Linux 专有):

      * **作用 (TCP)**: 实现的效果同 `TCP_CORK` 套接字选项类似，告知内核“后面还有数据”，先不要急着发送当前的数据包，以便将多个小包“粘合”成一个大包再发送。
      * **作用 (UDP, 自 Linux 2.6 起)**: 将连续的、都带有 `MSG_MORE` 标记的 `send()` 调用中的数据**打包成一个单独的数据报**。只有当某次调用中**没有**指定该标记时，累积的数据报才会被真正地发送出去。

  * **`MSG_NOSIGNAL`** (Linux 专有):

      * **作用**: 当在已连接的流式套接字上发送数据，而连接的另一端已经关闭时，指定该标记将**不会**产生 `SIGPIPE` 信号。
      * **行为**: `send()` 调用会失败，并返回 `EPIPE` 错误。这与忽略 `SIGPIPE` 信号的行为相同，但提供了对单次调用的控制。

  * **`MSG_OOB`**:

      * **作用**: 在流式套接字上发送**带外数据**。