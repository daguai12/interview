### **61.5 获取套接字地址**

`getsockname()` 和 `getpeername()` 这两个系统调用分别返回**本地**套接字地址以及**对端 (peer)** 套接字地址。

```c
#include <sys/socket.h>

int getsockname(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
int getpeername(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
```

  * **`sockfd`**: 指向套接字的文件描述符。
  * **`addr`**: 一个指向 `sockaddr` 结构体的指针，用于返回套接字的地址。
  * **`addrlen`**: 一个**值-结果 (value-result)** 参数。在调用前，它必须指向一个整数，该整数的值是 `addr` 缓冲区的大小；调用返回后，该整数会被内核修改为实际返回的地址结构的字节数。

-----

#### **`getsockname()`**

`getsockname()` 返回 `sockfd` **本地**绑定的地址。它的主要用途有：

  * 当一个服务器进程继承了一个已绑定的套接字（例如，由 `inetd` 启动）时，可以用它来找出自己的地址和端口。
  * 当内核为一个套接字**隐式绑定**了一个**临时端口 (ephemeral port)** 时，可以用它来获取这个由内核分配的端口号。内核会在以下情况执行隐式绑定：
      * 在一个未绑定的 TCP 套接字上执行了 `connect()` 或 `listen()`。
      * 在一个未绑定的 UDP 套接字上首次调用 `sendto()`。
      * 调用 `bind()` 时将端口号指定为 0。

-----

#### **`getpeername()`**

`getpeername()` 返回与流式套接字 `sockfd` 连接的**对端**套接字的地址。

  * **用途**: 主要用于 TCP 服务器，以找出发起连接的客户端的地址。虽然 `accept()` 也可以返回客户端地址，但如果 `accept()` 是由另一个程序（如 `inetd`）执行的，那么服务器进程就只能通过 `getpeername()` 来获取客户端信息。

-----

#### **程序示例**

程序清单 61-3 中的程序演示了 `getsockname()` 和 `getpeername()` 的用法。该程序创建了一个监听套接字，然后自己连接自己，最后打印出连接两端的地址信息。

**程序清单 61-3：使用 `getsockname()` 和 `getpeername()`**

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netdb.h>

// inetListen, inetConnect, inetAddressStr 是来自 59.12 节的辅助函数
// 为使代码完整，此处提供它们的简单实现
int inetListen(const char*, int, socklen_t*);
int inetConnect(const char*, const char*, int);
char* inetAddressStr(const struct sockaddr*, socklen_t, char*, int);
// (这些函数的完整实现见 59.12 节)

int main(int argc, char *argv[]) {
    int listenFd, acceptFd, connFd;
    socklen_t len;
    void *addr;
    char addrStr[1024];

    if (argc != 2 || strcmp(argv[1], "--help") == 0) {
        fprintf(stderr, "Usage: %s service\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    // 1. 创建监听套接字
    listenFd = inetListen(argv[1], 5, &len);
    if (listenFd == -1) {
        perror("inetListen");
        exit(EXIT_FAILURE);
    }

    // 2. 创建客户端套接字并连接到监听套接字 (自连接)
    connFd = inetConnect("localhost", argv[1], SOCK_STREAM);
    if (connFd == -1) {
        perror("inetConnect");
        exit(EXIT_FAILURE);
    }

    // 3. 接受自连接
    acceptFd = accept(listenFd, NULL, NULL);
    if (acceptFd == -1) {
        perror("accept");
        exit(EXIT_FAILURE);
    }
    
    addr = malloc(len);
    if (addr == NULL) {
        perror("malloc");
        exit(EXIT_FAILURE);
    }

    // 4. 调用 getsockname() 获取客户端连接套接字 connFd 的本地地址
    //    这将显示内核为客户端分配的临时端口号
    if (getsockname(connFd, addr, &len) == -1) {
        perror("getsockname");
        exit(EXIT_FAILURE);
    }
    printf("getsockname(connFd):   %s\n", inetAddressStr(addr, len, addrStr, sizeof(addrStr)));
    
    // 5. 调用 getpeername() 获取服务器接受套接字 acceptFd 的对端地址
    //    这应该与上面的地址相同
    if (getpeername(acceptFd, addr, &len) == -1) {
        perror("getpeername");
        exit(EXIT_FAILURE);
    }
    printf("getpeername(acceptFd): %s\n", inetAddressStr(addr, len, addrStr, sizeof(addrStr)));
    
    // 6. 暂停以便运行 netstat
    printf("Pausing so you can run netstat...\n");
    sleep(15);
    
    free(addr);
    close(listenFd);
    close(acceptFd);
    close(connFd);

    exit(EXIT_SUCCESS);
}

// (此处省略 inetListen, inetConnect, inetAddressStr 的完整实现代码，
// 完整的可编译版本请参考 59.12 节)
```

##### **编译和运行演示**

1.  **编译程序**: `gcc get_addrs_demo.c inet_sockets.c -o get_addrs_demo` (需要链接 59.12 节的库)
2.  **在一个终端中运行程序**:
    ```bash
    $ ./get_addrs_demo 50000
    getsockname(connFd):   (127.0.0.1, 32835)
    getpeername(acceptFd): (127.0.0.1, 32835)
    Pausing so you can run netstat...
    ```
3.  **在暂停期间，在另一个终端中运行 `netstat`**:
    ```bash
    $ netstat -n -A inet | grep 50000
    tcp        0      0 127.0.0.1:50000         0.0.0.0:* LISTEN
    tcp        0      0 127.0.0.1:50000         127.0.0.1:32835         ESTABLISHED
    tcp        0      0 127.0.0.1:32835         127.0.0.1:50000         ESTABLISHED
    ```

**解读**:

  * `getsockname()` 成功地获取了客户端 `connFd` 由内核分配的临时端口号 **32835**。
  * `getpeername()` 在服务器端的 `acceptFd` 上也成功地获取了其对端（即客户端）的地址，结果完全相同。
  * `netstat` 的输出确认了这三个套接字的存在：一个 `LISTEN` 状态的监听套接字，和一对 `ESTABLISHED` 状态的、相互连接的套接字。