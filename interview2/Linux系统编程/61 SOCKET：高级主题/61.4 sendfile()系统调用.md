
### **61.4 sendfile()系统调用**

像 Web 服务器和文件服务器这样的应用程序，常常需要将磁盘上的文件内容不做修改地通过套接字传输出去。

**传统方法的问题**:
传统的方法是使用一个循环：`read()` 从文件读入用户空间缓冲区，然后 `write()` 从用户空间缓冲区写入套接字。这种技术效率低下，因为它涉及两次不必要的数据拷贝：

1.  数据从内核的**文件缓冲区**拷贝到**用户空间缓冲区**。
2.  数据再从**用户空间缓冲区**拷贝回内核的**套接字缓冲区**。

**`sendfile()` 的解决方案：零拷贝**
`sendfile()` 系统调用被设计用来消除这种低效性。当调用 `sendfile()` 时，文件内容会**直接**在内核空间中从文件缓冲区传送到套接字缓冲区，而**不会经过用户空间**。这种技术被称为**零拷贝传输 (zero-copy transfer)**。

**数据传输路径对比 (对应原文图 61-1)**


![[Pasted image 20250919101751.png]]

-----

#### **`sendfile()`**

`sendfile()` 在代表输入文件的描述符 `in_fd` 和代表输出文件的描述符 `out_fd` 之间传送文件内容。

```c
#include <sys/sendfile.h>

ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count);
```

  * **`out_fd`**: 输出文件描述符，**必须**指向一个套接字。
  * **`in_fd`**: 输入文件描述符，必须指向一个可以进行 `mmap()` 操作的文件（通常是一个普通文件）。
  * **`offset`**: 一个指向 `off_t` 值的指针。
      * 如果**不为 `NULL`**: `sendfile()` 从 `in_fd` 的这个指定偏移量处开始传输数据，并且在返回时，`*offset` 会被更新为传输完最后一个字节后的下一个字节的偏移量。`in_fd` 自身的文件偏移量**不会**被改变。
      * 如果为 **`NULL`**: `sendfile()` 从 `in_fd` 的当前文件偏移量处开始传输，并在传输时相应地更新文件偏移量。
  * **`count`**: 请求传输的字节数。
  * **返回值**: 成功时，返回实际传输的字节数。

**局限性**:
`sendfile()` 的使用受到一些局限。例如，它只能将数据从文件传递到套接字上，但反过来不行；也不能在两个套接字之间直接传送数据。

> **其他相关系统调用**: 从 2.6.16 版内核开始，Linux 提供了 `splice()`、`vmsplice()` 以及 `tee()` 等新的非标准系统调用，它们提供了 `sendfile()` 功能的超集。

-----

#### **TCP\_CORK 套接字选项**

为了进一步提高 TCP 应用使用 `sendfile()` 时的性能，可以采用 Linux 专有的套接字选项 **`TCP_CORK`**。

  * **问题场景**: 一个 Web 服务器通常需要先 `write()` 一个小的 HTTP 头部，然后再 `sendfile()` 一个大的文件内容。这可能会导致网络上发送了两个 TCP 报文段：一个小的头部报文段和一个大的数据报文段，这对网络带宽的利用不够高效。
  * **`TCP_CORK` 的作用**: 当在 TCP 套接字上启用了 `TCP_CORK` 选项后（就像给瓶子塞上软木塞），后续所有的输出都会被**内核缓冲**起来，直到发生以下情况之一，内核才会将所有缓冲的数据“粘合”成一个单独的 TCP 报文段发送出去：
      * 应用程序取消了 `TCP_CORK` 选项。
      * 套接字被关闭。
      * 距离写入第一个字节已超过 200 毫秒。
      * 缓冲区已满。

**使用示例 (HTTP 服务器)**:

```c
int cork_on = 1;
int cork_off = 0;

// 1. 启用 TCP_CORK
setsockopt(cfd, IPPROTO_TCP, TCP_CORK, &cork_on, sizeof(cork_on));

// 2. 写入 HTTP 头部 (数据被内核缓冲)
write(cfd, header, header_len);

// 3. 传输文件内容 (数据也被内核缓冲，并与头部数据结合)
sendfile(cfd, file_fd, ...);

// 4. 取消 TCP_CORK，此时内核会将头部和文件内容打包成一个报文段发送出去
setsockopt(cfd, IPPROTO_TCP, TCP_CORK, &cork_off, sizeof(cork_off));
```

通过这种方式，`sendfile()` 的零拷贝高效性和传输单个优化报文段的能力被结合了起来。

> **与 `MSG_MORE` 的对比**:
> `send()` 的 `MSG_MORE` 标志提供了类似的功能，但 `MSG_MORE` 是**基于每次调用**的，而 `TCP_CORK` 是一个在文件描述符上**持续生效**的选项。
