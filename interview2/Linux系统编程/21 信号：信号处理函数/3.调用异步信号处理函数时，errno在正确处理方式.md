这段内容主要解释了两个核心问题：**信号处理器函数中使用 `errno` 可能导致的问题及解决方法**，以及**为什么示例程序中会出现不安全函数（如 `printf()`）**。下面分点详细解读：


### 一、信号处理器中使用 `errno` 的风险：全局状态污染
#### 1. `errno` 的本质
`errno` 是一个**全局变量**（或线程局部变量，但信号处理器与主程序属于同一线程），用于保存系统调用或库函数的错误码。当函数执行失败时，会将错误原因对应的数值写入 `errno`，供后续代码判断错误类型（例如 `if (ret == -1 && errno == EINTR)`）。

#### 2. 信号处理器对 `errno` 的干扰
信号处理器函数如果调用了可能修改 `errno` 的函数（即使是**异步信号安全的函数**，如 `write()`、`close()` 等），可能会覆盖主程序之前设置的 `errno` 值，导致主程序错误判断执行状态。  
- 例如：主程序调用 `read()` 失败，`errno` 被设置为 `EAGAIN`（资源暂时不可用）；此时信号处理器被触发，调用 `write()` 失败并将 `errno` 修改为 `EBADF`（无效文件描述符）；信号处理器返回后，主程序检查 `errno` 时会读到 `EBADF`，而非原本的 `EAGAIN`，从而做出错误的错误处理。  

这种因共享全局变量 `errno` 导致的状态混乱，会让信号处理器函数成为**不可重入函数**。


#### 3. 变通方法：保存和恢复 `errno`
为避免 `errno` 被信号处理器污染，可在信号处理器**入口处保存 `errno` 的值**，**出口处恢复原值**。这样主程序的 `errno` 状态不会被干扰，示例如下：
```c
#include <errno.h>
#include <unistd.h>

void handler(int signum) {
    int saved_errno = errno;  // 入口处保存当前errno
    // 信号处理器逻辑：调用可能修改errno的函数
    if (write(STDOUT_FILENO, "signal received\n", 16) == -1) {
        // 此处errno可能被修改，但不影响主程序
    }
    errno = saved_errno;  // 出口处恢复原值
}
```
- 原理：通过局部变量 `saved_errno` 暂存主程序的 `errno`，信号处理器内部的操作即使修改 `errno`，退出前也会恢复，主程序后续检查 `errno` 时仍能得到正确值。  


### 二、示例程序中使用非安全函数的原因：演示便利性与实际开发的区别
#### 1. 示例中为何用 `printf()` 等不安全函数？
书中明确提到：尽管 `printf()`、`strsignal()` 等函数**不是异步信号安全的**（可能操作全局缓冲区、修改静态数据，导致主程序与信号处理器冲突），但在示例中频繁使用，原因是：  
- **简洁直观**：`printf()` 能方便地输出信号处理器的调用状态、变量值等信息，让读者快速理解信号触发和处理的流程。  
- **演示目的**：示例的核心是展示信号机制的基本用法（如信号注册、处理器调用时机），而非强调并发安全性，因此暂时忽略了“非安全函数”的风险。  


#### 2. 实际应用中必须避免非安全函数
真正的应用程序绝对不能在信号处理器中调用非异步信号安全的函数，原因是：  
- 非安全函数（如 `printf()`、`malloc()`、`fopen()` 等）依赖全局状态（如stdio缓冲区、内存管理链表），信号处理器与主程序的交叉调用可能导致数据错乱（如缓冲区内容被覆盖、链表指针断裂），甚至程序崩溃。  
- 例如：主程序正在调用 `printf()` 向缓冲区写入数据时，信号处理器中断并调用 `printf()`，可能导致缓冲区数据混杂，输出乱码。  


#### 3. 示例与实际开发的平衡
书中在示例中使用非安全函数时，会通过注释明确标注“此用法不安全”，目的是：  
- 兼顾演示的简洁性（让读者聚焦信号机制本身）；  
- 提醒读者实际开发中需替换为异步信号安全的函数（如用 `write()` 替代 `printf()` 输出简单信息）。  


### 总结
1. **`errno` 风险**：信号处理器调用的函数可能修改全局 `errno`，污染主程序的错误状态，需通过“入口保存、出口恢复”解决。  
2. **示例与实际的差异**：示例中使用 `printf()` 等非安全函数是为了演示便利，实际开发必须替换为异步信号安全的函数（如 `write()`），并严格避免操作全局状态。  

核心原则：信号处理器需最小化逻辑，仅调用异步信号安全的函数，必要时保存/恢复全局状态（如 `errno`），确保主程序与处理器的状态不冲突。