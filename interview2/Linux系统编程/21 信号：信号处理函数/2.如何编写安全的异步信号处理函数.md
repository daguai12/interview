这部分内容阐述了编写信号处理器函数时确保程序安全的两种核心策略，本质上是为了解决信号处理器与主程序之间可能出现的**资源竞争**和**状态混乱**问题。下面结合信号的异步特性和可重入性问题，详细解释这两种策略的原理和应用场景：


### 核心背景：信号的“异步干扰”问题
信号处理器函数的执行具有**异步性**——它可能在程序的任何时刻（包括主程序执行关键操作时）被触发并中断主程序。如果信号处理器与主程序共享资源（如全局变量、静态数据）或调用了不安全的函数，就可能导致数据损坏、逻辑错误甚至程序崩溃。例如：
- 主程序正在更新全局链表，信号处理器突然中断并修改同一链表，导致指针混乱；
- 主程序调用 `printf()`（非异步安全函数）时被中断，信号处理器也调用 `printf()`，导致stdio缓冲区数据错乱。


### 策略一：确保信号处理器自身可重入，且只调用异步信号安全函数
#### 原理
信号处理器函数本身的代码逻辑和所调用的函数必须满足**可重入性**和**异步信号安全性**，从而避免对主程序的执行状态造成干扰。

#### 具体要求
1. **信号处理器自身可重入**  
   处理器函数内部应只使用**局部变量**（存储在栈上，每个线程独立），避免修改全局变量、静态变量或共享数据结构。如果必须操作共享资源，需通过原子操作或其他同步机制确保安全性。

2. **只调用异步信号安全（Async-Signal-Safe）函数**  
   异步信号安全函数是指在信号处理器中调用时，不会导致状态混乱的函数。这类函数的特点是：
   - 不使用静态数据或全局变量（或对其访问是原子的）；
   - 不依赖malloc/free等需要内部锁或链表维护的函数；
   - 不调用其他非异步安全函数。  
   例如：`write()`、`_exit()`、`signal()` 是异步安全的；而 `printf()`、`malloc()`、`getpwnam()` 是非异步安全的（会操作全局缓冲区或链表）。

#### 示例场景
如果信号处理器仅需要记录信号发生次数，可使用局部变量或原子变量：
```c
#include <signal.h>
#include <stdatomic.h>

atomic_int sig_count = 0;  // 原子变量，确保并发安全

void handler(int sig) {
    sig_count++;  // 原子操作，可安全在处理器中调用
}

int main() {
    signal(SIGINT, handler);
    while (1);  // 主程序循环，等待信号
    return 0;
}
```


### 策略二：主程序执行不安全操作时，阻塞信号传递
#### 原理
当主程序需要执行**非异步安全操作**（如调用 `printf()`、`malloc()`）或操作**共享资源**（如全局链表）时，临时阻塞可能触发信号处理器的信号，避免处理器在关键操作中途中断主程序，从而防止资源竞争。

#### 具体步骤
1. **确定需要阻塞的信号**  
   通常是当前注册了处理器的信号（如SIGINT、SIGUSR1）。

2. **在关键操作前后阻塞/解除阻塞信号**  
   使用 `sigprocmask()` 等函数在执行不安全操作前阻塞信号，操作完成后解除阻塞。被阻塞的信号会被内核记录，解除阻塞后再触发处理。

#### 示例场景
主程序需要调用 `printf()`（非异步安全），同时信号处理器也可能操作共享数据，此时需在 `printf()` 前后阻塞信号：
```c
#include <signal.h>
#include <stdio.h>

int shared_data = 0;  // 共享全局变量

void handler(int sig) {
    shared_data++;  // 假设处理器需要修改共享变量
}

int main() {
    struct sigaction sa;
    sa.sa_handler = handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;
    sigaction(SIGINT, &sa, NULL);

    // 主程序执行不安全操作（调用printf）前，阻塞SIGINT
    sigset_t mask, oldmask;
    sigemptyset(&mask);
    sigaddset(&mask, SIGINT);
    sigprocmask(SIG_BLOCK, &mask, &oldmask);  // 阻塞SIGINT

    // 执行非异步安全操作：printf会操作stdio缓冲区
    printf("主程序执行不安全操作...\n");

    // 操作完成，解除阻塞
    sigprocmask(SIG_SETMASK, &oldmask, NULL);  // 恢复原信号掩码

    return 0;
}
```
在上述代码中，`printf()` 执行期间SIGINT被阻塞，避免了信号处理器在 `printf()` 操作stdio缓冲区时中断它，从而防止输出错乱。


### 两种策略的适用场景
| 策略一                       | 策略二                              |
| ------------------------- | -------------------------------- |
| 信号处理器逻辑简单，仅依赖局部变量和异步安全函数  | 信号处理器或主程序需操作共享资源，或主程序必须调用非异步安全函数 |
| 适用于处理器功能单一（如记录信号、设置标志）的场景 | 适用于主程序有复杂操作（如IO、内存分配、链表修改）的场景    |
| 无需阻塞信号，性能开销低              | 需要主动管理信号阻塞状态，需注意避免信号长期阻塞导致延迟     |


### 总结
编写信号处理器的核心原则是**避免异步干扰**：  
- 要么让处理器自身“足够安全”（可重入+只调用安全函数）；  
- 要么在主程序执行危险操作时“暂时屏蔽干扰”（阻塞信号）。  
实际开发中常结合两种策略：处理器尽量简单（策略一），主程序在关键步骤主动阻塞信号（策略二），以最大化程序的安全性和可靠性。