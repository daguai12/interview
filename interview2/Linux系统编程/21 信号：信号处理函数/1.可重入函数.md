这一章核心讲解了**可重入函数与非可重入函数的概念、区别及实际影响**，尤其聚焦于信号处理器函数场景下的函数安全性问题。以下是分点解读：


### 一、理解“执行线程”与可重入的前提
- **单线程 vs 多线程**：  
  典型UNIX程序是单线程的，只有一条执行逻辑；多线程程序则有多个独立、并发的执行流。  
  但**信号处理器函数会让单线程程序“变相”出现两条执行线程**：主程序的执行可能被信号处理器异步中断，此时主程序和信号处理器相当于两条独立的执行流（虽然不是真正并发，但可能交叉执行）。

- **可重入的核心定义**：  
  若一个函数能被同一进程的多条线程（包括主程序与信号处理器）**同时安全调用**，则为“可重入函数”。  
  这里的“安全”指：无论线程调用的顺序如何交叉，函数最终结果都与“线程依次调用”的结果一致（符合预期）。


### 二、可重入函数的判断标准
- **可重入函数的特征**：  
  仅使用**局部变量**（保存在栈中，每个线程/调用有独立副本），不依赖全局变量、静态数据或外部资源（如文件描述符的全局状态）。  
  这类函数的执行状态完全由输入参数和局部变量决定，多个线程调用时不会相互干扰。

- **非可重入函数的常见原因**：  
  依赖或修改**全局变量、静态数据结构**，或使用了“共享状态”（如内部缓冲区、链表等）。  
  当多个线程（或主程序与信号处理器）同时调用时，可能因交叉修改共享状态导致数据错乱。


### 三、非可重入函数的典型例子
1. **依赖全局/静态数据结构的函数**：  
   - `malloc()`/`free()`：维护全局内存管理链表（记录已分配/释放的内存块）。若主程序调用`malloc()`时被信号处理器中断，而信号处理器也调用`malloc()`，可能导致链表指针错乱（内存泄漏或崩溃）。  
   - 自定义全局数据结构（如链表、哈希表）：若主程序和信号处理器都修改同一链表，可能因交叉更新指针导致链表断裂。

2. **使用静态内存返回结果的函数**：  
   - `crypt()`、`getpwnam()`、`gethostbyname()`等：通过静态分配的内存返回结果（如`getpwnam()`返回指向静态结构体的指针）。若信号处理器调用这些函数，会覆盖主程序上次调用的结果（反之亦然），导致数据不一致。

3. **依赖内部状态的函数**：  
   - `stdio`库函数（`printf()`、`scanf()`等）：维护内部缓冲区和状态（如输出缓冲区的位置指针）。若主程序正在调用`printf()`时被信号处理器中断，而信号处理器也调用`printf()`，可能导致缓冲区数据混乱（输出错乱或程序崩溃）。


### 四、信号处理器函数的特殊风险
信号处理器函数可能在**任意时刻中断主程序**，因此对“可重入性”要求极高：  
- 若信号处理器调用了非可重入函数（如`printf()`、`malloc()`），而主程序恰好在执行同一函数，极可能导致共享状态被破坏。  
- 即使不调用库函数，若信号处理器和主程序都修改自定义全局变量，也会导致函数不可重入（信号处理器成为主程序的“干扰源”）。


### 五、实际编程建议
1. 判断函数是否可重入：查看手册页，注意是否使用全局/静态变量、是否有内部状态（如`malloc`明确标注不可重入）。  
2. 信号处理器中**只调用可重入函数**：优先使用局部变量，避免修改全局状态；必须使用全局变量时，需用`volatile sig_atomic_t`等原子类型（保证读写的原子性）。  
3. 复杂逻辑移到主程序：信号处理器仅做简单操作（如设置标志位），主程序通过轮询标志位处理复杂逻辑（避免在处理器中调用非可重入函数）。


### 总结
本章核心是：**可重入函数是多线程（含信号场景）安全的基础，其关键是不依赖共享状态；非可重入函数因依赖全局/静态数据，在信号处理器等异步场景中可能导致数据错乱，需严格避免**。理解这一点对编写可靠的信号处理逻辑和多线程程序至关重要。


```cpp
#include <stdio.h>
#include <signal.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>

// 全局变量，用于演示非可重入函数
int global_counter = 0;
char static_buffer[100]; // 静态缓冲区

// 非可重入函数1：修改全局变量
void non_reentrant1() {
    // 递增操作实际包含多个步骤：读取->修改->写入
    // 可能被信号处理器中断导致错误
    global_counter++;
}

// 非可重入函数2：使用静态缓冲区返回结果
char* non_reentrant2(const char* input) {
    strcpy(static_buffer, input);
    return static_buffer; // 返回静态缓冲区地址
}

// 可重入函数1：只使用局部变量
int reentrant1(int a, int b) {
    int local_sum = a + b; // 局部变量，每个调用有独立副本
    return local_sum;
}

// 可重入函数2：使用调用者提供的缓冲区
void reentrant2(const char* input, char* output, size_t size) {
    strncpy(output, input, size - 1); // 使用外部提供的缓冲区
    output[size - 1] = '\0';
}

// 信号处理器：调用非可重入函数（危险）
void bad_handler(int signum) {
    printf("信号处理器：调用非可重入函数\n");
    
    // 危险：修改全局变量，可能与主程序冲突
    non_reentrant1();
    
    // 危险：使用静态缓冲区，可能覆盖主程序结果
    char* handler_str = non_reentrant2("handler_data");
    printf("信号处理器中字符串：%s\n", handler_str);
}

// 信号处理器：只调用可重入函数（安全）
void good_handler(int signum) {
    printf("信号处理器：调用可重入函数\n");
    
    // 安全：使用局部变量
    int sum = reentrant1(3, 5);
    
    // 安全：使用栈上的缓冲区
    char stack_buffer[100];
    reentrant2("handler_data", stack_buffer, sizeof(stack_buffer));
    printf("信号处理器中字符串：%s\n", stack_buffer);
}

// 测试非可重入函数的问题
void test_non_reentrant() {
    printf("\n=== 测试非可重入函数 ===\n");
    signal(SIGINT, bad_handler);
    
    while (1) {
        // 主程序调用非可重入函数
        non_reentrant1();
        char* main_str = non_reentrant2("main_data");
        
        // 打印当前状态
        printf("全局计数器：%d, 主程序字符串：%s\n", 
               global_counter, main_str);
        
        sleep(1);
        // 按Ctrl+C触发信号处理器
    }
}

// 测试可重入函数的安全性
void test_reentrant() {
    printf("\n=== 测试可重入函数 ===\n");
    signal(SIGINT, good_handler);
    
    int main_counter = 0;
    while (1) {
        // 主程序调用可重入函数
        main_counter = reentrant1(main_counter, 1);
        
        char main_buffer[100];
        reentrant2("main_data", main_buffer, sizeof(main_buffer));
        
        // 打印当前状态
        printf("主程序计数器：%d, 主程序字符串：%s\n", 
               main_counter, main_buffer);
        
        sleep(1);
        // 按Ctrl+C触发信号处理器
    }
}

int main() {
    // 先测试非可重入函数（按Ctrl+C会看到异常）
    test_non_reentrant();
    
    // 取消注释测试可重入函数（按Ctrl+C不会有异常）
    // test_reentrant();
    
    return 0;
}

```