这段内容核心讲解了**信号中断阻塞系统调用后的处理机制**，包括默认行为（EINTR错误）、手动重启方式、自动重启机制（SA_RESTART标志）及相关注意事项。以下是分点解读：


### 一、核心场景与默认行为
当程序执行**阻塞系统调用**（如 `read()` 等待终端输入、`accept()` 等待网络连接）时，若此时有信号到达并触发信号处理器，会发生：  
- 阻塞系统调用被暂时中断，内核先执行信号处理器；  
- 信号处理器返回后，**默认情况下，被中断的系统调用会失败**，返回 `-1` 并将 `errno` 设为 `EINTR`（表示“调用被信号中断”）。  


### 二、手动重启被中断的系统调用
若希望被中断的系统调用继续执行（而非失败），需手动检测 `EINTR` 并重启调用。典型做法是用循环包裹系统调用，示例如下：  

#### 基本逻辑
```c
ssize_t ret;
while ((ret = read(fd, buf, BUFSIZE)) == -1 && errno == EINTR) {
    // 空循环：若因EINTR失败，继续重试
}
if (ret == -1) {
    // 处理其他错误（非EINTR）
    perror("read failed");
}
```

#### 封装为宏（简化重复使用）
频繁使用时，可定义宏自动处理重试：  
```c
#define NO_EINTR(func) \
    do { \
        while ((func) == -1 && errno == EINTR); \
    } while (0)

// 使用示例：
NO_EINTR(read(fd, buf, BUFSIZE));  // 自动重试EINTR的情况
```

GNU C库提供了非标准宏 `TEMP_FAILURE_RETRY()`（需定义 `_GNU_SOURCE`），功能与上述 `NO_EINTR` 相同。


### 三、自动重启：SA_RESTART标志
手动重启需为每个阻塞调用添加代码，繁琐且易遗漏。通过 `sigaction()` 注册信号处理器时，设置 `SA_RESTART` 标志，可让内核**自动重启被中断的系统调用**，无需处理 `EINTR`。  

#### 使用方式
```c
struct sigaction sa;
sa.sa_handler = handler;  // 信号处理器
sigemptyset(&sa.sa_mask);
sa.sa_flags = SA_RESTART;  // 关键：启用自动重启
sigaction(SIGINT, &sa, NULL);  // 为SIGINT注册处理器
```

设置后，被该信号中断的阻塞系统调用会在处理器返回后**自动继续阻塞等待**，如同未被中断过（不会返回 `EINTR`）。  


### 四、SA_RESTART对系统调用的适用范围
并非所有系统调用都支持 `SA_RESTART` 自动重启，这与历史实现（BSD vs System V）有关。需重点区分以下两类：  


#### 1. 支持SA_RESTART自动重启的系统调用
这些调用多源自BSD，主要包括：  
- **I/O操作（慢速设备）**：`read()`、`readv()`、`write()`、`writev()`、`ioctl()`（针对终端、管道、FIFO、套接字等“慢速设备”，即可能阻塞的设备）。  
- **进程等待**：`wait()`、`waitpid()`、`wait3()`、`wait4()`、`waitid()`。  
- **套接字操作**：`accept()`、`accept4()`、`connect()`、`send()`、`recv()` 等。  
- **消息队列/POSIX信号量**：`mq_receive()`、`mq_send()`、`sem_wait()`、`sem_timedwait()` 等。  
- **文件锁**：`flock()`、`fcntl()`（加锁操作）、`lockf()`。  

**注意**：若I/O操作已传输部分数据（如 `read()` 已读入50字节），信号中断后会返回实际字节数（50），而非 `EINTR`，也不会重启（因部分完成）。  


#### 2. 不支持SA_RESTART的系统调用
这些调用多源自System V或设计上不适合重启，包括：  
- **I/O多路复用**：`poll()`、`ppoll()`、`select()`、`pselect()`、`epoll_wait()`、`epoll_pwait()`。  
- **时间等待**：`sleep()`、`nanosleep()`、`clock_nanosleep()`。  
- **信号等待**：`pause()`、`sigsuspend()`、`sigtimedwait()`、`sigwaitinfo()`。  
- **System V IPC**：`semop()`、`semtimedop()`（信号量）、`msgrcv()`、`msgsnd()`（消息队列）。  
- **inotify**：对inotify文件描述符的 `read()` 调用。  

对于这些调用，即使设置 `SA_RESTART`，被信号中断后仍会返回 `EINTR`，需手动重启。  


### 五、其他相关机制
#### 1. siginterrupt()函数
用于修改信号的 `SA_RESTART` 设置，原型：  
```c
#include <signal.h>
int siginterrupt(int sig, int flag);
```  
- `flag=1`：信号处理器会中断系统调用（即不自动重启，等价于清除 `SA_RESTART`）。  
- `flag=0`：信号处理器返回后自动重启系统调用（等价于设置 `SA_RESTART`）。  

**注意**：SUSv4已将其标记为“废止”，推荐直接使用 `sigaction()` 控制 `SA_RESTART`。  


#### 2. 未处理的停止信号导致的EINTR
即使程序未为某些信号（如 `SIGSTOP`、`SIGTSTP`、`SIGTTIN`、`SIGTTOU`）注册处理器，若进程因这些信号停止后被 `SIGCONT` 恢复，部分系统调用（如 `epoll_wait()`、`semop()`）仍可能返回 `EINTR`。需注意这种特殊情况，必要时手动重启。  


### 总结
信号中断阻塞系统调用后的处理核心是：  
- **默认行为**：系统调用失败，返回 `EINTR`。  
- **手动处理**：用循环检测 `EINTR` 并重启（适合不支持自动重启的调用）。  
- **自动重启**：通过 `SA_RESTART` 标志让内核自动处理（适合支持的调用，简化代码）。  

实际开发中需根据具体系统调用的特性选择处理方式，尤其注意不支持 `SA_RESTART` 的调用（如 `select()`、`poll()`）必须手动处理 `EINTR`。