这部分内容核心讲解了**备选信号栈（Alternative Signal Stack）的作用、原理及使用方法**，解决了“进程主栈溢出时信号处理器无法执行”的关键问题。以下是分点解读：


### 一、为什么需要备选信号栈？
进程的正常执行依赖于**主栈**（用于函数调用、局部变量存储等）。但当主栈因异常情况（如无限递归、栈空间耗尽）溢出时，会触发内核发送 `SIGSEGV` 信号（段错误）。此时若信号处理器仍需在主栈上创建栈帧，会因主栈已无空间而无法执行，导致进程直接终止（`SIGSEGV` 的默认动作）。  

**备选信号栈的核心作用**：为信号处理器提供一块独立的内存区域作为栈，确保即使主栈溢出，信号处理器仍能正常执行（如打印调试信息、执行清理操作或恢复程序）。


### 二、备选信号栈的工作机制
#### 1. 核心流程
要使用备选信号栈，需完成三个关键步骤：  
- **分配备选栈内存**：在主栈正常时，提前分配一块内存作为备选信号栈（可静态分配或从堆动态分配）。  
- **注册备选栈**：通过 `sigaltstack()` 系统调用，将备选栈的地址、大小等信息告知内核。  
- **指定信号处理器使用备选栈**：注册信号处理器时，通过 `SA_ONSTACK` 标志（在 `struct sigaction` 的 `sa_flags` 中设置），通知内核“该信号的处理器需在备选栈上执行”。  


#### 2. `sigaltstack()` 系统调用详解
`sigaltstack()` 用于创建、查询或禁用备选信号栈，函数原型及核心参数如下：  
```c
#include <signal.h>
int sigaltstack(const stack_t *restrict sigstack, stack_t *restrict old_sigstack);
```  

- **`stack_t` 结构体**：描述备选栈的属性，定义为：  
  ```c
  struct stack_t {
      void  *ss_sp;    // 备选栈的起始地址（内存指针）
      size_t ss_size;  // 备选栈的大小（字节数）
      int    ss_flags; // 备选栈状态标志（如 SS_ONSTACK、SS_DISABLE）
  };
  ```  

- **参数说明**：  
  - `sigstack`：若不为 `NULL`，表示设置新的备选栈（需填充 `ss_sp`、`ss_size` 和 `ss_flags`）；若为 `NULL`，仅查询当前备选栈信息。  
  - `old_sigstack`：若不为 `NULL`，内核会将上一次的备选栈信息（如存在）写入该结构体，用于保存旧配置。  

- **`ss_flags` 标志**：  
  - `SS_ONSTACK`：查询时返回，表示当前进程正在使用备选信号栈执行信号处理器。此时若尝试通过 `sigaltstack()` 设置新备选栈，会返回 `EPERM` 错误（避免嵌套使用）。  
  - `SS_DISABLE`：设置时表示禁用当前备选栈；查询时返回，表示当前无可用备选栈。  


#### 3. 备选栈的大小规范
- **`SIGSTKSZ`**：POSIX 定义的“典型备选栈大小”（Linux/x86-32 上为 8192 字节），适用于大多数场景。  
- **`MINSIGSTKSZ`**：备选栈的“最小 required 大小”（Linux/x86-32 上为 2048 字节），是信号处理器执行所需的最小空间，实际分配时不应小于此值。  


### 三、使用备选信号栈的典型场景
最常见的场景是**处理因主栈溢出导致的 `SIGSEGV` 信号**，确保信号处理器能在备选栈上运行，执行必要的调试或恢复操作。  

#### 示例流程（对应程序清单 21-3）：  
1. **分配备选栈内存**：  
   ```c
   char alt_stack[SIGSTKSZ];  // 用典型大小静态分配备选栈
   struct stack_t ss;
   ss.ss_sp = alt_stack;
   ss.ss_size = SIGSTKSZ;
   ss.ss_flags = 0;
   sigaltstack(&ss, NULL);  // 注册备选栈
   ```  

2. **注册 `SIGSEGV` 处理器并指定使用备选栈**：  
   ```c
   struct sigaction sa;
   sa.sa_handler = sigsegv_handler;  // 自定义SIGSEGV处理器
   sigemptyset(&sa.sa_mask);
   sa.sa_flags = SA_ONSTACK;  // 关键：通知内核使用备选栈
   sigaction(SIGSEGV, &sa, NULL);
   ```  

3. **触发主栈溢出**：  
   调用无限递归函数，主栈持续增长直至溢出，内核发送 `SIGSEGV`。  

4. **备选栈生效**：  
   内核检测到 `SA_ONSTACK` 标志，在备选栈上为 `sigsegv_handler` 创建栈帧，处理器正常执行（如打印“栈溢出”信息后终止进程）。  


### 四、注意事项
1. **备选栈的独立性**：备选栈是独立于主栈的内存区域，需在主栈正常时提前分配，避免依赖主栈空间。  
2. **避免备选栈溢出**：备选栈大小有限，信号处理器应尽量精简（如仅执行打印、清理或非本地跳转），避免在备选栈上执行复杂操作导致二次溢出。  
3. **`SS_ONSTACK` 限制**：当进程正在使用备选栈（`ss_flags` 为 `SS_ONSTACK`）时，不能修改备选栈配置，否则会返回 `EPERM` 错误。  
4. **适用信号**：通常只为 `SIGSEGV` 等可能因主栈问题触发的信号设置备选栈，其他信号仍可使用主栈。  


### 总结
备选信号栈是应对“主栈溢出时信号处理器无法执行”的关键机制，通过提前分配独立内存、注册到内核并指定信号处理器使用，确保极端情况下信号仍能被处理。核心步骤为：分配内存 → 注册备选栈 → 用 `SA_ONSTACK` 标志注册处理器。这一机制显著提高了程序在栈溢出等异常场景下的健壮性和可调试性。