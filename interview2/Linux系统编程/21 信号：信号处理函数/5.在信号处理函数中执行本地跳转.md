这部分内容核心讲解了**在信号处理器函数中使用非本地跳转（non-local jump）的技术细节、问题及解决方案**，重点对比了传统 `setjmp()/longjmp()` 与 POSIX 标准的 `sigsetjmp()/siglongjmp()` 在信号掩码处理上的差异。以下是分点解读：


### 一、非本地跳转在信号处理器中的应用场景
非本地跳转（通过 `setjmp()` 保存跳转点、`longjmp()` 恢复到该点）的作用是：让信号处理器在捕获信号后，**跳过正常的函数返回流程，直接将程序控制转移到主程序的某个预设位置**。  
典型场景包括：  
- 硬件异常（如内存访问错误）后，从信号处理器跳回主程序的错误处理逻辑；  
- Shell 捕获 `SIGINT`（`Ctrl+C`）后，跳回主输入循环以读取下一条命令，而非终止程序。  


### 二、传统 `setjmp()/longjmp()` 的问题：信号掩码处理不一致
在信号处理器中使用 `longjmp()` 退出时，最大的问题是**不同 UNIX 系统对“信号掩码是否恢复”的处理不一致**，导致程序不可移植：  

#### 1. System V 一脉（包括 Linux）的行为：  
进入信号处理器时，内核会自动将“引发信号”和 `sa_mask` 中的信号添加到信号掩码（阻塞这些信号）。  
若用 `longjmp()` 退出处理器，**信号掩码不会恢复**——这些信号会保持阻塞状态。  
例如：捕获 `SIGINT` 后用 `longjmp()` 跳转，`SIGINT` 会一直被阻塞，后续 `Ctrl+C` 无法再次触发处理器，这通常不符合预期。  

#### 2. BSD 一脉的行为：  
`setjmp()` 会将当前信号掩码保存在 `jmp_buf` 中，`longjmp()` 跳转时会**恢复该信号掩码**。  
但 BSD 还提供 `_setjmp()/_longjmp()` 遵循 System V 语义（不恢复掩码），进一步增加了混乱。  

这种差异导致使用 `setjmp()/longjmp()` 的程序在不同系统上行为不一致，可移植性差。


### 三、POSIX 解决方案：`sigsetjmp()/siglongjmp()`
为解决可移植性问题，POSIX 定义了 `sigsetjmp()` 和 `siglongjmp()`，**显式控制信号掩码的保存与恢复**。  

#### 函数原型与核心区别：  
```c
#include <setjmp.h>
int sigsetjmp(sigjmp_buf env, int savesigs);  // 保存跳转点
void siglongjmp(sigjmp_buf env, int val);     // 跳回保存的跳转点
```  
- 与 `setjmp()/longjmp()` 的主要区别：  
  - `sigsetjmp()` 多了 `savesigs` 参数，控制是否保存信号掩码；  
  - 使用 `sigjmp_buf` 类型而非 `jmp_buf`，专门用于信号场景。  

#### `savesigs` 参数的作用：  
- 若 `savesigs = 1`：`sigsetjmp()` 会将当前信号掩码**保存到 `env` 中**，`siglongjmp()` 跳转时会**恢复该掩码**（解除进入处理器时阻塞的信号）。  
- 若 `savesigs = 0`：不保存/恢复信号掩码，行为类似 System V 的 `longjmp()`。  


### 四、`sigsetjmp()/siglongjmp()` 的优势与用法
#### 解决信号掩码问题：  
在 Linux 等 System V 系统中，若信号处理器用 `siglongjmp()` 跳转且 `savesigs = 1`，则会恢复进入处理器前的信号掩码，避免信号长期阻塞。  
例如：捕获 `SIGINT` 后，`siglongjmp()` 会解除 `SIGINT` 的阻塞，后续 `Ctrl+C` 可再次触发处理器。  

#### 示例逻辑：  
```c
#include <setjmp.h>
#include <signal.h>

sigjmp_buf jmp_env;       // 保存跳转环境
volatile sig_atomic_t canJump = 0;  // 守卫变量：标记env是否初始化

void handler(int signum) {
    if (canJump) {  // 确保env已初始化
        siglongjmp(jmp_env, 1);  // 跳回sigsetjmp保存的位置
    }
}

int main() {
    signal(SIGINT, handler);
    
    // 保存跳转点，savesigs=1表示保存信号掩码
    if (sigsetjmp(jmp_env, 1) == 0) {
        canJump = 1;  // 标记env已初始化
        printf("主程序运行中，按Ctrl+C测试...\n");
        while (1) pause();  // 等待信号
    } else {
        // 从信号处理器跳转回来
        printf("捕获到信号，跳回主程序处理逻辑\n");
    }
    return 0;
}
```  
- 运行逻辑：`sigsetjmp()` 保存主程序的信号掩码（初始为空），`SIGINT` 处理器触发后，`siglongjmp()` 恢复该掩码（解除 `SIGINT` 阻塞），因此后续 `Ctrl+C` 可再次触发处理器。  


### 五、使用非本地跳转的注意事项
1. **守卫变量的必要性**：  
   信号可能在 `sigsetjmp()` 初始化 `jmp_env` 之前触发，此时 `siglongjmp()` 使用未初始化的 `jmp_env` 会导致崩溃。因此需要 `canJump` 等守卫变量，确保跳转仅在 `env` 初始化后执行。  

2. **非异步信号安全风险**：  
   `longjmp()` 和 `siglongjmp()` 均不在“异步信号安全函数”列表中。若信号处理器在主程序更新敏感数据（如链表）时中断并跳转，可能导致数据结构处于不一致状态（如指针未更新完成）。解决方案：主程序操作敏感数据时，用 `sigprocmask()` 临时阻塞信号。  

3. **语义规范**：  
   SUSv3 禁止在赋值语句中调用 `setjmp()` 或 `sigsetjmp()`，需通过条件判断（如 `if (sigsetjmp(...))`）使用，避免未定义行为。  


### 总结
在信号处理器中使用非本地跳转时：  
- 传统 `setjmp()/longjmp()` 因信号掩码处理不一致，可移植性差；  
- POSIX 推荐 `sigsetjmp()/siglongjmp()`，通过 `savesigs` 参数显式控制信号掩码的恢复，解决可移植性问题；  
- 需使用守卫变量确保跳转环境初始化，并避免在主程序操作敏感数据时被信号中断，以保证程序安全。  

这一机制是信号处理中实现“灵活恢复控制流程”的关键技术，但需严格遵循规范以规避风险。