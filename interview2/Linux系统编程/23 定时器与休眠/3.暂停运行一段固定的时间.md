### 休眠函数详解：`sleep()` 与 `nanosleep()`  
进程常常需要暂停执行一段时间（休眠），Unix/Linux 提供了 `sleep()` 和 `nanosleep()` 两种核心休眠函数，分别适用于低精度和高精度场景。以下是详细解析：


### 一、低分辨率休眠：`sleep()`  
`sleep()` 是最简单的休眠函数，用于让进程暂停执行**秒级**时间，但其功能存在一定限制。  


#### 1. 函数原型与返回值  
```c
#include <unistd.h>
unsigned int sleep(unsigned int seconds);
```  
- **参数**：`seconds` 为希望休眠的秒数。  
- **返回值**：  
  - 若正常休眠完毕，返回 `0`。  
  - 若被信号中断，返回**未休眠完的剩余秒数**（例如：请求休眠5秒，3秒后被信号中断，返回 `2`）。  


#### 2. 核心特性  
- **低分辨率**：仅支持秒级精度，无法设置毫秒或纳秒级休眠。  
- **信号敏感性**：休眠过程中若收到信号（且信号处理器未终止进程），`sleep()` 会提前返回，返回值为剩余未休眠时间。  
- **实现依赖**：  
  - Linux 中 `sleep()` 基于 `nanosleep()` 实现，不依赖信号。  
  - 许多老系统（如传统 Unix）通过 `alarm()` 和 `SIGALRM` 信号实现 `sleep()`，因此与 `alarm()`/`setitimer()` 混用可能冲突（例如：`sleep()` 会覆盖 `alarm()` 设置的定时器）。  


#### 3. 可移植性问题  
SUSv3 未规范 `sleep()` 与定时器函数（`alarm()`/`setitimer()`）的交互行为，因此：  
- 避免在同一程序中混用 `sleep()` 和 `alarm()`/`setitimer()`，可能导致定时器失效或休眠异常。  
- 若需定时器与休眠共存，优先使用 `nanosleep()`。  


### 二、高分辨率休眠：`nanosleep()`  
`nanosleep()` 是更强大的休眠函数，支持**纳秒级**精度，且设计上避免了信号依赖，可移植性更好。  


#### 1. 函数原型与数据结构  
```c
#include <time.h>
int nanosleep(const struct timespec *request, struct timespec *remain);
```  
- **参数**：  
  - `request`：指向 `timespec` 结构，指定期望休眠的时间（秒 + 纳秒）：  
    ```c
    struct timespec {
        time_t  tv_sec;   // 秒
        long    tv_nsec;  // 纳秒（0 ≤ tv_nsec < 1e9）
    };
    ```  
  - `remain`：非空时，若休眠被信号中断，返回**未休眠完的剩余时间**（可用于重启休眠）。  
- **返回值**：  
  - 成功：返回 `0`（休眠完毕）。  
  - 失败：返回 `-1` 并设置 `errno`，其中 `errno = EINTR` 表示被信号中断。  


#### 2. 核心优势  
- **高精度**：支持纳秒级休眠（实际精度受系统时钟粒度限制，通常为微秒级）。  
- **无信号依赖**：SUSv3 明确规定 `nanosleep()` 不得通过信号实现，因此与 `alarm()`/`setitimer()` 混用无冲突，可移植性强。  
- **可重启性**：被信号中断后，通过 `remain` 参数获取剩余时间，可重新调用 `nanosleep()` 完成休眠（见程序清单23-3示例）。  


#### 3. 程序清单23-3解析：信号中断后重启休眠  
程序清单23-3演示了 `nanosleep()` 被信号中断后，如何通过 `remain` 参数重启休眠，确保总休眠时间达标：  

```c
#include <time.h>
#include <signal.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

// 信号处理器：仅用于中断nanosleep()
void sigint_handler(int sig) {
    printf("\n收到 SIGINT 信号，中断休眠\n");
}

int main(int argc, char *argv[]) {
    if (argc != 3) {
        fprintf(stderr, "用法：%s <秒> <纳秒>\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    // 注册 SIGINT 处理器（Ctrl+C触发）
    struct sigaction sa;
    sa.sa_handler = sigint_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;
    if (sigaction(SIGINT, &sa, NULL) == -1) {
        perror("sigaction 失败");
        exit(EXIT_FAILURE);
    }

    // 设置期望休眠时间
    struct timespec request, remain;
    request.tv_sec = atoi(argv[1]);
    request.tv_nsec = atoi(argv[2]);

    printf("开始休眠 %ld 秒 %ld 纳秒...\n", request.tv_sec, request.tv_nsec);

    // 循环休眠：若被中断则用剩余时间重启
    while (nanosleep(&request, &remain) == -1 && errno == EINTR) {
        request = remain;  // 更新请求时间为剩余时间
        printf("剩余休眠时间：%ld 秒 %ld 纳秒，继续休眠...\n", 
               request.tv_sec, request.tv_nsec);
    }

    printf("休眠完成\n");
    exit(EXIT_SUCCESS);
}
```  

**运行效果**：  
```bash
$ ./nanosleep_demo 5 0  # 休眠5秒
开始休眠 5 秒 0 纳秒...
^C  # 按下Ctrl+C发送SIGINT
收到 SIGINT 信号，中断休眠
剩余休眠时间：3 秒 123456789 纳秒，继续休眠...
休眠完成  # 剩余时间休眠完毕
```  


#### 4. 注意事项  
- **时钟粒度限制**：实际休眠时间可能比 `request` 略长，因系统时钟存在最小间隔（如10毫秒），若 `request` 小于间隔，会向上取整。  
- **高频率信号问题**：若频繁被信号中断，`remain` 可能因取整误差累积导致总休眠时间远超预期。Linux 2.6+ 可通过 `clock_nanosleep()` 解决（见23.5.4节）。  
- **`SIGCONT` 处理差异**：  
  - Linux 2.4及更早：进程因 `SIGSTOP` 暂停后，`SIGCONT` 恢复运行时，暂停时间不计入休眠，需重新计算。  
  - Linux 2.6+：暂停时间计入休眠，恢复后自动继续剩余时间。  


### 三、`sleep()` 与 `nanosleep()` 对比  
| 特性                | `sleep()`                          | `nanosleep()`                          |
|---------------------|------------------------------------|----------------------------------------|
| 精度                | 秒级（低）                          | 纳秒级（高，实际受系统限制）            |
| 信号依赖            | 部分系统依赖 `SIGALRM`              | 无信号依赖，通过内核定时器实现          |
| 与定时器交互        | 可能与 `alarm()`/`setitimer()` 冲突 | 无冲突，可安全混用                      |
| 被中断后重启        | 需手动计算剩余时间，较复杂          | 通过 `remain` 参数轻松重启              |
| 可移植性            | 较差（依赖实现）                    | 较好（SUSv3规范，无信号依赖）          |
| 适用场景            | 简单秒级休眠，无定时器混用          | 高精度休眠、需与定时器共存的场景        |  


### 总结  
- `sleep()` 适合简单的秒级休眠，代码简洁但精度低、可移植性受限。  
- `nanosleep()` 适合高精度休眠，支持中断后重启，无信号依赖，是更可靠的选择。  
- 实际开发中，优先使用 `nanosleep()` 以避免定时器冲突，确保休眠行为可控。