### `setitimer()`：创建间隔式定时器的系统调用  
`setitimer()` 是用于创建**间隔式定时器（interval timer）** 的系统调用，支持按不同时间类型（真实时间、CPU时间等）计时，到期后发送特定信号，且可设置为一次性或周期性触发。以下是详细解析：


### 一、核心功能与定时器类型  
`setitimer()` 允许进程创建3种不同类型的定时器，每种定时器基于不同的时间维度计时，到期时发送特定信号：  

| 定时器类型            | 计时维度                | 到期信号        | 说明                               |     |
| ---------------- | ------------------- | ----------- | -------------------------------- | --- |
| `ITIMER_REAL`    | 真实时间（墙上时钟时间）        | `SIGALRM`   | 按实际流逝时间倒计时，受系统休眠影响（如进程阻塞时仍会计时）。  |     |
| `ITIMER_VIRTUAL` | 进程虚拟时间（用户态CPU时间）    | `SIGVTALRM` | 仅统计进程在用户态执行的CPU时间，进程阻塞时不计时。      |     |
| `ITIMER_PROF`    | 进程总时间（用户态+内核态CPU时间） | `SIGPROF`   | 统计进程占用的所有CPU时间（用户态+内核态），常用于性能分析。 |     |


### 二、参数与数据结构  
`setitimer()` 的参数通过 `itimerval` 结构定义定时器的初始延迟和周期，函数原型如下：  
```c
#include <sys/time.h>
int setitimer(int which, const struct itimerval *new_value, struct itimerval *old_value);
```  

#### 1. 关键参数  
- **`which`**：指定定时器类型（`ITIMER_REAL`/`ITIMER_VIRTUAL`/`ITIMER_PROF`）。  
- **`new_value`**：指向 `itimerval` 结构，定义新定时器的属性（初始延迟和周期）。  
- **`old_value`**：非空时，返回之前定时器的设置（用于还原旧配置）。  


#### 2. `itimerval` 结构定义  
```c
struct itimerval {
    struct timeval it_value;    // 初始延迟：距离首次到期的时间
    struct timeval it_interval; // 周期间隔：每次到期后重新加载的时间
};

struct timeval {
    time_t      tv_sec;  // 秒
    suseconds_t tv_usec; // 微秒（1秒 = 1,000,000微秒）
};
```  

- **`it_value`**：定时器首次到期的延迟时间。若为 `(0, 0)`，则关闭当前定时器。  
- **`it_interval`**：周期间隔。若为 `(0, 0)`，定时器为**一次性**（仅到期一次）；否则为**周期性**（到期后自动以该间隔重新计时）。  


### 三、定时器工作机制  
1. **初始化**：调用 `setitimer()` 时，定时器从 `it_value` 开始倒计时。  
2. **到期触发**：倒计时至0时，发送对应信号（如 `SIGALRM`），并检查 `it_interval`：  
   - 若 `it_interval` 为 `(0, 0)`：定时器终止（一次性）。  
   - 若 `it_interval` 非0：定时器自动重置为 `it_interval` 继续倒计时（周期性）。  
3. **修改与关闭**：再次调用 `setitimer()` 可修改定时器属性；若 `new_value.it_value` 为 `(0, 0)`，则关闭定时器。  


### 四、获取定时器状态：`getitimer()`  
`getitimer()` 用于查询当前定时器的状态（无需修改设置），函数原型：  
```c
int getitimer(int which, struct itimerval *curr_value);
```  
- **`curr_value.it_value`**：返回距离下次到期的剩余时间（动态变化）。  
- **`curr_value.it_interval`**：返回周期间隔（固定，除非重新设置）。  


### 五、使用示例：创建实时定时器  
以下示例使用 `ITIMER_REAL` 创建周期性定时器，首次2秒后到期，之后每1秒到期一次，通过 `SIGALRM` 信号处理函数捕获到期事件：  

```c
#include <sys/time.h>
#include <signal.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

static volatile sig_atomic_t got_alarm = 0; // 信号标志

// SIGALRM 处理器：设置标志
void handle_alarm(int sig) {
    got_alarm = 1;
}

// 显示定时器当前状态
void display_timer_status() {
    struct itimerval curr;
    if (getitimer(ITIMER_REAL, &curr) == -1) {
        perror("getitimer 失败");
        exit(EXIT_FAILURE);
    }
    printf("剩余时间：%ld秒 %ld微秒，周期：%ld秒 %ld微秒\n",
           curr.it_value.tv_sec, curr.it_value.tv_usec,
           curr.it_interval.tv_sec, curr.it_interval.tv_usec);
}

int main() {
    struct itimerval timer;
    struct sigaction sa;
    int count = 0;

    // 注册 SIGALRM 处理器
    sa.sa_handler = handle_alarm;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;
    if (sigaction(SIGALRM, &sa, NULL) == -1) {
        perror("sigaction 失败");
        exit(EXIT_FAILURE);
    }

    // 配置定时器：首次2秒后到期，之后每1秒到期一次
    timer.it_value.tv_sec = 2;    // 初始延迟2秒
    timer.it_value.tv_usec = 0;
    timer.it_interval.tv_sec = 1; // 周期1秒
    timer.it_interval.tv_usec = 0;

    // 设置定时器
    if (setitimer(ITIMER_REAL, &timer, NULL) == -1) {
        perror("setitimer 失败");
        exit(EXIT_FAILURE);
    }

    printf("定时器启动：首次2秒后到期，之后每1秒一次（按Ctrl+C退出）\n");
    display_timer_status();

    // 循环等待信号，捕获3次后退出
    while (count < 3) {
        if (got_alarm) {
            got_alarm = 0;
            count++;
            printf("第%d次到期！", count);
            display_timer_status();
        }
        pause(); // 阻塞等待信号
    }

    printf("程序退出\n");
    return 0;
}
```  


### 六、与 `alarm()` 的关系与注意事项  
#### 1. 简化接口 `alarm()`  
`alarm()` 是创建一次性实时定时器的简化接口，仅支持 `ITIMER_REAL` 类型，到期发送 `SIGALRM`：  
```c
unsigned int alarm(unsigned int seconds); // 到期秒数，返回之前剩余时间
```  
- 调用 `alarm(0)` 可关闭现有定时器。  
- 与 `setitimer(ITIMER_REAL)` 共享同一实时定时器，二者调用会相互覆盖。  


#### 2. 关键注意事项  
- **信号处置**：定时器到期信号（`SIGALRM` 等）的默认处置是终止进程，必须提前注册处理器。  
- **继承与保留**：定时器在 `exec()` 后保留，但 `fork()` 创建的子进程不继承（子进程需重新设置）。  
- **精度限制**：定时器精度受系统时钟粒度影响，微秒级可能不精确；周期性定时器可能因系统负载延迟。  
- **可移植性**：SUSv4 已废止 `setitimer()` 和 `getitimer()`，推荐使用更灵活的 POSIX 定时器 API（如 `timer_create()`），但 `setitimer()` 仍广泛兼容。  

### 总结  
`setitimer()` 提供了灵活的间隔式定时器功能，支持按真实时间、CPU时间计时，可设置一次性或周期性触发。使用时需注意信号处理、定时器类型选择，以及与 `alarm()` 的交互。尽管 POSIX 定时器是推荐替代方案，但 `setitimer()` 仍是简单场景下的实用工具。