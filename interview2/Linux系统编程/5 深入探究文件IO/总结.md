### 5.1 原子操作和竞争条件

**原子操作**是指内核保证其所有步骤都会一次性执行完毕，期间不会被其他进程或线程中断。所有系统调用都是原子操作。原子性是避免**竞争条件**的关键。竞争条件指的是，当两个或多个进程/线程操作共享资源时，其最终结果依赖于它们获得CPU使用权的不可预测的先后顺序。

#### 以独占方式创建一个文件

一个常见的竞争条件是：先检查文件是否存在，然后再创建它。在这两个独立操作之间，另一个进程可能已经创建了该文件。

  * **非原子操作 (错误方式)**:

    1.  `open(path, O_RDONLY)` 检查文件是否存在。
    2.  如果不存在，则 `open(path, O_WRONLY | O_CREAT)` 创建文件。

  * **原子操作 (正确方式)**:
    通过在 `open()` 中同时使用 `O_CREAT` 和 `O_EXCL` 标志位。

    ```c
    fd = open("somefile", O_WRONLY | O_CREAT | O_EXCL, mode);
    ```

    这个调用将“检查文件是否存在”和“创建文件”合并为一个单一的、不可中断的原子操作。如果要创建的文件已存在，调用会直接失败，从而保证了当前进程是该文件的唯一创建者。

#### 向文件尾部追加数据

另一个竞争场景是多个进程同时向同一个日志文件的末尾追加数据。

  * **非原子操作 (错误方式)**:

    1.  `lseek(fd, 0, SEEK_END)` 将文件偏移量移到末尾。
    2.  `write(fd, buf, len)` 写入数据。
        在一个进程执行完 `lseek` 但还未执行 `write` 时，它可能被中断。此时另一个进程也执行 `lseek` 定位到相同的位置，最终导致后一个进程覆盖前一个进程写入的数据。

  * **原子操作 (正确方式)**:
    在调用 `open()` 时使用 `O_APPEND` 标志。

    ```c
    fd = open("logfile", O_WRONLY | O_APPEND);
    ```

    `O_APPEND` 标志确保了每次 `write()` 操作都会在内核层面以原子方式定位到文件末尾并写入数据，从而消除了竞争条件。

### 5.2 文件控制操作：fcntl()

`fcntl()` 是一个多功能的系统调用，用于对一个已打开的文件描述符执行各种控制操作。

```c
int fcntl(int fd, int cmd, ... /* arg */ );
```

`cmd` 参数指定了要执行的具体操作，第三个可选参数的类型和含义则取决于 `cmd` 的值。

### 5.3 打开文件的状态标志

`fcntl()` 的一个主要用途是获取或修改一个已打开文件的状态标志（这些标志通常在 `open()` 时通过 `flags` 参数设置）。

  * **`F_GETFL`**: 获取文件状态标志。
    ```c
    flags = fcntl(fd, F_GETFL);
    ```
    由于 `O_RDONLY`, `O_WRONLY`, `O_RDWR` 不是独立的比特位，需要使用 `O_ACCMODE` 掩码来判断文件的访问模式。
  * **`F_SETFL`**: 设置文件状态标志。
    此操作只能修改部分标志，如 `O_APPEND`、`O_NONBLOCK`、`O_ASYNC` 等。修改的典型步骤是：先用 `F_GETFL` 读出当前标志，然后用位操作修改它们，最后用 `F_GETFL` 写回。
    ```c
    flags = fcntl(fd, F_GETFL); // 获取当前标志
    flags |= O_APPEND;         // 添加 O_APPEND 标志
    fcntl(fd, F_SETFL, flags); // 设置新标志
    ```

### 5.4 文件描述符和打开文件之间的关系

文件描述符和打开的文件之间并非简单的一一对应关系。多个文件描述符可以指向同一个打开的文件。这涉及到内核维护的三个关键数据结构：

1.  **进程级的文件描述符表 (per-process file descriptor table)**:

      * 每个进程独有。
      * 表的索引就是文件描述符。
      * 每个表项包含一个指向系统级打开文件表的指针，以及文件描述符标志（如 `close-on-exec`）。

2.  **系统级的打开文件表 (system-wide open file table)**:

      * 整个系统唯一。
      * 表中的每个条目称为“**打开文件句柄** (open file handle)”。
      * 包含文件偏移量、文件状态标志 (`O_APPEND` 等)、文件访问模式以及一个指向 i-node 表的指针。

3.  **文件系统的 i-node 表 (file system i-node table)**:

      * 每个文件在文件系统中都对应一个 i-node。
      * 包含文件的元数据，如文件类型、权限、大小、时间戳以及数据块在磁盘上的位置。

这些关系的核心要点如下：

  * **共享文件偏移量**：如果两个文件描述符（无论是否在同一进程中）指向**同一个打开文件句柄**，它们将共享同一个文件偏移量和文件状态标志。通过一个描述符修改偏移量（如 `read`, `write`, `lseek`），另一个描述符也会看到这个变化。这种情况在 `fork()` 或 `dup()` 后发生。
  * **独立文件偏移量**：如果两个文件描述符指向**不同的打开文件句柄**，即使这些句柄最终指向同一个 i-node（即同一个文件），它们也会有各自独立的文件偏移量。这种情况发生在同一个文件被 `open()` 两次。
  * **私有标志**：文件描述符标志（如 `close-on-exec`）是与文件描述符表中的特定条目相关联的，因此是每个文件描述符**私有**的，不会互相影响。
  
  ![[Pasted image 20250904111450.png]]
### 5.5 复制文件描述符

复制文件描述符是指创建一个新的文件描述符，使其指向与现有文件描述符**相同的打开文件句柄**。这正是 shell 中 `2>&1` 重定向的实现原理：它将文件描述符2（标准错误）复制到文件描述符1（标准输出），使得两者共享同一个文件偏移量和状态，从而确保输出不会相互覆盖。

有多种系统调用可以实现此功能：

  * **`dup(int oldfd)`**:
    复制 `oldfd`，并返回一个当前未使用的、编号最低的新文件描述符。

  * **`dup2(int oldfd, int newfd)`**:
    同样复制 `oldfd`，但指定新文件描述符的编号为 `newfd`。如果 `newfd` 已经打开，`dup2()` 会在复制前先将其关闭。这是实现I/O重定向最直接的方式。

    ```c
    // 实现将标准错误重定向到标准输出 (类似 2>&1)
    dup2(1, 2);
    ```

  * **`fcntl(int oldfd, F_DUPFD, int startfd)`**:
    `fcntl` 提供了一种更灵活的复制方式，它会返回一个大于或等于 `startfd` 的、编号最低的未用文件描述符作为 `oldfd` 的副本。

  * **`dup3(int oldfd, int newfd, int flags)`** (Linux 特有):
    功能与 `dup2` 类似，但增加了一个 `flags` 参数。目前唯一支持的标志是 `O_CLOEXEC`，它可以在复制文件描述符的同时，以原子操作方式为新描述符设置 `close-on-exec` 标志。

一个核心要点是：通过这些调用创建的副本与原始文件描述符共享同一个打开文件句柄，因此它们也**共享相同的文件偏移量和文件状态标志**。但是，新文件描述符拥有自己独立的**文件描述符标志**（例如 `close-on-exec` 标志）。

### 5.6 在文件特定偏移量处的 I/O：pread()和 pwrite()

`pread()` 和 `pwrite()` 是 `read()` 和 `write()` 的变体，它们允许在文件的指定偏移量（`offset`）处进行读写，而**不使用也不改变**当前文件的偏移量。

```c
ssize_t pread(int fd, void *buf, size_t count, off_t offset);
ssize_t pwrite(int fd, const void *buf, size_t count, off_t offset);
```

  * **原子性**: `pread()` 的操作等同于将 `lseek()` 和 `read()` 合并为一个原子操作。
  * **主要用途**: 在多线程应用中非常有用。由于一个进程内的所有线程共享同一个文件偏移量，如果使用 `lseek` + `read/write` 的组合，可能会产生竞争条件。而 `pread()` 和 `pwrite()` 允许每个线程独立地在文件的任意位置进行I/O操作，而不会相互干扰。

### 5.7 分散输入和集中输出（Scatter-Gather I/O）：readv() 和 writev()

这两个系统调用允许在一次操作中与**多个非连续的内存缓冲区**进行数据传输。数据缓冲区由一个 `iovec` 结构体数组定义，每个结构体包含一个指向缓冲区的指针 (`iov_base`) 和其长度 (`iov_len`)。

#### 分散输入

**`readv()`** 从文件中读取一块连续的数据，然后按顺序将其“分散”填充到 `iovec` 数组指定的多个缓冲区中。

#### 集中输出

**`writev()`** 将 `iovec` 数组指定的多个缓冲区中的数据“集中”起来，然后作为一块连续的数据写入文件。

  * **原子性**: `readv()` 和 `writev()` 都是原子操作。这意味着，例如 `writev()` 会一次性地将所有缓冲区的数据连续写入文件，不会被其他进程或线程的写操作打断或插入。
  * **优势**:
    1.  **便捷性**: 无需手动分配一个巨大的临时缓冲区来拼接或拆分数据。
    2.  **高效性**: 执行一次系统调用比执行多次系统调用的开销要小。

#### 在指定的文件偏移量处执行分散输入/集中输出

Linux 后来新增了 `preadv()` 和 `pwritev()` 系统调用，它们结合了 `pread/pwrite` 和 `readv/writev` 的功能：即在指定的 `offset` 处执行分散输入或集中输出，同时不改变文件的当前偏移量。这对于需要进行复杂I/O的多线程应用尤其有用。

