### **56.2 创建一个 socket：socket()**

`socket()` 系统调用用于创建一个新 socket。

```c
#include <sys/socket.h>

int socket(int domain, int type, int protocol);
```

  * **`domain`**: 指定 socket 的通信 domain（例如 `AF_INET` 表示 IPv4）。
  * **`type`**: 指定 socket 类型（例如 `SOCK_STREAM` 表示流 socket，`SOCK_DGRAM` 表示数据报 socket）。
  * **`protocol`**: 对于 TCP 和 UDP，通常指定为 0，让内核选择合适的协议。
  * **返回值**: 成功时，返回一个文件描述符，用于在后续系统调用中引用这个新创建的 socket。

#### **Linux 特有标志 (自内核 2.6.27 起)**

Linux 允许在 `type` 参数中通过“或”运算加入以下两个非标准标记：

  * **`SOCK_CLOEXEC`**: 在创建 socket 的同时，原子地为其文件描述符启用 **close-on-exec** 标志 (`FD_CLOEXEC`)。
  * **`SOCK_NONBLOCK`**: 在创建 socket 的同时，原子地为其底层的打开文件描述设置 **`O_NONBLOCK`** 标记，使得后续的 I/O 操作都变成非阻塞的。

这两个标志可以避免在多线程程序中因 `socket()` 和 `fcntl()` 之间的竞态条件而产生的问题。

-----

### **56.3 将 socket 绑定到地址：bind()**

`bind()` 系统调用将一个 socket 绑定（即分配）到一个地址上。

```c
#include <sys/socket.h>

int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
```

  * **`sockfd`**: `socket()` 调用返回的文件描述符。
  * **`addr`**: 一个指向特定 domain 地址结构的指针（需要强制转换为 `struct sockaddr *`）。
  * **`addrlen`**: `addr` 结构的大小（字节）。

通常，**服务器**需要调用 `bind()` 来将其 socket 绑定到一个**众所周知**的地址上，这是一个固定的、客户端提前就知道的地址，以便客户端能够定位到服务器。

> **替代方案**: 服务器也可以不调用 `bind()` 而直接调用 `listen()`，这会导致内核为该 socket 选择一个**临时端口 (ephemeral port)**。之后服务器必须使用 `getsockname()` 来获取这个被分配的地址，并通过某种目录服务来发布它，以便客户端能够找到它。

-----

### **56.4 通用 socket 地址结构：struct sockaddr**

由于不同的通信 domain 使用不同格式的地址（`AF_UNIX` 使用路径名，`AF_INET` 使用 IP 地址和端口号），socket API 定义了一个通用的地址结构 `struct sockaddr`，以便像 `bind()` 这样的系统调用能够接受任意类型的地址结构。

这个通用结构的唯一用途是将各种 domain 特定的地址结构**强制转换**成一个统一的类型。

```c
struct sockaddr {
    sa_family_t  sa_family;     /* address family */
    char         sa_data[14];   /* socket address (family-specific) */
};
```

所有 domain 特定的地址结构（如 `sockaddr_in`, `sockaddr_un`）都遵循一个模板，即它们的第一个字段都是 `family` 字段，其类型与 `sa_family` 相同。内核通过检查这个 `family` 字段的值（如 `AF_INET`）就能确定整个结构的实际类型、大小和格式。

**使用示例 (强制转换)**:
在实际编程中，我们总是先填充一个 domain 特定的结构，然后在调用 `bind()` 等函数时将其指针强制转换为 `(struct sockaddr *)`。

```c
// 伪代码
struct sockaddr_in my_addr; // IPv4 特定的地址结构

my_addr.sin_family = AF_INET;
my_addr.sin_port = htons(80);
my_addr.sin_addr.s_addr = htonl(INADDR_ANY);
// ...

// 调用 bind() 时进行强制转换
bind(sockfd, (struct sockaddr *) &my_addr, sizeof(my_addr));
```