### **流 Socket 操作**

流 socket 的运作与电话系统非常类似，可以通过以下步骤来理解：

1.  **`socket()` - 安装电话**:
    每个应用程序都需要先调用 `socket()` 来创建一个通信端点，这等价于为自己安装一部电话。

2.  **建立连接 - 拨打和接听电话**:
    一个应用程序在通信之前，必须将其 socket 连接到另一个应用程序的 socket 上。

      * **(a) 服务器准备接听**: 服务器程序调用 `bind()` 将其 socket 绑定到一个**众所周知**的地址（相当于拥有一个公开的电话号码），然后调用 `listen()` 通知内核它愿意接受接入的连接（相当于打开电话，让它可以响铃）。
      * **(b) 客户端发起呼叫**: 客户端程序通过调用 `connect()`，并指定服务器的地址来建立连接。这类似于拨打某人的电话号码。
      * **(c) 服务器接听呼叫**: 服务器程序使用 `accept()` 来接受客户端的连接请求。这类似于在电话响起时拿起话筒。如果在客户端调用 `connect()` 之前服务器就执行了 `accept()`，那么 `accept()` 就会阻塞（即“等待电话响起”）。

3.  **数据传输与关闭 - 通话和挂断**:
    一旦连接建立，双方就可以通过 `read()`/`write()` 或 `send()`/`recv()` 进行双向数据传输（类似于通话）。当一方通信结束时，会使用 `close()` 关闭连接（相当于挂断电话）。

**流 Socket 系统调用流程 (对应原文图 56-1)**

![[Pasted image 20250918102351.png]]


#### **主动和被动 Socket**

流 socket 通常可以分为主动和被动两种：

  * **主动 Socket (Active Socket)**:
    这是 `socket()` 创建后的默认状态。一个主动 socket 可用在 `connect()` 调用中来向一个被动 socket 发起连接。执行此操作的通常是**客户端**。

  * **被动 Socket (Passive/Listening Socket)**:
    这是一个通过调用 `listen()` 被标记为允许接受接入连接的 socket。执行此操作的通常是**服务器**。

-----

#### **56.5.1 监听接入连接：listen()**

`listen()` 系统调用将 `sockfd` 引用的流 socket 标记为被动 socket，使其能够接受来自其他主动 socket 的连接请求。

```c
#include <sys/socket.h>

int listen(int sockfd, int backlog);
```

![[Pasted image 20250918102336.png]]
**注意**: 无法在一个已经连接的 socket（即已经成功执行 `connect()` 或由 `accept()` 返回的 socket）上执行 `listen()`。

##### **`backlog` 参数**

`backlog` 参数的用途是限制**未决连接 (pending connection)** 的队列长度。

  * **未决连接**: 客户端可能会在服务器调用 `accept()` 之前就调用 `connect()`。例如，服务器可能正忙于处理其他客户端。此时，这个已经到达但尚未被服务器接受的连接就是一个“未决连接”。
  * **队列**: 内核必须为这些未决的连接请求维护一个队列。`backlog` 参数就规定了这个队列的最大长度。
  * **行为**:
      * 在这个限制之内的连接请求会立即成功（从客户端的角度看）。
      * 超出这个限制的连接请求则可能会被拒绝，或者在 TCP 的情况下，客户端的 `connect()` 会被阻塞或超时。

##### **`backlog` 的限制值**

  * **`SOMAXCONN`**: SUSv3 规定，实现应通过在 `<sys/socket.h>` 中定义 `SOMAXCONN` 常量来发布 `backlog` 的上限值。
  * **Linux 上的值**: 在 Linux 上，`SOMAXCONN` 的值被定义为 **128**。但从内核 2.4.25 起，Linux 允许通过修改 `/proc/sys/net/core/somaxconn` 文件来在运行时调整这个上限。
  * **历史值**: 在最初的 BSD socket 实现中，`backlog` 的上限是 5，因此在一些较早的代码中经常可以看到 `listen(sockfd, 5)` 的写法。

#### **56.5.2 接受连接：accept()**

`accept()` 系统调用在 `sockfd` 引用的**监听流 socket** 上接受一个接入的连接。

```c
#include <sys/socket.h>

int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
```

  * **阻塞行为**: 如果在调用 `accept()` 时不存在未决的连接，那么调用就会**阻塞**，直到有连接请求到达为止。
  * **关键机制**: `accept()` 的核心是它会**创建一个新 socket**。正是这个新 socket 会与执行 `connect()` 的对等 socket（客户端）进行连接。`accept()` 调用返回的是这个**已连接的新 socket 的文件描述符**。
  * **监听 socket**: 原来的监听 socket (`sockfd`) 会保持打开状态，并且可以被用来继续接受后续的其他客户端连接。
  * **`addr` 和 `addrlen`**: 这两个参数用于返回对端 socket (客户端) 的地址。
      * `addr`: 指向一个用来返回 socket 地址的结构。
      * `addrlen`: 是一个**值-结果 (value-result)** 参数。调用前，它必须指向一个整数，该整数的值是 `addr` 缓冲区的大小；调用返回后，该整数会被内核修改为实际返回的地址结构的字节数。
      * 如果不关心客户端的地址，可以将 `addr` 和 `addrlen` 分别指定为 `NULL` 和 `NULL`。

##### **Linux 特有的 `accept4()`**

从内核 2.6.28 开始，Linux 支持一个新的非标准系统调用 `accept4()`。它与 `accept()` 相同，但增加了一个 `flags` 参数，可以原子地为**新创建的已连接 socket** 设置 `SOCK_CLOEXEC` 和 `SOCK_NONBLOCK` 标志，从而避免了额外调用 `fcntl()`。

-----

#### **56.5.3 连接到对等 socket：connect()**

`connect()` 系统调用将 `sockfd` 引用的**主动 socket** 连接到由 `addr` 和 `addrlen` 指定的**监听 socket** 上。

```c
#include <sys/socket.h>

int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
```

  * `addr` 和 `addrlen` 参数指定了服务器 socket 的地址。
  * **重试**: 如果 `connect()` 失败，SUSv3 规定，可移植的做法是先 `close()` 这个失败的 socket，然后创建一个新 socket，再重新进行连接。

-----

#### **56.5.4 流 socket I/O**

一对已连接的流 socket 在两个端点之间提供了一个双向通信信道。其 I/O 语义与管道类似。

**通信信道示意图 (对应原文图 56-3)**:
![[Pasted image 20250918103200.png]]

  * **I/O 函数**: 可以使用 `read()` 和 `write()`，或 socket 特有的 `send()` 和 `recv()` 来进行双向通信。
  * **对端关闭的处理**:
      * 如果对端应用程序 `close()` 了连接，那么本端在读取完所有缓冲数据后，再次调用 `read()` 将会返回 **0** (文件结束 EOF)。
      * 如果此时本端再试图向 socket **写入**数据，将会收到一个 **`SIGPIPE`** 信号（默认会终止进程）。如果忽略 `SIGPIPE` 信号，那么 `write()` 调用会失败，`errno` 被置为 `EPIPE`。

-----

#### **56.5.5 连接终止：close()**

终止一个流 socket 连接的常见方式是调用 `close()`。如果多个文件描述符引用了同一个 socket（例如通过 `dup()`），那么只有当所有描述符都被关闭之后，连接才会终止。


> **重要提示：关于数据可靠性**
> 调用 `close()` 只能保证本地缓冲区的数据被发送出去，但它**无法保证**对等应用程序是否已经读取或正确处理了这些数据。如果需要确保数据被成功地接收和处理，必须在应用程序中构建某种**确认协议**（例如，接收方在处理完数据后，向发送方回传一个确认消息）。
>
> `shutdown()` 系统调用为如何关闭一个流 socket 连接提供了更加精细的控制。