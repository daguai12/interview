### **56.6 数据报 socket**

数据报 socket 的运作类似于邮政系统，可以按以下步骤来理解：

1.  **`socket()` - 创建邮箱**:
    所有需要发送和接收数据报的应用程序都需要使用 `socket()` 来创建一个数据报 socket，这等价于创建一个邮箱。

2.  **`bind()` - 注册地址**:
    一个应用程序（通常是服务器）需要使用 `bind()` 将其 socket 绑定到一个众所周知的地址上，这相当于拥有一个公开的、固定的邮寄地址，以便其他应用程序（客户端）知道往哪里寄信（数据报）。

3.  **`sendto()` - 寄信**:
    一个应用程序调用 `sendto()` 来发送一个数据报。这个函数需要指定数据报要发送到的目标 socket 地址，这类似于将收信人的地址写在信封上并投递这封信。

4.  **`recvfrom()` - 收信**:
    一个应用程序调用 `recvfrom()` 来接收一个数据报。如果没有数据报到达，该调用会阻塞。`recvfrom()` 还会返回发送者的地址，这样接收方就知道是谁寄来的信，并可以在需要时进行回复。

5.  **`close()` - 弃用邮箱**:
    当不再需要 socket 时，应用程序使用 `close()` 将其关闭。

与邮政系统一样，数据报 socket 的通信是**不可靠的**：

  * 无法保证数据报一定能到达。
  * 无法保证数据报按被发送的顺序到达。
  * 同样的数据报可能会重复到达。

**数据报 Socket 系统调用流程 (对应原文图 56-4)**

![[Pasted image 20250918104251.png]]

-----

#### **56.6.1 交换数据报：recvfrom() 和 sendto()**

`recvfrom()` 和 `sendto()` 系统调用是在数据报 socket 上接收和发送数据报的核心函数。

##### **`recvfrom()`**

```c
#include <sys/socket.h>

ssize_t recvfrom(int sockfd, void *buffer, size_t length, int flags,
                 struct sockaddr *src_addr, socklen_t *addrlen);
```

  * **作用**: 从 `sockfd` 接收一条数据报，并将其存入 `buffer`。
  * **`src_addr` 和 `addrlen`**: 这两个是**结果参数**，用于返回发送该数据报的远程 socket 的地址。`addrlen` 是一个值-结果参数。如果不关心发送者的地址，可以将这两个参数都指定为 `NULL`。
  * **返回值**: 返回实际读取的字节数。
  * **重要警告：静默截断**:
    `recvfrom()` 一次只会从 socket 中读取**一条**消息。如果这条消息的实际大小超过了 `buffer` 的大小 (`length`)，那么消息中超出的部分会被**静默地截断并丢弃**。程序不会收到任何错误提示。

##### **`sendto()`**

```c
#include <sys/socket.h>

ssize_t sendto(int sockfd, const void *buffer, size_t length, int flags,
               const struct sockaddr *dest_addr, socklen_t addrlen);
```

  * **作用**: 将 `buffer` 中的数据作为一条数据报，发送到由 `dest_addr` 和 `addrlen` 指定的目标 socket 地址。
  * **无连接特性**: `sendto()` 的核心在于，每一次发送都可以指定一个不同的目标地址。这就是“无连接”的体现。

> **可移植性**: 在 Linux 上可以使用 `sendto()` 发送长度为 0 的数据报，但不是所有的 UNIX 实现都允许这样做。


#### **56.6.2 在数据报 socket 上使用 connect()**

尽管数据报 socket 是无连接的，但 `connect()` 系统调用仍然可以应用于数据报 socket。

在数据报 socket 上调用 `connect()` **并不会**像在流 socket 上那样建立一个真正的连接（例如，没有三次握手）。相反，它会导致内核**在本地记录这个 socket 的对等 (peer) socket 的地址**。经过此操作的 socket 被称为**已连接的 (connected)** 数据报 socket。

##### **“已连接”的数据报 Socket 的行为**

当一个数据报 socket 已连接之后：
1.  **发送数据**:
    * 可以使用更简单的 `write()` 或 `send()` 系统调用来发送数据报，而**无需**在每次调用时都指定目标地址。
    * 内核会自动将数据报发送到 `connect()` 时记录的那个对等地址上。
    * （注意：每次 `write()` 调用仍然会发送一个独立的、有边界的数据报。）

2.  **接收数据**:
    * 该 socket **只能**接收由 `connect()` 指定的那个对等 socket 发送来的数据报。
    * 来自任何其他地址的数据报都将被内核**过滤并丢弃**。

> **不对称性**: `connect()` 的作用对数据报 socket 是**不对称的**。上述行为只适用于调用了 `connect()` 的这一端，而另一端的对等 socket（服务器端）对此一无所知，它仍然可以自由地向任何地址发送数据报，或从任何地址接收数据报。

##### **修改和解除对等关联**
* **修改**: 可以通过再次调用 `connect()` 并指定一个**新的**对等地址来修改已连接的 socket 的关联。
* **解除**: 可以通过再次调用 `connect()`，并指定一个地址族为 `AF_UNSPEC` 的地址结构来解除对等关联关系，使 socket 恢复到未连接状态。

##### **优点**
为一个数据报 socket 设置一个对等 socket，主要有两个优势：
1.  **简化 API 调用**: 在需要向同一个对等 socket 发送多个数据报时（通常是客户端的场景），可以使用更简单的 `write()`，而无需在每次发送时都重复构建和传递目标地址结构给 `sendto()`。
2.  **性能提升**: 在一些 TCP/IP 的实现中，将数据报 socket 连接到一个对等 socket 能够带来性能上的提升。这是因为内核只需要在 `connect()` 时进行一次路由查找，而不是在每次 `sendto()` 时都进行查找。（在 Linux 上，这种性能差异通常比较微小。）