### **9.1 实际用户 ID 和实际组 ID (Real User ID and Real Group ID)**

* **核心定义**: 实际用户ID (RUID) 和实际组ID (RGID) 用来标识**进程的真正所有者**——即启动该进程的真实用户。

* **初始来源**:
    * 当一个用户登录系统时，其登录shell会从 `/etc/passwd` 文件中读取该用户记录的第三个字段（UID）和第四个字段（GID）。
    * 这两个值被分别设置为登录shell进程的**实际用户ID**和**实际组ID**。

* **继承机制**:
    * 当一个进程（如shell）创建新的子进程时，子进程会自动**继承**其父进程的实际用户ID和实际组ID。
    * 这个ID基本上一旦设定就不会改变，代表了进程发起者的身份。

---
### **9.2 有效用户 ID 和有效组 ID (Effective User ID and Effective Group ID)**

* **核心作用**: 有效用户ID (EUID) 和有效组ID (EGID) 是内核在进行**权限检查**时**实际使用**的凭证。无论是访问文件、操作IPC对象，还是向其他进程发送信号，系统都会根据这些有效ID来决定进程是否有权执行该操作。

* **特权级进程**: 当一个进程的有效用户ID为 0（即root的UID）时，它被称为**特权级进程 (privileged process)**，拥有超级用户的所有权限，能够执行一些受限制的系统调用。

* **与实际ID的关系**: 在通常情况下，进程的有效ID与其相应的实际ID是**相等**的。

* **改变方式**: 要使有效ID与实际ID不同，主要有两种方法：
    1.  通过特定的系统调用（如 `setuid()`, `seteuid()` 等）进行修改。
    2.  执行一个设置了 `set-user-ID` 或 `set-group-ID` 权限位的程序。
	
---
好的，这是对您提供的关于 "Set-User-ID 和 Set-Group-ID 程序" 这部分内容的整理和总结。

### **9.3 Set-User-ID 和 Set-Group-ID 程序**

#### 核心定义
* **Set-User-ID (setuid) 程序**：是一种特殊的可执行文件。当任何用户执行它时，所产生的进程的**有效用户ID (EUID) 会被自动设置为该文件本身的属主ID**，而不是执行者的ID。
* **Set-Group-ID (setgid) 程序**：与setuid类似，它会将被执行进程的**有效组ID (EGID) 设置为可执行文件本身的属组ID**。

#### 实现机制
* 这是通过在可执行文件上设置一个特殊的**权限位**（set-user-ID位或set-group-ID位）来实现的。
* 使用 `chmod u+s <file>` 可以添加setuid权限。
* 使用 `ls -l` 查看时，该权限位会显示为一个 `s`（取代了原来 `x` 的位置），例如 `-rwsr-xr-x`。

#### 目的与用途
其核心目的是**允许普通用户临时、受控地获得更高的权限**来执行特定任务，而无需将完整的超级用户权限赋予该用户。这是一种实现**最小权限原则**的重要机制。

1.  **获取root权限 (最常见用法)**:
    * 一个由 `root` 用户拥有的程序被设置了setuid位。当任何普通用户执行它时，进程的EUID就变为0，从而能执行特权操作。
    * **经典示例**: `passwd` 命令。普通用户执行它时，可以临时获得root权限来修改受保护的 `/etc/shadow` 文件。

2.  **获取特定用户权限 (更精细的控制)**:
    * 也可以用于非root场景。例如，创建一个专用用户`dbadmin`来管理某个数据库文件，然后编写一个属于`dbadmin`用户的setuid程序。这样，其他普通用户就可以通过执行这个程序来安全地访问数据库，而不会获得其他不必要的权限。

#### 重要说明与示例
* **安全警告**: setuid/setgid 程序功能强大，但如果编写不当，极易成为系统安全漏洞。必须谨慎设计，遵循安全编程的最佳实践。
* **对脚本无效**: 在Linux系统中，出于安全考虑，setuid/setgid对**Shell脚本是无效的**。
* **常见示例**:
    * **setuid**: `passwd` (修改密码), `mount` (挂载文件系统), `su` (切换用户)。
    * **setgid**: `wall` (向所有终端发送消息，需要 `tty` 组的权限)。

---
好的，这是对您提供的关于 "保存 set-user-ID 和保存 set-group-ID" 这部分内容的整理和总结。

### **9.4 保存 set-user-ID 和保存 set-group-ID (Saved Set-User-ID and Saved Set-Group-ID)**

#### 核心目的

保存 set-user-ID (SUID) 和保存 set-group-ID (SGID) 的核心设计目的是让一个 `setuid` 或 `setgid` 程序能够**“记住”它所获得的特权**。

这使得程序可以**临时放弃该特权，并在需要时重新获取它**，实现了权限的“收放自如”。

#### 设置机制

当一个进程通过 `exec()` 执行一个新程序时，内核会进行如下操作：

1.  **更新有效ID (Effective ID)**:
    * 如果被执行的程序文件设置了 `setuid` 位，则进程的**有效用户ID (EUID)** 被更新为**该文件所有者的ID**。
    * 如果未设置，则EUID保持不变。

2.  **更新保存ID (Saved ID)**:
    * 随后，进程的**保存 set-user-ID (SUID)** 被设置为**当前有效ID (EUID) 的值**。
    * **注意**: 这一步**总是会发生**，无论 `setuid` 位是否被设置。

#### 示例说明

这个机制的效果可以通过一个例子清晰地展示。假设一个普通用户 (UID=1000) 执行一个由 `root` (UID=0) 拥有的 `setuid` 程序：

* **执行前**:
    * 实际用户ID (Real UID) = 1000
    * 有效用户ID (Effective UID) = 1000
    * 保存用户ID (Saved UID) = 1000

* **执行后**:
    * 实际用户ID (Real UID) = 1000 *(不变，代表进程的真正主人)*
    * **有效用户ID (Effective UID) = 0** *(因为执行了root的setuid程序)*
    * **保存用户ID (Saved UID) = 0** *(从新的有效ID复制而来)*

#### 主要优势与安全实践

正是因为 `Saved UID` 保存了 `root` 的身份（0），这个进程现在可以通过 `seteuid()` 等系统调用，在其实际用户ID（1000）和保存用户ID（0）之间**自由切换其有效用户ID**。

这支持了一种非常重要的安全编程实践：**最小权限原则 (Principle of Least Privilege)**。程序只在绝对必要时才以高权限（EUID=0）运行，在执行其他非特权任务时，应将权限降至普通用户级别（EUID=实际用户ID），从而最大程度地减小安全风险。

---
好的，这是对您提供的关于 "文件系统用户ID和组ID" 这部分内容的整理和总结。

### **9.5 文件系统用户 ID 和组 ID (Filesystem User ID and Group ID)**

#### 核心定义与行为

* **Linux的特殊性**: 文件系统用户ID (FSUID) 和组ID (FSGID) 是**Linux特有**的一组凭证，专门用于进行**文件系统相关操作的权限检查**（如打开文件、修改权限等）。

* **默认行为**: 在通常情况下，FSUID的值与有效用户ID (EUID) **完全相等**。每当EUID因为执行setuid程序或通过系统调用改变时，FSUID也会自动随之改变为相同的值。因此，在大部分场景下，Linux的行为与其他UNIX系统（使用EUID进行文件权限检查）并无区别。

#### 存在原因（历史背景）

FSUID主要是出于**历史原因**而被引入，旨在解决一个早期Linux内核（2.0版本之前）存在的安全漏洞。

* **当时的场景**: 旧内核的信号发送权限规则允许一个进程向另一个EUID相同的进程发送信号。这使得NFS服务器这类需要模拟客户端身份来访问文件的程序变得很脆弱——如果服务器将自己的EUID改成客户端的ID，那么恶意客户端就可以向服务器发送信号进行攻击。

* **FSUID的解决方案**: 通过引入FSUID，NFS服务器可以保持自己的EUID为`root`（以防范信号攻击），同时仅将FSUID修改为客户端的ID，从而安全地以客户端的身份进行文件操作。

#### 现状与意义

* **现状：已过时**。自Linux内核2.0起，信号发送的权限规则被修正，遵循了POSIX标准，FSUID最初要解决的安全问题已不复存在。
* 它被保留下来仅仅是为了**保持对旧有软件的向后兼容性**。
* 在日常讨论和大多数编程实践中，可以近似地认为**有效用户ID (EUID) 决定了文件访问权限**，因为FSUID的行为在绝大多数情况下都与EUID保持一致。

---
### **9.6 辅助组 ID (Supplementary Group IDs)**

* **核心定义**:
    辅助组ID (Supplementary Group IDs) 是一个ID列表，用于标识一个进程除了其**主用户组 (Primary Group)**之外，还属于哪些**附加的用户组**。这使得一个用户可以同时拥有多个组的成员身份。

* **主要用途**:
    在进行权限检查时（如文件访问），系统会将进程的**有效组ID (EGID)** 与这个**辅助组ID列表**结合起来。只要资源的属组匹配了进程的EGID **或** 其辅助组ID列表中的任何一个，进程就能获得相应的组权限。

* **来源**:
    1.  **登录时设定**: 当用户登录时，其登录Shell会从系统组文件（如 `/etc/group`）中读取该用户所属的所有组，并设置为其辅助组ID。
    2.  **从父进程继承**: 新创建的进程会自动**继承**其父进程的辅助组ID列表。




# 代码案例


这个程序的核心目标是：**证明一个程序在启动时拥有root权限，然后展示如何用 `seteuid()` 放弃这个权限。**

我们将通过尝试读取一个只有root才能读取的文件 (`/etc/shadow`) 来验证权限的变化。

-----

### 简单示例代码 (`simple_demo.c`)

```c
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>

// 辅助函数，打印当前进程的真实和有效用户ID
void print_uids(const char* step_name) {
    printf("\n--- %s ---\n", step_name);
    printf("我的实际用户ID (Real UID)  : %d\n", getuid());
    printf("我的有效用户ID (Effective UID): %d\n", geteuid());
    printf("---------------------------\n");
}

// 尝试执行一个需要root权限的操作
void try_privileged_action() {
    FILE *fp = fopen("/etc/shadow", "r");
    if (fp) {
        printf("✅ 成功！我拥有root权限，可以读取 /etc/shadow。\n");
        fclose(fp);
    } else {
        printf("❌ 失败！我没有足够权限读取 /etc/shadow。\n");
    }
}

int main() {
    // 1. 打印初始状态
    print_uids("程序启动时");

    // 2. 尝试执行特权操作 (此时 euid=0, 应该会成功)
    try_privileged_action();

    // 3. 使用 seteuid() 放弃权限
    printf("\n>>> 现在，调用 seteuid() 放弃 root 权限...\n");
    seteuid(getuid()); // 将有效ID设置为和实际ID一样

    // 4. 再次打印状态，确认权限已改变
    print_uids("放弃权限后");

    // 5. 再次尝试特权操作 (此时 euid=普通用户ID, 应该会失败)
    try_privileged_action();

    return 0;
}
```

-----

### 如何编译和运行

这个程序**必须**被设置为 `setuid-root` 才能看到效果。

1.  **编译程序**

    ```bash
    gcc -o simple_demo simple_demo.c
    ```

2.  **设置权限 (关键步骤)**
    使用 `sudo` 更改文件的所有者为 `root`，并添加 `setuid` 权限位。

    ```bash
    # 将文件所有者改为 root
    sudo chown root simple_demo

    # 添加 setuid 权限 (s)
    sudo chmod u+s simple_demo
    ```

3.  **以普通用户身份运行**
    直接在终端里运行，**不要加 `sudo`**。

    ```bash
    ./simple_demo
    ```

### 预期输出

假设你的用户ID是 `1000`，你会看到：

```
--- 程序启动时 ---
我的实际用户ID (Real UID)  : 1000
我的有效用户ID (Effective UID): 0
---------------------------
✅ 成功！我拥有root权限，可以读取 /etc/shadow。

>>> 现在，调用 seteuid() 放弃 root 权限...

--- 放弃权限后 ---
我的实际用户ID (Real UID)  : 1000
我的有效用户ID (Effective UID): 1000
---------------------------
❌ 失败！我没有足够权限读取 /etc/shadow。
```

### 简单总结

  * **启动时**: 因为程序是 `setuid-root` 文件，所以它的**有效ID (Effective UID)** 是 `0` (root)，即使是普通用户 `1000` 运行的。这给了它临时的超级权限。
  * **放弃权限**: 调用 `seteuid(getuid())` 后，程序将自己的**有效ID**降级成了和**实际ID**一样的 `1000` (普通用户)。
  * **结果**: 权限一旦放弃，程序就再也无法执行需要root才能做的操作了。

这个过程被称为\*\*“权限丢弃” (Privilege Dropping)\*\*，是安全编程中的一个核心原则：**仅在需要时持有最高权限，完成后立即放弃**。