Linux提供了一系列丰富的系统调用来查询和修改进程的用户/组ID。这些接口源于不同的UNIX传统（如System V, BSD），因此功能上偶有重叠，并且包含少量Linux特有的扩展。

操作权限的核心是**特权级进程**（通常指EUID=0的进程），在现代Linux中，这具体对应于内核的**能力 (Capabilities)**，主要是 `CAP_SETUID` 和 `CAP_SETGID`。

---

#### **9.7.1 获取和修改实际、有效和保存设置标识**

##### **获取ID (Getting IDs)**

* **获取实际和有效ID (标准)**:
    * `getuid()` / `getgid()`: 分别返回**实际**用户ID和组ID。
    * `geteuid()` / `getegid()`: 分别返回**有效**用户ID和组ID。
    * *这些调用总是会成功。*

* **获取全部三个ID (Linux特有)**:
    * `getresuid()` / `getresgid()`: 分别返回**实际(Real)、有效(Effective)和保存(Saved)**的用户ID和组ID。
    * *注意：这是非标准的Linux扩展，不具备可移植性。*

##### **修改ID (Modifying IDs)**

修改ID的规则很大程度上取决于调用进程是否拥有特权 (EUID=0)。

**1. `setuid()` / `setgid()`**
   * **非特权进程**: 只能将自己的有效ID(EUID)设置为当前的实际ID(RUID)或保存ID(SUID)。
   * **特权进程**: 调用 `setuid(non_root_uid)` 是一个**“重量级”且不可逆**的操作。它会同时将进程的**实际、有效和保存**三个ID全部设置为 `non_root_uid`，从而**永久性地放弃所有特权**。

**2. `seteuid()` / `setegid()` (推荐的权限切换方式)**
   * **非特权进程**: 规则与 `setuid()` 相同。
   * **特权进程**: 这是一个“轻量级”且**可逆**的操作。它**只修改有效ID(EUID)**，而实际ID和保存ID保持不变（仍为0）。这意味着进程可以临时放弃权限（`seteuid(non_root_uid)`），并在需要时通过调用 `seteuid(0)` 重新获得root权限。

**3. `setreuid()` / `setregid()`**
   * **功能**: 允许独立地修改**实际ID**和**有效ID**。传入 `-1` 表示不修改某个ID。
   * **特权进程**: 可以将实际ID和有效ID设置为任意值。
   * **非特权进程**: 规则复杂，通常只能在已有的几个ID（RUID, EUID, SUID）之间进行有限的转换。

**4. `setresuid()` / `setresgid()` (Linux特有)**
   * **功能**: 这是最灵活的API，允许独立地修改**实际、有效和保存**全部三个ID。
   * **特权进程**: 可以将这三个ID设置为任意值。
   * **注意**: 功能强大，但这是**非标准的Linux扩展**，会严重影响程序的可移植性。

---

### **核心总结**

| 修改函数          | 主要影响范围            | 权限可逆性   | 可移植性        | 核心用途                 |
| :------------ | :---------------- | :------ | :---------- | :------------------- |
| `setuid()`    | **实际、有效、保存** 三个ID | **不可逆** | 标准          | **永久**放弃权限（如守护进程启动后） |
| `seteuid()`   | **仅限有效ID**        | **可逆**  | 标准          | **临时**切换权限（推荐的安全实践）  |
| `setreuid()`  | 实际ID 和 有效ID       | 取决于用法   | 标准          | 灵活修改RUID和EUID        |
| `setresuid()` | **实际、有效、保存** 三个ID | 取决于用法   | **Linux特有** | 最灵活的ID管理，但不可移植       |

---
### **9.7.2 获取和修改文件系统 ID**

#### 核心功能与上下文

* **Linux特有**: 要想**独立于**有效用户ID (EUID) 来修改文件系统用户ID (FSUID)，必须使用Linux特有的系统调用：`setfsuid()` 和 `setfsgid()`。
* **默认行为**: （需要注意的是，所有前面讨论过的、能够修改EUID的系统调用，在修改EUID的同时都会自动将FSUID更新为相同的值）。

#### 修改规则

* **特权进程 (EUID=0)**: 可以将FSUID设置为任意值。
* **非特权进程**: 只能将FSUID设置为其已有的凭证之一（如实际ID、有效ID、保存ID或当前的FSUID）。

#### 设计上的“怪癖” (Quirks)

这两个系统调用的API设计存在一些不寻常之处：

1.  **无专门的 `get` 函数**: 系统没有提供一个如 `getfsuid()` 这样直接获取当前FSUID的函数。
2.  **静默失败**: 当非特权进程尝试设置一个非法值时，调用会**静默地失败**，不做任何提示，也不会通过返回-1并设置 `errno` 来报告错误。
3.  **特殊的返回值**: 无论调用成功与否，这两个函数的返回值**总是修改前的FSUID（或FSGID）值**。

这个特殊的返回值特性也提供了一种间接获取当前FSUID的方法：即调用 `setfsuid()` 并检查其返回值。

#### 使用建议：避免使用

* **已非必要**: 由于FSUID本身是因历史原因而存在的，其最初要解决的安全问题在现代Linux内核中已不复存在，因此在功能上**已非必要**。
* **影响可移植性**: 因为它们是**非标准的、Linux特有的**调用，为了保证应用程序能够移植到其他UNIX系统上，应当在设计时**避免使用**这两个函数。

---
### **9.7.3 获取和修改辅助组 ID**

#### **获取辅助组ID (`getgroups`)**

* **功能**:
    `getgroups()` 系统调用用于获取当前进程的**辅助组ID列表**。

* **使用方法**:
    1.  调用者需要预先分配一个 `gid_t` 类型的数组 (`grouplist`) 来存放结果。
    2.  `gidsetsize` 参数指定了这个数组的大小（能容纳多少个ID）。
    3.  成功时，函数返回实际获取到的组ID数量。

* **处理数组大小**:
    * **固定大小**: 最简单的方法是使用 `<limits.h>` 中定义的常量 `NGROUPS_MAX` 来声明数组，该常量定义了进程能拥有的最大组数量（在现代Linux中通常是65536）。
    * **动态获取**: 更灵活的方法是先调用 `getgroups(0, NULL)`。这个特殊的调用会返回当前进程实际拥有的组数量，然后可以根据这个数量动态分配所需大小的数组。

#### **修改辅助组ID (仅限特权进程)**

只有特权级进程（通常是EUID=0的进程）才能修改自己的辅助组ID列表。

* **`setgroups()`**:
    * **功能**: 用一个全新的组ID列表 (`grouplist`) **替换**掉当前进程原有的整个辅助组ID列表。

* **`initgroups()`**:
    * **功能**: 这是一个用于**初始化**辅助组ID列表的便捷函数。它会扫描 `/etc/group` 文件，找出指定用户 (`user`) 所属的所有组，并将它们设为进程的辅助组ID。
    * **附加组**: 同时，它还会将 `group` 参数指定的组ID也添加到这个列表中。
    * **主要用途**: 主要由像 `login` 这样的程序使用。在用户登录后、启动shell之前，`login` 程序会调用 `initgroups()` 为用户的会话设置正确的组身份。

#### **可移植性**

虽然 `setgroups()` 和 `initgroups()` 没有被正式纳入SUSv3 (POSIX) 规范，但它们在几乎所有的UNIX实现中都得到了广泛支持，因此具有很好的事实可移植性。

---
### **9.7.4 修改进程凭证的系统调用总结**

本节内容通过一个总览表和补充说明，对用于修改进程凭证的各种API进行了全面总结。核心要点在于区分**特权进程**和**非特权进程**的不同行为，并注意各个函数的可移植性。

#### **各类修改函数的精要**

* **`setuid()` / `setgid()`**
    * **核心用途**: **永久性**地改变进程身份。
    * **对特权进程**: 调用 `setuid(non_root_uid)` 会同时修改**实际、有效和保存**三个ID，是一个**不可逆**的权限放弃操作。
    * **可移植性**: POSIX标准，但在BSD系统上有行为差异。

* **`seteuid()` / `setegid()` (推荐)**
    * **核心用途**: **临时性**地改变进程的有效权限。
    * **对特权进程**: **只修改有效ID**，由于保存ID不变（仍为0），进程可以随时恢复特权，是**可逆**的。这是安全编程中进行权限切换的首选。
    * **可移植性**: POSIX标准，广泛支持。

* **`setreuid()` / `setregid()`**
    * **核心用途**: 独立地修改**实际ID**和**有效ID**。
    * **复杂性**: 其行为规则较为复杂，尤其对于非特权进程，不同系统的实现可能不同。它也能影响到保存ID。
    * **可移植性**: POSIX标准，但细节行为需注意。

* **`setresuid()` / `setresgid()`**
    * **核心用途**: 最灵活的API，可以独立修改**实际、有效和保存**全部三个ID。
    * **可移植性**: **Linux特有，不可移植**。除非确定只在Linux上运行，否则应避免使用。

* **`setfsuid()` / `setfsgid()`**
    * **核心用途**: 唯一能独立于有效ID来修改文件系统ID的方法。
    * **可移植性**: **Linux特有，不可移植**，且在现代系统中已非必要。

* **`setgroups()`**
    * **核心用途**: 修改进程的辅助组ID列表。
    * **权限**: 只有特权进程才能调用。
    * **可移植性**: 非POSIX标准，但事实상所有UNIX系统都支持。

![[Pasted image 20250908162559.png]]
#### **关键补充规则总结**

1.  **文件系统ID (FSUID) 跟随有效ID (EUID)**: 这是一个重要的隐式规则。**任何修改EUID的调用（`setuid`, `seteuid`, `setreuid`, `setresuid`）都会自动将FSUID也修改为新的EUID值**。

2.  **保存ID (Saved ID) 的隐式修改**:
    * glibc库实现的 `setegid()` 在特定情况下会修改保存组ID。
    * `setreuid()` 在修改实际ID或将有效ID改为与原实际ID不同的值时，也会更新保存ID。
    * 这些是细微但关键的行为，可能影响权限恢复的逻辑。

3.  **可移植性是关键考量**: 在编写需要跨平台运行的程序时，应优先使用 `seteuid()` 等SUSv3/POSIX标准函数，并避免依赖 `setresuid()` 等Linux特有功能或特定实现的行为。