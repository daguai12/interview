以下说法中错误的是（）

```
类必须提供一个构造函数；

默认构造函数没有形参；
```

- #### 什么是默认构造函数？

　　**默认构造函数是可以不用实参进行调用的构造函数，它包括了以下两种情况：**

1. **没有带明显形参的构造函数。**
2. **提供了默认实参的构造函数。**   

　　**类设计者可以自己写一个默认构造函数。编译器帮我们写的默认构造函数，称为“合成的默认构造函数”。强调“没有带明显形参”的原因是，编译器总是会为我们的构造函数形参表插入一个隐含的this指针，所以”本质上”是没有不带形参的构造函数的，只有不带明显形参的构造函数，它就是默认构造函数。**



- #### 默认构造函数什么时候被调用？

　　　**如果**定义一个对象时没有提供初始化式，就使用默认构造函数。例如：

```c++
class A {
public:
    A(bool _isTrue= true, int _num=10){ isTrue = isTrue; num = _num; }; //默认构造函数
    bool isTrue;
    int num;

};
int main() {
    A a; //调用类A的默认构造函数
}
```

- #### 理解“被需要”这三个字

　　**前面提到在《Effective C++》中指出惟有默认构造函数”被需要“的时候编译器才会合成默认构造函数。关键字眼是”被需要“。被谁需要?做什么事情？像下面这段代码，默认构造函数”被需要“了吗？**

```c++
class A {
public:
    bool isTrue;
    int num;
};
int main() {
    A a;
    if (a.isTrue)
        cout << a.num;
    return 0;
}
```

**你可能认为这里定义类对象a的时候没有提供参数且A没有定义默认构造函数，编译器肯定是合成了一个默认构造函数并调用它来初始化A的数据成员，实则不是。当你试图查看合成默认构造函数把数据成员num初始化为什么值的时候，你会发现编译器甚至都让你运行不了程序：**

```
error C4700: 使用了未初始化的局部变量a
```

**当类只含有内置类型或复合类型的成员时，编译器是不会为类合成默认构造函数的，这种类并不符合”被需要“的条件，甚至当类满足“被需要”条件，编译器合成了默认构造函数时，类中内置类型与复合类型数据成员依然不会在默认构造函数中进行初始化。Primer中也有提到：“如果类包含内置或复合类型的成员，则该类不应该依赖于合成的默认构造函数“。**

　 **上面代码中，默认构造函数”被需要“是对程序来说的，程序需要isTrue被初始化以便可以进行条件判断，需要num被初始化以便可以输出。然而这种需要并不会促使编译器合成默认构造函数。惟有被编译器所需要时，编译器才会合成默认构造函数。那怎样的类才是编译器需要合成默认构造函数的呢？**

　　**总结：**

1. 　**合成默认构造函数总是不会初始化类的内置类型及复合类型的数据成员。**
2.  　**分清楚默认构造函数被程序需要与被编译器需要，只有被编译器需要的默认构造函数，编译器才会合成它。**

- #### **何时默认构造函数才会被编译器需要？**

　　**以下四种情况的类，编译器总是需要默认构造函数完成某些工作：**





**1. 含有类对象数据成员，该类对象类型有默认构造函数。**

　　**如果一个类没有任何构造函数，但是它含有一个类对象数据成员，且该类对象类型有默认构造函数，那么编译器就会为该类合成一个默认构造函数，不过这个合成操作只有在构造函数真正需要被调用的时候才会发生。举个例子，编译器将为类B合成一个默认构造函数：**

```c++
class A
{
public:
    A(bool _isTrue=true, int _num = 0){ isTrue = _isTrue; num = _num; }; //默认构造函数
    bool isTrue;
    int num;

};
class B
{
public:
    A a;//类A含有默认构造函数
    int b;
    //...
};
int main()
{
    B b;    //编译至此时，编译器将为B合成默认构造函数
    return 0;
}
```

## 2.基类带有默认构造函数的派生类。

## 3. 带有虚函数的类

## 4.带有虚基类的类

**编译器需要默认构造函数的四种情况，总结起来就是:**

**a)  调用对象成员或基类的默认构造函数。**

**b)  为对象初始化虚表指针与虚基类指针。**





---

AVL树是平衡二叉查找树，在AVL树中任何节点的两个子树的高度最大差别为1，现有一结点序列（100，70，50，80，90，60），逐个插入一颗空的AVL树，插入过程中，树不断调整，则在上述情境下，分析正确的是（树中插入90时，破坏平衡了，需要将90变为100和80的父节点 ）

90的发现者的在最低点祖先节点，100的左子树的右边，故是LR调整，先右单旋，再左单旋，
原来为:

​          100

​         /

​        80

​           \

​            90

失衡最小祖先为100，故先80(100的子树)右旋调整，变为 

​    100

​    /

  90

  /

80

失衡最小祖先为100，故先90(100的子树)左左旋为

​     90
​    /  \

   80   100

---

分页存储管理将进程的逻辑地址空间分成若干个页，并为各页加以编号，从0开始，若某一计算机主存按字节编址，逻辑地址和物理地址都是32位，页表项大小为4字节，若使用一级页表的分页存储管理方式，逻辑地址结构为页号（20位），页内偏移量（12位），则页的大小是（4KB ）？页表最大占用（4MB ）？

（这姑且算一个高频的考点的好吧）

### 解析：

某计算机主存按字节编址，逻辑地址和物理地址都是32位，**页表项大小为4B**，请回答下列问题

（1）若使用一级页表的分页存储管理方式，逻辑地址结构为

| 页号（20位） | 页内偏移量（12位） |
| ------------ | ------------------ |
|              |                    |

**问：页的大小是多少字节？页表最大占用多少字节？**

先说答案再分析：

页的大小=页内偏移量的大小=2^12B=4KB

页表项个数=2^20

页表占用字节=(2^20)*4B=4MB

分析：

页的大小为什么等于页内偏移量的大小？

这个应该很好理解吧，寻址的时候，需要页号和页内偏移量，类比楼层和房间，我要找3楼的1号房；

那么3楼一共有多少房间呢？房间号加起来就是房间数，就得到总共有多少房间。

页表项个数为什么等于页号个数？

页表是干嘛的呀？配置页表过后，通过查页表，就能找到每页在内存中的物理块号，页表的作用是实现从页号到物理块号的地址映射。现在题目告诉了页号是20位的，其实就是2^20 物理块，因为20位就对应这么多物理块；而我们的页表中的一个页表项就可以代表一个物理块，那么就需要2^20个页表项。

 

（2）采用（1）中的分页存储管理方式，一个代码段的起始逻辑地址为0000 8000H, 其长度为8KB被装载到从

物理地址0090 0000H开始的连续主存空间中。页表从主存 0020 0000H 开始的物理地址处连续存放，如下图所示（地址大小自下向上递增）。请计算处该代码段对应的两个页表项的物理地址，这两个页表项中的页框号，以及代码页面2的起始物理地址

![img](https://img-blog.csdnimg.cn/20200924180607617.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N5aDY2NjIzMw==,size_16,color_FFFFFF,t_70)

先说答案：

代码段长度8KB=2个页

逻辑地址0000 8000H  转换为二进制0000 0000 0000 0000 1000 0000 0000 0000 0000 B，由于采用的是（1）中的分页存储管理方式，故后12位是页内偏移量，则代码段对应的两个页号为00008H,00009H

8号页表项物理地址=0020 0000H +8*4=0020 0020H 

9号页表项物理地址=0020 0000H +9*4=0020 0024H

页框号代表真正的物理地址，而页框大小和页面大小是4KB,12位，逻辑地址和物理地址都是32位的

那么页框号就是20位的，已知页框号1的物理地址 0090 0000H，就有页框号1=00900H，而连续存放这个条件

就能得到页框号2=00901H

物理地址3指向的是代码页面2的起始位置，所以页内偏移量是没有的，直接补上3个0

即物理地址3=0090 1000H






---

### 第一题

`牛牛有一个特殊的硬币，它有百分之p的概率正面朝上，否则反面朝上。牛牛现在有2*n个数字a[1]~a[2*n]， 要把这2*n个数字分成n组，每组2个数字。然后对于每一组，牛牛会投掷他这个特殊的硬币，如果硬币正面朝上，牛牛会将答案加上这组两个数中较大的那个数，否则牛牛会将答案加上这组两个数中较小的那个数。现在问你怎么分组，能使牛牛最后的得到的答案的期望最大。请输出这个最大期望。`

要用 unsigned long long 或者写高精度就行了

p >= 50 就排序后 0 和 n-1，1 和 n-2 分组

p < 50 就排序后 i 和 i + 1 分组

```c++
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;
int main(){
    unsigned long long n,p,x,s1=0,s2=0,s3=0,s4=0,ans=0;
    vector<long long> v;
    cin>>n>>p;
    n*=2;
    for(int i=0;i<n;i++){
        cin>>x; v.push_back(x);
    }
    sort(v.begin(),v.end());
    for(int i=0;i<n/2;i++) s1+=v[i];
    for(int i=n/2;i<n;i++) s2+=v[i];
    for(int i=0;i<n;i++){
        if(i%2==0) s3+=v[i];
        else s4+=v[i];
    }
    if(p>=50){
        ans+=p*s2;
        ans+=(100-p)*s1;
    }
    else{
        ans+=p*s4;
        ans+=(100-p)*s3;
    }
    if(ans%100==0) cout<<ans/100;
    else{
        cout<<ans;
        cout<<"%";
    }
}
```



---

### 第二题

牛牛刚刚学了二叉树和最短路
他现在很好奇，对于一棵完全二叉树(对于有孩子的节点i，其左孩子为![img](https://www.nowcoder.com/equation?tex=2%20%5Ctimes%20i)，右孩子为![img](https://www.nowcoder.com/equation?tex=2%20%5Ctimes%20i%2B1))，给定的两个点之间的最短路的长度是多少

我们认为相邻两点之间的距离为1

```c++
#include<iostream>
using namespace std;
int main(){
    int t,a,b;
    cin>>t;
    while(t--){
        cin>>a>>b;
        int ans=0;
        while(a!=b){
            if(a>b) a/=2;
            else b/=2;
            ans++;
        }
        cout<<ans<<endl;
    }
}
```

