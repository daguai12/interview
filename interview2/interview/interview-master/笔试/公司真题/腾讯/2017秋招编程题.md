### 第一题

（题目有一些过于难了啊啊啊）

假定一种编码的编码范围是a ~ y的25个字母，从1位到4位的编码，如果我们把该编码按字典序排序，形成一个数组如下： a, aa, aaa, aaaa, aaab, aaac, … …, b, ba, baa, baaa, baab, baac … …, yyyw, yyyx, yyyy 其中a的Index为0，aa的Index为1，aaa的Index为2，以此类推。 编写一个函数，输入是任意一个编码，输出这个编码对应的Index.

##### **输入描述:**

```
输入一个待编码的字符串,字符串长度小于等于100.
```

##### **输出描述:**

```
输出这个编码的index
```

##### **输入例子1:**

```
baca
```

##### **输出例子1:**

```
16331
```

题目还是有依据的：

五笔的编码范围是a到y的25个字母，从1位到4位的编码，

如果将五笔的编码按字典序排序，形成数组如下：a, aa, aaa, aaaa, aaab, aaac, ..., b, ba, baa, baaa, baab...yyyx, yyyy

\-------------

不过还是有些难懂，这个字典序

首先可以分成25个大块，每块是以字母a-y开头（不是x是叉，代表空，不满四个字符）

<img src="https://uploadfiles.nowcoder.com/images/20170725/3913740_1500946166076_27928B54457DD4AAA54A0C7EFD580FB8" alt="img" style="zoom: 25%;" />

<img src="https://uploadfiles.nowcoder.com/images/20170725/3913740_1500946198664_F2E723C26A859B64F97569C099521633" alt="img" style="zoom:25%;" />

第一大块包含多少个呢？如果长度是4，说明都不包含空（x）第一位已经确定，就是a还有三位可选（选25个字母之一），就是`25*25*25`，长度是3说明有一个空，25*25,长度为2，两个空只剩一个位置可以是25个字母中任意一个，25，长度是1，那就只有a自己了。所以一共是 ` 25^3+25^2+25+1`

\--------

例：bcd

第一位是b所以处在第二大块，`result += 1 * (25^3+25^2+25+1) `

第二位是c， `result += 2 *（25^2+25+1）+1`

第三位是d， `result += 3* （25+1）+1 ` （加一是因为最前面有个空）

第四位是空，不管，因为空就是第一个

result = 17658

\--------

例：defc

第一位是d所以处在第四大块，`result += 3 * (25^3+25^2+25+1) `

第二位是e，` result += 4 *（25^2+25+1）+1`

第三位是 f， `result += 5* （25+1）+1`

第四位是c，` result += 2* （1）+1`

result = 51567



```c++
#include <bits/stdc++.h>
using namespace std;
int main() {
    string str;
    cin >> str;
    int n = str.length();
    int result = 0;
    for (int i = 0; i < n; ++i, ++result) {       
        int d = str[i] - 'a';      
        for(int j = 0; j < 4 - i; ++j){
            result += d * pow(25, j);
        }
    }
    cout << result - 1;
    return 0;
}
```





### 第二题

[编程题]游戏任务标记

时间限制：C/C++ 1秒，其他语言2秒

空间限制：C/C++ 32M，其他语言64M

游戏里面有很多各式各样的任务，其中有一种任务玩家只能做一次，这类任务一共有1024个，任务ID范围[1,1024]。**请用32个unsigned int类型来记录着1024个任务是否已经完成**。初始状态都是未完成。 输入两个参数，都是任务ID，需要设置第一个ID的任务为已经完成；并检查第二个ID的任务是否已经完成。 输出一个参数，如果第二个ID的任务已经完成输出1，如果未完成输出0。如果第一或第二个ID不在[1,1024]范围，则输出-1。

##### **输入描述:**

```
输入包括一行,两个整数表示人物ID.
```

##### **输出描述:**

```
输出是否完成
```

##### **输入例子1:**

```
1024 1024
```

##### **输出例子1:**

```
1
```



如果只是只是为了输入输出正确，就算过了测试用例，估计到时候复审的时候依旧是gg

## 题解

在题目中，要求我们用 32 个 unsigned int 类型来记录 1024 个任务，这就相当于让我们用位图的方式来记录。因为 32*32 = 1024 个 bit 位，用 one-hot 的形式表示就有 1024 种表示方法。假设我们就用最简单的 000...01 对应 1 ，000...10 对应 2 这种方法。然后我们要解决的问题就是找到十进制数转为位图编码后对应的 1 的位置在哪。因为我们是以 unsigned int 的形式来存储的，我们需要先定位它在数组中的哪个整数中，再定位那个整数中的位置，最后再在那个位置添加 1 并且不改变其它位置的值。详细的步骤如下：

定位数组编号：index = id/32

定位整数中的位置：pos = id%32 （也可以这么写 id & 31, 但是 32 这个位置的值必须是 2 的幂）

转为 one-hot 形式： 1 << (pos-1) 相当于 2^pos-1^

在那个位置添加 1 并且不改变其它位置的值：对那个位置的整数做或运算就可以了。

实现的代码如下所示：

```c
#include <stdio.h>
#include <string.h>
int main(){
    int id1,id2;
    scanf("%d %d",&id1,&id2);
    unsigned int tasks[32];
    memset(tasks,0,sizeof(tasks));
    if(id1 >= 1 && id1 <= 1024 && id2 >= 1 && id2 <= 1024){
        int index1 = id1/32;
        int pos1 = id1%32;
        int onehot = 1<<(pos1-1);
        tasks[index1] |= onehot;

        int index2 = id2/32;
        int pos2 = id1%32;
        int onehot2 = 1<<(pos2-1);
        if ((tasks[index2] & onehot2) == onehot2)
            printf("%d",1);
        else
            printf("%d",0);
    }else
        printf("%d",-1);
    return 0;
}
```



---



### 第三题

给定一个正整数，编写程序计算有多少对质数的和等于输入的这个正整数，并输出结果。输入值小于1000。
如，输入为10, 程序应该输出结果为2。（共有两对质数的和为10,分别为(5,5),(3,7)）

##### **输入描述:**

```
输入包括一个整数n,(3 ≤ n < 1000)
```

##### **输出描述:**

```
输出对数
```

##### **输入例子1:**

```
10
```

##### **输出例子1:**

```
2
```

```c++
#include <bits/stdc++.h>
using namespace std;
int main() {
    //筛选法求素数（删除所有素数的倍数）
    vector<int> v(1000,1);
    for(int i=2;i<1000;++i){
        for(int j=2;i*j<1000;++j){
            if(v[i]){
                v[i*j]=0;
            }
        }
    }
    int x;
    cin>>x;
    int res=0;
    for(int i=2;i<=x/2;++i){
        if(v[i]&&v[x-i]) ++res;
    }
    cout<<res<<endl;   
    
    return 0;
}
```





### 第四题

---

都是非常灵活的题目，稍微有一些不是很适应是吧

**所得编码位数为6**

geohash编码：geohash常用于将二维的经纬度转换为字符串，分为两步：第一步是经纬度的二进制编码，第二步是base32转码。
此题考察纬度的二进制编码：算法对纬度[-90, 90]通过二分法进行无限逼近（取决于所需精度，本题精度为6）。注意，本题进行二分法逼近过程中只采用向下取整来进行二分，针对二分中间值属于右区间。算法举例如下： 针对纬度为80进行二进制编码过程：
1) 区间[-90, 90]进行二分为[-90, 0),[0, 90]，成为左右区间，可以确定80为右区间，标记为1；
2) 针对上一步的右区间[0, 90]进行二分为[0, 45),[45, 90]，可以确定80是右区间，标记为1；
3) 针对[45, 90]进行二分为[45, 67),[67,90],可以确定80为右区间，标记为1；
4) 针对[67,90]进行二分为[67, 78),[78,90]，可以确定80为右区间，标记为1；
5) 针对[78, 90]进行二分为[78, 84),[84, 90]，可以确定80为左区间，标记为0；
6) 针对[78, 84)进行二分为[78, 81), [81, 84)，可以确定80为左区间，标记为0；



##### **输入描述:**

```
输入包括一个整数n,(-90 ≤ n ≤ 90)
```

##### **输出描述:**

```
输出二进制编码
```

##### **输入例子1:**

```
80
```

##### **输出例子1:**

```
111100
```

```c++
#include<iostream>
#include<string>
using namespace std;
string s = "";
void bi(int l, int r, int v){
    int cnt = 6;
    while(l < r && cnt--){
        int mid = (r + l)/2;
        if(v >= mid) {s += '1'; l = mid;}
        else {s += '0'; r = mid;}
    }
}

int main(){
    int n; scanf("%d", &n);
    bi(-90, 90, n);
    cout<<s<<endl;
    return 0;
}
```

