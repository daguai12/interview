### 机试

一堆单选题，两个填空题，两个编程题（用暴力法都可以过，但是题目中有空间复杂度和时间复杂度的要求，需要优化），一道服务器开发的简答题（

### 线下

？？？1.一颗二叉树，最浅的叶子和最深的叶子深度相差为1，且该树由4665个节点构成，则这棵二叉树**叶子结点**至少有 \__个，最多有\____ 个  

2.程序运行的结果？

```c++
char a[][5] = {"abc", "ijk", "defg", "opq"};
char* p = &a[1][1];
printf("%d,%s,%s", a[2] - a[0], &p[1], &p[5]);
```

10,k,efg

分析：a[2] - a[0] = 10, &p[1]-> &(*(p + 1)) 转换为char\*指针，%s输出

&p[5] = &(*(p + 5))



​		   a

a[0]	abc\0\0

a[1]	ijk\0\0

a[2]	defg\0

a[3]	opq\0\0



3.一颗二叉树画在透明胶片上，每个节点有不同的颜色。当甲方拿到胶片时，写下中序遍历到结果为：白绿蓝粉紫黑橙金  

当乙拿到胶片的时候，**误把胶片拿反了**（左右颠倒？根右左），他写下了前序遍历的结果为：粉橙金紫黑白蓝绿

则此树的后序遍历的结果应该是__

4.栈



### 简答题

1.C/C++中宏函数和inline函数有什么区别，两者相较有什么优劣？

#### 优点：

1. inline定义的内联函数，函数代码被放入**符号表**中，在使用时进行替换（内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度），效率很高。

2. 类的内联函数也是函数。编绎器在调用一个内联函数，首先会检查参数问题，保证调用正确，像对待真正函数一样，消除了隐患及局限性。内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。 

3. inline可以作为类的成员函数。在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。

4. 内联函数在运行时可调试，而宏定义不可以。

#### 缺点：


1. 代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大（比如函数体内有循环），那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。这种情况编译器可能会自动把它作为非内联函数处理。
2. inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接。
3. 是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。

2.C++为什么把源码分为头文件和源文件？

上世纪70年代初，C语言初始版本被设计出来时，是没有头文件的。这一点与后世的Java只有 .java 文件，C#只有 .cs 文件很相似。即使是现代的C编译器，头文件也不是必须的。

```c++
// alpha.c
int main() {
    print_hello();
}
```



```c++
// beta.c
void print_hello() {
    puts("hello");
}
```

上例只有两个源文件，alpha.c 与 beta.c 。其中 alpha.c 使用了一个自定义函数 print_hello ，beta.c 中使用了标准库函数 puts 。注意：alpha.c 与 beta.c 都没有包含任何头文件。

```
clang -o program alpha.c beta.c
```

这样会得到一个名为 program 的可执行文件，并且它可以正常工作。

以 beta.c 为例：当 beta.c 被编译时，编译器解析到名为 puts 的符号，虽然它是未定义的，但从语法上可以判断 puts 是一个函数，故而将其认定为函数，作为外部符号等待链接就可以了（倘若 alpha ，beta 是 C++ 源文件，编译无法通过，这个后文会做解释）。

“编译”与“链接”流程图：

```
alpha.c -> alpha.obj
                            \
                             program.exe
                            /
beta.c  -> beta.obj
```



其实这是上世纪60、70年代各语言的“套路”做法，因为各个 obj 文件可能并不是同一种语言源文件编译得到的，它们可能来自于 C，可能是汇编、也可能是 Fortran 这样与 C 一样的高级语言。即是说“编译”、“链接”的流程其实是这样的：

```
alpha.c    -> alpha.obj
                                \
beta.asm -> beta.obj     --> program.exe
                                /
gamma.f -> gamma.obj
```

所以，编译阶段C源文件（当然也包括其它语言的源文件）是不与其它源文件产生关系的，因为编译器（这里指的是狭义的编译器，不包括链接器）本身有可能并不能识别其它源。

说到这里，定然有人要问：连函数参数和返回值都不知道，直接链接然后调用，会不会出现问题。答案是：不会，至少当时不会。因为当时的C只有一种数据类型，即“字长”（同时代的大多数语言也一样）。

我们考虑这样一个函数调用：

```text
n = add(1, 2, 3, 4);
```

[1] 首先，add函数的调用者，将4个参数自右向左压入栈，即是说压栈完成后 1 在栈顶，4在栈底；[2] 然后，add被调用，对于被调用者（也就是 add）而言，栈长度是不可知的，但第一个参数在栈顶，往下一个字长就是第二个参数，以此类推，所以栈长度不可知并不会带来问题；[3] add 处理完成后，将返回值放入数据寄存器，并返回；[4] 调用者弹栈，因为压栈操作是调用者实施的，故而栈长度、压栈前栈顶位置等信息调用者是可知的，可以调用者有能力保持栈平衡。

> 这里说一个题外话：倘若 调用者 压栈的参数不够，那会如何？答案是 被调用者 会在栈上读到垃圾数据；又问：倘若 被调用者 没有返回值，那会如何？答案是 调用者 会在寄存器得到垃圾数据；再问：如此在代码维护上不会有问题吗？答案是从后来的实践上看，问题不大，其实可以对比下如今python、lua等弱类型语言。

通过上面的论述，我们得知C语言设计之初是没有头文件的，调用某个函数也不需要提前声明。

不过好景不长，后来出现了不同的数据类型。例如出于可移植性和内存节省的考虑，出现了 short int 、long int ；为了加强对块处理的 IO 设备的支持，出现了 char 。如此就带来了一个问题，即函数的调用者不知道压栈的长度。例如有函数调用：

```text
add(x, y);
```

调用者知道 add 是一个函数，也知道需要将 x、y 压栈，但应该是先压2个字节、再压4个字节喃，还是先压4个字节，再压2个字节喃；还是连续压2个4字节喃？

> 这里需要说明一下，在上世纪80年代intel 8084系的处理器普及以前，并没有公认的“字节(byte)”概念，以上只是我举例方便。

紧接着结构体等特性陆续引入，问题变得更复杂。在这种情况下，函数调用需要提前声明，以便让调用者得知函数的参数与返回值尺寸（结构体使用也需要提前声明，以便让调用者知道其成员、尺寸、内存对其规则等，这里不赘述了）。

于是，头文件就出现了。这里有人可能就会问了：为什么在编译一个源文件时，不去其它源文件查找声明，就如后世的Java、C#一样。主要原因上文已经说过：C源文件在编译时不与其它源产生关系，因为其它源可能根本就不是C；此外使用 include 将声明插入到源文件中，技术实现毕竟很简单，也可以说是一种技术惯性。

又后来出现了C++，由于函数重载、模板等特性，当编译器识别到一个函数，不仅是参数与返回值尺寸，连调用哪一个函数都无法从函数名辨别了（即上文的“倘若 alpha ，beta 是 C++ 源文件，编译无法通过，这个后文会做解释”一语）。函数与数据结构需要提前声明才能使用更是不可或缺。







### 编程题一

给定一个乱序的整数数组，找出其中3个乘积最大的元素。输出到屏幕。

（时间复杂度越低则分越高）

函数原型：

`void FindMax(int* pArray, int nCount)`

```c++
void FindMax(int* pArray, int nCount) {
    
    
}
```



方法一：排序
首先将数组排序。

如果数组中全是非负数，则排序后最大的三个数相乘即为最大乘积；如果全是非正数，则最大的三个数相乘同样也为最大乘积。

如果数组中有正数有负数，则最大乘积既可能是三个最大正数的乘积，也可能是两个最小负数（即绝对值最大）与最大正数的乘积。

综上，我们在给数组排序后，分别求出三个最大正数的乘积，以及两个最小负数与最大正数的乘积，二者之间的最大值即为所求答案。

```C++
class Solution {
public:
    int maximumProduct(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        int n = nums.size();
        return max(nums[0] * nums[1] * nums[n - 1], nums[n - 3] * nums[n - 2] * nums[n - 1]);
    }
};
```


复杂度分析

时间复杂度：O(NlogN)，其中 N 为数组长度。排序需要 O(NlogN) 的时间。

空间复杂度：O(logN)，主要为排序的空间开销。

方法二：线性扫描
在方法一中，我们实际上只要求出数组中最大的三个数以及最小的两个数，因此我们可以不用排序，用线性扫描直接得出这五个数。

```C++
class Solution {
public:
    int maximumProduct(vector<int>& nums) {
        // 最小的和第二小的
        int min1 = INT_MAX, min2 = INT_MAX;
        // 最大的、第二大的和第三大的
        int max1 = INT_MIN, max2 = INT_MIN, max3 = INT_MIN;

        for (int x: nums) {
            if (x < min1) {
                min2 = min1;
                min1 = x;
            } else if (x < min2) {
                min2 = x;
            }
    
            if (x > max1) {
                max3 = max2;
                max2 = max1;
                max1 = x;
            } else if (x > max2) {
                max3 = max2;
                max2 = x;
            } else if (x > max3) {
                max3 = x;
            }
        }
    
        return max(min1 * min2 * max1, max1 * max2 * max3);
    }

};
```


复杂度分析

时间复杂度：O(N)，其中 N 为数组长度。我们仅需遍历数组一次。

空间复杂度：O(1)。



### 编程题二

甲乙丙丁玩投篮游戏，

大家按顺序投篮，投进的同学需要指定淘汰一名对手，被淘汰的同学则不能继续投篮。

如此往复直到只剩下一名同学为胜者。

已知他们的投篮技术不同，投中的概率分别是30%, 40%, 50%, 70%.

为了公平，从技术最差的同学开始投，技术越好越后面投。顺序：甲(30%)乙(40%)丙(50%)丁(70%)。

他们各自有各自的想法：

甲：如果丁还没淘汰，我就故意不投中，除非只剩我跟丁。如果丁被淘汰，我就尽力淘汰技术最好的同学，最终获胜。



乙：我要尽力创造与丙对决的局面。最终获胜



丙：我要先淘汰甲，然后一次淘汰技术最好的同学，最终获胜



丁：我要尽力让甲获胜，如果甲无法获胜，我才尽力争胜。



写一个程序能得出甲乙丙丁这些策略下各自的胜率，误差0.1%以内。先说明你的思路

（系统提供随机函数int Random(int nMax), 该函数随机返回 [0, nMax)的一个整数

思路：





### 编程题三

海盗分金币