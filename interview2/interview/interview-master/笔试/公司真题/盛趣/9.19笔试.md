选择题记不得了，

编程题

一：翻转字符串秒了

二: 3空瓶换饮料-秒了

三：信封嵌套->最长上升子序列（但是要求nlogn的算法）

#### [354. 俄罗斯套娃信封问题](https://leetcode-cn.com/problems/russian-doll-envelopes/)

给你一个二维整数数组 envelopes ，其中 envelopes[i] = [wi, hi] ，表示第 i 个信封的宽度和高度。

当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。

请计算 最多能有多少个 信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。

注意：不允许旋转信封。


示例 1：

输入：envelopes = [[5,4],[6,4],[6,7],[2,3]]
输出：3
解释：最多信封的个数为 3, 组合为: [2,3] => [5,4] => [6,7]。





反思：之前一直没有精益求精的想法，导致考场反应不过来，真的是非常菜

O(n^2)的算法暂且不提，



#### 方法二：修改状态定义（同时用到了贪心算法、二分查找）

稍微有些难以理解，但问题不大，主要还是心有些乱了





**状态设计思想**：依然着眼于某个上升子序列的 **结尾的元素**，如果 **已经得到的上升子序列的结尾的数越小**，**那么遍历的时候后面接上一个数**，**会有更大的可能构成一个长度更长的上升子序列**。既然结尾越小越好，我们可以记录 在长度固定的情况下，结尾最小的那个元素的数值，

**1 .定义新状态（特别重要）**

`tail[i]` 表示：长度为 `i + 1` 的 **所有** 上升子序列的结尾的最小值。

**说明**：

* tail[0] 表示长度为 1 的所有上升子序列中，结尾最小的元素的数值。以题目中的示例为例 [10, 9, 2, 5, 3, 7, 101, 18] 中，容易发现长度为 2 的所有上升子序列中，结尾最小的是子序列 [2, 3] ，因此 tail[1] = 3；
* 下标和长度有数值为 `1` 的偏差；

状态定义其实也描述了状态转移方程。

**2. 状态转移方程**：

从直觉上看，数组 `tail` 也是一个严格上升数组。

可以用反证法，如果0 <= i < j < len, 存在tail[i] >= tail[j]，那么

tail[i]-> 对应一个上升子序列：[a0, a1, ....ai], 根据定义，有tail[i] = a[i]

tail[j]-> 对应[b0, b1, ....bi,...bj]  有tail[j] = b[j]

tail[i] >= tail[j] ->等价$a_i \ge b_j$,然而[b0, b1, ....bi, ...bj]  中 bi 严格小于bj, 所以ai >= bj > bi

则[b0, b1, ..., bi] 也是长度为i + 1,且结尾bi 比ai小，应该tail[i] = bi才对，矛盾了。

---



因为只需要维护状态数组 tail 的定义，它的长度就是最长上升子序列的长度。下面说明在遍历中，如何维护状态数组 tail 的定义。

1. 在遍历数组 nums 的过程中，看到一个新数 num，如果这个数 **严格** 大于有序数组 tail 的最后一个元素，就把 num 放在有序数组 tail 的后面，否则进入第 2 点；

<!--注意：这里的大于是「严格大于」，不包括等于的情况。-->

2. 在有序数组 tail 中查找第 1 个等于大于 num 的那个数，试图让它变小；
   * 如果有序数组 tail 中存在 等于 num 的元素，什么都不做，因为以 num 结尾的最短的「上升子序列」已经存在；
   * 如果有序数组 tail 中存在 大于 num 的元素，找到第 1 个，让它变小，这样我们就找到了一个 结尾更小的相同长度的上升子序列。

**说明**：

我们再看一下数组 tail[i] 的定义：长度为 i + 1 的 所有 最长上升子序列的结尾的最小值。因此，在遍历的过程中，我们试图让一个大的值变小是合理的；
这一步可以认为是「贪心算法」，总是做出在当前看来最好的选择，当前「最好的选择」是：当前只让让第 1 个严格大于 nums[i] 的数变小，变成 nums[i]，这一步操作是「无后效性」的；
由于是在有序数组中的操作，因此可以使用「二分查找算法」。

3. 初始化：

遍历第 1 个数 nums[0]，直接放在有序数组 tail 的开头 tail[0] = nums[0]。

4. 输出：

有序数组 tail 的长度，就是所求的「最长上升子序列」的长度。

```c++
#include <iostream>
#include <vector>

using namespace std;

class Solution {
public:
    int lengthOfLIS(vector<int> &nums) {
        int len = nums.size();
        if (len < 2) {
            return len;
        }
		// tail 数组的定义：长度为 i + 1 的上升子序列的末尾最小是几
        vector<int> tail;
         // 遍历第 1 个数，直接放在有序数组 tail 的开头
        tail.push_back(nums[0]);
        // end 表示有序数组 tail 的最后一个已经赋值元素的索引
        int end = 0;

        for (int i = 1; i < len; ++i) {
            // 【逻辑 1】比 tail 数组实际有效的末尾的那个元素还大
            if (nums[i] > tail[end]) {
                // 直接添加在那个元素的后面，所以 end 先加 1
                tail.push_back(nums[i]);
                end++;
            } else {
                // 使用二分查找法，在有序数组 tail 中
                // 找到第 1 个大于等于 nums[i] 的元素，尝试让那个元素更小
                int left = 0;
                int right = end;
                while (left < right) {
                    // 选左中位数不是偶然，而是有原因的
                    int mid = (left + right) >> 1;
                    if (tail[mid] < nums[i]) {
                        // 中位数肯定不是要找的数，把它写在分支的前面
                        left = mid + 1;
                    } else {
                        right = mid;
                    }
                }
                // 走到这里是因为 【逻辑 1】 的反面，因此一定能找到第 1 个大于等于 nums[i] 的元素
                // 因此，无需再单独判断
                tail[left] = nums[i];
            }
        }
        // 此时 end 是有序数组 tail 最后一个元素的索引
        // 题目要求返回的是长度，因此 +1 后返回
        return end + 1;
    }
};
```

评论中一些观点：

```
输入 [10, 9, 2, 5, 3, 7, 101, 18, 4, 8, 6, 12]
```

整个过程进行逐步分析，应该就明白了

过程分析，用表格记录：

每一行记录一个“上升子序列”，特点：**”结尾“是所有相同长度的上升子序列里最小的**

* 第1行记录长度为1的“上升子序列”
* 第2行记录长度为2的”上升子序列“
* 。。。。。
* 第n行记录长度为n的上升子序列

整个过程：

[10, 9, 2, 5, 3, 7, 101, 18, 4, 8, 6, 12]

初始条件： tail[0] = 10, end = 0

表格：

10

---



i = 1, nums[i] = 9, nums[i] <= tail[end]进入二分的过程，

在tail[0]对应第一行中， 找到第 1 个大于等于 nums[i] 的元素，尝试让那个元素更小，

现在表格:

9



---

i = 2, nums[i] = 9, 同理

表格

2

---

i = 3, nums[i] = 5, 逻辑1，直接放到后面

表格

2 

2 5

---

i = 4，nums[i] = 3, 逻辑2

表格

2

2 3

---

i = 5, nums[i] = 7, 逻辑1

表格

2

2 3

2 3 7

---

i = 6, nums[i] = 101

表格

2

2 3

2 3 7

2 3 7 101

---

i = 7, nums[i] = 18

只用关心最长的表格的那一行

2 3 7 18

---

这一步理解至关重要！！

2 3 7 18的确存在与 [10, 9, 2, 5, 3, 7, 101, 18, 4, 8, 6, 12]中，但是tail的含义并不是实际的LIS，

变成2 3 4 18之后虽然不真实存在，但是最长长度没有影响，这一步超重要！



i = 8, nums[i] = 4

表格

2 3 4 18

---

i = 9, nums[i] = 8

表格

2 3 4 8

---

i = 10, nums[i] = 6

表格

2 3 4 6

---

i = 11, nums[i] = 12

表格

2 3 4 6 12

