有一个苹果，两个人抛硬币来决定谁吃这个苹果，先抛到正面者吃。请问先抛者吃到苹果的概率为_2/3_

第一次成功：1/2

第三次成功（即前两次失败）：`（1-1/2）*（1-1/2）*（1/2）`

第五次成功（即前四次都失败）：`（1-1/2）*（1-1/2）*（1-1/2）*（1-1/2）*（1/2）`

第`2*k + 1`次成功（即前2*k次都失败）：`（1-1/2）*（1-1/2）*...*（1-1/2）*（1-1/2）*（1/2）`

当k趋向于无穷大时，最后一项等于0

将前面所有的加起来，即求等比数列的和：（1/2）/（1-1/4）= 2/3

---

将一个白木质的正方体的6个面都涂上红漆，再将它锯成64个小正方体，从中取3个，其中至少有一个3面是红漆的小正方体的概率为_83/248

有8个小正方体三面有红漆。没有任何一个取到的概率为：

C(3,56)/C(3,64)

则至少取到一个三面红漆小方块的概率为1-C(3,56)/C(3,64)=1-165/248=83/248.



---

甲乙两个办公室的员工都不到 20 人，如果从甲办公室调N个人到乙办公室，则甲办公室的人数是乙办公室人数的 2 倍；如果乙办公室调N个人到甲办公室，则甲办公室的人数就是乙办公室的 3 倍，请问则N的值是？1

如果从甲办公室调N个人到乙办公室，则甲办公室的人数是乙办公室人数的 2 倍；

​      x-N=2(y+N)

如果乙办公室调N个人到甲办公室，则甲办公室的人数就是乙办公室的 3 倍；

​      x+N=3(y-N)

综上两式子 x=2y+3N

​          y=7N

由于x和y都小于20 所以N=1或2  N=2时x=2y+3N>20舍去 得N=1

---

6个人分乘两辆不同的汽车，每辆车最多坐4人，则不同的乘车方法数为_50_



首先认定一辆车，把6个人选出来坐在这辆车里，
余下的人坐在另一辆车里，
符合条件的选法有选2，3，4
分别有C62，C63，C64种结果，
根据分类计数原理知共有15+20+15=50种结果，



---

三个人独立地破译一份密码，已知各人能译出的概率分别为 1/5，1/4，1/3，则密码能被破译的概率为_3/5



没有一个人能破译的概率：4/5 * 3/4 *2/3 = 2/5，

能破译（至少有一个人破译）的概率： 1 - 2/5 = 3/5

---

一个平面的法线是指与该平面垂直的直线。下面哪条直线是过点(1,1,1)、(0,3,0)、(2,0,0)的平面的法线？

```
过点(2,0,0)、(5,2,1)的直线
```

因为点（1,1,1）与点（2,0,0）的间的向量为（1,-1,-1,）
因为法向量（法线方向的向量）与平面上的向量的乘积为0
所以D满足要求 过点（2,0,0）、（5,2,1）得向量为（-3,-2,-1）
`（1,-1,-1,）*（-3,-2,-1）=1*（-3）+（-1）*（-2）+（-1）*（-1）=0`

---

估算下 sin1° 最接近下列选项中的哪个值？

```
游戏中，我们也是这么干的，利用增量思想
f（x） = sin(x)
f'(x) = cos(x)
当h非常小，f(x + h) = f(x) + f'(x)h
1度 => 3.14/180弧度 
x = 0, h = 3.14/180 = 0.017...，带入求解
选D
```

```
0.0174
```

---

已知A点的坐标为(12,13)，B点坐标为(10,11)，求A点绕B点逆时针旋转30度后的坐标为？已知根3 约等于1.73

```
(10.73,13.73)
```

```
将A转为B所在坐标系，套用旋转公式进行旋转，再转回世界坐标系即可。
旋转公式
x’ = xcos(-30') + ysin(-30')
y’ = ycos(-30') - xcos(-30')
选A
```

---



已知向量![img](https://uploadfiles.nowcoder.com/images/20170809/301039_1502273074958_F1BF68DB82F323443390A2185EBFC5D3)是单位向量且![img](https://uploadfiles.nowcoder.com/images/20170809/301039_1502273086123_AB7312A2A3F796CAF162DC9B362B7CE0)的最大值为_根2_

```
（x，y）经过xcos + ysin公式，得到x’，x‘为旋转后的x轴投影，最大为长度``sqrt``(x*x+y*y)
二维笛卡尔坐标系中绘制（x，y），（x，y-b），（x-a，y），连接为三角形
单位向量长度1（固定），可知，b或者a越大，得到长度越长。
n（0，1），m（1，0）
=> max = ``sqrt``(2)
```





---



假设 4 个作业如下表所示同时到达，当使用最高优先权优先调度算法时（优先级数值越大优先级越高），这4个作业的平均周转时间为多少小时？周转时间为：完成时间与到达时间的时间差。

![img](https://uploadfiles.nowcoder.com/images/20170809/301039_1502273293729_9EB60BC8BF2B004E4DB7D1CC0D5F1D8C)



```
16.75
```

执行顺序：2 3 1 4

到达时间均为0，按优先级顺序完成时间分别为：10，10+7，10+7+2，10+7+2+2

平均周转时间：（10+17+19+21）/4 = 16.75







---

在TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接。

第一次握手：建立连接时，客户端发送syn包(seq=j)到服务器，并进入SYN_SEND状态，等待服务器确认；

第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（seq=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；

第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。

完成三次握手，客户端与服务器开始传送数据

---

1元钱买一瓶汽水，喝完后两个空瓶可以换一瓶汽水，请问有20元钱，最多可以喝到几瓶汽水？

```
40
```

把这2个瓶 换1瓶继续喝，喝完后把这1个空瓶换1瓶汽水，喝完换来的那瓶再把瓶子还给人家即可，所以最多可以喝的汽水数为：20＋10＋5＋2＋1＋1＋1＝40 



---

设无向图的顶点个数为n，则该图最多有______n(n-1)/2_______条边。

**无向图G中边数目的取值范围：0＜-e＜=n(n-1)/2。有n(n-1)/2条边的无向图称为完全图。**





---

下列排序算法中，在最后一趟开始之前，所有元素都有可能不在其最终的位置上的是_插入排序_



例如从小到大插入排序，最后一个插入的是最小的元素，此时最后一次前所有的数都不在正确的位置上。 其他几种排序每次循环都会确认至少一个元素的正确位置，所以不可能出现这种情况





---

无向图有n个顶点m条边，则建立该图邻接表的时间复杂度为_O(n+m)



---

一棵二叉树现有如下关系：若任意父结点为(x,y)，那么其左子结点为(x + y,y)，右子结点为(x,y + x)。已知一棵二叉树根结点为(1,1)，请问以下哪个结点可能存在于该树中？

```
(88,75)
```

按题目规律从下往上推父节点一直推到根节点是（1，1）就是对的 A   （88，75）——（13，75）——（13，62）——（13，49）——（13，36）——（13，23）——（13，10）——（3，10）——（3, 7）——（3，4）——（3，1）——(2，1) ——(1，1) 是对的 B   （76，128）——（76，52）——（24，52）——（24，28）——（24，4）——（20，4）——（16，4）——（12，4）——（8，4）——（4，4）——（0，4）/（4，0） 错的 C D同上



---

有4份作业，每一份均需要先在机器A上加工完，然后在机器B上加工，机器A上同一时间只能加工一份作业，机器B上同一时间也只能加工一份作业，且作业之间无依赖关系。作业i在机器A和B上加工所需的时间分别为ai和bi，且(a1,a2,a3,a4)=(4,5,12,10)，(b1,b2,b3,b4)=(8,2,15,9)，加工完4份作业所需的最短时间是_42



约翰逊法具体步骤：

第一步，取出最小工时。如该工时为第一工序的，则最先加工；反之，则放在最后加工。

第二步，将该已排序工作划去。

第三步，对余下的工作重复上述排序步骤，直至完毕。得到最终的排序，计算整批工件的停留时间。



此题，取最小工时b2=2，则作业2为最后完成的。a1=4，作业1为最先完成的。b4=9，作业4为第三个完成的。所以作业顺序为：作业1 -> 作业3 -> 作业4 -> 作业2，总时长为：4+12+10+(15-10)+5+(9-5)+2=42 或 4+12+15+9+2=42 （第n项作业所需工时值为第n项a工序和第n-1项b工序的最大值，即max(an,bn-1)）

---

用二进制表示十进制数1到4，分别为1、10、11、100，这些二进制数所有位上1的个数共有5个。那么，用二进制表示的十进制数1到128，所有位上1的个数共有_________449____个。



128的二进制是10000000（8位），那么对于1到128的数来说，前7位0和1的出现次数是相等的（这个很好理解，举个简单的例子，对于001到100之间的数是001 010 011 100 ，对于前两位来说，可以看到0和1的数量是相等的），那么这样就好做了，对于前7位来说，一共128个数，那么就是说1出现的个数就是7*64，对于第八位来说，很明显可以看到只有在128的时候第八位取到了1，所以说第八位一共就一个1，所以最后的结果就是449



---

```c
#include <stdio.h>

int main()

{

    int m = 0;

    for (int i = 1; i <= 100; i++)

    {

        for (int j = 1; j <= i; j++)

        {

            if (j % 2 != 0)

                continue;

 

            m++;

        }

    }

 

printf("%d\n",m); // 2500

return 0;

}
```



```c
#include <stdio.h>

int f(int n)

{

    int i = 0;

    for (int k = 1; k <= n; k *= 2)

        ++i;

 

    for (int j = i / 2; j > 0; --j)

    {

        int v1 = (1 << (j - 1));

        int v2 = (1 << (i - j));

        bool flag1 = ((n & v1) != 0);

        bool flag2 = ((n & v2) != 0);

        if (flag1 != flag2)

        {

            n ^= v1;

            n ^= v2;

        }

    }

 

    return n;

}

 

int main(int argc, char* argv[])

{

    printf("%d", f(3456)); // 27

    return 0;

}
```

i=初始值为12。

n=3456=2048+1024+256+128;

n根据规律属于递减的。

当j=2时

v1=2

v2=1024

f1=0;f2=1

n=n^v1=n+2;

n=n^v2=n+2-1024;



当j=1时

v1=1

v2=2048;

f1=0;f2=1

n=n^v1=n+1;

n=n^v2=n+1-2048;

n减了有3000多剩下的一定小于c的639,所以选D.

本题主要在于看规律，大致的蒙，准确计算 心算的话不现实。手算又太费时间。

故大致计算是性价比最高的。





看图编程题目

```c++
#include <bits/stdc++.h>
using namespace std;

void foo(int arr[], int a, int b, int* out1, int* out2) {
    if (b - a <= 1) {
        if (arr[a] < arr[b]) {
            *out1 = arr[b];
            *out2 = arr[a];
        } else {
            *out1 = arr[a];
            *out2 = arr[b];
        }
        return ;
    }
    int l1, l2, r1, r2;
    foo (arr, a, a + (b - a) / 2, &l1, &l2);
    foo (arr, a + (b - a) / 2 + 1, b, &r1, &r2);
    if (l1 > r2)
        *out1 = l1;
    else
        *out1 = r1;
    if (l2 < r2)
        *out2 = l2;
    else
        *out2 = r2;
}

int main() {
    int a, b;
    int arr[] = {2, 3, 413, 3, -7, -8, -9, 8, 9, 3123, 131};
    foo(arr, 0, sizeof(arr)/sizeof(int) - 1, &a, &b);
    printf("%d", a);
    return 0;

}

```





```c++
#include <bits/stdc++.h>
using namespace std;

void foo(int nums[], int size) {
    int tmp = 0, low = 0, mid = 0, high = size - 1;
    while (mid <= high) {
        if (nums[mid] == 0) {
            tmp = nums[low];
            nums[low] = nums[mid];
            nums[mid] = tmp;
            low++;
            mid++;
        } else if (nums[mid] == 1)
            mid++;
        else if (nums[mid] == 2) {
            tmp = nums[high];
            nums[high] = nums[mid];
            nums[mid] = tmp;
            high--;
        }
    }
}
int main() {
    int arr[] = {0,1,2,0,1,2,0,1,2,0,1,2};
    foo(arr, sizeof(arr)/sizeof(int));
    for (int i = 0; i < sizeof(arr) / sizeof(int); i++)
        printf("%d", arr[i]);
    return 0;

}

```





编程题



G社正在开发一个新的战棋类游戏，在这个游戏中，角色只能向2个方向移动：右、下。移动需要消耗行动力，游戏地图上划分M*N个格子，当角色移动到某个格子上时，行动力就会加上格子上的值K（-100~100），当行动力<=0时游戏失败，请问要从地图左上角移动到地图右下角至少需要多少起始行动力，注意（玩家初始化到起始的左上角格子时也需要消耗行动力）



**【关键点】角色的三种状态：**

1. `角色在(i, j)之前（即在(i-1, j)或者(i, j-1)，下一步即将移动到(i, j)）行动力用dp[i][j]表示，比如初始行动力为dp[0][0]，下一步即将移动到(0, 0)；`
2. `角色在(i, j)时（下一步即将移动到(i+1, j)或者(i, j+1)）行动力等于dp[i][j]+a[i][j]，比如初始行动力为dp[0][0]，角色在(0, 0)时行动力为dp[0][0]+a[0][0]；`
3. `角色在(i, j)之后（即在(i+1, j)或者(i, j+1)，上一步在(i, j)），此时有min(dp[i+1][j], dp[i][j+1])等于dp[i][j]+a[i]`[j]。

**【分析】**`dp[i][j]表示角色尚在格子(i, j)之前并且即将要移动到格子(i, j)时的行动力。`

`dp[0][0]表示初始的行动力。`

`当行动力小于或者等于0时游戏失败，dp[i][j]必然大于或者等于(对应递推公式的max)1，即dp[i][j]>=1。`

`dp[i][j]+a[i][j]表示角色在格子(i, j)但尚未往下移动时的行动力，此时行动力为min(dp[i+1][j], dp[i][j+1])，采用min是因为最后要求的是最小值。`

最后求解初始时刻的行动力，则应该从后往前推理，可得，

`dp[i][j] = max(1, min(dp[i+1][j], dp[i][j+1]) – a[i][j])。`



```c++
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;
int main()
{
    int m,n;
    cin>>m>>n;
    vector<vector<int> > a(m,vector<int>(n,0));
    vector<vector<int> > dp(m+1,vector<int>(n+1,0));
    for(int i=0;i<m;++i)
        for(int j=0;j<n;++j)
            cin>>a[i][j];
    for(int i=m-1;i>=0;--i)
        for(int j=n-1;j>=0;--j)
            dp[i][j]=max(1,min(dp[i+1][j],dp[i][j+1])-a[i][j]);
    cout<<dp[0][0]<<endl;
    return 0;
}
```

