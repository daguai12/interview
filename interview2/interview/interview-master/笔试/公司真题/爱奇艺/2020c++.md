有如图所示的二叉树，E结点的前辈结点有（ A B C   ）

![img](https://uploadfiles.nowcoder.com/images/20200101/310337_1577868551683_53382406E5E56C9C9DA3F8DC530C5551)



**树的相关术语：**

1. **结点**：包括一个数据元素及若干指向其结点的分支信息
2. **结点的度**：一个节点的子树个数（说白了就是节点拥有的子分支数）
3. **叶节点**：**度为0的结点**，即无后继的结点，也称终端结点
4. **分支结点**：度不为零的结点，也称非终端结点
5. **结点的层次**：从根节点开始定义，根节点的层次为1，根的直接后继的层次为2，以此类推
6. **节点的层序编号**：将数中的结点按从上层到下层，同层从左到右的次序排成一个线性序列，把他们编成连续的自然数
7. **树的度**：树中所有结点的度的最大值
8. **树的高度（深度）**：数中所有结点的层次的最大值
9. **有序树**：在树T中，如果个子树之间有先后次序的，则称为有序树
10. **森林**：m（m>=0）个互不相见交的树的集合，将一颗非空树的根节点删去，树就变成一个森林；繁殖给森林增加一个统一的根结点，森林就变成一棵树
11. **同构**：对两棵树，通过对结点是当地重命名，就可以使两棵树完全相等，（对应结点相等，对应结点的相关关系也相等），则称为两棵树的同构
12. **孩子结点**：一个结点的直接后继称为该结点的孩子结点
13. **双亲结点**：一个结点的直接前驱称为该结点的双亲结点
14. **兄弟结点**：同一双亲结点的孩子结点间互称兄弟结点
15. **堂兄结点**：父亲是兄弟关系或堂兄弟关系的堂兄弟结点
16. **祖先结点**：一个结点的祖先结点是指从根结点到该结点的路径上的所有结点
17. **子孙结点**：一个结点的直接后继和间接后继称为该节点的子孙结点
18. **前辈**：层号比该结点小的结点
19. **后辈**：层号比该结点大的结点



---

关于结点树相同的折半判定树和完全二叉树，以下说法正确的是（   ）

#### 正确答案: A  你的答案: D (错误)

```
A 折半判定树的高度与完全二叉树高度一致
B 折半判定树的高度比完全二叉树高度大
C 折半判定树的高度比完全二叉树高度小
D 折半判定树的高度与完全二叉树高度没有关系
```

考点：二叉树的性质--折半判定树和完全二叉树

- **折半判定树**

  - 折半判定树的**构造过程**其实就是对有序列表二分查找的过程，有序列表的中点是折半判定树的根节点，比根节点小的被分到根节点的左子树，比根节点大的被分到根节点的右子树；

  - 折半判定树的

    性质：

    - 任意两棵折半查找判定树，若它们的结点个数相同，则它们的结构完全相同
    - 任意结点的左右子树中结点个数最多相差1
    - 任意结点的左右子树的高度最多相差1
    - 任意两个叶子所处的层次最多相差1

- 完全二叉树：如果二叉树的深度为k，除第 k 层外，其它各层 (1～k-1) 的结点数都达到最大个数，第k 层所有的结点都连续集中在最左边

---

? 答案不确定

多个ALOHA用户每秒产生60个请求，时间槽单位为20ms，则首次成功发送的概率为多少（0.05)

![img](https://uploadfiles.nowcoder.com/images/20200118/800352933_1579346684170_5473BD32F2D8158C2BF7CF5C5C71E360)



现在时槽长度为20ms，则每秒50个时槽，产生60个请求，所以每个时槽产生1.2个请求，则G＝1.2，因此首次尝试成功的概率是e-1.2=0.3



---

在Linux内核中，创建一个文件操作可以使用（fopen ）

的确可以，但？？？



---

MyISAM引擎的表tg_user，主键为tg_id，tg_email是允许为空的列，下列能正确统计出该表记录数的语句是（   ）

##### 正确答案: A B D  你的答案: B (错误)

```sql
A SELECT count(*) FROM `tg_user`
B SELECT count(tg_id) FROM `tg_user`  
C SELECT count( tg_email ) FROM `tg_user ` 
D SELECT count(1) FROM `tg_user`
```

select count(*) from table 表示返回表中包括空行和重复行在内的行数,但是会扫描所有列

select count(1) from table 也是返回表中包括空行和重复行在内的行数，不会扫描所有列,1其实就是表示有多少个符合条件的行，但是此时没有where,所有没条件也就是返回总行数

select count(id) from table 表示返回表中存在该列id的行数，但是该列的值不为空，为空的不计算，所以在此题中是不能用这个，因为tg_email都为空，用主键可以，因为主键肯定不为空

---

在解决汉诺塔问题时，可使用哪种数据结构进行设计（ 栈  ）

汉诺塔问题是一个递归问题，递归问题往往需要用到栈这种数据结构来解决。



---



下列程序的运行结果是5 5，请将横线处缺失程序补充完整（x = 5）

```c++
#include <iostream>
#include <algorithm>
#include <vector>
#include<iterator>
using namespace std;
class f
{            
public:
 int operator()() const
 {return __________;}
private:
 static int x;
};
int f::x=0;       
int main()
{
 int A[]={7,8,9,4,0};
 vector<int> B(A+1,A+3);   
 ostream_iterator< int > output( cout, " " ); 
    generate(B.begin(),B.end(),f());
 copy(B.begin(),B.end(),output);
 cout<<endl; 
    return 0;
}
```

---

不可重载的运算符列表：

- **.**：成员访问运算符
- **.\***, **->\***：成员指针访问运算符
- **::**：域运算符
- **sizeof**：长度运算符
- **?:**：条件运算符
- **#**： 预处理符号



operator+ 其实是 x.operator+(y)

自然成员方法自然可以访问私有成员变量

下列代码执行的输出结果为（  3, 5 ）

```c++
#include<iostream>
using namespace std;
class MyClass{
    double Re,Im;
     
    public:
        MyClass(double r,double i)
        {
            Re=r;
            Im=i;
        }
        MyClass()
        {
            Re=0;
            Im=0;
        }
        MyClass operator+(MyClass);
         
        void showMyClass();
};
MyClass MyClass::operator+(MyClass m)
{
    MyClass tmp;
     
    tmp.Re = Re + m.Re;
    tmp.Im = Im + m.Im;
     
    return tmp;
}
void MyClass::showMyClass()
{
    cout << Re << "," << Im <<endl;
}
int main()
{
    MyClass obj1(1,2),obj2(2,3);
    MyClass obj3 = obj1+obj2;
    obj3.showMyClass();
    return 0;
}
```





---

下图的UML类结构图表示的是哪种设计模式？

![img](https://uploadfiles.nowcoder.com/images/20200102/310337_1577945661648_4980001F89E5E579B66D22A9398C4C8A)

#### 正确答案: A  你的答案: D (错误)

```
备忘录模式
适配器模式
工厂方法模式
抽象工厂模式
```

备忘录模式(Memento Pattern)是一种软件设计模式:

在不破坏封闭的前提下,捕获一个对象的内部状态,并在该对象之外保存这个状态.

这样就可以将对象恢复到原先保存的状态.

设计角色:

1.Originator(发起人), 发起人负责创建一个备忘录Memento,用于记录当前时刻自身(Orginator)的内部状态.

2.Mememto(备忘录),存储Originator对象的内部状态,并防止Originator以外的对象访问备忘录.

3.Caretaker(管理者),管理Mememto.

---



请问下图的UML是什么设计模式?（ ）

![img](https://uploadfiles.nowcoder.com/images/20200102/310337_1577945719628_A903327012FDF3F4E394C27575D15C20)

### 正确答案: B  你的答案: D (错误)

```
模板方法模式
责任链模式
迭代器模式
命令模式
```

责任链模式是一种设计模式。在责任链模式里，很多对象由每一个对象对其下家的引用(next)而连接起来形成一条链。