## 解答一：
这主要是为了防止已失效的连接请求报文段突然又传送到了B,因而产生错误.假设没有客户端的第三次确认。A发送连接请求，但连接请求丢失而未收到B的确认，于是A重新发出了一次请求连接，后来B收到了请求，发出确认建立了连接，在完成通信后连接释放，成功完成一次通信。A虽发送了两次连接请求,但第一次丢失,第二次成功,所以此时不存在已失效的连接请求报文。现假设A第一次发送的连接请求报文因为网络问题长时间滞留了，到第二次通信完成释放连接后才到达B,这就是一个已失效的报文,但此时B以为是A的又一次连接请求,于是发出了确认,若没有第三次确认,连接就成功建立了。由于A现在并没有发出建立请求,所以B回复的确认A不理睬,所以不与B进行通信,然而B就一直等着A发数据给他,就这样,B等了很久,白白浪费了B的资源。


## 解答二：
三次握手的原因：三次握手可以防止已经失效的连接请求报文突然又传输到服务器端导致的服务器资源浪费。例如，客户端先发送了一个SYN，但是由于网络阻塞，该SYN数据包在某个节点长期滞留。然后客户端又重传SYN数据包并正确建立TCP连接，然后传输完数据后关闭该连接。该连接释放后失效的SYN数据包才到达服务器端。在二次握手的前提下，服务器端会认为这是客户端发起的又一次请求，然后发送SYN ，并且在服务器端创建socket套接字，一直等待客户端发送数据。但是由于客户端并没有发起新的请求，所以会丢弃服务端的SYN 。此时服务器会一直等待客户端发送数据从而造成资源浪费。

## 解答三：

三次握手是为了防止，客户端的请求报文在网络滞留，客户端超时重传了请求报文，服务端建立连接，传输数据，释放连接之后，服务器又收到了客户端滞留的请求报文，建立连接一直等待客户端发送数据。

服务器对客户端的请求进行回应(第二次握手)后，就会理所当然的认为连接已建立，而如果客户端并没有收到服务器的回应呢？此时，客户端仍认为连接未建立，服务器会对已建立的连接保存必要的资源，如果大量的这种情况，服务器会崩溃。