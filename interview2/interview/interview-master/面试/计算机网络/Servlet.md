让我们坐上时光机，回到那个年代——上个世纪90年代的中叶。C语言稳坐江湖第一把交椅，C++也羽翼渐丰。彼时在圣克拉拉的某个咖啡馆里出现了一位其貌不扬的少年。谁都不会想到这个手持盒子，靠嵌入式起家的孩子会成为日后十年、二十年乃至更长的时空中，左右互联网江湖的重要人物。他的名字是——Java。

## 1. Applet——进军Web领域的简单尝试

Java在Web领域第一个让人眼前一亮的东西是applet，可以理解为轻量级小程序的意思。**不过这是个客户端的产品**，作为浏览器的插件而出现，applet增强了用户与浏览器之间的交互体验。虽然让人眼前一亮，但却是昙花一现。它不仅缺乏好用的IDE、UI丑陋，更加过分的是需要用户电脑先安装JVM、JRE。

不过Java拥有着的诸多现代编程理念（OO，内存安全，跨平台）使得人们意识到**它在服务端开发中的潜力**。

## 2. Servlet——Web开发的弄潮儿

Servlet应运而生，成为服务端Web开发的新宠。虽然从概念上与CGI异曲同工，但是却摒弃掉了CGI的诸多弊端，同时借助Java语言本身的优势，从而达到无论是从性能还是安全性上都更上一层楼。

*Servlet知识点众多，本文无意全部覆盖（也不需要）。网络上各类Servlet教程一大把，诸君自行搜索便是了。*

## 2.1 Servlet容器

通常Web服务器（比如Apache）天然的职责是解析HTTP请求，处理静态页面。通过插件（Apache的各种mod）实现了解析PHP页面，调用CGI程序的功能。但其并不具备处理Servlet程序的能力，因此需要一个中间层来完成这件事。这一中间层被称为“**Servlet 容器**”。Tomcat就是最著名的一个Servlet容器。

尽管Web服务器和Servlet通常是分离提供的，但应该视Servlet容器为Web服务器的一个组件，而不应该视作两个独立的事物。

## 2.2 生命周期

CGI程序最大的毛病就是Fork-Exec的模式。每次请求一个CGI程序，Web服务器都会创建一个新的进程去执行CGI程序，高并发的时候，成为一大性能杀手。而Servlet则不然，它采用的是多线程的模型。每次对于Servlet的请求，只不过是创建了一个新的线程，众所周知，线程远比进程要轻量。

在Servlet容器（比如Tomcat）启动的时候，其注册的Servlet类并不会被创建出实例（new），仅当其第一次被访问的时候，才会new出这个Servlet对象。**而当一次Servlet的请求结束之后，该实例并不会被销毁，其生命周期并不会结束！**

一个Servlet对象实例的生命周期内，会调用三个方法：

- **init ()** 方法用于初始化。生命周期内，仅仅会被调用一次；创建时调用。
- **service()** 方法来处理客户端的请求。每次请求过来都会被调用。
- **destroy()** 方法终止。生命周期内，仅仅会被调用一次；销毁时调用。



![img](https://pic1.zhimg.com/80/v2-9793331628ab250d0cbc82cdf0bde760_720w.jpg)

（图片来自于网络）

## 2.3 HTTP方法的处理

讲一点Servlet的API。实现一个自定义Servlet，即要继承HttpServlet类。并且我们通常需要实现doGet和doPost两个方法。

我们都知道**GET**和**POST**是最常见的两个HTTP Method（另外还有不常见的DELETE、PUT、HEAD等）。Servlet容器会将不同的HTTP Method路由到该Servlet对应的处理方法中。即用doGet来处理GET请求，doPost处理POST请求。此处不再展开，大家自行百度各类API教程即可。

## 2.4 JSP

学过Java Web开发的同学们，肯定对JSP并不陌生。其实这个脚本语言的本质也是转化成Servlet的。在该JSP页面第一次访问的时候，JSP会被**Servlet容器(或称JSP容器)**编译成Servlet形式的Java代码。而后续再访问该页面的时候，则不会再次编译，直到下次JSP被更新，然后被访问到的时候才会触发编译。

## 3. 多线程的迷思

上文谈到了Servlet之于CGI，由于采用了多线程的模式而获得的好处，但光明和阴影总是相伴相生的。既然是多线程的模型，你无法回避的，你必须直面的一个问题就是——**线程安全问题**。

当高并发的时候，如果两个请求同时请求同一个Servlet对象。那么可能会造成该对象访问某些资源时的竞争，从而导致与预期不一致的结果。

最常见的一个问题就是，使用成员变量。Servlet其本质也是一个普通的Java类，可以定义成员变量。但是高并发的时候成员变量通常会成为线程安全问题的罪魁祸首。当前这个问题解决起来十分容易，可以通过synchronized关键字来同步一个变量的访问，或者通过规范一个编码风格来规避（不在Servlet中使用成员变量）。