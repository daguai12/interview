唉，面玩多益紧接着西山居，就迟到了几分钟，有些愧疚。

面试官开门见山直接进入面试环节。



### 第一题

```c++
class A{
    public:
    void test(){printf("test A");}
};
int main(){
    A*pA=NULL;
    pA->test();
}
```

**结果是输出“test A”而不是程序崩溃，原因如下：**

#### 一种解释：

> `A*pA=null;`
> `pA->test();`//当调用成员函数时，**只是将实参`null`传给`this`指针**

- test成员函数中并无任何需要通过this指针访问的数据成员，因此没有带来任何影响

**会崩溃的情况，调用的成员函数需要通过this指针访问类的数据成员**

```c++
#include<stdio.h>
 
class A{
public:
    void test1(){ printf("test 1"); }
    void test2(){ printf("test 2%d",data); }
 
private:
    int data = 10;
};
int main(){
    A*pA = NULL;
    pA->test1();//成功输出”test 1"
    pA->test2();//程序崩溃（注意不是编译错误）
 
    return 0;
}
```

结果：运行时崩溃
\- `0x00E013E8 处有未经处理的异常(在 code_test.exe 中): 0xC0000005: 读取位置 0x00000000 时发生访问冲突。`

## 更详细的解释：从c++静态绑定谈起

因为对于非虚成员函数，Ｃ++这门语言是静态绑定的。这也是Ｃ++语言和其它语言Java, Python的一个显著区别。以此下面的语句为例：

`pA->test();`
这语句的意图是：调用对象 pA 的 test 成员函数。如果这句话在Java或Python等动态绑定的语言之中，编译器生成的代码大概是：

找到 pA 的 test 成员函数，调用它。（注意，这里的找到是程序运行的时候才找的，这也是所谓动态绑定的含义：运行时才绑定这个函数名与其对应的实际代码。有些地方也称这种机制为迟绑定，晚绑定。）

但是对于C++。为了保证程序的运行时效率，Ｃ++的设计者认为凡是编译时能确定的事情，就不要拖到运行时再查找了。所以C++的编译器看到这句话会这么干：
\1. 查找 pA 的类型，发现它有一个非虚的成员函数叫 test 。（编译器干的）
\2. 找到了，在这里生成一个函数调用，直接调A:: test ( pA )。



你平时使用成员函数的时候，大概就是这样的：

```cpp
A a;
a.func(2);
```

其实在编译器看来，是这个样子的：

```cpp
A_func(&a, 2);
```



所以到了运行时，由于 test ()函数里面并没有任何需要解引用 pA 指针的代码，所以真实情况下也不会引发segment fault。这里对成员函数的解析，和查找其对应的代码的工作都是在编译阶段完成而非运行时完成的，这就是所谓的静态绑定，也叫早绑定。

正确理解C++的静态绑定可以理解一些特殊情况下C++的行为。





### 第二题（如果是空指针调用成员虚函数呢？）

```c++
class A {
private:
    int data;
public:  
    virtual void fun1(){ }
};

int main() {
    A *p = nullptr;
    p->fun1();
}

```



* 对象的静态类型 ：对象在声明时采用的类型（编译器确定）。
* 对象的动态类型 ：当前所指的对象类型，动态类型是动态绑定的，可以改变。
         

* 联编（binding） ：
          就是明确调用关系，指明调用函数的语句调用的究竟是哪一个函数。
* 静态联编（静态绑定、早绑定） ：
          静态联编是指在编译阶段就将函数实现和函数调用关联起来，因此静态联编也叫早绑定。绑定的是对象的静态类型，某特性（比如函数）依赖于对象的静态类型，发生在编译期。（为了保证程序运行时的效率，凡是能在编译期做的事情就不会在运行期干）。
* 动态联编（动态绑定、晚绑定） ：
          动态联编是指在程序执行的时候才将函数实现和函数调用关联，因此也叫运行时绑定或者晚绑定。绑定的是对象的动态类型，某特性（比如函数）依赖于对象的动态类型，发生在运行期。       

* this指针 ：
          类的每个对象，都有一个指向自己的this指针。这个指针的值，将会因为对象的不同而不同;它的作用主要就是用来区分不同的对象，同一个成员函数把类的各个对象的数据区别开。这样你就可以根据this来访问不同的对象的成员变量。函数体内所有对类数据成员的访问，都会被转化为this->数据成员的方式。
         

​       

然后我们来看这个问题的答案：
（2）空指针调用虚函数运行时会出错。
（3）这两种情况在**编译时都能通过**。

空指针为什么无法调用虚函数？
        我们先来看，如果是用一个不是NULL的指针去调用虚函数的过程。

```c++
A a;
A* p=&a;
```

​       a决定了p的动态类型，调用虚函数是动态联编，在运行时才会根据p的动态类型（p所指向的对象的类型）去确定调用哪个函数。看下面的图，这个过程是：
​       （1）根据p去找到实例a存放数据的那块内存，实例a的内存中放在最前面的是指向虚表的虚指针vptr。
​       （2）然后根据虚指针vptr找到类A的虚函数表（类A所有对象共享这一个虚函数表）。
​       （3）查虚函数表，在虚函数表里找到虚函数fun1()的地址，再根据这个地址去找到对应的函数代码。

![img](https://img-blog.csdnimg.cn/20200914221731916.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIyMjMyNA==,size_16,color_FFFFFF,t_70#pic_center)

   如果现在p=NULL，无法根据p找到虚指针vptr，找不到虚指针就找不到虚表，虚函数的地址放在虚表里呢，虚表都找不到，就无法调用对应的虚函数。

### 第三题

场景设计题，请问你怎么设计架构。

1. 现在有青蛙和飞鸟， 如果它们各自有自己动作， 青蛙是游泳， 飞鸟是飞翔。

2. 如果现在策划改了需求，要求鸟和青蛙可以合体，并且合体之后两种动作都会你怎么设计？

3. 如果现在可以鸟和青蛙合体，变青鸟，青鸟和牛花狗合体。。。10000个合体你又怎么设计？

   

### 第四题

项目

包括设计目的，是否测试，gdb valgrind使用？

### 第五题

用过什么工具？类似.net?不是很懂？

反问