技术面：

会问一些[游戏](https://www.nowcoder.com/jump/super-jump/word?word=游戏)设计的问题，由于我之前并没有这方面的经验，都是当场想一些可能的思路，没有具体深入。



7.[Garena](https://www.nowcoder.com/jump/super-jump/word?word=Garena) 图论问到我懵了



### HR面

接着就是一些非常常规的问题，比如个人的情况、期望薪资、对公司的了解、个人发展计划等等。





### 技术面 

 这轮面试由两个[客户端]()开发大佬主持，我先是做了的简单的个人介绍，然后面试官根据我的[项目]()经历和个人技能进行相关的提问。了解到我之前并没有在[游戏]()公司实习和工作的经验，面试的问题更多注重于程序设计的基础知识。我在这里被问到的问题都非常基础，因为这里的理念是新人都是需要培养的。大佬们认为只要基础知识足够扎实，加上工作中的不断学习和实践，一定可以胜任以前没有接触过的U3D开发工作。考虑到我有后端开发的经验，考官还追加了一些[算法]()问题。我被问到的问题是[游戏]()中排行榜的[排序]()[算法]()，如何用最高的效率排出前100名，需要分析各种[算法]()的优劣、特点，然后借助白板进行演示。在面试的最后，我也向面试官展示了学生时期用[游戏]()引擎做出的一些小作品DEMO，也许成为了后来录用加分项。

###  BOSS面 

 最后一轮面试官是[Garena]()上海[游戏]()研发的负责人，也就是这里的老大（我也是后来才知道）。[Garena]()这轮面试充分向候选人展示了领导层的亲和力，整轮面试更像是非常亲切的交流，问的问题多半是自己学习生活中的有趣的事，或者是简历中感兴趣的地方。我当时被问到的是自己简历中提及的创业经历，我在阐述自己故事的同时，和考官分享自己对生活、对职业发展、对[游戏]()行业的看法。



我是游戏服务器开发，三面是场景题

就是如何设计游戏玩家在线和不在线，如何设计好友列表



基础，就常问的c++11还有三次握手四次挥手，进程这些，算法也很简单，找倒数第n个链表节点





### 可能的重点

### 

### 图论





**模版的声明和实现应该在.h还是.cpp** 

 因为当实例化一个模板时，编译器必须看到模板确切的定义，而不仅仅是它的声明。因此，最好的办法就是将模板的声明和定义都放置在同一个.h文件中。这就是为什么所有的STL头文件都包含模板定义的原因。 

 另外一个方法就是使用关键字“export”！你可以在.h文件中，声明模板类和模板函数；在.cpp文件中，使用关键字export来定义具体的模板类对象和模板函数；然后在其他用户代码文件中，包含声明头文件后，就可以使用该这些对象和函数了。







#### shared_ptr是线程安全的吗？

shared_ptr的引用次数加减操作内部自动加锁解锁，是线程安全的。但是指向对象的指针不是线程安全的
一、使用智能指针访问资源不是线程安全的，需要手动加锁解锁。
二、智能指针的拷贝也不是线程安全的
智能指针的赋值拷贝，首先拷贝指向对象的指针，再使引用次数加减操作，虽然引用次数加减是原子操作，
但是指针拷贝和引用次数两步操作 并不是原子操作，线程不安全，需要手动加锁解锁



#### 网络编程API别忘了

### select

\1.   select能监听的文件描述符个数受限于FD_SETSIZE,一般为1024，单纯改变进程打开的文件描述符个数并不能改变select监听文件个数

\2.   解决1024以下客户端时使用select是很合适的，但如果链接客户端过多，select采用的是轮询模型，会大大降低服务器响应效率，不应在select上投入更多精力

### epoll

epoll是Linux下多路复用IO接口select/poll的增强版本，它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率，因为它会复用文件描述符集合来传递结果而不用迫使开发者每次等待事件之前都必须重新准备要被侦听的文件描述符集合，另一点原因就是获取事件的时候，它无须遍历整个被侦听的描述符集，只要遍历那些被内核IO事件异步唤醒而加入Ready队列的描述符集合就行了。

目前epell是linux大规模并发网络程序中的热门首选模型。

epoll除了提供select/poll那种IO事件的电平触发（Level Triggered）外，还提供了边沿触发（Edge Triggered），这就使得用户空间程序有可能缓存IO状态，减少epoll_wait/epoll_pwait的调用，提高应用程序效率。

#### 基础API

\1.   创建一个epoll句柄，参数size用来告诉内核监听的文件描述符的个数，跟内存大小有关。

```c
  #include <sys/epoll.h>

  int epoll_create(int size)   size：监听数目
```

\2.   控制某个epoll监控的文件描述符上的事件：注册、修改、删除。

```c
  \#include <sys/epoll.h>

  int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)

​    epfd： 为epoll_creat的句柄

​    op：  表示动作，用3个宏来表示：

​      EPOLL_CTL_ADD (注册新的fd到epfd)，

​      EPOLL_CTL_MOD (修改已经注册的fd的监听事件)，

​      EPOLL_CTL_DEL (从epfd删除一个fd)；

​    event： 告诉内核需要监听的事件

 

​    struct epoll_event {

​      __uint32_t events; /* Epoll events */

​      epoll_data_t data; /* User data variable */

​    };

​    typedef union epoll_data {

​      void *ptr;

​      int fd;

​      uint32_t u32;

​      uint64_t u64;

​    } epoll_data_t;

```



**EPOLLIN** ： 表示对应的文件描述符可以读（包括对端SOCKET正常关闭）

**EPOLLOUT**： 表示对应的文件描述符可以写

EPOLLPRI： 表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）

**EPOLLERR**： 表示对应的文件描述符发生错误

EPOLLHUP： 表示对应的文件描述符被挂断；

EPOLLET：  将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)而言的

EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里

 

  

\3.   等待所监控文件描述符上有事件的产生，类似于select()调用。

  ```c
  \#include <sys/epoll.h>
  
    int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout)
  
  ​    events：  用来存内核得到事件的集合，
  
  ​    maxevents： 告之内核这个events有多大，这个maxevents的值不能大于创建epoll_create()时的size，
  
  ​    timeout：  是超时时间
  
  ​      -1： 阻塞
  
  ​      0： 立即返回，非阻塞
  
  ​      \>0： 指定毫秒
  
  ​    返回值： 成功返回有多少文件描述符就绪，时间到时返回0，出错返回-1
  ```



## epoll进阶

### 事件模型

EPOLL事件有两种模型：

Edge Triggered (ET) 边缘触发只有数据到来才触发，不管缓存区中是否还有数据。

Level Triggered (LT) 水平触发只要有数据都会触发。

思考如下步骤：

\1.   假定我们已经把一个用来从管道中读取数据的文件描述符(RFD)添加到epoll描述符。

\2.   管道的另一端写入了2KB的数据

\3.   调用epoll_wait，并且它会返回RFD，说明它已经准备好读取操作

\4.   读取1KB的数据

\5.   调用epoll_wait……

在这个过程中，有两种工作模式：

#### ET模式

ET模式即Edge Triggered工作模式。

如果我们在第1步将RFD添加到epoll描述符的时候使用了EPOLLET标志，那么在第5步调用epoll_wait之后将有可能会挂起，因为剩余的数据还存在于文件的输入缓冲区内，而且数据发出端还在等待一个针对已经发出数据的反馈信息。只有在监视的文件句柄上发生了某个事件的时候 ET 工作模式才会汇报事件。因此在第5步的时候，调用者可能会放弃等待仍在存在于文件输入缓冲区内的剩余数据。epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。最好以下面的方式调用ET模式的epoll接口，在后面会介绍避免可能的缺陷。

1)   基于非阻塞文件句柄

2)   只有当read或者write返回EAGAIN(非阻塞读，暂时无数据)时才需要挂起、等待。但这并不是说每次read时都需要循环读，直到读到产生一个EAGAIN才认为此次事件处理完成，当read返回的读到的数据长度小于请求的数据长度时，就可以确定此时缓冲中已没有数据了，也就可以认为此事读事件已处理完成。

#### LT模式

LT模式即Level Triggered工作模式。

与ET模式不同的是，以LT方式调用epoll接口的时候，它就相当于一个速度比较快的poll，无论后面的数据是否被使用。

LT(level triggered)：LT是缺省的工作方式，并且同时支持block和no-block socket。在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的，所以，这种模式编程出错误可能性要小一点。传统的select/poll都是这种模型的代表。

ET(edge-triggered)：ET是高速工作方式，只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知。请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once).
