### 如何去触发定时器呢

https://my.oschina.net/anur/blog/2252539

在一个线程里面

```c++
void TimeWheelScheduler::Run() {
    while (true) {
        std::this_thread::sleep_for(std::chrono::milliseconds(timerStep_));

        std::lock_guard<std::mutex> lock(mutex_);
        if (stop_) {
            break;
        }
        TimeWheelPtr leastTimeWheel = GetLeastTimeWheel();
        leastTimeWheel->Increase();
        std::list<TimerPtr> slot = std::move(leastTimeWheel->GetAndClearCurrentSlot());
        for (const TimerPtr& timer : slot) {
            auto it = cancelTimerIds_.find(timer->id());
            if (it != cancelTimerIds_.end()) {
                cancelTimerIds_.erase(it);
                continue;
            }
            timer->Run();
            if (timer->repeated()) {
                timer->UpdateWhenTime();
                GetGreatestTimeWheel()->AddTimer(timer);
            }
        }
    }
}
```

---



#### 内核中fork，pthread_create，还有两者的区别。

fork用来穿用来创建一个子进程，内核会赋值父进程的代码，数据，寄存器，堆栈以及文件句柄等所有资源给子进程（先忽略写时拷贝），基本上刚fork出来的子进程就是父进程的镜像，拥有进程的该有的所有资源。



而pthread_create创建线程时，只是给线程分配了自己的栈内存、寄存器，而代码段，数据段，文件句柄，堆内存等是进程内所有线程共享的资源。



Linux通过`clone`系统调用实现fork.调用通过一系列的**参数标志来指明父、子进程需要共享的资源**。fork、vfork、和__clone的库函数都根据各自需要的参数标志去调用clone，然后由clone()去调用do_fork()。



调用fork和 pthread_create,然后利用strace跟踪两者的调用过程，发现果然都是调用的clone。

---



#### 线程间同步与互斥方法

**互斥**：通过保证同一时间只有一个执行流可以对临界资源进行访问（一个执行流访问期间，其它执行流不能访问），来保证数据访问的安全性。

**同步**：通过一些条件判断来实现多个执行流对临界资源访问的合理性（有资源则访问，没有资源则等待，等有了资源再被唤醒）。

**线程间通信的方式:**

线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制  

**锁机制**

* 包括互斥锁/量（mutex）、读写锁（reader-writer lock）、自旋锁（spin lock）、条件变量（condition）
  * 互斥锁/量（mutex）：提供了以排他方式防止数据结构被并发修改的方法。
  * 读写锁（reader-writer lock）：允许多个线程同时读共享数据，而对写操作是互斥的。
  * 自旋锁（spin lock）与互斥锁类似，都是为了保护共享资源。互斥锁是当资源被占用，申请者进入睡眠状态；而自旋锁则循环检测保持者是否已经释放锁。
  * 条件变量（condition）：可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。

**临界区：**

通过多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问；

**互斥量Synchronized/Lock：**

采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问

互斥量又称互斥锁，主要用于线程互斥，不能保证按序访问，可以和条件锁一起实现同步。当进入临界区      时，需要获得互斥锁并且加锁；当离开临界区时，需要对互斥锁解锁，以唤醒其他等待该互斥锁的线程。其主要的系统调用如下：

`pthread_mutex_init`:初始化互斥锁

`pthread_mutex_destroy`：销毁互斥锁

`pthread_mutex_lock`：以原子操作的方式给一个互斥锁加锁，如果目标互斥锁已经被上锁，`pthread_mutex_lock`调用将阻塞，直到该互斥锁的占有者将其解锁。

`pthread_mutex_unlock`:以一个原子操作的方式给一个互斥锁解锁。

**条件变量**，

又称条件锁，用于在线程之间同步共享数据的值。条件变量提供一种线程间通信机制：当某个共享数据达到某个值时，唤醒等待这个共享数据的一个/多个线程。即，当某个共享变量等于某个值时，调用 signal/broadcast。此时操作共享变量时需要加锁。其主要的系统调用如下：

`pthread_cond_init`:初始化条件变量

`pthread_cond_destroy`：销毁条件变量

`pthread_cond_signal`：唤醒一个等待目标条件变量的线程。哪个线程被唤醒取决于调度策略和优先级。

`pthread_cond_wait`：等待目标条件变量。需要一个加锁的互斥锁确保操作的原子性。该函数中在进入wait状态前首先进行解锁，然后接收到信号后会再加锁，保证该线程对共享资源正确访问。

**信号量Semphare：**

* 信号量机制(Semaphore)
  * 无名线程信号量
  * 命名线程信号量

为控制具有有限数量的用户资源而设计的，它允许多个线程在同一时刻去访问同一个资源，但一般需要限制同一时刻访问此资源的最大线程数目。
信号量是一种特殊的变量，可用于线程同步。**它只取自然数值**，并且只支持两种操作：

**P(SV):如果信号量SV大于0，将它减一；如果SV值为0，则挂起该线程。**

**V(SV)：如果有其他进程因为等待SV而挂起，则唤醒，然后将SV+1；否则直接将SV+1。**

其系统调用为：

`sem_wait（sem_t *sem）`：以原子操作的方式将信号量减1，如果信号量值为0，则sem_wait将被阻塞，直到这个信号量具有非0值。

`sem_post（sem_t *sem)`：以原子操作将信号量值+1。当信号量大于0时，其他正在调用sem_wait等待信号量的线程将被唤醒。

**事件(信号)**

* 信号机制(Signal)：类似进程间的信号处理
  Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作

**屏障**

* 屏障（barrier）：屏障允许每个线程等待，直到所有的合作线程都达到某一点，然后从该点继续执行。

  

#### 进程间同步与互斥方法

当多个进程协同完成一些任务时，不同进程的执行进度不一致，这便产生了进程的同步问题。需要操作系统干预，在特定的同步点对所有进程进行同步，这种协作进程之间相互等待对方消息或信号的协调关系称为进程同步。进程互斥本质上也是一种进程同步。

**进程的同步方法**：

1. 互斥锁
2. 读写锁
3. 条件变量
4. ？记录锁(record locking)
5. 信号量
6. 屏障（barrier）



#### 简述进程间通信方法

每个进程各自有不同的用户地址空间,任何一个进程的全局变量在另一个进程中都看不到，**所以进程之间要交换数据必须通过内核**,在内核中开辟一块缓冲区,进程A把数据从用户空间拷到内核缓冲区,进程B再从内核缓冲区把数据读走,内核提供的这种机制称为进程间通信。

不同进程间的通信本质：进程之间可以看到一份公共资源；而提供这份资源的形式或者提供者不同，造成了通信方式不同。

进程间通信主要包括管道、系统IPC（包括消息队列、信号量、信号、共享内存等）、以及套接字socket。



### 管道

1. 无名管道(普通管道)(PIPE)，是 UNIX 系统IPC最古老的形式。


    1. 它是半双工的（即数据只能在一个方向上流动），具有固定的读端和写端
    
    2. 它只能用于具有亲缘关系的进程之间的通信（也是父子进程或者兄弟进程之间）
    
    3. 它可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中


* 优点：简单方便
* 缺点：
  1. 局限于单向通信 
  2. 只能创建在它的进程以及其**有亲缘关系**的进程之间
  3. 缓冲区有限

2. FIFO，也称为命名管道，它是一种文件类型。

   1. FIFO可以在无关的进程之间交换数据,与无名管道不同。

   2. FIFO有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。

* 优点：可以实现任意关系的进程间的通信
* 缺点：
  1. 长期存于系统中，使用不当容易出错
  2. 缓冲区有限

### 系统IPC：

3. **消息队列**，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标识。 (消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等特点)具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息；

特点：

    1. 消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。
    
    2. 消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。
    
    3. 消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取。


* 优点：可以实现任意进程间的通信，并通过系统调用函数来实现消息发送和接收之间的同步，无需考虑同步问题，方便
* 缺点：信息的复制需要额外消耗 CPU 的时间，不适宜于信息量大或操作频繁的场合

4. **信号量（semaphore）**与已经介绍过的 IPC 结构不同，它是一个计数器，可以用来控制多个线程对共享资源的访问。**信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据**。

特点：

    1. 信号量用于进程间同步，若要在进程间传递数据需要结合共享内存。
    
    2. 信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作。
    
    3. 每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数。
    
    4. 支持信号量组。


* 优点：可以同步进程
* 缺点：信号量有限

5. 信号（Signal）：一种比较复杂的通信方式，用于通知接收进程某个事件已经发生

6. 套接字（Socket）：
   socket也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同主机之间的进程通信。

* 优点：
  1. 传输数据为字节级，传输数据可自定义，数据量小效率高
  2. 传输数据时间短，性能高
  3. 适合于客户端和服务器端之间信息实时交互
  4. 可以加密,数据安全性强
* 缺点：需对传输的数据进行解析，转化成应用级的数据。

7. 共享内存（Shared Memory）

它使得多个进程可以访问同一块内存空间（这段共享内存由一个进程创建），不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要**依靠某种同步操作，如互斥锁和信号量等**
特点：

    1. 共享内存是最快的一种IPC，因为进程是直接对内存进行存取
    
    2. 因为多个进程可以同时操作，所以需要进行同步
    
    3. 信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问


* 优点：无须复制，快捷，信息量大
* 缺点：
  1. 通信是通过**将共享空间缓冲区直接附加到进程的虚拟地址空间**中来实现的，因此进程间的读写操作的同步问题
  2. 利用内存缓冲区直接交换信息，内存的实体存在于计算机中，只能同一个计算机系统中的诸多进程共享，不方便网络通信

---



### 多少并发量，epoll才会比select更有效。



---

### 如何设计一个可以自动扩容的哈希





---

### vector扩容会时间复杂度比较高，有没有边复制边扩容的方法。



---

### UDP怎么保证可靠？

UDP要想可靠，就要接收方收到UDP之后回复个确认包，发送方有个机制，收不到确认包就要重新发送，每个包有递增的序号，接收方发现中间丢了包就要发重传请求，当网络太差时候频繁丢包，防止越丢包越重传的恶性循环，要有个发送窗口的限制，发送窗口的大小根据网络传输情况调整，调整算法要有一定自适应性。

UDP实现的可靠协议，基本都会对TCP的某一部分进行加强，另外一部分进行削弱。因为：
“实时性+可靠性+公平性” 三者不能同时保证，因此可以牺牲TCP的局部公平性来换取更好的实时性，或者更浪费点带宽，来实现更低的延迟。比如我实现的一般快速可靠协议，使用比tcp多浪费15%的带宽的代价，换取了平均延迟降低30%-40%，最大延迟降低两倍的传输效果，成功的用到了多个项目中：



作者：韦易笑（KCP）




---

###  手写strcpy

```c
char *strcpy(char* strDest, const char* strSrc)
{
    assert( (strDest != NULL) && (strSrc != NULL));
    char *address = strDest;
    while((*strDest++ = *strSrc++) != '\0');
    return address;
}
```

这里有如下几点需要注意：

- 源字符串要使用const类型，避免在程序中被修改；
- 在函数入口处要加上断言，检查源字符串指针和目标字符串指针是否有为空的，否则会产生不可预料的错误；
- 使用while循环要简单而清晰，使用尽量精简的代码；
- 返回值要是`char*`，且返回了目标字符串指针的原值，使得函数可以支持链式表达式，增加了函数的附加值。

以上这些点不只适用于strcpy这里，而是我们任何时候写代码都尽量遵循这些规则，这样才能写出高可用、高健壮性的代码。

对于以上代码，我们可以看出来，它是存在隐患的，当源字符串的长度超出目标字符串时，会导致把数据写入到我们无法控制的地址中去，存在很大的风险，所以就有了strncpy，下面也给一个strncpy的实现，如下：

```c
char *strncpy(char* strDest, const char* strSrc, size_t n)
{
    assert( (strDest != NULL) && (strSrc != NULL));
    char *address = strDest;
    while ( n-- && (*strDest++ = *strSrc++) != '\0');
    return address;
}
```

要根据输入的长度做一个控制，而往往我们使用的时候，输入的长度都是目标字符串的长度减1，因为要留一个位置给结束符`'\0'`。

### 自己实现memcpy.

注意条件判断和拷贝的覆盖问题

memcpy的实现其实可以参考strncpy的实现，比如我们把指针类型转换成char*来实现拷贝，这种方式就是按照一个字节一个字节来进行拷贝了，首先还是一睹代码为快，如下：



```c
#include <stdio.h>
#include <string.h>

struct people
{
    int iAge;
    char szName[12];
    char szSex[3];
};

//模拟memcpy的实现
void * mymemcpy(void *dest, const void *src, size_t n)
{
    if (dest == NULL || src == NULL)
          return NULL;
    char *pDest = static_cast <char*>(dest);
    const char *pSrc  = static_cast <const char*>(src);
    if (pDest > pSrc && pDest < pSrc+n)
    {
        for (size_t i=n-1; i != -1; --i)
        {
                pDest[i] = pSrc[i];
        }
    }
    else
    {
        for (size_t i= 0; i < n; i++)
        {
                pDest[i] = pSrc[i];
        }
    }

    return dest;
}

int main()
{
    people stPeople1, stPeople2;
    memset((void*)&stPeople1, 0x00, sizeof(stPeople1));
    memset((void*)&stPeople2, 0x00, sizeof(stPeople2));
    stPeople1.iAge = 32;
    mymemcpy(stPeople1.szName, "li lei", sizeof(stPeople1.szName));
    mymemcpy(stPeople1.szSex, "man", sizeof(stPeople1.szSex));

    mymemcpy((void*)&stPeople2, (void*)&stPeople1, sizeof(stPeople2));

    printf("this people age is %d, name is %s, sex is %s\n", stPeople2.iAge, stPeople2.szName, stPeople2.szSex);

    return 0;
}
```

我们看mymemcpy的实现，此时是一个字节的实现，但它与strncpy实现不能一样，看一下memcpy实现的注意点：

- 同样的，在函数入口处要检查源字符串指针和目标字符串指针是否有为空的，否则会产生不可预料的错误；
- 因为是按照一个字节拷贝，那就要把形参转换成`char*`类型来操作；
- 要检查源内存和目标内存是否存在内存重叠，如果目标内存首地址在源内存的中间，则要从后往前拷贝，因为如果从前往后拷贝，那从目标内存首地址开始的地方就会被覆盖掉，如果没有重叠，或者源内存地址在目标内存的中间，那没有关系，可以从前往后拷贝；
- 不能使用`'\0'`来判断拷贝的结束，因为它是对一整块内存的拷贝，举一个浅显的例子，假设拷贝一个结构体，类似上面代码，那么它很可能拷贝到中间的某个地方就停止了，这个拷贝就相当于没有完成；
- 同样的，memcpy也要返回目标字符串地址；

但是这个时候如果面试官问你，按照4个字节来拷贝，该怎么实现呢？

根据前面的逻辑，其实按照4个字节拷贝就是把指针类型转换成int*来拷贝，不过有一点不同的是，如果按照4个字节来拷贝，就没办法去判断内存重叠的情况了，因为内存的基本单位是一个字节，4个字节是没有办法避免覆盖情况的，一个可用的4个字节拷贝代码如下：

```c
void * mymemcpy(void *dest, const void *src, size_t n)
{
    if (dest == NULL || src == NULL)
          return NULL;
    int *pDest = (int*)dest;
    int *pSrc  = (int*)src;
    int iWordNum = n/4;
    int iSlice = n%4;
    while(iWordNum--)
    {
        *pDest++ = *pSrc++;
    }
    char* pcDest = (char*)pDest;
    char* pcSrc = (char*)pSrc;

    while(iSlice--)
    {
        *pcDest++ = *pcSrc++;
    }

    return dest;
}
```

按照4个字节判断，一个清晰的思路是满足4个字节的按照int类型去拷贝，不满足4个字节的就还是按照char类型去拷贝。

好了，关于strcpy和memcpy的实现就介绍到这里，如果我的创作对你有用的话，麻烦点个赞呗。

