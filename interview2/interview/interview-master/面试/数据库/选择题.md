遵守两段锁协议的事务一定不会死锁。（  F  ）

两段锁协议（Two-Phase Locking――2PL）
两段锁协议规定所有的事务应遵守的规则：
① 在对任何数据进行读、写操作之前，首先要申请并获得对该数据的封锁。
② 在释放一个封锁之后，事务不再申请和获得其它任何封锁。
即事务的执行分为两个阶段：
第一阶段是获得封锁的阶段，称为扩展阶段。

第二阶段是释放封锁的阶段，称为收缩阶段。

**定理：**若所有事务均遵守两段锁协议，则这些事务的所有交叉调度都是可串行化的。
对于遵守两段协议的事务，其交叉并发操作的执行结果一定是正确的。值得注意的是，上述定理是充分条件，不是必要条件。一个可串行化的并发调度的所有事务并不一定都符合两段锁协议，存在不全是2PL的事务的可串行化的并发调度。
同时我们必须指出，遵循两段锁协议的事务有可能发生死锁。

此时事务T1 、T2同时处于扩展阶段，两个事务都坚持请求加锁对方已经占有的数据，导致死锁。
为此，又有了一次封锁法。一次封锁法要求事务必须一次性将所有要使用的数据全部加锁，否则就不能继续执行。因此，一次封锁法遵守两段锁协议，但两段锁并不要求事务必须一次性将所有要使用的数据全部加锁，这一点与一次性封锁不同，这就是遵守两段锁协议仍可能发生死锁的原因所在。

---

DBMS是位于用户和OS（操作系统）之间的一层数据库管理软件，是系统软件

DBS是计算机系统引入数据库以后的系统，包含数据库（DB）、数据库管理系统（DBMS）、数据库管理员（DBA）、应用系统等。

---

设有图书管理数据库：
图书(总编号C(6),分类号C(8),书名C(16),作者C(6),出版单位C(20),单价N(6,2))
读者(借书证号C(4),单位C(8),姓名C(6),性别C(2),职称C(6),地址C(20))
借阅(借书证号C(4),总编号C(6),借书日期D(8))
对于图书管理数据库，查询0001号借书证的读者姓名和所借图书的书名。

SQL语句正确的是_B。
SELECT 姓名,书名 FROM 借阅,图书,读者 WHERE;
借阅.借书证号="0001" AND;

__?

__?

```sql
图书.分类号=借阅.分类号 AND;
读者.借书证号=借阅.借书证号

图书.总编号=借阅.总编号 AND;
读者.借书证号=借阅.借书证号

读者.总编号=借阅.总编号 AND;
读者.借书证号=借阅.借书证号

图书.总编号=借阅.总编号 AND;
读者.书名=借阅.书名

```

A借阅没有分类号

C读者没有总编号

D读者没有书名

---

数据表的基本操作 

创建数据表： CREATE TABLE 数据表名称 

查看数据表： SHOW CREATE TABLE 数据表名称 

修改数据表： ALTER TABLE （修改表名RENAME TO；修改字段名和数据类型CHANGE；修改字段数据类型MODIFY；添加字段ADD；删除字段DROP；修改字段位置MODIFY…AFTER） 



删除数据表： DROP TABLE 表名



1、当你不再需要该表时， 用 **drop**;

2、当你仍要保留该表，但要删除所有记录时， 用 **truncate**;

3、当你要删除部分记录时， 用 **delete**。

---



如果ORDER BY子句后未指定ASC或DESC，默认使用以下哪个？ ASC

---

在 SQL 语言中使用 FOREIGN KEY 时，与之配合的语句是（REFERENCES）。

建立外键的前提： 本表的列必须与外键类型相同(外键必须是外表[主键](http://baike.baidu.com/view/68068.htm))。

指定主键关键字： foreign key(列名)

引用外键关键字： references <外键表名>(外键列名)（被参考的表）

```
假设两张表,表1(学号,姓名,性别),学号为主键. 
表2(学号,课程,成绩). 
可以为表2的学号定义外键(FOREIGN KEY),该外键的取值范围参照(REFERENCES)表1的学号。
```

---

在 MySql 中，以下哪种备份方式是在某一次完全备份的基础，只备份其后数据的变化？

```
增量备份
```

---

一个第三范式的关系模式，一定属于第二范式。（  T  ）

 满足第三范式（3NF）必须先满足第二范式（2NF）。满足第二范式（2NF）必须先满足第一范式（1NF）。

第一范式要求元组的每个分量必须是不可分的数据项。
第二范式要求在第一范式基础上每一个非主属性完全函数依赖于码。
第三范式要求在第二范式基础上每一个非主属性不传递依赖于码。
Boyce-Codd范式要求在第一范式基础上对于每一个非平凡的函数依赖X-Y都有X包含码。
第四范式要求在第一范式基础上对于每一个非平凡的多值依赖X→→Y(Y不是X的子集)都有X包含码。
因此，消除了部分函数依赖的1NF关系模式属于2NF。



---

![img](https://uploadfiles.nowcoder.com/images/20190415/221424248_1555323845699_71C85ED07FC7D71337218AD5DFA3AFA3)

---

在数据库设计中，将E－R图转换成关系数据模型的过程属于（ 逻辑设计阶段 ）。

```
需求分析阶段
概念设计阶段
逻辑设计阶段
物理设计阶段
```

数据库的设计总体上分为6个阶段：

**1、** **需求分析阶段**

  准确了解用户的需求，撰写需求说明

**2、概念设计阶段**

  它是整个数据库设计的关键，通过对用户需求进行综合，归纳与抽象，形成一个独立于具体DBMS的概念模型。E-R图的设计在此阶段。

**3、逻辑结构设计阶段**

  将概念结果转换为某个DBMS所支持的数据模型。也就是指E-R图和关系模型的转换，具体为将实体，实体的属性和实体之间的联系转换为关系模式。

**4、数据库物理设计阶段**

  为逻辑结果选取一个最适合应用环境的物理结构，包括存储结构和存取方法。

**5、数据库实施阶段**

 此阶段利用SQL语句实现逻辑结构设计和物理设计阶段的内容，包括建立数据库，编制与调试应用程序等。

**6、数据库运行和维护阶段**

 运行过程中不断的调整，修改和优化数据库系统。

---

在数据库的三级模式结构中，描述数据库中全体数据的全局逻辑结构和特征的是（ D）。

```
外模式
内模式
存储模式
模式
```

数据库系统由**外模式、模式和内模式**构成。

外模式是数据库用户能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图；

模式也称逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。

内模式也称存储模式，是数据物理结构和存储方式的描述。

---

关系规范化中的 删除 异常是指(不该删除的数据被删除 )

删除异常：不该删除的数据被删除

<p>插入异常：应该插入的数据未被插入</p>

---

下列关系运算中， （广义笛卡尔积 ） 运算不属于专门的关系运算。

关系运算:包括选择、投影、连接以及除法。

集合运算:是二目运算，包括并、差、交、广义笛卡尔积四种运算。

---

**一个关系数据库文件中的各条记录（前后顺序可以任意颠倒，不影响库中的数据关系）** **。**

一个关系表中的数据就是数据集，集合大家都明白吧！无序的！

---

逻辑数据独立性是指修改（模式保持外模式不变 ） 。

逻辑独立性是外模式不变，模式改变时，如增加新的关系，新的属性，改变属性的数据类型，由数据库管理员对各个外模式/模式的映像做相应改变，可以使得外模式不变，因为应用程序依据外模式编写的，所以外模式不变，应用程序也不变，即保证了逻辑独立


物理独立性是模式不变，内模式改变，如数据库存储结构发生改变，选用另一种数据结构，由数据库管理员对各个模式/内模式的映像做相应改变，可以使得模式不变 ，从而保证了应用程序也不变

---

概念模型独立于(  硬件设备和DBMS )

概念模型是从用户角度看到的模型，是第一层抽象，与具体的计算机和DBMS(数据库管理系统)无关。数据模型是从计算机角度看到的模型。

---

下列关于数据库系统特点的叙述中，正确的一项是 

```
数据库系统的存储模式如有改变，概念模式无需改动
```

![img](https://uploadfiles.nowcoder.com/images/20171003/4017480_1507005784986_F4D63139C09EFF644F308497B1D205D3)

---

MySQL主从架构的主数据库中不可能出现的日志为：中继日志

**主服务器**将改变记录到二进制日志文件（binary log)中，

**从服务器**将主服务器的二进制文件拷贝到它的中继日志（relay log)中，并重新开启线程处理中继日志中的事件。

**从服务器的 slave 进程从主服务器处获取二进制日志的内容并写入中继日志，然后由 IO 进程读取并执行中继日志中的语句。**

MySQL中日志类型

a、错误日志：记录启动、运行或停止mysqld时出现的问题。

b、通用日志：记录建立的客户端连接和执行的语句。

c、更新日志：记录更改数据的语句。该日志在MySQL 5.1中已不再使用。

d、二进制日志：记录所有更改数据的语句。还用于复制。

e、慢查询日志：记录所有执行时间超过long_query_time秒的所有查询或不使用索引的查询。

f、Innodb日志：innodb redo log

g、中继日志(relay log)**: 用于主从复制架构中的从服务器上**

---

雇员表EMP 结构如下
( 雇员编号 EMPNO ,  姓名 ENAME ,
工作岗位 JOB , 管理员编号 MGR ,
受雇时间 HIREDATE , 工资 SAL ,
奖金 COMM , 部门编号 DEPTNO );
下列操作语句正确的是：（   ）

```
显示在10和30部门工作并且工资大于5500元的雇员的姓名和工资，列标题显示为Employee和Monthly Salary 语句：SELECT ENAME EMPLOYEE ,SAL “MONTHLY SALARY” FROM EMP WHERE DEPTNO IN(10,30)AND SAL>5500;
```

---

```
这是模糊查询的通配符
_:代表的是任意单个字符
%:任意长度的字符串
所以_A%代表返回第二个单词为A的任意字符串
兄弟姐妹们记住咯!!!!不能再错了!!!
拓展:[]:代表指定范围内的任意单个字符

[^]: 代表指定范围内或者集合中的任意单个字符
```

