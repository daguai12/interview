一，作者讲了什么？
  1，Redis的底层数据结构

二，作者是怎么把这事给讲明白的？
  1，讲了Redis的数据结构：数据的保存形式与底层数据结构
  2，由数据结构的异同点，引出数据操作的快慢原因

三，为了讲明白，作者讲了哪些要点？有哪些亮点？
  1，亮点1：string，list，set，hast,sortset都只是数据的保存形式，底层的数据结构是：简单动态字符串（sds），双向链表，压缩列表，哈希表，跳表，整数数组
  2，亮点2：Redis使用了一个哈希表保存所有的**键值对**（指针形式，void实现泛型）
  3，要点1：五种数据形式的底层实现
      a，string：简单动态字符串
      b，list：双向链表，压缩列表（快速列表，快速列表是把压缩列表作为元素的双向链表。）
      c，hash：压缩列表，哈希表
      d，Sorted Set：压缩列表，跳表
      e，set：哈希表，整数数组
  4，要点2：List ,hash，set ,sorted set被统称为集合类型，一个键对应了一个集合的数据
  5，要点3：集合类型的键和值之间的结构组织
      a：Redis使用一个哈希表保存所有键值对，一个哈希表实则是一个数组，数组的每个元素称为哈希桶。
      b：哈希桶中的元素保存的不是值的本身，而是指向具体值的指针
  6，要点4：哈希冲突解决
      a：Redis的hash表是全局的，所以当写入大量的key时，将会带来哈希冲突，已经rehash可能带来的操作阻塞
      b：Redis解决hash冲突的方式，是链式哈希：同一个哈希桶中的多个元素用一个链表来保存
      c：当哈希冲突链过长时，Redis会对hash表进行rehash操作。rehash就是增加现有的hash桶数量，分散entry元素。
  7，要点5：rehash机制
      a：为了使rehash操作更高效，Redis默认使用了两个全局哈希表：哈希表1和哈希表2，起始时hash2没有分配空间
      b：随着数据增多，Redis执行分三步执行rehash;
        1，给hash2分配更大的内存空间，如是hash1的两倍
        2，把hash1中的数据重新映射并拷贝到哈希表2中
        3，释放hash1的空间
  8，要点6：渐进式rehash
      a：由于步骤2重新映射非常耗时，会阻塞redis
      b：讲集中迁移数据，改成每处理一个请求时，就从hash1中的第一个索引位置，顺带将这个索引位置上的所有entries拷贝到hash2中。
  9，要点7 ：压缩列表，跳表的特点
      a：压缩列表类似于一个数组，不同的是:压缩列表在表头有三个字段zlbytes,zltail和zllen分别表示长度，列表尾的偏移量和列表中的entry的个数，压缩列表尾部还有一个zlend，表示列表结束
        所以压缩列表定位第一个和最后一个是O(1),但其他就是O(n)
      b：跳表：是在链表的基础上增加了多级索引，通过索引的几次跳转，实现数据快速定位

四，对于作者所讲，我有哪些发散性思考？

五，在将来的哪些场景中，我能够用到它？

六，评论区收获

整数数组和压缩列表在查找时间复杂度方面并没有很大的优势，那为什么 Redis 还会把它们作为底层数据结构呢？

  1，数组和压缩列表可以提升内存利用率，因为他们的数据结构紧凑
  2，数组对CPU高速缓存支持友好，当数据元素超过阈值时，会转为hash和跳表，保证查询效率