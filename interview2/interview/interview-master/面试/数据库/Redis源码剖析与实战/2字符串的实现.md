### 02 | 键值对中字符串的实现，用char*还是结构体？

而对于 Redis 来说，键值对中的键是字符串，值有时也是字符串。我们在 Redis 中写入一条用户信息，记录了用户姓名、性别、所在城市等，这些都是字符串，如下所示：

```
SET user:id:100 {“name”: “zhangsan”, “gender”: “M”,“city”:"beijing"}
```

既然字符串的使用如此广泛和关键，就使得我们在实现字符串时，需要尽量满足以下三个要求：

* 能支持丰富且高效的字符串操作，比如字符串追加、拷贝、比较、获取长度等；
* 能保存任意的二进制数据，比如图片等；
* 能尽可能地节省内存开销。

其实，Redis 设计了**简单动态字符串**（Simple Dynamic String，SDS）的结构，用来表示字符串。相比于 C 语言中的字符串实现，SDS 这种字符串的实现方式，会**提升字符串的操作效率，并且可以用来保存二进制数据**。

### 为什么 Redis 不用 char*？

字符数组的结尾位置就用“\0”表示，意思是指字符串的结束。

C 语言标准库中字符串的操作函数，就会通过检查字符数组中是否有“\0”，来判断字符串是否结束。

**这就不符合 Redis 希望能保存任意二进制数据的需求了**

而除了 char* 字符数组结构的设计问题以外，使用“\0”作为字符串的结束字符，虽然可以让字符串操作函数判断字符串的结束位置，但它也会带来另一方面的负面影响，也就是会导致操作函数的复杂度增加。

我们再来看另一个常用的操作函数：字符串追加函数 strcat。strcat 函数是将一个源字符串 src 追加到一个目标字符串的末尾。该函数的代码如下所示：

```c

  char *strcat(char *dest, const char *src) {
     //将目标字符串复制给tmp变量
     char *tmp = dest;
     //用一个while循环遍历目标字符串，直到遇到“\0”跳出循环，指向目标字符串的末尾
     while(*dest)
        dest++;
     //将源字符串中的每个字符逐一赋值到目标字符串中，直到遇到结束字符
     while((*dest++ = *src++) != '\0' )
     return tmp;
  }
```

也都需要先通过遍历字符串才能得到目标字符串的末尾。然后对于 strcat 函数来说，还要再遍历源字符串才能完成追加。另外，它在把源字符串追加到目标字符串末尾时，还需要确认目标字符串具有足够的可用空间，否则就无法追加。**不符合 Redis 对字符串高效操作的需求**

### SDS 的设计思想

首先，SDS 结构里包含了一个字符数组 buf[]，用来保存实际数据。同时，SDS 结构里还包含了三个元数据，分别是**字符数组现有长度 len、分配给字符数组的空间长度 alloc**，以及 **SDS 类型 flags**。其中，Redis 给 len 和 alloc 这两个元数据定义了多种数据类型，进而可以用来表示不同类型的 SDS，稍后我会给你具体介绍。下图显示了 SDS 的结构，你可以先看下。

![img](https://static001.geekbang.org/resource/image/77/a3/772d340bfbfe52de3a66fbb011ac22a3.jpg?wh=1891x647)

SDS 本质还是字符数组，只是在字符数组基础上增加了额外的元数据。在 Redis 中需要用到字符数组时，就直接使用 sds 这个别名。

