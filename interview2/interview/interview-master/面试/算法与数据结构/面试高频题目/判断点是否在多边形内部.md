# [判断点是否在多边形内部](https://www.cnblogs.com/luxiaoxun/p/3722358.html)

如何判断一个点是否在多边形内部？

（1）面积和判别法：判断目标点与多边形的每条边组成的三角形面积和是否等于该多边形，相等则在多边形内部。

（2）夹角和判别法：判断目标点与所有边的夹角和是否为360度，为360度则在多边形内部。

（3）引射线法：从目标点出发引一条射线，看这条射线和多边形所有边的交点数目。如果有奇数个交点，则说明在内部，如果有偶数个交点，则说明在外部。

具体做法：将测试点的Y坐标与多边形的每一个点进行比较，会得到一个测试点所在的行与多边形边的交点的列表。在下图的这个例子中有8条边与测试点所在的行相交，而有6条边没有相交。如果测试点的两边点的个数都是奇数个则该测试点在多边形内，否则在多边形外。在这个例子中测试点的左边有5个交点，右边有三个交点，它们都是奇数，所以点在多边形内。

![img](https://images0.cnblogs.com/i/434101/201405/112137381678569.gif)

算法图解：

![img](https://images0.cnblogs.com/blog/434101/201412/061456221234057.jpg)

关于这个算法的具体的更多图形例子：http://alienryderflex.com/polygon/

最终选择了一种简单易懂，且适合所有多边形的方法--**水平/垂直交叉点数判别法**。

方法
如果从点P作**水平向左**的射线的话，假设P在多边形内部，那么这条射线与多边形的交点必为奇数，如果P在多边形外部，则交点个数必为偶数（0也在内）。所以，我们可以顺序（顺时针或逆时针）考虑多边形的每条边，求出交点的总个数。还有一些特殊情况要考虑。假如考虑边(P1,P2)，
1) 如果射线正好穿过P1或者P2,那么这个交点会被算作2次，处理办法是如果P的从坐标与P1,P2中较小的纵坐标相同，则直接忽略这种情况
2) 如果射线水平，则射线要么与其无交点，要么有无数个，这种情况也直接忽略。
3) 如果射线竖直，而P的横坐标小于P1,P2的横坐标，则必然相交。
4) 再判断相交之前，先判断P是否在边(P1,P2)的上面，如果在，则直接得出结论：P再多边形内部。

```c++
//作用：判断点是否在多边形内
//p指目标点， ptPolygon指多边形的点集合， nCount指多边形的边数
int BlobDetect::PtInPolygon (Point p, vector<cv::Point>& ptPolygon, int nCount)  
{  
	// 交点个数  
	int nCross = 0;  
	for (int i = 0; i < nCount; i++)   
	{  
		Point p1 = ptPolygon[i];  
		Point p2 = ptPolygon[(i + 1) % nCount];// 点P1与P2形成连线  
 
		if ( p1.y == p2.y )  
			continue;  
		if ( p.y < min(p1.y, p2.y) )  
			continue;  
		if ( p.y >= max(p1.y, p2.y) )  
			continue;  
		// 求交点的x坐标（由直线两点式方程转化而来）   
 
		double x = (double)(p.y - p1.y) * (double)(p2.x - p1.x) / (double)(p2.y - p1.y) + p1.x;  
 
		// 只统计p1p2与p向右射线的交点  
		if ( x > p.x )  
		{  
			nCross++;  
		}  
 
	}  
 
	// 交点为偶数，点在多边形之外  
	// 交点为奇数，点在多边形之内
	if ((nCross % 2) == 1)
	{
		g_proj_log.ShowInfo("点在区域内");
		return BLOB_OK;
	}
	else
	{
		g_proj_log.ShowInfo("点在区域外");
		return BLOB_FAIL;
	}
} 
```

