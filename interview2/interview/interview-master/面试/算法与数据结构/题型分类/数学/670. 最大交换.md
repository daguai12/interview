给定一个非负整数，你**至多**可以交换一次数字中的任意两位。返回你能得到的最大值。

**示例 1 :**

```
输入: 2736
输出: 7236
解释: 交换数字2和数字7。
```

#### 暴力的做法很简单，

一句话总结就是：

从左往右枚举每个位上的数字，找到比当前数字大且最大，最靠右(最低位)的数字，进行交换。没有则不交换

举几个例子先：

2736：2找到后面最大的7👉交换👉7236
98368：9后面没有比它大的，8也是。3找到后面最大的8👉交换👉98863
1993：这个例子就体现最靠右，1找到后面最大的9，而且要是最靠右的9👉交换👉9913（❌9193）

#### 贪心

我们预处理出每个数字最后一次出现的下标，再从左向右依次枚举每个位上的数字，找到当前数字大的(预处理保证了最靠右边)的数字并交换。

我们用每个位上的数字作为下标，所以预处理的数组有10位，0-9

每次我们从预处理的数组的右往左找，确保找到的是比当前数字大且要求最大的数

注意下转换就行了

```c++
class Solution {
public:
    int maximumSwap(int num) {
        // 自己都看不懂自己之前写的是什么玩意是吧
        vector<int> index(10);
        vector<int> nums;
        while (num) {
            int t = num % 10;
            num /= 10;
            nums.push_back(t);
        }
        reverse(nums.begin(), nums.end());
        int n = nums.size();
        // 记录每个数字出现的最右边的地方
        for (int i = 0; i < n; ++i) {
            index[nums[i]] = i;
        }
        for (int i = 0; i < n; ++i) {
            // 比当前数字最大
            for (int j = 9; j > nums[i]; --j) {
                if (index[j] > i) {
                    swap(nums[i], nums[index[j]]);
                    goto here;
                }
            }
        }
        here:
        int ans = 0;
        for (int i = 0; i < n; ++i) {
            ans = ans * 10 + nums[i];
        }
        return ans;
    }
};
```

