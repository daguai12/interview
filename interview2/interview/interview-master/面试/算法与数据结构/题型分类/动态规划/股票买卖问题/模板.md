每天都有三种「选择」：买⼊、卖出、⽆操作，我们⽤
buy, sell, rest 表⽰这三种选择。

但问题是，并不是每天都可以任意选择这三
种选择的，因为 sell 必须在 buy 之后，buy 必须在 sell 之后。那么 rest 操作
还应该分两种状态，
⼀种是 buy 之后的 rest（持有了股票），
⼀种是 sell 之
后的 rest（没有持有股票）。⽽且别忘了，我们还有交易次数 k 的限制，就
是说你 buy 还只能在 k > 0 的前提下操作。

这个问题的「状态」有三个，第⼀个是天
数，第⼆个是允许交易的最⼤次数，第三个是当前的持有状态（即之前说的
rest 的状态，我们不妨⽤ 1 表⽰持有，0 表⽰没有持有）。


```c++
dp[i][k][0 or 1]
0 <= i <= n-1, 1 <= k <= K
n 为天数，⼤ K 为最多交易数
此问题共 n × K × 2 种状态，全部穷举就能搞定。

for 0 <= i < n:
    for 1 <= k <= K:
        for s in {0, 1}:
            dp[i][k][s] = max(buy, sell, rest)

```
⽐如说 dp [3]\[2][1]
的含义就是：今天是第三天，我现在⼿上持有着股票，⾄今最多进⾏ 2 次交
易。

我们想求的最终答案是 dp\[n - 1]\[K][0]，即最后⼀天，最多允许 K 次交易，
最多获得多少利润。

读者可能问为什么不是 dp[n - 1[K]\[1]？因为 [1] 代表⼿
上还持有股票，[0] 表⽰⼿上的股票已经卖出去了，很显然后者得到的利润
⼀定⼤于前者。


```c++
dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
max( 选择 rest , 选择 sell )

解释：今天我没有持有股票，有两种可能：
要么是我昨天就没有持有，然后今天选择 rest，所以我今天还是没有持有；
要么是我昨天持有股票，但是今天我 sell 了，所以我今天没有持有股票了。


dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])
max( 选择 rest , 选择 buy )

解释：今天我持有着股票，有两种可能：
要么我昨天就持有着股票，然后今天选择 rest，所以我今天还持有着股票；
要么我昨天本没有持有，但今天我选择 buy，所以今天我就持有股票了。

```
⽽且注意 k 的限制，我们在选择 buy 的时候，把 k 减⼩了 1，很好理解
吧，当然你也可以在 sell 的时候减 1，
⼀样的。

不过还差最后⼀点点，就是定义 base case，即最简单的情况（边界）。


```c++
dp[-1][k][0] = 0
解释：因为 i 是从 0 开始的，所以 i = -1 意味着还没有开始，这时候的利润当然是 0。

dp[-1][k][1] = -infinity
解释：还没开始的时候，是不可能持有股票的，⽤负⽆穷表⽰这种不可能。

dp[i][0][0] = 0
解释：因为 k 是从 1 开始的，所以 k = 0 意味着根本不允许交易，这时候利润当然是 0。

dp[i][0][1] = -infinity
解释：不允许交易的情况下，是不可能持有股票的，⽤负⽆穷表⽰这种不可能。

```

把上⾯的状态转移⽅程总结⼀下：

```c++
base case：
dp[-1][k][0] = dp[i][0][0] = 0
dp[-1][k][1] = dp[i][0][1] = -infinity
状态转移⽅程：
dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])
```

