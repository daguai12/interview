给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。

注意:

可以认为区间的终点总是大于它的起点。
区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。

```
输入: [ [1,2], [2,3], [3,4], [1,3] ]

输出: 1

解释: 移除 [1,3] 后，剩下的区间没有重叠。
```

方案一：最长上升子序列可以将时间复杂度优化至 O*(*n*log*n)，怎么又又又快忘记了

```c++
int eraseOverlapIntervals(vector<vector<int>>& intervals) {
        sort(intervals.begin(), intervals.end());
        vector<int> dp(intervals.size(), 1);
        for (int i = 1; i < intervals.size(); ++i) {
            for (int j = 0; j < i; ++j) {
                // 还真他妈的就是最长上升子序列，笑死
                if (intervals[i][0] >= intervals[j][1])
                dp[i] = max(dp[i], dp[j] + 1);
            }
        }
        return intervals.size() - dp[intervals.size() - 1];
    }
```





#### 方法二：修改状态定义（同时用到了贪心算法、二分查找）

**状态设计思想**：依然着眼于某个上升子序列的 **结尾的元素**，如果 **已经得到的上升子序列的结尾的数越小**，**那么遍历的时候后面接上一个数**，**会有更大的可能构成一个长度更长的上升子序列**。既然结尾越小越好，我们可以记录 在长度固定的情况下，结尾最小的那个元素的数值，

**1 .定义新状态（特别重要）**

`tail[i]` 表示：长度为 `i + 1` 的 **所有** 上升子序列的结尾的最小值。

**说明**：

* tail[0] 表示长度为 1 的所有上升子序列中，结尾最小的元素的数值。以题目中的示例为例 [10, 9, 2, 5, 3, 7, 101, 18] 中，容易发现长度为 2 的所有上升子序列中，结尾最小的是子序列 [2, 3] ，因此 tail[1] = 3；
* 下标和长度有数值为 `1` 的偏差；

状态定义其实也描述了状态转移方程。

**2. 状态转移方程**：

从直觉上看，数组 `tail` 也是一个严格上升数组。

可以用反证法，如果0 <= i < j < len, 存在tail[i] >= tail[j]，那么

tail[i]-> 对应一个上升子序列：[a0, a1, ....ai], 根据定义，有tail[i] = a[i]

tail[j]-> 对应[b0, b1, ....bi,...bj]  有tail[j] = b[j]

tail[i] >= tail[j] ->等价$a_i \ge b_j$,然而[b0, b1, ....bi, ...bj]  中 bi 严格小于bj, 所以ai >= bj > bi

则[b0, b1, ..., bi] 也是长度为i + 1,且结尾bi 比ai小，应该tail[i] = bi才对，矛盾了。

---



因为只需要维护状态数组 tail 的定义，它的长度就是最长上升子序列的长度。下面说明在遍历中，如何维护状态数组 tail 的定义。

1. 在遍历数组 nums 的过程中，看到一个新数 num，如果这个数 **严格** 大于有序数组 tail 的最后一个元素，就把 num 放在有序数组 tail 的后面，否则进入第 2 点；

<!--注意：这里的大于是「严格大于」，不包括等于的情况。-->

2. 在有序数组 tail 中查找第 1 个等于大于 num 的那个数，试图让它变小；
   * 如果有序数组 tail 中存在 等于 num 的元素，什么都不做，因为以 num 结尾的最短的「上升子序列」已经存在；
   * 如果有序数组 tail 中存在 大于 num 的元素，找到第 1 个，让它变小，这样我们就找到了一个 结尾更小的相同长度的上升子序列。

**说明**：

我们再看一下数组 tail[i] 的定义：长度为 i + 1 的 所有 最长上升子序列的结尾的最小值。因此，在遍历的过程中，我们试图让一个大的值变小是合理的；
这一步可以认为是「贪心算法」，总是做出在当前看来最好的选择，当前「最好的选择」是：当前只让让第 1 个严格大于 nums[i] 的数变小，变成 nums[i]，这一步操作是「无后效性」的；
由于是在有序数组中的操作，因此可以使用「二分查找算法」。

3. 初始化：

遍历第 1 个数 nums[0]，直接放在有序数组 tail 的开头 tail[0] = nums[0]。

4. 输出：

有序数组 tail 的长度，就是所求的「最长上升子序列」的长度。

```c++
#include <iostream>
#include <vector>

using namespace std;

class Solution {
public:
    int lengthOfLIS(vector<int> &nums) {
        int len = nums.size();
        if (len < 2) {
            return len;
        }
		// tail 数组的定义：长度为 i + 1 的上升子序列的末尾最小是几
        vector<int> tail;
         // 遍历第 1 个数，直接放在有序数组 tail 的开头
        tail.push_back(nums[0]);
        // end 表示有序数组 tail 的最后一个已经赋值元素的索引
        int end = 0;

        for (int i = 1; i < len; ++i) {
            // 【逻辑 1】比 tail 数组实际有效的末尾的那个元素还大
            if (nums[i] > tail[end]) {
                // 直接添加在那个元素的后面，所以 end 先加 1
                tail.push_back(nums[i]);
                end++;
            } else {
                // 使用二分查找法，在有序数组 tail 中
                // 找到第 1 个大于等于 nums[i] 的元素，尝试让那个元素更小
                int left = 0;
                int right = end;
                while (left < right) {
                    // 选左中位数不是偶然，而是有原因的
                    int mid = (left + right) >> 1;
                    if (tail[mid] < nums[i]) {
                        // 中位数肯定不是要找的数，把它写在分支的前面
                        left = mid + 1;
                    } else {
                        right = mid;
                    }
                }
                // 走到这里是因为 【逻辑 1】 的反面，因此一定能找到第 1 个大于等于 nums[i] 的元素
                // 因此，无需再单独判断
                tail[left] = nums[i];
            }
        }
        // 此时 end 是有序数组 tail 最后一个元素的索引
        // 题目要求返回的是长度，因此 +1 后返回
        return end + 1;
    }
};
```

评论中一些观点：

```
输入 [10, 9, 2, 5, 3, 7, 101, 18, 4, 8, 6, 12]
```

整个过程进行逐步分析，应该就明白了

过程分析，用表格记录：

每一行记录一个“上升子序列”，特点：**”结尾“是所有相同长度的上升子序列里最小的**

* 第1行记录长度为1的“上升子序列”
* 第2行记录长度为2的”上升子序列“
* 。。。。。
* 第n行记录长度为n的上升子序列

整个过程：

[10, 9, 2, 5, 3, 7, 101, 18, 4, 8, 6, 12]

初始条件： tail[0] = 10, end = 0

表格：

10

---



i = 1, nums[i] = 9, nums[i] <= tail[end]进入二分的过程，

在tail[0]对应第一行中， 找到第 1 个大于等于 nums[i] 的元素，尝试让那个元素更小，

现在表格:

9



---

i = 2, nums[i] = 2, 同理

表格

2

---

i = 3, nums[i] = 5, 逻辑1，直接放到后面

表格

2 

2 5

---

i = 4，nums[i] = 3, 逻辑2

表格

2

2 3

---

i = 5, nums[i] = 7, 逻辑1

表格

2

2 3

2 3 7

---

i = 6, nums[i] = 101

表格

2

2 3

2 3 7

2 3 7 101

---

i = 7, nums[i] = 18

只用关心最长的表格的那一行

2 3 7 18

---

这一步理解至关重要！！

2 3 7 18的确存在与 [10, 9, 2, 5, 3, 7, 101, 18, 4, 8, 6, 12]中，但是tail的含义并不是实际的LIS，

变成2 3 4 18之后虽然不真实存在，但是最长长度没有影响，这一步超重要！



i = 8, nums[i] = 4

表格

2 3 4 18

---

i = 9, nums[i] = 8

表格

2 3 4 8

---

i = 10, nums[i] = 6

表格

2 3 4 6

---

i = 11, nums[i] = 12

表格

2 3 4 6 12



方案二：（贪心 + dp）O(nlogn) 

```c++
class Solution {
public:
    // 按照区间右边界排序
    static bool cmp (const vector<int>& a, const vector<int>& b) {
        return a[1] < b[1];
    }
    int eraseOverlapIntervals(vector<vector<int>>& intervals) {
        if (intervals.size() == 0) return 0;
        sort(intervals.begin(), intervals.end(), cmp);
        int count = 1; // 记录非交叉区间的个数
        int end = intervals[0][1]; // 记录区间分割点
        for (int i = 1; i < intervals.size(); i++) {
            if (end <= intervals[i][0]) {
                end = intervals[i][1];
                count++;
            }
        }
        return intervals.size() - count;
    }
};
```



![435.无重叠区间](https://pic.leetcode-cn.com/1631930017-fYYUAr-file_1631930017753)

区间，1，2，3，4，5，6都按照右边界排好序。

每次取非交叉区间的时候，都是可右边界最小的来做分割点（这样留给下一个区间的空间就越大），所以第一条分割线就是区间1结束的位置。

接下来就是找大于区间1结束位置的区间，是从区间4开始。那有同学问了为什么不从区间5开始？别忘已经是按照右边界排序的了。

区间4结束之后，在找到区间6，所以一共记录非交叉区间的个数是三个。

总共区间个数为6，减去非交叉区间的个数3。移除区间的最小数量就是3。

