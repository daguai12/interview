Nim 游戏
游戏规则是这样的：你和你的朋友⾯前有⼀堆⽯⼦，你们轮流拿，
⼀次⾄少
拿⼀颗，最多拿三颗，谁拿⾛最后⼀颗⽯⼦谁获胜。
假设你们都很聪明，由你第⼀个开始拿，请你写⼀个算法，输⼊⼀个正整数
n，返回你是否能赢（true 或 false）。
⽐如现在有 4 颗⽯⼦，算法应该返回 false。因为⽆论你拿 1 颗 2 颗还是 3
颗，对⽅都能⼀次性拿完，拿⾛最后⼀颗⽯⼦，所以你⼀定会输。
⾸先，这道题肯定可以使⽤动态规划，因为显然原问题存在⼦问题，且⼦问
题存在重复。但是因为你们都很聪明，涉及到你和对⼿的博弈，动态规划会
⽐较复杂。
我们解决这种问题的思路⼀般都是反着思考：
如果我能赢，那么最后轮到我取⽯⼦的时候必须要剩下 1~3 颗⽯⼦，这样
我才能⼀把拿完。
如何营造这样的⼀个局⾯呢？显然，如果对⼿拿的时候只剩 4 颗⽯⼦，那么
⽆论他怎么拿，总会剩下 1~3 颗⽯⼦，我就能赢。
如何逼迫对⼿⾯对 4 颗⽯⼦呢？要想办法，让我选择的时候还有 5~7 颗⽯
⼦，这样的话我就有把握让对⽅不得不⾯对 4 颗⽯⼦。

如何营造 5~7 颗⽯⼦的局⾯呢？让对⼿⾯对 8 颗⽯⼦，⽆论他怎么拿，都
会给我剩下 5~7 颗，我就能赢。
这样⼀直循环下去，我们发现只要踩到 4 的倍数，就落⼊了圈套，永远逃不
出 4 的倍数，⽽且⼀定会输。所以这道题的解法⾮常简单：

```c++
bool canWinNim(int n) {
// 如果上来就踩到 4 的倍数，那就认输吧
// 否则，可以把对⽅控制在 4 的倍数，必胜
return n % 4 != 0;
}
```

#### [877. 石子游戏](https://leetcode-cn.com/problems/stone-game/)

游戏规则是这样的：你和你的朋友⾯前有⼀排⽯头堆，⽤⼀个数组 piles 表
⽰，piles[i] 表⽰第 i 堆⽯⼦有多少个。你们轮流拿⽯头，
⼀次拿⼀堆，但是
只能拿⾛最左边或者最右边的⽯头堆。所有⽯头被拿完后，谁拥有的⽯头
多，谁获胜。
假设你们都很聪明，由你第⼀个开始拿，请你写⼀个算法，输⼊⼀个数组
piles，返回你是否能赢（true 或 false）。
注意，⽯头的堆的数量为偶数，所以你们两⼈拿⾛的堆数⼀定是相同的。⽯
头的总数为奇数，也就是你们最后不可能拥有相同多的⽯头，
⼀定有胜负之
分。
举个例⼦， piles=[2, 1, 9, 5] ，你先拿，可以拿 2 或者 5，你选择 2。
piles=[1, 9, 5] ，轮到对⼿，可以拿 1 或 5，他选择 5。
piles=[1, 9] 轮到你拿，你拿 9。
最后，你的对⼿只能拿 1 了。
这样下来，你总共拥有 2 + 9 = 11 颗⽯头，对⼿有 5 + 1 = 6 颗⽯头，
你是可以赢的，所以算法应该返回 true。

你看到了，并不是简单的挑数字⼤的选，为什么第⼀次选择 2 ⽽不是 5 呢？
因为 5 后⾯是 9，你要是贪图⼀时的利益，就把 9 这堆⽯头暴露给对⼿了，
那你就要输了。
这也是强调双⽅都很聪明的原因，算法也是求最优决策过程下你是否能赢。
这道题⼜涉及到两⼈的博弈，也可以⽤动态规划算法暴⼒试，⽐较⿇烦。但
我们只要对规则深⼊思考，就会⼤惊失⾊：只要你⾜够聪明，你是必胜⽆疑
的，因为你是先⼿。

```c++
boolean stoneGame(int[] piles) {
return true;
}
```

这是为什么呢，因为题⽬有两个条件很重要：⼀是⽯头总共有偶数堆，⽯头
的总数是奇数。这两个看似增加游戏公平性的条件，反⽽使该游戏成为了⼀
个割⾲菜游戏。我们以 piles=[2, 1, 9, 5] 讲解，假设这四堆⽯头从左到
右的索引分别是 1，2，3，4。

如果我们把这四堆⽯头按索引的奇偶分为两组，即第 1、3 堆和第 2、4 堆，
那么这两组⽯头的数量⼀定不同，也就是说⼀堆多⼀堆少。因为⽯头的总数
是奇数，不能被平分。

⽽作为第⼀个拿⽯头的⼈，你可以控制⾃⼰拿到所有偶数堆，或者所有的奇
数堆。
你最开始可以选择第 1 堆或第 4 堆。如果你想要偶数堆，你就拿第 4 堆，这
样留给对⼿的选择只有第 1、3 堆，他不管怎么拿，第 2 堆⼜会暴露出来，
你就可以拿。同理，如果你想拿奇数堆，你就拿第 1 堆，留给对⼿的只有第
2、4 堆，他不管怎么拿，第 3 堆⼜给你暴露出来了。
也就是说，你可以在第⼀步就观察好，奇数堆的⽯头总数多，还是偶数堆的
⽯头总数多，然后步步为营，就⼀切尽在掌控之中了。知道了这个漏洞，可
以整⼀整不知情的同学了。

### 动态规划

定义 f[l] [r]为考虑区间 [l,r]，在双方都做最好选择的情况下，先手与后手的最大得分差值为多少。

那么 f[1] [n] 为考虑所有石子，先手与后手的得分差值：

* f[1] [n] > 0，则先手必胜，返回 True

* f[1] [n] < 0，则先手必败，返回 False

不失一般性的考虑 f[l] [r]如何转移。根据题意，只能从两端取石子（令 piles 下标从 1 开始），共两种情况：

* 从左端取石子，价值为 piles[l - 1]；取完石子后，原来的后手变为先手，从 [l + 1, r] 区间做最优决策，所得价值为 f[l + 1] [r]。因此本次先手从左端点取石子的话，双方差值为：
  piles[l - 1] - f[l + 1] [r]

* 从右端取石子，价值为 piles[r - 1]；取完石子后，原来的后手变为先手，从 [l, r - 1] 区间做最优决策，所得价值为 f[l] [r - 1]。因此本次先手从右端点取石子的话，双方差值为：
  piles[r - 1] - f[l] [r - 1]

双方都想赢，都会做最优决策（即使自己与对方分差最大）。因此 f[l] [r]为上述两种情况中的最大值。

根据状态转移方程，我们发现大区间的状态值依赖于小区间的状态值，典型的区间 DP 问题。

按照从小到大「枚举区间长度」和「区间左端点」的常规做法进行求解即可。

代码：

```java
class Solution {
    public boolean stoneGame(int[] ps) {
        int n = ps.length;
        int[][] f = new int[n + 2][n + 2]; 
        for (int len = 1; len <= n; len++) { // 枚举区间长度
            for (int l = 1; l + len - 1 <= n; l++) { // 枚举左端点
                int r = l + len - 1; // 计算右端点
                int a = ps[l - 1] - f[l + 1] [r];
                int b = ps[r - 1] - f[l][r - 1];
                f[l][r] = Math.max(a, b);
            }
        }
        return f[1] [n] > 0;
    }
}

```





