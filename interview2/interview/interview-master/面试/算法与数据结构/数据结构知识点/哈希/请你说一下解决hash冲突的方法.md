当哈希表关键字集合很大时，关键字值不同的元素可能会映象到哈希表的同一地址上，这样的现象称为哈希冲突。目前常用的解决哈希冲突的方法如下：
开放定址法: 当发生地址冲突时，按照某种方法继续探测哈希表中的其他存储单元，直到找到空位置为止。

再哈希法：当发生哈希冲突时使用另一个哈希函数计算地址值，直到冲突不再发生。这种方法不易产生聚集，但是增加计算时间，同时需要准备许多哈希函数。

链地址法：将所有哈希值相同的Key通过链表存储。key按顺序插入到链表中

建立公共溢出区：采用一个溢出表存储产生冲突的关键字。如果公共溢出区还产生冲突，再采用处理冲突方法处理。



1、开放定址

开放地址法有个非常关键的特征，就是所有输入的元素全部存放在哈希表里，也就是说，位桶的实现是不需要任何的链表来实现的，换句话说，也就是这个哈希表的装载因子不会超过1。它的实现是在插入一个元素的时候，先通过哈希函数进行判断，若是发生哈希冲突，就以当前地址为基准，根据再寻址的方法（探查序列），去寻找下一个地址，若发生冲突再去寻找，直至找到一个为空的地址为止。所以这种方法又称为再散列法。

有几种常用的探查序列的方法：

①线性探查

dii=1，2，3，…，m-1；这种方法的特点是：冲突发生时，顺序查看表中下一单元，直到找出一个空单元或查遍全表。

从发生冲突位置的下一个位置开始寻找空的散列地址。发生冲突时，线性探测下一个散列地址是：Hi=(H(key)+di)%m，（di=1,2,3...,m-1）。闭散列表长度为m。它实际是按照H(key)+1，H(key)+2,...,m-1,0,1,H(key)-1的顺序探测，一旦探测到空的散列地址，就将关键码记录存入。

该方法会产生堆积现象，即使是同义词也可能会争夺同一个地址空间，今后在其上的查找效率会降低。

②二次探查

di=12，-12，22，-22，…，k2，-k2    ( k<=m/2 )；这种方法的特点是：冲突发生时，在表的左右进行跳跃式探测，比较灵活。

发生冲突时，下一位置的探测采用公式：Hi=(H(key)+di)%m，(di=1^2,-1^2,2^2,-2^2,.....,q^2,-q^2,q<=根号下m)

在一定程度上可解决线性探测中的堆积现象。

③ 伪随机探测

di=伪随机数序列；具体实现时，应建立一个伪随机数发生器，（如i=(i+p) % m），生成一个位随机序列，并给定一个随机数做起点，每次去加上这个伪随机数++就可以了。



2、链地址
将所有散列地址相同的记录存储在同一个单链表中，该单链表为同义词单链表，或同义词子表。该单链表头指针存储在散列表中。散列表就是个指针数组，下标就是由关键码用散列函数计算出的散列地址。初始，指针数组每个元素为空指针，相当于所有单链表头指针为空，以后每扫描到一条记录，按其关键码的散列地址，在相应的单链表中加入含该记录的节点。开散列表容量可很大，仅受内存容量的限制。


每个位桶实现的时候，采用链表或者树的数据结构来去存取发生哈希冲突的输入域的关键字，也就是被哈希函数映射到同一个位桶上的关键字。
![image](https://uploadfiles.nowcoder.com/images/20190315/308571_1552656618645_A1331D1E34D3B9C3C4C03BC55F106A79)
紫色部分即代表哈希表，也称为哈希数组，数组的每个元素都是一个单链表的头节点，链表是用来解决冲突的，如果不同的key映射到了数组的同一位置处，就将其放入单链表中，即链接在桶后。

3、公共溢出区

建立一个公共溢出区域，把hash冲突的元素都放在该溢出区里。查找时，如果发现hash表中对应桶里存在其他元素，还需要在公共溢出区里再次进行查找。

另外开辟一个存储空间，当发生冲突时，把同义词均顺序放入该空间。若把散列表看成主表或父表，则公共的同义词表就是一个次表或子表。查找时，现在散列表中查，找不到时再去公共同义词子表顺序查找。

4、再hash
除基本散列函数外，事先设计一个散列函数序列，RH1,RH2,...,RHk，k为某个正整数。RHi均为不同的散列函数。对任一关键码，若在某一散列函数上发生冲突，则再用下一个散列函数，直到不发生冲突为止。

再散列法其实很简单，就是再使用哈希函数去散列一个输入的时候，输出是同一个位置就再次散列，直至不发生冲突位置。

缺点：每次冲突都要重新散列，计算时间增加。

