刷了很多道LeetCode上链表的题，有了一些经验总结。

非常好用的方法：

虚拟节点。

有些时候，我们考虑链表问题，就和考虑递归一样。

递归，说明程序每一步骤都有很大的相似性，传入参数不同，结果才会不同，但是执行的过程是一样的。

其实很多时候对链表的操作也是这样的，对于链表上的每一个节点，操作的时候都是一样的。

但是，如果涉及到头结点，或者尾节点，情况就有些特殊。

因为头结点的上一个节点不存在，很多对于其他节点，需要用上上一个节点的操作对头结点就不适合，因此，就需要单独考虑头结点。

这时候问题就来了，如果单独考虑头结点，就会有官方给你挖的一系列的坑等着你跳，接下来你就会不断的提交代码，不断的出现BUG，不断的根据官方给的数据改代码。

这一点我有亲身体验，或许这就是评论区说的：面向测试用例编程吧。

终于你改好了代码，提交通过了。

但你的代码真的丑，没有一点美观可言。

这样的代码，毫无价值，无法得到有用的经验总结。

有没有这样一种方法，能够将头结点也当做普通节点考虑？

它来了，虚拟节点~dummy dummy的意思就是假的。

有些人会叫他哨兵，一样的意思。

当你在链表的头部放入一个哨兵，然后连上head节点。

之后就把head节点当做普通节点，不用单独考虑了。

ListNode* dummy=new ListNode(-1);
        dummy->next=head;
最后返回

     return dummy->next;


链表的题，很多都需要用上dummy

我建议做链表题的时候首先就先做好dummy，后面肯定用得上。



只有经历过没用过dummy解题的哭，才会珍惜dummy的好！