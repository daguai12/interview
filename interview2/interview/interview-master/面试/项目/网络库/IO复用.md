### 你用了epoll，说一下为什么用epoll，还有其他复用方式吗？区别是什么？

——先说说其他的复用方式吧，比较常用的有三种：select/poll/epoll。本项目之所以采用epoll，[参考问题（Why is epoll faster than select?）](https://link.zhihu.com/?target=https%3A//stackoverflow.com/questions/17355593/why-is-epoll-faster-than-select)



* 对于select和poll来说，所有文件描述符都是在用户态被加入其文件描述符集合的，**每次调用都需要将整个集合拷贝到内核态**；epoll则将整个文件描述符集合维护在内核态，每次添加文件描述符的时候都需要**执行一个系统调用**。系统调用的开销是很大的，而且在有很多短期活跃连接的情况下，epoll可能会慢于select和poll由于这些大量的系统调用开销。

* select使用线性表描述文件描述符集合，**文件描述符有上限**；poll使用**链表来描述**；epoll底层通过红黑树来描述，并且维护一个ready list，将事件表中已经就绪的事件添加到这里，在使用epoll_wait调用时，仅观察这个list中有没有数据即可。
* select和poll的最大开销来自内核判断是否有文件描述符就绪这一过程：每次执行select或poll调用时，**它们会采用遍历的方式**，遍历整个文件描述符集合去判断各个文件描述符是否有活动；epoll则不需要去以这种方式检查，当有活动产生时，**会自动触发epoll回调函数通知epoll文件描述符**，然后内核将这些就绪的文件描述符放到之前提到的**ready list中等待epoll_wait调用后被处理**。
* select和poll都只能工作在**相对低效的LT模式**下，而epoll同时支持LT和ET模式。
* 综上，**当监测的fd数量较小**，且各个fd都很活跃的情况下，建议使用select和poll；**当监听的fd数量较多**，且单位时间仅部分fd活跃的情况下，使用epoll会明显提升性能。







### [epoll的边沿触发ET和水平触发LT有什么区别？(epoll的源码并不长，从源码的角度回答比较好)](https://www.cnblogs.com/charlesblc/p/6242479.html)

 **水平触发(level-trggered)**

- 只要文件描述符关联的读内核缓冲区非空，有数据可以读取，就一直发出可读信号进行通知，
- 当文件描述符关联的内核写缓冲区不满，有空间可以写入，就一直发出可写信号进行通知

**LT模式支持阻塞和非阻塞两种方式。epoll默认的模式是LT。**

 **边缘触发(edge-triggered)**

- 当文件描述符关联的读内核缓冲区由空转化为非空的时候，则发出可读信号进行通知，
- 当文件描述符关联的内核写缓冲区由满转化为不满的时候，则发出可写信号进行通知
- 两者的区别在哪里呢？水平触发是只要读缓冲区有数据，就会一直触发可读信号，而边缘触发仅仅在空变为非空的时候通知一次。
- 执行epoll_create时，创建了**红黑树和就绪链表**，执行epoll_ctl时，如果增加socket句柄，则检查在红黑树中是否存在，存在立即返回，不存在则添加到树干上，然后**向内核注册回调函数**，用于当中断事件来临时向准备就绪链表中插入数据。执行epoll_wait时立刻返回准备就绪链表里的数据即可。

[![img](https://camo.githubusercontent.com/8aaaa5b6aadae73efe7cb7159729e773cf323f4a63e411b4588d1c0e348c1fd4/68747470733a2f2f696d61676573323031352e636e626c6f67732e636f6d2f626c6f672f3839393638352f3230313730312f3839393638352d32303137303130323134343731343232322d3331383836363734392e706e67)](https://camo.githubusercontent.com/8aaaa5b6aadae73efe7cb7159729e773cf323f4a63e411b4588d1c0e348c1fd4/68747470733a2f2f696d61676573323031352e636e626c6f67732e636f6d2f626c6f672f3839393638352f3230313730312f3839393638352d32303137303130323134343731343232322d3331383836363734392e706e67)

- LT, ET这件事怎么做到的呢？当一个socket句柄上有事件时，内核会把该句柄插入上面所说的准备就绪list链表，这时我们调用epoll_wait，**会把准备就绪的socket拷贝到用户态内存，然后清空准备就绪list链表**，最后，epoll_wait干了件事，就是检查这些socket，如果不是ET模式（就是**LT模式的句柄**了），**并且这些socket上确实有未处理的事件时，又把该句柄放回到刚刚清空的准备就绪链表了**。所以，非ET的句柄，只要它上面还有事件，epoll_wait每次都会返回这个句柄。（从上面这段，可以看出，LT还有个**回放的过程，低效了**）

