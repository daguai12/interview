### 定时器简介

定时器通常包括至少两个成员：一个超时时间（通常采用相对时间或者超时时间）和一个超时时间到达后的一个回调函数。

有时候还可能包括回调函数被运行时须要传入的参数，以及是否又一次启动定时器，更改定时器的超时时间等。

假设使用链表作为容器来串联全部的定时器。则每一个定时器还要包括指向下一个定时器的指针成员。进一步，假设链表是双向的，则每一个定时器还须要包括指向前一个定时器的指针成员。


#### 排序链表的弊端

基于排序链表的定时器使用唯一的一条链表来管理所有的定时器，所以插入操作的效率随着定时器的数目增多而降低。而时间轮使用了哈希表处理冲突的思想，将定时器散列到不同的链表上。这样每条链表上的定时器数目都将明显少于原来的排序链表上的定时器数目，插入操作的效率基本不受定时器数目的影响。



#### 时间轮的设计

![](D:\interview\面试\c++并发\协程\brpc\image\TimwWheel.jpg)

时间轮的每个槽（ *`slot`* ）都连着一个定时器链表。时间轮以恒定的速度顺时针转动，每转动一次，就指向下一个槽（*`slot`*）。每次转动就称为一个滴答（*`tick`*），一个滴答的时间称为时间轮的槽间隔 `si`（*`slot interval`*），实际上就是心搏时间。如上图，一般会根据 `epoll_wait` 或者 `select` 函数来触发定时器，每轮都是会进行触发一些超时的定时器。

该时间轮共有N个（*`slot`*），因此运行一周的时间是 **`N*si`**。因此，每个槽的定时器链表的定时器具有相同的特征：他们的定时时间相差  **`N*si`**  的整倍数。

假如现在指针指向槽 *cs* （*current slot*），我们要添加一个定时时间为 `ti` 的定时器，则该定时器将插入到槽 `ts` （*`timer slot`*）对应的链表中：
$$
t_s = (c_s + (t_i / s_i))  \% N
$$





对于时间轮而言，要**提高精度**，就要使**si的值足够小**; 要提高**执行效率**，类似于 *hashtable*，则要求**N值足够大**，使定时器尽可能的分布在不同的槽。

但是简单时间轮存在一个明显的弊端是，在一个轮子的情况下，可跨越的最大计时时长（一个轮子的刻度数总数 * `si`）和时间轮的精度难以达到平衡，这个时候，多级时间轮即可在不丢失精度的前提下，加大时间轮计时器可计时的跨度。

#### 多级时间轮简介

时间轮分成多个层级，每一层是一个圈，和时钟类似，和水表更像，如下面图：

![水表](D:\interview\面试\项目\时间轮\20201218162333877.jpg#pic_center)


当个位的指针转完一圈到达0这个刻度之后，十位的指针转1格；当十位的转完一圈，百位的转1格，以此类推。这样就能表示很长的度数。

时间轮能表达的时间长度，和圈的数量以及每一圈的长度成正比。假设有4圈，每个圈60个刻度，每个刻度表示1毫秒，那么这个时间轮可以表示这么长：

​		                                 $60 * 60 * 60 * 60 = 12,960,000‬(ms) = 3.6 小时$



#### 时间轮进制的本质分析

考虑到多级时间轮的进位思想，本质是一种计数进制的体现，上面例子中的4个轮子，每个轮子60刻度其实就是60进制。无论采用多少进制，计数的本质都是连续的。所以无论是用60进制，61进制，10进制都是一样的。

#### 利用位运算的取巧进制实现(本项目没采用，不过可以作为一个优化点)

对于计算机而言，人类看到的10,20的整数，对它们并不友善。它们更喜欢二进制数，这样它们能够处理的更快。



#### 主动轮与从动轮

虽然是多级时间轮，但是每个轮子的作用并不相同。

轮子的类型主要有两类：工作轮与从动轮。以本例实现为例子进行讲解，如下图所示：

![在这里插入图片描述](D:\interview\面试\项目\时间轮\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FpeWFuemllbGY=,size_16,color_FFFFFF,t_70#pic_center)

#### 进位逻辑

**主动轮**：即上图中序号最大的5号轮，每一个定时周期指针移动一格。当5轮转动一圈，4轮进一格，4轮转一圈3轮进一格。

**从动轮**：1-4轮，他们无法自己主动移动，需要被动等待低级轮进位才能移动。



#### 执行定时逻辑

**主动轮**：当刻度指针指向当前槽的时候，槽内的任务被顺序执行。这里采用的STL的`std::list`，每次新增的任务都插入到任务链的链头。这里选择插入链头和链尾的复杂度其实没本质区别。STL中的ist头插和尾插都是常数复杂度.

**从动轮**：当对应轮的刻度指针指向当前槽的时候，槽内的任务链依次向低级轮（序号较高的轮）转移，**特别注意，从动轮没有执行任务权限**，只是对任务进行记录与缓存。

这里需要指出的是，定时任务在添加进入时间轮的时候，**任务的跳转路径已经可以计算出来**。例如插入的时候，处于2号轮的第3个刻度，下一次跳到4号轮的第4个刻度这些信息在插入的那一刻已经可以得到。**每个任务插入的时候，立即算好跳转路径，后续转移查表即可，无需重新计算。**

#### 删除定时器逻辑

若无需涉及删除定时器的功能，那么数据结构可能直接将回调函数对象std::function放在槽中即可，这也是为什么很多开源定时器不提供删除插入定时器中任务的功能，简单好用。

但如果需要能够删除定时器的功能，那么数据结构就需要变化。这里采用了std::shared_ptr与std::unordered_map的方式实现删除功能。

#### 具体实现方式：

1. 使用智能指针（`std::shared_ptr`）保存定时任务对象的方式。`std::shared_ptr`对象在时间轮的对应槽中保存一份，同样在`std::unordered_map`也保存一份。

2. 每次在主动轮执行任务之前，使用一下`std::shared_ptr`的unique接口判断`std::shared_ptr`的引用计数，如果是独占的，那么说明这个任务已经被删除，是过期任务。那么不执行直接跳过。

3. 由于主动轮每次是弹出所有待执行任务，如果任务被跳过不执行，相当于已经被删除。

PS. 由于任务实际执行不在主动轮运行过程中进行，而是由一个异步任务线程池执行，所以这里选择使用`std::shared_ptr`的好处在于，对于异步任务线程池而言，`std::shared_ptr`能够确保执行任务的时候，对象是存活的，防止出现意外。

#### 复杂度分析

| 实现方式     | StartTimer | StopTimer | PerTickBookkeeping |
| ------------ | ---------- | --------- | ------------------ |
| 基于链表     | O(1)       | O(n)      | O(n)               |
| 基于排序链表 | O(n)       | O(1)      | O(1)               |
| 基于最小堆   | O(lgn)     | O(1)      | O(1)               |
| 基于时间轮   | O(1)       | O(1)      | O(1)               |

通过复杂度比较，也可以发现时间轮对比其他方式显现的定时器，具有各方面复杂度均为恒定的效果，但万事万物都是均衡的，这样的常数时间复杂度是用较大的空间消耗换来的。可幸的是，这份空间开销目前在承受范围内。

#### 精度分析

精度依旧是由`std::chrono`保证的。



参考：https://blog.csdn.net/aiyanzielf/article/details/111337541?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-0.essearch_pc_relevant&spm=1001.2101.3001.4242
