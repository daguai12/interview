RESTful API在很多实际项目中并不使用。因此真的做了项目，你可能会发现只能用HTTP+JSON来定义接口，无法严格遵守REST风格。(特别是国内)

为什么说不实际呢？因为这个风格太理想化了，比方说：

* REST要求要将接口以资源的形式呈现。但实际上，很多时候都不太可能将一些业务逻辑看作资源。即使强制这么干了，也会非常非常别扭。登录就是登录，而不是“创建一个session”；播放音乐就是播放，而不是“创建一个播放状态“。

  我们之所以要定义接口，本身的动机是做一个抽象，把复杂性隐藏起来，而绝对不是把内部的实现细节给暴露出去。REST却反其道而行之，要求实现应该是“资源”并且这个实现细节要暴露在接口的形式上。

  但一个好的接口设计就应该是简单、直观的，能够完全隐藏内部细节的，不管底层是不是资源，资源的组合还是别的什么架构。此外，让业务逻辑与接口表现一致，对系统的长期维护和演进都有极大的好处。

* REST只提供了增删改查的基本语义，其他的语义基本上不管。比如批量添加，批量删除，修改一个资源的一部分字段。区分“物理删除”和“标记删除”等等。复杂的查询更加不显示，对于像筛选这类的场景，REST明显就是个渣。


* REST建议用HTTP的status code做错误码，以便于“统一”，实际上这非常难统一。各种业务的含义五花八门，抽象层次高低不齐，根本就无法满足需要。比如一个404到底是代表这个接口找不到，还是代表一个资源找不到。400表达请求有问题，但是我想提示用户“你登录手机号输入的格式不对“，还是“你登录手机号已经被占用了“。既然201表示“created”，为啥deleted和updated没有对应的status code，只能用200或者204（no content）？错误处理是web系统里最麻烦的，最需要细心细致的地方。REST风格在这里只能添乱。

* web请求参数可能散布在url path、querystring、body、header。服务器端处理对此完全没有什么章法。客户端和服务器端的研发之间还是要做约定。

* 在url path上的变量会对很多其他的工作带来不良影响。

  比如监控，本来url可以作为一个接口的key统计次数/延迟，结果url里出了个变量，所以自动收集nginx的access log，自动做监控项目增加就没法弄了。再比如，想对接口做流量控制的计数，本来url可以做key，因为有变量，就得多费点事才行。

* 现实中接口要处理的真正的问题，REST基本上也没怎么管。比如认证、授权、流控、数据缓存（http的etag还起了点作用）、超时控制、数据压缩……。

* REST有很多好的工具可以便利的生成对应的代码和文档，也容易形成规范。但问题是REST在实际的项目中并没有解决很多问题，也在很多时候不合用，因此产生的代码和文档也就没什么用，必须经过二次加工才能真的用起来。因此可以基于REST+你的业务场景定义一个你自己的规范。

这是学习RESTful API的参考学习资料：
https://github.com/aisuhua/restful-api-design-references


REST是一种设计风格，它的很多思维方式与RPC是完全冲突的。 

RPC（Remote Procedure Call）（翻译为中文叫“远程过程调用”）的思想是把本地函数映射到API，也就是说一个API对应的是一个function，我本地有一个getAllUsers，远程也能通过某种约定的协议来调用这个getAllUsers。至于这个协议是Socket、是HTTP还是别的什么并不重要； 

而在分布式系统中，因为每个服务的边界都很小，很有可能调用别的服务提供的方法。这就出现了服务A调用服务B中方法的需求，即远程过程调用。

RPC中的主体都是动作，是个动词，表示我要做什么。 

而REST则不然，它的URL主体是资源，是个名词。而且也仅支持HTTP协议，规定了使用HTTP Method表达本次要做的动作，类型一般也不超过那四五种。这些动作表达了对资源仅有的几种转化方式。

---

那说了这么多，HTTP相比大家也都清楚了，但是RESTful和RPC到底存在意义是什么？与HTTP区别是什么？

首先明确 ：**HTTP和RPC不是对等的概念**。

RPC是一个完整的远程调用方案，它包括了：接口规范+序列化反序列化规范+通信协议等。

HTTP+Restful规范+序列化与反序列化，构成一个完整的远程调用方案，再和RPC进行比较。而单纯的HTTP，只是一个通信协议，自然无法和RPC比较。

我们先介绍基于HTTP的远程调用方案。

HTTP+Restful，其优势很大。它**可读性好**，且可以得到防火墙的支持、跨语言的支持。而且，在近几年的报告中，Restful大有超过RPC的趋势。

但是使用该方案也有其缺点，这是与其优点相对应的：

* 首先是有用信息占比少，毕竟HTTP工作在第七层，包含了大量的HTTP头等信息。

* 其次是效率低，还是因为第七层的缘故，必须按照HTTP协议进行层层封装。

* 还有，其可读性似乎没有必要，因为我们可以引入网关增加可读性。

* 此外，使用HTTP协议调用远程方法比较复杂，要封装各种参数名和参数值。


而RPC则与HTTP互补，我们详细介绍下。

应用调用另一个应用的方法的解决方案

1. 暴露接口后使用HTTP调用
   * 接口定义**规范**————RESTful

2. 远程过程调用
   * 动态代理
   * 序列化与反序列化
   * 通信
     *HTTP 或 TCP 或 UDP
   * 异常处理


RPC，要了解远程过程调用，那先理解过程调用。非常简单，就是调用一个方法。

---

```
调用方————————————>被调用的方法
```

---


要想让服务A调用服务B中的方法，最先想到的就是通过HTTP请求实现。是的，这是很常见的，例如服务B暴露Restful接口，然后让服务A调用它的接口。基于Restful的调用方式因为可读性好（服务B暴露出的是Restful接口，可读性当然好）而且HTTP请求可以通过各种防火墙，因此非常不错。

然而，如前面所述，基于Restful的远程过程调用有着明显的缺点，主要是效率低、封装调用复杂。当存在大量的服务间调用时，这些缺点变得更为突出。

服务A调用服务B的过程是应用间的内部过程，**牺牲可读性提升效率、易用性是可取的**。基于这种思路，RPC产生了。

通常，RPC要求在调用方中放置被调用的方法的接口。**调用方只要调用了这些接口，就相当于调用了被调用方的实际方法，十分易用**。于是，调用方可以像调用内部接口一样调用远程的方法，而不用封装参数名和参数值等操作。

---

```
      调用方           |            被调用到方法
        |              |
        |              |
        |              |
        |              |
        *              |
被调用方法的接口         |

```

---

那要想实现这个过程该怎么办呢？

首先，调用方调用的是接口，必须得为接口构造一个假的实现。显然，要使用动态代理。这样，调用方的调用就被动态代理接收到了。

第二，动态代理接收到调用后，应该想办法调用远程的实际实现。这包括下面几步：

* 识别具体要调用的远程方法的IP、端口
* 将调用方法的入参进行序列化
* 通过通信将请求发送到远程的方法中

这样，远程的服务就接收到了调用方的请求。它应该：

* 反序列化各个调用参数
* 定位到实际要调用的方法，然后输入参数，执行方法
* 按照调用的路径返回调用的结果

整个过程如下所示。
---

```
                    分割线
      调用方           |            被调用到方法
        |              |                    *
        |              |                    |
        |              |                    |
        |              |                    |
        *              |                    |
被调用方法的接口         |                    |
        |                                   |
- - - - |- - - - - - - - - - - - - - - - - - - - -  
 |      *                                   |
 |    代理方法                               |                   
 |      |                                   |            
 |      |                                   |
 |      *                                   |
 |     序列化————————>通信————————————>反序列化
 |
 |
 |
- - - - - - - - - - - - - - - - - - - - - - - - - -  
RPC

```

---

调用方调用内部的一个方法，但是被RPC框架偷梁换柱为远程的一个方法。之间的通信数据可读性不需要好，只需要RPC框架能读懂即可，因此效率可以更高。通常使用UDP或者TCP作为通讯协议，当然也可以使用HTTP。

所以，不要被RPC吓到，它就是让一个应用调用另一个应用中方法的一种实现方式。