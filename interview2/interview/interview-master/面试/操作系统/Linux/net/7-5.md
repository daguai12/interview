Reactor模式

要求主线程（I/O处理单元）只负责监听文件描述符上是否有事件发生，有的话就立即将事件通知工作线程（逻辑单元）数据的读写，接受新的连接以及处理客户请求均在工作线程中完成；除此之外，逻辑线程不作任何工作。

1. 主线程往epoll内核事件表中注册socket上的读就绪事件
2. 主线程调用epoll_wait等待socket上有数据可读
3. 当socket上有数据可读时，epoll_wait通知主线程，主线程则将socket可读事件放入请求队列。
4. 睡眠在请求队列上的某个工作线程被唤醒，它从socket读取数据，并处理客户请求，然后往epoll内核事件表中注册该socket上的写就绪事件。
5. 主线程调用epoll_wait等待socket可写
6. 当socket可写时，epoll_wait通知主线程，主线程将socket可写事件放入请求队列
7. 睡眠在请求队列上的某个工作线程（工作线程从请求队列读取事件后，根据事件的类型来决定如何处理它，没有必要区分读工作线程和写工作线程）被唤醒，它往socket上写入服务器处理客户请求的结果

![image](https://pic2.zhimg.com/80/v2-bffff9670e2b9a3259c1a3c79176d9e9_1440w.jpg)

proactor模式

Proactor将所有I/O操作都交给主线程和内核来处理，工作线程仅仅负责业务逻辑。使用异步I/O模型（aio_read和aio_write）来实现Proactor模式的工作流程是：

1. 主线程调用aio_read向内核注册socket上的读完成事件，并告诉内核用户缓冲区的位置，以及读操作完成时如何通知应用程序（可以用信号）
2. 主线程继续处理其他逻辑
3. 当socket上的读数据被读入用户缓冲区后，内核向应用进程发送一个信号，已通知应用程序数据已经可用
4. 应用进程预先定义好的信号处理函数选择一个工作线程来处理处理客户请求，工作线程处理完客户请求之后，调用aio_write向内核注册socket的完成写事件，并告诉内核用户写缓冲区的位置，以及操作完成时如何通知应用程序（可以用信号）
5. 主线程继续处理其他逻辑
6. 当用户缓冲区的数据被写入socket之后，内核将向应用程序发送一个信号，已通知应用程序数据已经发送完毕
7. 应用程序预先定义好的信号处理函数选择一个工作线程来做善后处理，比如决定是否关闭socket