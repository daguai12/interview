# C++ 协程的概念

## 一、什么是 C++ 协程？

在 C++20 中，如果你在一个函数里使用了以下任意关键字之一：

* `co_await`：表示挂起等待某个异步操作完成；
* `co_yield`：用于生成值（类似于 Python 中的生成器）；
* `co_return`：用于从协程中返回结果。

只要函数体内出现了这些关键字之一，这个函数就会被编译器 **自动变成协程**。

---

## 二、协程的三大核心组成

每一个协程在运行时，编译器会在背后自动创建一套“框架”（frame），这个框架由三种重要的对象组成：

### 1. **promise 对象**

* 虽然叫 `promise`，但它 **跟 `std::promise` 没有关系**。
* 它是编译器生成的对象，用来 **代表协程的行为**。
* 你可以通过这个对象：

  * 控制协程何时挂起/恢复；
  * 获取协程的返回值；
  * 捕获协程抛出的异常。

> 可以理解为：`promise` 就是协程与用户之间沟通的桥梁。

### 2. **协程句柄（handle）**

* 本质上是一个 **指向协程帧的指针**。
* 用它可以访问协程的 promise，也可以恢复（resume）或销毁（destroy）协程。
* 这是你在外部操作协程的入口。

> 类似于“遥控器”，你通过协程句柄控制协程运行状态。

### 3. **协程状态**

* 为了让协程在 `co_await` 的时候挂起、稍后再恢复，它必须记录当前执行到哪一行、局部变量的值等等。
* 所以协程的状态需要保存在一个“帧”（frame）里，供下一次恢复使用。

---

## 三、什么是协程帧（Coroutine Frame）？

### 激活帧（activation frame）= 栈帧 + 协程帧

#### 1. **栈帧（stack frame）**

* 跟普通函数一样，当协程被调用的时候，也会有栈帧创建。
* 一旦协程返回，栈帧就会被销毁。

#### 2. **协程帧（coroutine frame）**

* 专门为协程保存状态的内存区域。
* 包含了上面提到的三大对象（promise、handle、状态）。
* 它不是在栈上分配的，而是通常 **在堆上分配** 的。
* 为什么？因为协程可以在挂起后脱离调用栈，异步恢复，所以不能用栈上那种“调用完就销毁”的内存。

> 打个比方：
>
> * 普通函数：像一个打电话的人，电话挂了（函数结束），一切就没了。
> * 协程：像发了条语音信息，接收者可以过一会再听，所以信息内容要放在手机（堆内存）里，不是嘴巴（栈）里。

---

## 四、内存管理说明

协程帧是由编译器为你生成的，但它是 **在堆上分配的**（通常），所以需要注意：

* **你自己要负责销毁** 协程句柄（也就是释放协程帧），否则就会 **内存泄漏**。
* 有一种情况可以优化：如果编译器确定协程的生命周期 **一定短于调用它的函数**，它也可以尝试从栈帧中分配这块内存，避免堆分配。

---

## 五、协程的执行过程简化版

调用一个协程函数时，其实做了两件事：

1. **正常函数的那一套**：

   * 入栈、创建栈帧。
2. **协程的特殊部分**：

   * 编译器自动分配协程帧（堆上）；
   * 初始化 promise；
   * 返回协程句柄给你，供后续 resume/use。

---

## 总结一句话：

> **C++ 协程 = 普通函数 + 状态保存 + 异步挂起恢复能力 + 编译器自动生成的协程帧。**

它通过 `promise` 对象暴露接口，通过 `句柄` 操作恢复/销毁，通过 `协程帧` 保存中间状态，在堆上存活，不再局限于函数调用栈。


# 示例讲解

非常好，这是一个经典的 C++20 协程示例，手动实现了一个可 `co_yield` 多次、可获取最终 `co_return` 结果的协程对象 `Task`。你提供的代码设计非常严谨，也包含了 C++ 协程机制中几乎所有核心概念：`promise_type`、协程句柄、挂起/恢复控制、yield 机制、异常处理、生命周期管理等。

我会 **按模块逐步详细讲解整段代码**，包括你需要理解的底层机制、设计原因和语言特性。

---

## 🌱 第一步：协程相关基础知识复习（快速）

### C++20 协程的五大核心组件

每一个协程都会关联以下组件，由编译器自动管理：

| 组件                                    | 说明                               |
| ------------------------------------- | -------------------------------- |
| `promise_type`                        | 用户定义的类，用来管理协程的状态、产出和异常等，必须提供特定接口 |
| `co_await`, `co_yield`, `co_return`   | 协程关键字，用来挂起、生成值和返回值               |
| `std::coroutine_handle<promise_type>` | 协程句柄，可以操作该协程，如 resume、destroy    |
| `initial_suspend` / `final_suspend`   | 控制协程启动后是否立即挂起、结束后是否挂起            |
| 协程帧（Coroutine Frame）                  | 协程的“状态快照”，保存在堆上，由 `handle` 指向    |

---

## 🧱 第二步：用户协程类型 `Task`

这是你作为用户层看到的“协程对象”，整个 `Task` 是围绕 `promise_type` 和 `handle_type` 构建的壳。

### `class Task`

```cpp
class Task {
public:
  class promise_type;
  using handle_type = std::coroutine_handle<promise_type>;
  ...
};
```

#### 📌 `promise_type` 是协程背后的“控制器”

这个 `Task::promise_type` 是必须定义的，因为编译器在处理协程函数 `run()` 时，会自动调用这些接口：

* `get_return_object()`
* `initial_suspend()`
* `yield_value(...)`
* `return_value(...)`
* `unhandled_exception()`
* `final_suspend()`

#### 📌 `handle_type` 是指向协程帧的指针

它是控制协程运行的主要接口。你可以通过它：

* `resume()` 协程
* `destroy()` 销毁协程帧
* `done()` 判断是否结束
* `promise()` 获取内部的 `promise_type`

---

## 🚀 第三步：重点分析 promise\_type

```cpp
class promise_type {
  friend class Task;

public:
  Task get_return_object();
  constexpr std::suspend_always initial_suspend();
  void return_value(std::string result);
  std::suspend_always yield_value(int value);
  void unhandled_exception();
  constexpr std::suspend_always final_suspend() noexcept;

private:
  std::exception_ptr m_exception{nullptr};
  std::optional<std::string> m_result{std::nullopt};
  std::optional<int> m_yield{std::nullopt};
};
```

### 👇 方法分析：

#### ✅ `get_return_object()`

* 由编译器自动调用，用于返回协程的封装对象。
* 它返回的是 `Task`，通过 `handle_type::from_promise(*this)` 获取句柄指向当前 `promise_type` 的协程帧。

```cpp
Task get_return_object() {
    auto handle = handle_type::from_promise(*this);
    return Task(handle);
}
```

#### ✅ `initial_suspend()`

* 控制协程创建完成后是否立即挂起。
* 返回 `std::suspend_always{}` 表示：**创建协程后立即挂起，需要手动 resume() 才能开始运行**。

```cpp
constexpr std::suspend_always initial_suspend() { return {}; }
```

#### ✅ `yield_value(int)`

* 每次 `co_yield xxx` 会自动调用此函数。
* 你在这里存储了 yield 的值，之后在 `Task::next()` 中取出。

```cpp
std::suspend_always yield_value(int value) {
    m_yield = value;
    return {};
}
```

#### ✅ `return_value(std::string)`

* 协程使用 `co_return` 返回值时，调用此函数。
* 存储了返回值 `m_result`，供外部通过 `.result()` 访问。

```cpp
void return_value(std::string result) {
    m_result = result;
}
```

#### ✅ `unhandled_exception()`

* 如果协程内部抛出异常，编译器自动调用这个函数。
* 存储异常供外部 rethrow。

```cpp
void unhandled_exception() {
    m_exception = std::current_exception();
}
```

#### ✅ `final_suspend()`

* 协程执行完后会自动调用，用来决定协程是否挂起等待销毁，或直接销毁。
* 返回 `suspend_always{}` 说明：**结束后仍然挂起，需 resume() 来彻底完成销毁流程。**

```cpp
constexpr std::suspend_always final_suspend() noexcept { return {}; }
```


## 🧩 第四步：`Task` 类的设计与外部接口分析

### 🎯 目标

`Task` 封装了协程运行的整个过程，为用户提供三个主要接口：

* `next()`：驱动协程向前执行，拿到 `co_yield` 出来的值。
* `result()`：在协程执行结束后拿到最终 `co_return` 的返回值。
* `resume()`：直接恢复协程（但不适用于 yield 控制流程）。

---

## ✳️ 构造函数与析构函数设计

```cpp
Task(handle_type handle) : m_handle(handle) {}
~Task() {
  m_handle.destroy();
}
```

* 构造：传入句柄，保存到成员变量中。
* 析构：销毁句柄（意味着销毁协程帧，释放堆上内存）。

❗️注意：

> `std::coroutine_handle::destroy()` 会调用 `operator delete` 来释放协程帧，因此每一个协程的最终销毁都必须由用户负责！

---

## 🔁 移动构造与移动赋值

```cpp
Task(Task&& other) : m_handle(other.m_handle) {
  other.m_handle = nullptr;
}

Task& operator=(Task&& other) {
  if (m_handle) {
    m_handle.destroy(); // 释放原资源
  }
  m_handle = other.m_handle;
  other.m_handle = nullptr;
  return *this;
}
```

✅ 支持移动构造/赋值；
🚫 禁止拷贝构造/赋值；

目的是：

* 避免句柄重复析构；
* 强制你在明确需要时才移动所有权。

---

## 🚀 关键函数一：`next()` — 驱动协程

```cpp
std::optional<int> next() {
  promise_type &p = m_handle.promise(); // 取出 promise

  p.m_yield = std::nullopt; // 先清除上一次 yield 值
  p.m_exception = nullptr;  // 清除上一次异常

  if (!m_handle.done()) {
    m_handle.resume(); // 恢复协程运行
  }

  if (p.m_exception) {
    std::rethrow_exception(p.m_exception);
  }

  return p.m_yield; // 返回新的 yield 值
}
```

### 核心流程：

1. 清空旧的 `yield` 值，准备获取新的。
2. 如果协程还没结束（`!done()`），就调用 `resume()`，继续运行。
3. 若协程抛出异常，通过 `promise.m_exception` 重新抛出。
4. 返回这次 `co_yield` 的值（如果有）。

---

## 📦 关键函数二：`result()` — 获取返回值

```cpp
std::optional<std::string> result() {
  return m_handle.promise().m_result;
}
```

协程执行到 `co_return` 时，会通过 `promise_type::return_value()` 存储返回值，这里可以直接访问。

---

## 🌀 第五步：run() 协程函数分析

```cpp
Task run(int i) {
  std::cout << "task " << i << " start" << std::endl;
  co_yield 1;
  for (int i = 2; i <= 5; i++) {
    co_yield i;
  }
  std::cout << "task " << i << " end" << std::endl;
  co_return "task run finish";
}
```

这就是一个真正的 **协程函数**。因为它包含了 `co_yield` 和 `co_return`，所以会被编译器视为协程。

### 编译器自动生成逻辑如下：

1. 编译器创建 `promise_type` 对象。
2. 调用 `promise.get_return_object()` → 构造 `Task`。
3. 调用 `initial_suspend()` → 控制是否立刻挂起（本例中立刻挂起）。
4. `next()` 驱动协程执行：

   * 执行到 `co_yield` → 执行 `yield_value()` → 返回值给调用者。
   * 下一次 resume 从 `co_yield` 之后继续运行。
5. 执行 `co_return` → 执行 `return_value()`。
6. 运行 `final_suspend()`，协程暂停但不立即销毁。

---

## 🎬 最后一步：`main()` 中的运行逻辑

```cpp
int main() {
  auto task = run(5);
  std::optional<int> val;
  while ((val = task.next())) {
    std::cout << "get yield value: " << (*val) << std::endl;
  }
  std::cout << "get return value: " << (*task.result()) << std::endl;
}
```

### 运行流程分析：

1. 调用 `run(5)` → 创建协程，返回 `Task` 对象，但协程没有开始执行（因为 `initial_suspend()` 返回了 suspend）。
2. `task.next()`：

   * 恢复协程，开始执行；
   * 打印 `task 5 start`；
   * 执行 `co_yield 1`，保存 yield 值，挂起；
   * `next()` 返回 1；
   * 输出 `get yield value: 1`
3. 下一轮 `task.next()`：

   * 恢复协程；
   * 进入 for 循环，yield 2 → yield 3 → ... → yield 5；
   * 每次都挂起并返回一个值；
   * 打印对应值。
4. 最后一次 resume：

   * 打印 `task 5 end`；
   * 执行 `co_return "task run finish"`；
   * 进入 `final_suspend()` 挂起；
   * `next()` 返回空。
5. `result()` 返回最终字符串。

---

## 🧠 总结知识点

| 知识点                                     | 说明                                    |
| --------------------------------------- | ------------------------------------- |
| 协程函数签名                                  | 自动由编译器转化为状态机                          |
| `promise_type`                          | 管理协程状态、返回值、异常、yield 值                 |
| `co_yield` / `co_return`                | 触发 `yield_value()` 和 `return_value()` |
| `coroutine_handle`                      | 控制 resume/destroy，访问 promise          |
| `initial_suspend()` / `final_suspend()` | 控制协程何时挂起                              |
| 堆上协程帧                                   | 自动构建，手动释放（`destroy()`）                |
| `std::optional`                         | 处理 yield/return 的可空语义                 |

---

这是一个高度手工控制的协程实现方式，在学习 C++20 协程机制时非常适合用来了解底层运行逻辑。如果你后续要写协程调度器、任务系统、异步框架，掌握这一层知识至关重要。

# 部分执行流程详解

好问题！

你问的是：

> `m_handle.done()` 什么时候会返回 `true`？

这个是 C++20 协程中非常关键的机制，我们来 **详细解释 `std::coroutine_handle::done()` 的语义、作用时机，以及你给出的协程中它何时为真**。

---

## ✅ 一、`std::coroutine_handle::done()` 是什么？

```cpp
bool std::coroutine_handle::done() const noexcept;
```

这个方法的作用是判断：

> **协程是否已经执行完成，不能再 resume。**

* 如果协程还没有运行完，则 `done() == false`
* 如果协程已经：

  * 正常运行到 `co_return`
  * 或者抛出异常且未恢复
  * 或者整个状态机走到终止状态

  那么就会变成 **完成状态（done）**，此时：

  ```cpp
  handle.done() == true
  ```

---

## ✅ 二、协程完成状态的判断标准

`done()` 的判断和 `final_suspend()` 有强相关关系。

### ▶️ 协程生命周期（核心流程）：

1. 创建协程帧；
2. `initial_suspend()` → suspend（挂起）；
3. 调用 `resume()`：

   * 运行协程逻辑；
   * 遇到 `co_yield` → 执行 `yield_value()` → 再次 suspend；
   * resume → 继续执行后续逻辑；
4. 遇到 `co_return` 或逻辑末尾：

   * 调用 `return_value()`（或 `return_void()`）；
   * 跳转到 `final_suspend()`；
   * 如果 `final_suspend()` 返回 `suspend_always`，那么此时协程仍然挂起，但逻辑上已完成；
5. 如果再次 resume，运行完成 `final_suspend()` 后，就变成 `done()` 为 true。

---

## ✅ 三、结合你的代码分析 `done()` 为 true 的时机

看你的协程函数：

```cpp
Task run(int i) {
  std::cout << "task " << i << " start" << std::endl;
  co_yield 1;
  for (int i = 2; i <= 5; i++) {
    co_yield i;
  }
  std::cout << "task " << i << " end" << std::endl;
  co_return "task run finish";
}
```

协程执行顺序是：

| 次数         | 执行语句                                          | 说明                |
| ---------- | --------------------------------------------- | ----------------- |
| 1st        | 打印 start + `co_yield 1`                       | yield 1，挂起        |
| 2nd        | `co_yield 2`                                  | yield 2，挂起        |
| 3rd\~5th   | yield 3 → yield 4 → yield 5                   | 每次挂起              |
| 6th        | 打印 end → `co_return "..."`                    | 进入 final\_suspend |
| 7th resume | resume 完 final\_suspend，**此时 done() == true** |                   |

---

## ✅ 四、示意图说明

```text
            +----------------------+
            | initial_suspend()    |
            | return suspend_always|
            +----------------------+
                       |
                       v
               用户调用 resume()
                       |
                       v
            +----------------------+
            | run() 执行主体逻辑   |
            | 触发 co_yield         |
            +----------------------+
                       |
                       v
            +----------------------+
            | yield_value()        |
            | return suspend_always|
            +----------------------+
                       |
            (resume again 继续 run)
                       |
                       v
            +----------------------+
            | run 到 co_return     |
            | 调用 return_value()  |
            +----------------------+
                       |
                       v
            +----------------------+
            | final_suspend()      |
            | return suspend_always|
            +----------------------+
                       |
            (最后一次 resume)
                       |
                       v
               协程彻底结束，done() == true
```

---

## ✅ 五、结论

> `m_handle.done()` 会在协程 **完全执行完毕** 并且已经从 `final_suspend()` resume 后变成 `true`。

所以你在 `next()` 里这样写是合理的：

```cpp
if (!m_handle.done()) {
    m_handle.resume(); // 如果没结束，就继续执行
}
```

一旦协程结束，后续调用 `resume()` 会是 undefined behavior（UB），所以必须用 `done()` 保护。

---

如果你想验证 `done()` 的变化过程，你可以在 `next()` 中打印：

```cpp
std::cout << "done before resume: " << std::boolalpha << m_handle.done() << std::endl;
```

你会发现最后一次调用完 resume 后它才变成 `true`。

---

需要我补充：

* `co_await` 情况下的 `done()` 机制；
* `suspend_never` 与 `suspend_always` 对协程状态的影响；
* yield 和 return 共存时对 resume 语义的控制；

都可以继续问。


##  ==run函数的作用==

非常棒的问题！这个问题看起来简单，但实际上涉及 C++20 协程的底层 **生命周期构造过程、编译器自动生成逻辑** 和你自己定义的 `Task` 类型行为。

---

## 🌟 问题：

```cpp
auto task = run(5);
```

这是协程的创建语句。那么，**在这一行执行的过程中到底发生了什么？**

---

## 🧠 答案概要：

> 当执行 `auto task = run(5);` 这一步时，**协程没有真正运行起来，只是被构造出来，进入了初始挂起状态。**
>
> 编译器会自动生成：
>
> 1. `promise_type` 对象；
> 2. 协程帧（在堆上）；
> 3. 调用 `get_return_object()` 创建 `Task`；
> 4. 调用 `initial_suspend()` → 返回 `suspend_always`，所以协程挂起；
> 5. 最后返回你自定义的 `Task` 对象。

---

## 🔬 详细步骤（编译器自动生成的逻辑）

你定义的 `run()` 是一个协程函数，因为里面用了 `co_yield` 和 `co_return`。

```cpp
Task run(int i);
```

执行 `run(5)` 时，**发生了下面这些自动化过程**，全部由编译器生成：

---

### ✅ 第一步：创建 `promise_type` 对象

编译器生成一段代码逻辑相当于：

```cpp
Task::promise_type promise; // 本质是 new 出来的（在协程帧里）
```

* 这个对象是协程运行的“中控”，后续所有状态都绑定在这里。

---

### ✅ 第二步：构造协程帧，并生成 `coroutine_handle`

编译器为协程帧分配内存（默认在 **堆上**），协程帧中包含：

* 局部变量状态
* 当前指令位置
* `promise_type` 实例

然后获取一个 `coroutine_handle`：

```cpp
auto handle = std::coroutine_handle<promise_type>::from_promise(promise);
```

> 本质上就是 `coroutine_handle` 是指向协程帧的指针，而帧里有 `promise_type`。

---

### ✅ 第三步：调用 `promise.get_return_object()`，获取返回对象

你在 `promise_type` 里定义了这个方法：

```cpp
Task get_return_object() {
    auto handle = handle_type::from_promise(*this);
    return Task(handle);
}
```

它会构造你自定义的 `Task` 对象，把协程句柄包装进去。

---

### ✅ 第四步：调用 `promise.initial_suspend()`

```cpp
constexpr std::suspend_always initial_suspend() { return {}; }
```

表示协程创建后**立即挂起**，不自动运行，需要手动 resume。

所以协程本体 `run()` 的语句都还没有开始执行（包括 `std::cout << "task 5 start"` 也没打印）。

---

### ✅ 第五步：返回 `Task` 对象（整个表达式结果）

```cpp
Task task = run(5);  // 执行完上面所有步骤后，task 被赋值
```

你得到的 `Task` 对象里：

* `m_handle` 指向协程帧；
* 协程尚未开始运行；
* 可以通过 `task.next()` 来逐步 resume 执行。

---

## 📌 图解协程创建过程

```text
run(5)
  |
  |-- create promise_type
  |
  |-- create coroutine frame (堆上)
  |
  |-- get coroutine_handle from promise
  |
  |-- call promise.get_return_object()
  |     -> return Task(handle)
  |
  |-- call promise.initial_suspend()
        -> suspend_always → 协程暂停
  |
  |-- 返回 Task
```

---

## 🧪 验证：协程没有立即运行

你可以在 `run()` 函数的第一句打印：

```cpp
std::cout << "task " << i << " start" << std::endl;
```

即使你写了这句，也不会在 `auto task = run(5);` 这一步打印任何东西。

直到你执行：

```cpp
task.next();
```

协程才真正恢复、执行到第一个 `co_yield` 并挂起。

---

## 🔚 小结

执行 `auto task = run(5);` 时发生了以下事件：

| 步骤  | 动作                                   |
| --- | ------------------------------------ |
| ①   | 编译器构造 `promise_type`                 |
| ②   | 创建协程帧（堆分配）                           |
| ③   | 生成协程句柄（指向帧）                          |
| ④   | 调用 `get_return_object()` → 返回 `Task` |
| ⑤   | 调用 `initial_suspend()` → 协程自动挂起      |
| ✅   | `run()` 没有执行任何语句，协程尚未开始              |

# promise: 协程核心

这段话主要解释了C++协程中**promise对象的构造逻辑**，以及为什么协程的参数列表会与promise的构造函数关联，核心是为了让promise能获取协程运行所需的上下文信息（包括普通参数和成员函数的`this`指针）。


### 先拆解核心逻辑：promise的构造规则
当你调用一个协程时，编译器会先在协程对应的`promise_type`（协程必须关联的类型）中创建一个`promise`对象（存放在协程帧中）。这个`promise`对象的构造函数选择遵循以下规则：
1. 优先匹配**协程的参数列表**与`promise`的构造函数参数列表（参数类型可转换即可，不必完全一致）；
2. 若匹配失败，再看`promise`是否有**无参构造函数**，有则用它；
3. 若前两者都不满足，编译报错。


### 关键：为什么协程参数要和promise构造函数关联？
核心目的是让`promise`对象在创建时就能拿到协程运行所需的**上下文信息**。这些信息可能是：
- 普通协程的参数（如函数参数）；
- 成员函数作为协程时的`this`指针（类的上下文）。


### 重点理解：成员函数作为协程的场景
在C++中，类的成员函数调用时会**隐式传递`this`指针**（编译器层面，成员函数的第一个参数其实是`类名* this`，只是用户不用显式写）。

当成员函数是协程时，这个`this`指针对协程至关重要——协程需要通过`this`访问类的成员变量和其他方法。因此，编译器必须把`this`指针传递给`promise`对象，而传递的方式就是通过`promise`的构造函数。

#### 示例说明
假设我们有一个类`MyClass`，其中的成员函数`coro_func`是协程：
```cpp
class MyClass {
private:
    int value = 100; // 类的成员变量
public:
    // 协程（成员函数）
    MyCoro coro_func(int x) {
        co_return value + x; // 协程中需要访问this->value
    }
};
```

从编译器视角看，这个协程的参数列表其实是`(MyClass* this, int x)`（`this`是隐式的）。为了让`promise`能拿到`this`（否则协程无法访问`value`），`promise_type`的构造函数必须接受`MyClass*`和`int`作为参数：
```cpp
struct MyCoro::promise_type {
    MyClass* self; // 存储this指针
    int x;         // 存储协程参数x

    // 构造函数：接收this指针和协程参数x
    promise_type(MyClass* t, int arg) : self(t), x(arg) {}

    // ... 其他必要成员（如get_return_object、initial_suspend等）
};
```

这样，当`MyClass`的对象调用`coro_func(5)`时，编译器会：
1. 识别协程的实际参数是`(this指针, 5)`；
2. 用`promise_type(MyClass* t, int arg)`构造`promise`对象，将`this`和`5`传入；
3. `promise`中存储了`self`（`this`指针），协程运行时就能通过`self->value`访问类成员。


### 总结
C++协程设计中，“协程参数列表与promise构造函数关联”的核心目的是：  
让`promise`对象在创建时就能获取协程运行所需的全部上下文（普通参数或成员函数的`this`指针），从而支持协程对这些信息的访问（比如成员函数协程访问类成员）。这是C++通过“构造函数参数匹配”实现上下文传递的自然设计。
