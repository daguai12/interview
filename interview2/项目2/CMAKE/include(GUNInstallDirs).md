好的，这三行 `include` 命令是现代 CMake 项目中非常常见的用法，它们的作用是**加载 CMake 自带的三个标准模块**，从而让您可以在项目中使用这些模块提供的强大功能。

我来为您逐一详细解释它们的作用：

### 1. `include(GNUInstallDirs)`

* **这是做什么的？**
    * 这个模块**定义了一系列标准的安装目录变量**，比如 `${CMAKE_INSTALL_LIBDIR}` (库目录), `${CMAKE_INSTALL_INCLUDEDIR}` (头文件目录), `${CMAKE_INSTALL_BINDIR}` (可执行文件目录) 等。
* **为什么需要它？**
    * 不同的操作系统（比如 Ubuntu, CentOS, macOS）对于库文件、头文件应该安装在哪里，有不同的约定和标准（例如，有些系统是 `lib`，有些是 `lib64`）。
    * 如果您自己硬编码安装路径（比如 `install(TARGETS ... DESTINATION "/usr/local/lib")`），您的项目在其他系统上可能就无法正常工作。
    * `GNUInstallDirs` 模块会自动检测当前的操作系统，并为您设置好符合该系统标准的安装路径变量。您只需要在 `install` 命令中使用这些变量，就能**确保您的项目可以在各种主流 Linux/Unix 系统上被正确地安装**，大大增强了项目的可移植性。

---

### 2. `include(GenerateExportHeader)`

* **这是做什么的？**
    * 这个模块提供了我们之前详细讨论过的 `generate_export_header()` 函数。
* **为什么需要它？**
    * 当您编写一个需要被编译成动态链接库（`.so` 或 `.dll`）的项目时，您需要一种机制来明确地告诉编译器，哪些函数或类是库的“公共API”（需要导出），哪些是内部实现（不需要导出）。
    * 这个模块提供的 `generate_export_header()` 函数能**自动生成一个 C++ 头文件**（在这个项目中是 `export.hpp`），里面包含了跨平台的宏（如 `CORO_EXPORT`）。您只需要在代码中用这个宏来标记您的公共API，CMake 就会自动处理在不同操作系统和编译器下的符号导出细节。
    * 简单来说，它让**库的 API 版本管理和跨平台编译变得非常简单和标准化**。

---

### 3. `include(CMakeDependentOption)`

* **这是做什么的？**
    * 这个模块提供了我们之前也详细讨论过的 `cmake_dependent_option()` 函数。
* **为什么需要它？**
    * 在复杂的项目中，不同的编译选项之间常常存在依赖关系。例如，在这个项目中，“开启编译优化” (`ENABLE_COMPILE_OPTIMIZE`) 和 “开启调试模式” (`ENABLE_DEBUG_MODE`) 就是互斥的。
    * `cmake_dependent_option()` 函数允许您**定义一个依赖于其他选项的 CMake 选项**。
    * 它能帮助您**建立清晰、健壮的编译逻辑**，防止用户选择一组相互冲突或不合理的编译选项，从而避免潜在的编译错误或运行时问题。

### 总结

这三个 `include` 命令，分别从**安装部署**、**API封装**和**编译配置逻辑**三个方面，引入了 CMake 的标准化、自动化功能，是提升项目工程化水平和代码质量的关键实践。