这篇文章是 C++ 协程技术规范（Coroutines TS，N4736）系列的第三篇。

本系列之前的文章包括：

* 协程理论（Coroutine Theory）
* 理解 `operator co_await`

在这篇文章中，我将探讨编译器是如何将你编写的协程代码转换为编译后的代码的具体机制，以及你如何通过自定义 Promise 类型来定制协程的行为。

---

## 协程概念

Coroutines TS 新增了三个关键字：`co_await`、`co_yield` 和 `co_return`。
当你在函数体中使用任意一个协程关键字时，这会触发编译器将该函数编译为协程，而不是普通函数。

编译器会对你编写的代码进行一些机械化的转换，将其变为一个状态机，使它能够在函数执行的特定位置挂起，并在之后恢复执行。

在上一篇文章中，我介绍了 Coroutines TS 引入的第一个新接口：**Awaitable 接口**。
本篇要介绍的第二个接口是：**Promise 接口**，它对于代码转换非常重要。

Promise 接口定义了可自定义协程本身行为的方法。
库的开发者可以自定义：协程被调用时的行为、协程正常返回或因未处理异常返回时的行为，以及协程中任意 `co_await` 或 `co_yield` 表达式的行为。

---

## Promise 对象

Promise 对象通过在协程执行的特定时刻实现一些方法来定义和控制协程的行为。

在继续之前，我希望你暂时忘掉对 “promise” 一词的固有印象。
虽然在某些使用场景中，协程的 promise 对象确实类似于 `std::promise`（与 `std::future` 搭配使用），但在另一些场景中，这个类比就不太贴切了。
更容易理解的方式是：把协程的 promise 对象看作一个 **“协程状态控制器”**，它负责控制协程的行为，并可以用来跟踪协程的状态。

每次调用协程函数，**都会在协程帧（coroutine frame）中构造一个 Promise 对象实例。**

编译器会在协程执行的关键节点自动调用 Promise 对象的某些方法。

在接下来的示例中，假设某次调用协程时，协程帧中构造的 Promise 对象名为 `promise`。

当你编写的协程函数体 `<body-statements>` 中包含任意协程关键字（`co_return`、`co_await`、`co_yield`）时，编译器会将协程体大致转换成如下形式：

```cpp
{
  co_await promise.initial_suspend();
  try
  {
    <body-statements>
  }
  catch (...)
  {
    promise.unhandled_exception();
  }
FinalSuspend:
  co_await promise.final_suspend();
}
```

---

## 调用协程函数时的特殊步骤

当一个协程函数被调用时，在真正进入协程体执行之前，会有一些不同于普通函数的额外步骤。

以下是这些步骤的概要（后面会详细解释每一步）：

1. 使用 `operator new` 分配协程帧（可选步骤）。
2. 将协程函数的参数拷贝到协程帧中。
3. 构造 Promise 对象（类型为 `P`）。
4. 调用 `promise.get_return_object()` 方法，获得协程首次挂起时要返回给调用方的结果，并将该结果保存为局部变量。
5. 调用 `promise.initial_suspend()` 方法，并对返回值执行 `co_await`。
6. 当 `co_await promise.initial_suspend()` 恢复执行（可能是立即，也可能是异步）时，协程开始执行你编写的协程体语句。

---

## 当遇到 `co_return` 时的额外步骤

1. 调用 `promise.return_void()` 或 `promise.return_value(<expr>)`。
2. 按变量创建的逆序销毁所有具有自动存储周期的变量。
3. 调用 `promise.final_suspend()` 并对结果执行 `co_await`。

---

## 当因未处理异常退出协程体时

1. 捕获异常，并在 `catch` 块中调用 `promise.unhandled_exception()`。
2. 调用 `promise.final_suspend()` 并对结果执行 `co_await`。

---

## 当协程执行完毕后销毁协程帧

协程帧销毁涉及以下步骤：

1. 调用 Promise 对象的析构函数。
2. 调用已拷贝的函数参数的析构函数。
3. 调用 `operator delete` 释放协程帧所占的内存（可选步骤）。
4. 将执行控制权交还给调用方或恢复方。

当协程首次到达 `<return-to-caller-or-resumer>` 位置（通常在 `co_await` 表达式内部），或者在未遇到任何 `<return-to-caller-or-resumer>` 位置就运行结束时，协程会被挂起或销毁，并将之前由 `promise.get_return_object()` 返回的对象返回给调用协程的地方。

---

## 分配协程帧

首先，编译器会调用 `operator new` 为协程帧分配内存。

如果 Promise 类型 `P` 定义了自定义的 `operator new`，那么会调用它；否则会调用全局作用域的 `operator new`。

几点需要注意：

* 传给 `operator new` 的大小并不是 `sizeof(P)`，而是整个协程帧的大小。这个大小由编译器根据参数数量与大小、Promise 对象大小、本地变量数量与大小，以及用于管理协程状态的其他编译器内部存储来自动计算。
* 编译器可以在以下情况下省略 `operator new` 调用：

  1. 可以确定协程帧的生命周期严格嵌套在调用方的生命周期内；
  2. 编译器在调用点就能知道协程帧所需的大小。
     在这种情况下，编译器可以将协程帧分配在调用方的激活帧（activation frame）内（栈帧或协程帧部分）。

Coroutines TS 目前并没有规定在哪些情况下必须进行这种省略优化，因此你仍需假设协程帧分配可能会因内存不足而抛出 `std::bad_alloc`。**这意味着，除非你接受协程分配内存失败时调用 `std::terminate()`，否则通常不应将协程函数声明为 `noexcept`。**

[[段落解释]]

---

## 分配失败的替代方案

在某些不允许使用异常的环境（如嵌入式或对性能极端敏感的环境）下，可以使用另一种机制来处理协程帧分配失败的情况。

如果 Promise 类型提供了静态成员函数 `P::get_return_object_on_allocation_failure()`，那么编译器会改为调用 `operator new(size_t, nothrow_t)` 版本。如果该调用返回 `nullptr`，则协程会立刻调用 `P::get_return_object_on_allocation_failure()`，并将结果返回给调用方，而不是抛出异常。

---

## 自定义协程帧内存分配

Promise 类型可以自定义 `operator new()` 来替代全局的内存分配方式。

例如：

```cpp
struct my_promise_type
{
  void* operator new(std::size_t size)
  {
    void* ptr = my_custom_allocate(size);
    if (!ptr) throw std::bad_alloc{};
    return ptr;
  }

  void operator delete(void* ptr, std::size_t size)
  {
    my_custom_free(ptr, size);
  }

  ...
};
```

---

## 关于自定义分配器

你还可以为 Promise 类型提供带额外参数的 `operator new()` 重载，该重载会在协程函数参数为左值引用时被调用。这可以用来将分配动作交给协程参数中的分配器对象。

但由于 `operator delete` 调用时已无法访问原始参数（它们已在协程帧中被析构），因此需要在分配时额外分配一段空间保存分配器的副本，以便在释放时使用。

例如：

```cpp
template<typename ALLOCATOR>
struct my_promise_type
{
  template<typename... ARGS>
  void* operator new(std::size_t sz, std::allocator_arg_t, ALLOCATOR& allocator, ARGS&... args)
  {
    // 对齐到 ALLOCATOR 的对齐大小
    std::size_t allocatorOffset =
      (sz + alignof(ALLOCATOR) - 1u) & ~(alignof(ALLOCATOR) - 1u);

    void* ptr = allocator.allocate(allocatorOffset + sizeof(ALLOCATOR));

    // 拷贝分配器到额外空间
    new (((char*)ptr) + allocatorOffset) ALLOCATOR(allocator);

    return ptr;
  }

  void operator delete(void* ptr, std::size_t sz)
  {
    std::size_t allocatorOffset =
      (sz + alignof(ALLOCATOR) - 1u) & ~(alignof(ALLOCATOR) - 1u);

    ALLOCATOR& allocator = *reinterpret_cast<ALLOCATOR*>(
      ((char*)ptr) + allocatorOffset);

    ALLOCATOR allocatorCopy = std::move(allocator);
    allocator.~ALLOCATOR();

    allocatorCopy.deallocate(ptr, allocatorOffset + sizeof(ALLOCATOR));
  }
};
```

为了让自定义的 `my_promise_type` 在使用 `std::allocator_arg` 作为第一个参数的协程中生效，需要特化 `coroutine_traits`：

```cpp
namespace std::experimental
{
  template<typename ALLOCATOR, typename... ARGS>
  struct coroutine_traits<my_return_type, std::allocator_arg_t, ALLOCATOR, ARGS...>
  {
    using promise_type = my_promise_type<ALLOCATOR>;
  };
}
```

即使你自定义了协程的内存分配策略，编译器仍然可能省略对你的分配器的调用。

---

## 将参数拷贝到协程帧

协程需要将调用方传入的参数拷贝到协程帧，以便在协程挂起后它们依然有效。

* 如果参数是按值传递，则通过调用类型的移动构造函数进行拷贝。
* 如果参数是按引用（左值或右值引用）传递，则只会拷贝引用本身，而不是它指向的值。

对于具有平凡析构函数（trivial destructor）的类型，如果参数在到达某个可达的 `<return-to-caller-or-resumer>` 点后不再被引用，编译器可以省略拷贝。

这里有很多陷阱：当通过引用传递参数时，你不能总是依赖引用在整个协程生命周期内都保持有效。许多在普通函数中常见的技巧（如完美转发、万能引用）在协程中可能会导致未定义行为。Toby Allsopp 写过一篇很好的文章深入讨论了这个问题。

如果在拷贝/移动构造参数时抛出异常，那么已构造的参数会被析构，协程帧会被释放，异常会向调用方传播。

---

## 构造 Promise 对象

在所有参数拷贝到协程帧后，协程会构造 Promise 对象。

参数之所以先拷贝，是为了让 Promise 构造函数可以访问拷贝后的参数。

编译器会先检查 Promise 类型是否有一个构造函数可以接受拷贝后的所有参数的左值引用。如果找到这样的构造函数，就调用它；否则退回到默认构造函数。

这种 Promise 构造函数可以“窥视”参数的能力是 Coroutines TS 较新的改动（在 2018 年 Jacksonville 会议上的 N4723 中采纳，见 P0914R1 提案），因此某些旧版本的 Clang 或 MSVC 可能不支持。

如果 Promise 构造函数抛出异常，已拷贝的参数会被析构，协程帧会在栈展开过程中被释放，异常会向调用方传播。


### 获取返回对象

协程与 `promise` 对象的第一步交互是通过调用 `promise.get_return_object()` 来获取返回对象（return-object）。

返回对象就是当协程首次挂起时，或者协程执行完成并将控制权返回给调用者时，会返回给协程调用者的值。

你可以大致把控制流理解如下（非常粗略）：

```cpp
// 假设编译器生成了一个结构体 'coroutine_frame'
// 它保存协程所需的所有状态。构造函数
// 会复制参数并默认构造一个 promise 对象。
struct coroutine_frame { ... };

T some_coroutine(P param)
{
  auto* f = new coroutine_frame(std::forward<P>(param));

  auto returnObject = f->promise.get_return_object();

  // 通过恢复协程来开始执行协程体。
  // 当协程执行到第一个挂起点或运行完成时，这个调用会返回。
  coroutine_handle<decltype(f->promise)>::from_promise(f->promise).resume();

  // 然后返回对象会返回给调用者。
  return returnObject;
}
```

注意，我们必须在启动协程体之前获取返回对象，因为协程帧（以及 promise 对象）可能在 `coroutine_handle::resume()` 返回之前就被销毁（可能在本线程，也可能在其他线程）。因此在执行协程体之后再调用 `get_return_object()` 是不安全的。

==为什么必须在启动协程体之前获取返回对象？==

这是为了避免竞态条件和悬空引用。

想象一下，如果代码顺序反过来：先执行 .resume()，再获取 returnObject。

    .resume() 开始执行协程体。

    协程体中的某个 co_await 立即同步完成了，并且协程也运行到了最后，直接销毁了协程帧。

    .resume() 返回，但此时协程帧已经被销毁了。

    紧接着你试图调用 f->promise.get_return_object()，但 f 指向的内存已经失效了，这会导致未定义行为甚至崩溃。

因此，先获取 returnObject，再启动协程体的顺序是强制性的，它确保了即使协程瞬间完成并销毁了自己，你也能安全地拿到协程的返回值。这个设计保证了协程的创建和返回过程是线程安全的。

---

### 初始挂起点

协程在协程帧初始化完成、返回对象获取之后，接下来执行的是：

```cpp
co_await promise.initial_suspend();
```

这允许 `promise_type` 的作者控制协程是**在执行协程体前挂起**，还是**立即执行协程体**。

如果协程在初始挂起点挂起，则可以在之后通过调用协程句柄的 `resume()` 或 `destroy()` 来恢复或销毁协程。

`co_await promise.initial_suspend()` 的结果会被丢弃，因此 awaiter 的 `await_resume()` 方法通常应返回 `void`。

重要的是，这条语句位于 try/catch 块之外（如果忘记[[协程体定义]]，可以回去查看）。这意味着，如果 `co_await promise.initial_suspend()` 在到达返回调用者之前抛出异常，该异常会在销毁协程帧和返回对象之后，被抛回协程的调用者。

如果返回对象具有 RAII 语义，会在析构时销毁协程帧，则需要确保 `co_await promise.initial_suspend()` 是 `noexcept`，以避免协程帧被[[重复释放]]。

注意，有一个提议希望调整语义，使部分或全部的 `co_await promise.initial_suspend()` 位于协程体的 try/catch 块中，因此确切语义在协程最终标准化前可能会改变。

对于很多协程类型，`initial_suspend()` 通常返回 `std::experimental::suspend_always`（延迟启动）或 `std::experimental::suspend_never`（立即启动），这两者都是 `noexcept` 的 awaitable，因此通常不会有问题。

---

### 返回调用者

当协程函数到达第一个 `<return-to-caller-or-resumer>` 点（或者没有此类点，则协程执行完成时），会将 `get_return_object()` 返回的返回对象返回给调用者。[[额外补充/解释]]

注意，返回对象的类型不需要与协程函数的返回类型一致。如果需要，会进行隐式转换。

Clang 的协程实现（截至 5.0）会将转换延迟到返回对象返回时，而 MSVC（2017 Update 3）在调用 `get_return_object()` 后立即进行转换。Coroutines TS 并未明确规定行为，但 MSVC 计划将实现改为类似 Clang，以支持一些有趣的用例。

---

### 使用 co\_return 从协程返回

当协程执行到 `co_return` 语句时，它会被翻译为调用 `promise.return_void()` 或 `promise.return_value(<expr>)`，随后跳转到 `FinalSuspend`：

翻译规则如下：

```cpp
co_return;
-> promise.return_void();

co_return <expr>;
-> <expr>; promise.return_void();   // 如果 <expr> 类型为 void
-> promise.return_value(<expr>);   // 如果 <expr> 类型非 void
```

随后 `goto FinalSuspend;` 会导致所有局部自动变量按构造顺序逆序析构，然后执行：

```cpp
co_await promise.final_suspend();
```

注意，如果协程在没有 `co_return` 的情况下执行到末尾，相当于在函数末尾有一个隐式的 `co_return;`。此时，如果 `promise_type` 没有 `return_void()` 方法，则行为未定义。

如果 `<expr>` 的求值或调用 `promise.return_void()` / `promise.return_value()` 抛出异常，该异常仍然会传播到 `promise.unhandled_exception()`。

## [[代码完整展开]]

---

### 处理从协程体外传播的异常

如果一个异常从协程体外传播，那么该异常会被捕获，并在 `catch` 块内调用 `promise.unhandled_exception()` 方法。

该方法的实现通常会调用 `std::current_exception()` 来捕获异常的副本，并将其存储，以便稍后在不同的上下文中重新抛出。

另外，实施可以通过执行 `throw;` 语句立即重新抛出异常。例如，参见 [folly::Optional](https://github.com/facebook/folly/blob/4af3040b4c2192818a413bad35f7a6cc5846ed0b/folly/Optional.h#L587)。然而，采用这种做法将（可能会，见下文）导致协程帧立即销毁，异常会传播到调用者/恢复者。这可能会导致一些抽象出现问题，这些抽象假设/要求 `coroutine_handle::resume()` 的调用是 `noexcept` 的，因此通常只有在你完全控制谁/什么调用 `resume()` 时，才应该使用这种方法。

需要注意的是，当前的 [Coroutines TS](http://wg21.link/N4736) 规范的措辞在如果 `unhandled_exception()` 重新抛出异常（或者更准确地说，如果 `try` 块外的任何逻辑抛出异常时）时，意图的行为上存在 [一些不清楚的地方](https://github.com/GorNishanov/CoroutineWording/issues/17)。

我目前对措辞的理解是，如果控制流离开协程体，无论是通过异常从 `co_await promise.initial_suspend()`、`promise.unhandled_exception()` 或 `co_await promise.final_suspend()` 中传播，还是通过协程运行至完成，`co_await p.final_suspend()` 同步完成，则协程帧会在执行返回到调用者/恢复者之前自动销毁。然而，这种解释也存在一些问题。

未来的协程规范版本可能会澄清这一情况。不过，在此之前，我建议避免在 `initial_suspend()`、`final_suspend()` 或 `unhandled_exception()` 中抛出异常。敬请关注！


[[为什么将resume设计为noexcept]]
### [[额外补充/解释2]]
---

### 最终挂起点

一旦执行离开用户定义的协程体部分，并通过调用 `return_void()`、`return_value()` 或 `unhandled_exception()` 捕获了结果，同时局部变量已析构，协程还有机会在控制返回调用者/恢复者之前执行额外逻辑。

协程会执行：

```cpp
co_await promise.final_suspend();
```

这允许协程执行一些逻辑，例如发布结果、信号完成或恢复后续操作。同时，协程可以选择在执行完成前立即挂起，协程帧随后被销毁。

注意：在最终挂起点上调用 `resume()` 是未定义行为。在这里唯一可以做的操作是 `destroy()`。

Gor Nishanov 的解释是，这样设计可以减少编译器需要表示的挂起状态数量，降低分支数量，从而提高优化空间。

虽然协程允许在最终挂起点不挂起，但建议尽可能在 `final_suspend` 挂起。这样可以通过外部调用 `.destroy()`（通常在某个 RAII 对象析构函数中）销毁协程，便于编译器判断协程帧生命周期嵌套，从而更容易优化协程帧的内存分配。

---

### 编译器如何选择 promise 类型

现在来看编译器如何确定协程使用的 promise 类型。

promise 类型由协程签名决定，使用 `std::experimental::coroutine_traits` 模板。

例如：

```cpp
task<float> foo(std::string x, bool flag);
```

编译器会将返回类型和参数类型传给 `coroutine_traits` 来推导 promise 类型：

```cpp
typename coroutine_traits<task<float>, std::string, bool>::promise_type;
```

如果函数是非静态成员函数，则类类型作为第二个模板参数传给 `coroutine_traits`。如果方法对右值引用进行了重载，第二个模板参数就是右值引用。

例如：

```cpp
task<void> my_class::method1(int x) const;
task<foo> my_class::method2() &&;
```

编译器会选择：

```cpp
// method1 的 promise 类型
typename coroutine_traits<task<void>, const my_class&, int>::promise_type;

// method2 的 promise 类型
typename coroutine_traits<task<foo>, my_class&&>::promise_type;
```

`coroutine_traits` 的默认实现会查找返回类型中嵌套的 `promise_type`：

```cpp
namespace std::experimental
{
  template<typename RET, typename... ARGS>
  struct coroutine_traits<RET, ARGS...>
  {
    using promise_type = typename RET::promise_type;
  };
}
```

因此对于可控返回类型，可以在类中定义嵌套 `promise_type`，让编译器使用它作为协程的 promise 类型。例如：

```cpp
template<typename T>
struct task
{
  using promise_type = task_promise<T>;
  ...
};
```

如果返回类型不可控，可以通过特化 `coroutine_traits` 指定 promise 类型：

```cpp
namespace std::experimental
{
  template<typename T, typename... ARGS>
  struct coroutine_traits<std::optional<T>, ARGS...>
  {
    using promise_type = optional_promise<T>;
  };
}
```

### [[解释3]]

---

### 标识特定协程激活帧

调用协程函数时，会创建一个协程帧。要恢复协程或销毁协程帧，需要能引用该协程帧。

Coroutines TS 提供了 `coroutine_handle` 类型：

```cpp
namespace std::experimental
{
  template<typename Promise = void>
  struct coroutine_handle;

  template<>
  struct coroutine_handle<void>
  {
    constexpr coroutine_handle();
    constexpr void* address() const noexcept;
    static constexpr coroutine_handle from_address(void* addr);
    constexpr explicit operator bool() const noexcept;
    bool done();
    void resume();
    void destroy();
  };

  template<typename Promise>
  struct coroutine_handle : coroutine_handle<>
  {
    using coroutine_handle<>::coroutine_handle;

    static constexpr coroutine_handle from_address(void* addr);
    Promise& promise() const;
    static coroutine_handle from_promise(Promise& promise);
  };
}
```

可以通过两种方式获得协程句柄：

1. 在 `co_await` 表达式中传给 awaiter 的 `await_suspend()`
2. 通过 promise 对象重构协程句柄：`coroutine_handle<Promise>::from_promise()`

注意：`coroutine_handle` **不是 RAII 对象**，需要手动调用 `.destroy()` 释放资源。

通常建议使用封装了协程帧生命周期的高级类型，如 cppcoro 提供的类型，或自己实现的 RAII 封装。

---

### 自定义 co\_await 的行为

promise 类型可以自定义协程体中每个 `co_await` 的行为。

通过在 promise 类型上定义 `await_transform()` 方法，编译器会将每个 `co_await <expr>` 转换为：

```cpp
co_await promise.await_transform(<expr>)
```

用途：

1. 支持原本不可等待的类型，例如：

```cpp
template<typename T>
class optional_promise
{
  template<typename U>
  auto await_transform(std::optional<U>& value)
  {
    class awaiter { ... };
    return awaiter{ value };
  }
};
```

2. 禁止特定类型被等待：

```cpp
template<typename T>
class generator_promise
{
  template<typename U>
  std::experimental::suspend_never await_transform(U&&) = delete;
};
```

3. 修改原本可等待值的行为，例如在指定执行器上恢复：

```cpp
template<typename T, typename Executor>
class executor_task_promise
{
  template<typename Awaitable>
  auto await_transform(Awaitable&& awaitable)
  {
    return resume_on(this->executor, std::forward<Awaitable>(awaitable));
  }
};
```

注意：一旦定义了 `await_transform()`，所有 `co_await` 都会调用这个方法。因此如果只想针对部分类型自定义，还需要提供默认的转发重载。

### [[解释4]]

---

### 自定义 co\_yield 的行为

协程体中出现 `co_yield <expr>` 会被转换为：

```cpp
co_await promise.yield_value(<expr>)
```

promise 可以通过定义 `yield_value()` 方法来自定义 `co_yield` 的行为。

注意：与 `await_transform` 不同，如果 promise 类型未定义 `yield_value()`，`co_yield` 没有默认行为。promise 需要显式 opt-in 才能支持 `co_yield`。

典型例子是 `generator<T>`：

```cpp
template<typename T>
class generator_promise
{
  T* valuePtr;

  std::experimental::suspend_always yield_value(T& value) noexcept
  {
    valuePtr = std::addressof(value);
    return {};
  }
};
```

---

### 总结

本文讲解了编译器将函数编译为协程时的各种变换，包括如何通过自定义 promise 类型调整协程行为。协程机制中涉及很多细节，因此有多种方式可以自定义行为。

下一篇文章将讲解**协程体如何被转换为状态机**的详细机制。
