以下是 Lewis Baker 于 2017 年 11 月 17 日发表的文章《C++ Coroutines: Understanding operator co\_await》的**完整中文翻译**，力求准确还原原文结构与用语：

---

# C++ 协程：理解 `operator co_await`

**发表于 2017 年 11 月 17 日** ([Asymmetric Transfer][1])

在上一篇《Coroutine Theory》中，我介绍了函数与协程在高层面的区别，但未深入细节，也未讨论 C++ 协程 TS（技术规范 N4680）中的协程语法与语义。本文致力于解释新引入的 `co_await` 操作符机制，并介绍关联的 **Awaitable** 与 **Awaiter** 类型概念。([Asymmetric Transfer][1])

但在深入谈 `co_await` 之前，先简要回顾一下 Coroutines TS 提供了什么语境和支持。([Asymmetric Transfer][1])

---

## Coroutines TS 带来什么？

* 三个新关键词：`co_await`、`co_yield` 与 `co_return`
* `std::experimental` 命名空间中新类型：

  * `coroutine_handle<P>`
  * `coroutine_traits<Ts...>`
  * `suspend_always`
  * `suspend_never`
* 一个通用机制，允许库作者与协程机制交互并定制行为
* 一个使编写异步代码变得更轻松的语言设施([Asymmetric Transfer][1])

Coroutines TS 提供的低级语言功能（就像协程的“汇编指令”）可能难以安全使用，主要是给库作者构建更高层 abstractions 的基础，以便应用开发者使用更安全易用的接口。标准计划在 C++20 中引入这些低级构建块，并提供更安全更友好的标准库封装。([Asymmetric Transfer][1])

---

## 编译器与库之间的配合（Compiler ↔ Library）

有趣的是，Coroutines TS 本身并不定义协程的完整语义，例如：

* 如何生成返回值给调用者
* `co_return` 如何处理
* 异常传播如何处理
* 协程在哪个线程恢复

它只是指定了一个通用机制——由库通过定义特定接口类型来定制协程行为，编译器生成的代码则调用这些类型所提供的方法。这类似于库作者定义 `begin()`/`end()` 和 `iterator` 类型来定制范围循环行为的方式。([Asymmetric Transfer][1])

这种设计赋予协程机制极高灵活性，库作者可以构建：

* 异步产出单个值的协程
* 延迟生成序列的协程
* 针对 `optional<T>` 值简化控制流的协程

等多种用途的协程类型。([Asymmetric Transfer][1])

此规范定义了两类接口：

* **Promise 接口**：定制调用、返回（或异常）、`co_await`/`co_yield` 表达式的行为
* **Awaitable 接口**：定制 `co_await` 表达式的语义行为([Asymmetric Transfer][1])

本文聚焦于 Awaitable 接口，后续将介绍 Promise 接口。([Asymmetric Transfer][1])

---

## C++ 协程：理解 `operator co_await`

### 协程的 Awaiter 与 Awaitable

**`co_await`** 是一个新的一元操作符，例如 `co_await someValue`。它只能在协程上下文中使用，因为任何包含 `co_await` 的函数体都会被编译器编译为协程。

一个支持 `co_await` 操作符的类型被称为 **Awaitable** 类型。值得注意的是，`co_await` 操作符是否能应用于某个类型，可能取决于它出现的上下文。协程的 **promise** 类型可以通过其 `await_transform` 方法来改变 `co_await` 表达式的含义。

为了更清晰地描述，文章引入了两个术语：

  * **Normally Awaitable (正常可等待)**：指在没有 `await_transform` 成员的 promise 类型的协程上下文中，支持 `co_await` 的类型。
  * **Contextually Awaitable (上下文可等待)**：指由于协程的 promise 类型中存在 `await_transform` 方法，而仅在特定协程上下文中支持 `co_await` 的类型。

**Awaiter** 类型是一个实现了三个特殊方法的类型，这些方法是 `co_await` 表达式的核心：**`await_ready`**、**`await_suspend`** 和 **`await_resume`**。值得一提的是，一个类型可以同时是 **Awaitable** 和 **Awaiter**。

-----

### 获取 Awaiter 对象

当编译器看到 `co_await <expr>` 表达式时，它会生成代码来获取 **Awaiter** 对象。获取过程遵循以下步骤：

假设当前协程的 promise 对象的类型为 `P`，`promise` 是对该 promise 对象的左值引用。

1.  **处理 `await_transform`**：

      * 如果 promise 类型 `P` 有名为 `await_transform` 的成员，那么 `<expr>` 会首先被传递给 `promise.await_transform(<expr>)` 调用，以获得 **Awaitable** 值 `awaitable`。
      * 否则，如果 promise 类型没有 `await_transform` 成员，则直接使用 `<expr>` 的求值结果作为 **Awaitable** 对象 `awaitable`。

2.  **获取 Awaiter**：

      * 如果 **Awaitable** 对象 `awaitable` 有一个适用的 `operator co_await()` 重载，则调用它来获取 **Awaiter** 对象。
      * 否则，`awaitable` 对象本身被用作 **Awaiter** 对象。

用伪代码来描述这个过程，获取 `awaitable` 和 `awaiter` 的函数可能如下所示：

```cpp
template<typename P, typename T>
decltype(auto) get_awaitable(P& promise, T&& expr){
  if constexpr (has_any_await_transform_member_v<P>)
    return promise.await_transform(static_cast<T&&>(expr));
  else
    return static_cast<T&&>(expr);
}

template<typename Awaitable>
decltype(auto) get_awaiter(Awaitable&& awaitable){
  if constexpr (has_member_operator_co_await_v<Awaitable>)
    return static_cast<Awaitable&&>(awaitable).operator co_await();
  else if constexpr (has_non_member_operator_co_await_v<Awaitable&&>)
    return operator co_await(static_cast<Awaitable&&>(awaitable));
  else
    return static_cast<Awaitable&&>(awaitable);
}
```

-----

### 等待 Awaiter 的过程

假设我们已经将获取 `Awaiter` 对象的逻辑封装在上述函数中，那么 `co_await <expr>` 的语义大致可以翻译为如下代码：

```cpp
{
  auto&& value = <expr>;
  auto&& awaitable = get_awaitable(promise, static_cast<decltype(value)>(value));
  auto&& awaiter = get_awaiter(static_cast<decltype(awaitable)>(awaitable));

  // 1. 调用 await_ready()
  if (!awaiter.await_ready())
  {
    using handle_t = std::experimental::coroutine_handle<P>;
    using await_suspend_result_t = decltype(awaiter.await_suspend(handle_t::from_promise(promise)));

    // 2. 暂停协程
    <suspend-coroutine>

    // 3. 调用 await_suspend()
    if constexpr (std::is_void_v<await_suspend_result_t>)
    {
      awaiter.await_suspend(handle_t::from_promise(promise));
      <return-to-caller-or-resumer> // 返回给调用者/恢复者
    }
    else
    {
      static_assert(std::is_same_v<await_suspend_result_t, bool>, "await_suspend() must return 'void' or 'bool'.");

      if (awaiter.await_suspend(handle_t::from_promise(promise)))
      {
        <return-to-caller-or-resumer> // 返回给调用者/恢复者
      }
    }

    <resume-point> // 恢复点
  }

  // 4. 调用 await_resume()
  return awaiter.await_resume();
}
```

  * **`await_suspend()` 的返回类型**：

      * 返回 `void` 的版本会无条件地将执行权交还给协程的调用者或恢复者。
      * 返回 `bool` 的版本允许 awaiter 对象有条件地立即恢复协程，而无需返回给调用者或恢复者。如果返回 `false`，则协程会立即恢复并在当前线程上继续执行。这对于有时同步完成的异步操作非常有用，可以避免协程暂停的开销。

  * **`await_ready()` 的目的**：
    这个方法的目的是在操作已知会同步完成的情况下，避免协程暂停的开销。如果 `await_ready()` 返回 `true`，协程会跳过暂停步骤，直接执行 `await_resume()`。

  * **协程暂停**：
    在 `<suspend-coroutine>` 处，编译器生成代码来保存协程的当前状态，包括 `resume-point` 的位置以及寄存器中保存的任何值。当暂停操作完成后，协程被认为是已暂停。

  * **协程恢复**：
    `await_suspend()` 方法的职责是安排协程在未来某个时刻恢复或销毁。当协程最终恢复时，执行将从 `<resume-point>` 继续，即在调用 `await_resume()` 方法之前。`await_resume()` 的返回值将成为 `co_await` 表达式的结果。

  * **异常处理**：
    `await_resume()` 方法也可以抛出异常，此时异常会从 `co_await` 表达式中传播出去。如果 `await_suspend()` 调用中抛出异常，协程会自动恢复，并且异常会直接从 `co_await` 表达式中传播，而不会调用 `await_resume()`。

## 协程句柄 (Coroutine Handles)

您可能已经注意到，`co_await` 表达式的 `await_suspend()` 调用中使用了 **`coroutine_handle<P>`** 类型。

这个类型代表了协程帧的一个**非拥有句柄**，可以用来恢复协程的执行或销毁协程帧。它还能用来访问协程的 **promise** 对象。

`coroutine_handle` 类型具有以下（简化版）接口：

```cpp
namespace std::experimental {
  template<typename Promise>
  struct coroutine_handle;

  template<>
  struct coroutine_handle<void> {
    bool done() const;
    void resume();
    void destroy();
    void* address() const;
    static coroutine_handle from_address(void* address);
  };

  template<typename Promise>
  struct coroutine_handle : coroutine_handle<void> {
    Promise& promise() const;
    static coroutine_handle from_promise(Promise& promise);
    static coroutine_handle from_address(void* address);
  };
}
```

-----

#### 核心方法及其用途

当您实现 **Awaitable** 类型时，`coroutine_handle` 中最关键的方法是 **`.resume()`**。当异步操作完成并准备好恢复等待的协程时，就应该调用它。调用 `.resume()` 会在 `<resume-point>` 处重新激活已暂停的协程。该调用会在协程下一次到达 `<return-to-caller-or-resumer>` 点时返回。

**`.destroy()`** 方法用于销毁协程帧，它会调用任何在作用域内的变量的析构函数并释放协程帧使用的内存。通常，您**不需要**（也应尽量避免）调用 `.destroy()`，除非您是实现协程 promise 类型的库作者。协程帧通常由某种 RAII（资源获取即初始化）类型来拥有。如果不与该 RAII 对象协作，直接调用 `.destroy()` 可能会导致双重销毁的 bug。

**`.promise()`** 方法返回协程 promise 对象的引用。然而，和 `.destroy()` 一样，它通常只在编写协程 promise 类型时有用。您应该将协程的 promise 对象视为内部实现细节。对于大多数 **Normally Awaitable** 类型，您应该在 `await_suspend()` 方法中使用 `coroutine_handle<void>` 作为参数类型，而不是 `coroutine_handle<Promise>`。[[为什么?]]

**`coroutine_handle<P>::from_promise(P& promise)`** 函数允许您从协程的 promise 对象的引用中重新构造协程句柄。请注意，您必须确保类型 `P` 与协程帧使用的具体 promise 类型完全匹配；如果具体 promise 类型是 `Derived`，但您尝试构造 `coroutine_handle<Base>`，这可能导致未定义行为。

**`.address()` / `from_address()`** 函数允许将协程句柄转换为 `void*` 指针并从中转换回来。这主要是为了将句柄作为“上下文”参数传递给现有的 C 风格 API。在某些情况下，您可能会发现这在实现 Awaitable 类型时很有用。然而，在大多数情况下，我发现需要通过这个“上下文”参数传递更多额外信息，所以我通常会将 `coroutine_handle` 存储在一个结构体中，然后将指向该结构体的指针作为“上下文”参数传递，而不是直接使用 `.address()` 的返回值。

---

## 无需同步的异步执行

Awaiter 支持在协程挂起之后、恢复之前启动异步操作，并将 `coroutine_handle` 存入操作中，等操作完成后由其他线程直接调用 `.resume()` 恢复协程。这样无需额外同步机制即可完成异步逻辑。([Asymmetric Transfer][1])

但要注意：一旦 `.resume()` 被调用，就可能与 `await_suspend()` 并发执行。因此，在 `await_suspend()` 中只应访问本地变量，而不要访问 `this` 或 promise 对象，因为它们可能已被销毁。([Asymmetric Transfer][1])

[[内容解释]]

[[代码解释]]
## 无同步的异步代码

`co_await` 操作符的一个强大设计特点是，它能够在协程被挂起之后、但在执行权返回给调用者/恢复者之前，执行一段代码。

这允许 **Awaiter** 对象在协程已经挂起后才启动异步操作，并将已挂起协程的 **`coroutine_handle`** 传递给该操作。当操作完成时，它可以通过这个句柄安全地恢复协程（可能在另一个线程上），而**无需任何额外的同步**。

例如，在 `await_suspend()` 内部启动一个异步读取操作时，协程已经处于挂起状态。这意味着当操作完成时，我们可以直接恢复协程，而不需要任何线程同步来协调启动操作的线程和完成操作的线程。

下图展示了这个过程的时间线：

```
Time     Thread 1                           Thread 2
  |      --------                           --------
  |      ....                               Call OS - Wait for I/O event
  |      Call await_ready()                    |
  |      <supend-point>                        |
  |      Call await_suspend(handle)            |
  |        Store handle in operation           |
  V        Start AsyncFileRead ---+            V
                                  +----->   <AsyncFileRead Completion Event>
                                            Load coroutine_handle from operation
                                            Call handle.resume()
                                              <resume-point>
                                              Call to await_resume()
                                              execution continues....
           Call to AsyncFileRead returns
         Call to await_suspend() returns
         <return-to-caller/resumer>
```

-----

### 潜在的并发问题和注意事项

在使用这种方法时，有一点需要**非常小心**：一旦你启动了异步操作并将协程句柄发布到其他线程，那么**另一个线程可能在 `await_suspend()` 返回之前就恢复了协程**，并可能与 `await_suspend()` 方法的其余部分**并发执行**。

协程恢复后，它首先会调用 `await_resume()` 来获取结果，然后通常会立即销毁 **Awaiter** 对象（即 `await_suspend()` 调用中的 `this` 指针）。协程甚至有可能在 `await_suspend()` 返回之前就运行完成，并销毁协程和 promise 对象。

因此，在 `await_suspend()` 方法内部，一旦协程有可能在另一个线程上并发恢复，你就必须确保**避免访问 `this` 或协程的 `.promise()` 对象**，因为它们可能已经被销毁了。通常，在启动操作并安排协程恢复之后，唯一可以安全访问的是 `await_suspend()` 中的局部变量。

---

## 与 Stackful 协程的比较

Stackful 协程（如 Win32 fibers、boost::context）通常在 suspend 时同步地上下文切换，并不允许挂起后再执行逻辑。这样如要启动异步操作，就需要先启动再挂起，仍可能发生竞态，需额外同步。

而 stackless 协程（C++ Coroutines TS 的设计）则允许先挂起后启动操作，再简洁恢复，无需额外 context-switch 或同步机制，效率更高。([Asymmetric Transfer][1])

你引用的这段其实是在对比 **stackless（无栈）协程** 和 **stackful（有栈）协程** 在“挂起协程后还能做点事”这个能力上的差异。
我帮你按逻辑一点一点拆开解释：

---

### 1. Stackful 协程的暂停模型

像 **Win32 fibers**、**boost::context** 这样的 **stackful 协程**，暂停（suspend）一个协程的过程，通常就是**立即**切换到另一个协程的栈去运行（上下文切换）。

它的操作顺序是这样的：

```
[当前协程]  suspend()  ----->   [下一个协程] resume()
```

* 一旦调用挂起操作，执行权就立刻交给另一个协程。
* 挂起点与恢复另一个协程是**捆绑**的，中间没有空隙让你执行额外逻辑。

---

### 2. Stackless 协程的不同

**Coroutines TS** 的 **stackless 协程** 机制不一样。
它在 `await_suspend()` 阶段，可以：

* 接收当前协程的 `coroutine_handle`；
* **先执行一些自定义逻辑（比如启动 I/O 操作）**；
* 决定什么时候恢复协程（甚至不一定马上切到别的协程）。

也就是说，挂起协程和恢复其他代码是**分离的两个动作**，你可以在挂起之后、恢复之前做事。

---

### 3. 竞态问题的原因

如果用 stackful 协程做一个异步 I/O 操作，比如：

```cpp
// stackful 协程版本
start_async_file_read();
suspend(); // 立即切换上下文
```

这里有个风险：

1. `start_async_file_read()` 会让操作系统在后台启动 I/O；
2. 如果这个 I/O **很快完成**（甚至在另一个线程上），可能在协程还没执行 `suspend()` 前就触发“操作完成”事件；
3. 结果就是 **恢复信号来了，但协程还没挂起** → 出现竞态条件。

这时候必须用 **线程同步**（锁、条件变量等）来判断谁“先发生”，否则会错过唤醒信号。

---

### 4. Stackless 协程避免竞态的原因

在 stackless 协程里，流程是：

```cpp
await_suspend(handle) {
    store handle somewhere;
    start_async_file_read();
    return; // 协程挂起
}
```

* `await_suspend()` 是协程挂起前的最后一步；
* **挂起动作发生在启动 I/O 之后**，并且在同一段逻辑里完成；
* 这样可以确保：I/O 启动后，协程状态已经准备好挂起并能被恢复 → 不会出现 I/O 提前完成但协程还没准备好的竞态。

---

### 5. “蹦床（trampoline）”方案的意义

作者说的 trampoline 方案，是指：

* 在 stackful 模型里，不能直接在挂起后做事，于是用一个中间“代理协程”。
* 流程变成：

```
协程 A suspend() → 切到 trampoline → 启动 I/O → 再切到下一个协程
```

* 这样可以模拟 stackless 的“挂起后执行逻辑”效果。

缺点：

* 需要额外的基础设施（trampoline 协程本身）；
* 多了一次上下文切换（挂起 A → trampoline → 其他），开销可能比加锁还大。

---

✅ **总结理解**：

* **stackful 协程**：挂起和切换是捆绑的，没机会在挂起之后但切换之前启动 I/O → 容易出现竞态，需要额外同步；
* **stackless 协程**：挂起和恢复是解耦的，可以在挂起前/挂起后做自定义逻辑 → 避免了这种竞态问题；
* trampoline 是 stackful 的补救方案，但性能可能不划算。

---

如果你愿意，我可以帮你画一张 **stackless vs stackful 协程挂起过程的对比时序图**，把“启动 I/O”放在哪一步的差异直观画出来，这样你一眼就能看出为什么 stackless 避免了竞态。

---

## 避免额外内存分配

异步操作常需为每次操作维护状态（如 `OVERLAPPED` 结构），通常在堆上分配。使用协程时，Awaiter 存放于协程帧，可避免额外分配。协作期间挂起函数执行结束，Awaiter 会被销毁，自动释放内存。这让协程帧像一个高性能的 arena allocator，分配一次协程帧后可支持多次 await 操作，在性能上十分高效。([Asymmetric Transfer][1])

 对性能的意义
回调式：频繁堆分配 → 分配器开销 + 内存碎片

协程式：一次分配协程帧 → 所有操作的状态都复用帧里的内存

编译器能静态计算所需大小 → 内存管理几乎零成本

[[好处]]

---

## 实例：实现一个简单的异步同步原语

借助以上机制，实现一个免锁、免分配、`noexcept` 的**异步手动重置事件（`async_manual_reset_event`）**。支持多个协程并发等待，`co_await event` 会在事件 `set()` 调用之前挂起，调用后所有等待协程恢复；若事件已 `set`，则立即继续。([Asymmetric Transfer][1])

### 接口示例：

```cpp
class async_manual_reset_event {
public:
  async_manual_reset_event(bool initiallySet = false) noexcept;
  bool is_set() const noexcept;
  struct awaiter;
  awaiter operator co_await() const noexcept;
  void set() noexcept;
  void reset() noexcept;
private:
  mutable std::atomic<void*> m_state;
};
```

* 使用 `operator co_await()` 返回一个 `awaiter` 对象
* `m_state` 用于记录两种状态：

  * `this` 指针：事件已被设置
  * 链表头指针：等待的协程链表([Asymmetric Transfer][1])

### `awaiter` 类型定义：

```cpp
struct async_manual_reset_event::awaiter {
  awaiter(const async_manual_reset_event& event) noexcept;
  bool await_ready() const noexcept;
  bool await_suspend(std::experimental::coroutine_handle<> h) noexcept;
  void await_resume() noexcept {}
private:
  const async_manual_reset_event& m_event;
  std::experimental::coroutine_handle<> m_awaitingCoroutine;
  awaiter* m_next;
};
```

* `await_ready()`：若事件已设置，立即返回 `true`
* `await_suspend()`：将当前协程句柄加入等待链表；若事件在此期间已设置，则返回 `false` 表示立即恢复，否则返回 `true` 表示挂起([Asymmetric Transfer][1])

### `async_manual_reset_event` 方法实现：

```cpp
async_manual_reset_event::async_manual_reset_event(bool initiallySet) noexcept
  : m_state(initiallySet ? this : nullptr) {}

bool async_manual_reset_event::is_set() const noexcept {
  return m_state.load(std::memory_order_acquire) == this;
}

void async_manual_reset_event::reset() noexcept {
  void* old = this;
  m_state.compare_exchange_strong(old, nullptr, std::memory_order_acquire);
}

void async_manual_reset_event::set() noexcept {
  void* old = m_state.exchange(this, std::memory_order_acq_rel);
  if (old != this) {
    auto* waiters = static_cast<awaiter*>(old);
    while (waiters) {
      auto* next = waiters->m_next;
      waiters->m_awaitingCoroutine.resume();
      waiters = next;
    }
  }
}

async_manual_reset_event::awaiter async_manual_reset_event::operator co_await() const noexcept {
  return awaiter{*this};
}
```

这个实现是锁自由、无堆分配、且 `noexcept` 安全的异步同步原语。([Asymmetric Transfer][1])

---

## 结语

本文详解了 `operator co_await` 的实现机制，引入 Awaitable 与 Awaiter 概念；并通过实例展示如何利用协程帧避免额外堆分配，实现高效免锁同步原语。

希望本文帮助你更清晰理解 `co_await` 的行为与协程背后机制。下一篇文章将探讨 Promise 概念，以及如何定制协程行为。([Asymmetric Transfer][1])

---

如果你希望我继续翻译后续文章（如 “理解 promise 类型”）或进一步讲解以上内容，随时告诉我！

[1]: https://lewissbaker.github.io/2017/11/17/understanding-operator-co-await?utm_source=chatgpt.com "C++ Coroutines: Understanding operator co_await"
