
# C++ 协程：理解对称性切换（Symmetric Transfer）

本文发表于 2020 年 5 月 11 日

协程技术规范（Coroutines TS）为我们提供了一种极好的方式，可以像写同步代码一样去编写异步代码。你只需要在合适的位置“撒”上 `co_await`，编译器就会负责在协程挂起时保存状态，并在挂起点之间保持状态，等到操作完成后再恢复协程的执行。

然而，按照最初的规范，Coroutines TS 存在一个很糟糕的限制，如果不小心就会导致 **栈溢出（stack overflow）**。为了避免这种栈溢出，你不得不在 `task<T>` 类型中引入额外的同步开销，以安全地防范这一问题。

幸运的是，2018 年对协程设计做了一处调整，引入了一个名为 **“对称转移”（symmetric transfer）** 的能力，它允许在不消耗额外栈空间的情况下，从一个协程挂起并直接恢复另一个协程。这个能力的加入，消除了 Coroutines TS 中的一个关键限制，让我们能够更简单、更高效地实现异步协程类型，同时不会牺牲防止栈溢出的安全性。

在这篇文章中，我会尝试解释栈溢出问题，以及这个关键的“对称转移”能力是如何让我们解决它的。

---

## 首先介绍一下 task 协程是如何工作的

考虑下面的协程：

```cpp
task foo() {
  co_return;
}

task bar() {
  co_await foo();
}
```

假设我们有一个简单的 `task` 类型，它会在另一个协程等待它（`co_await`）时才会延迟执行（lazy execution）其函数体。这个特定的 `task` 类型不支持返回值。

下面我们来分析，当 `bar()` 执行 `co_await foo()` 时，发生了什么：

1. **`bar()` 调用 `foo()`**
   注意，对于调用方来说，协程只是一个普通函数。

2. **`foo()` 调用过程**

   * 为协程帧分配存储空间（通常是在堆上分配）
   * 将参数复制到协程帧（这里没有参数，所以是空操作）
   * 在协程帧中构造 promise 对象
   * 调用 `promise.get_return_object()` 获取 `foo()` 的返回值。这会生成一个 `task` 对象，并用一个指向刚刚创建的协程帧的 `std::coroutine_handle` 来初始化它。
   * 在初始挂起点（即 `{` 处）挂起协程执行
   * 将 `task` 对象返回给 `bar()`

3. **`bar()` 对返回的 task 进行 `co_await`**

   * `bar()` 协程挂起，然后调用该 task 的 `await_suspend()` 方法，并传入一个指向 `bar()` 协程帧的 `std::coroutine_handle`。
   * `await_suspend()` 方法将 `bar()` 的句柄保存到 `foo()` 的 promise 对象中，然后调用 `foo()` 的句柄 `.resume()` 来恢复 `foo()` 协程执行。

4. **`foo()` 执行**

   * `foo()` 同步执行并运行到结束。

5. **`foo()` 到达最终挂起点**（即 `}`）

   * 在 final suspend 处挂起，然后恢复 promise 中保存的协程句柄，也就是 `bar()` 协程。

6. **`bar()` 恢复执行**

   * 继续执行，直到到达包含 `co_await` 表达式的语句末尾，此时会调用 `foo()` 返回的临时 `task` 对象的析构函数。

7. **`task` 析构**

   * 析构函数会调用 `foo()` 的协程句柄 `.destroy()`，销毁协程帧及其中的 promise 对象和参数副本。

看起来，一个简单的调用也包含了很多步骤。

为了更深入理解，我们来看看在 **没有对称转移支持** 的 Coroutines TS 设计下，一个 `task` 类的简单实现会是什么样子。

---

## `task` 实现大纲

类的轮廓大概如下：

```cpp
class task {
public:
  class promise_type { /* 见下文 */ };

  task(task&& t) noexcept
  : coro_(std::exchange(t.coro_, {}))
  {}

  ~task() {
    if (coro_)
      coro_.destroy();
  }

  class awaiter { /* 见下文 */ };

  awaiter operator co_await() && noexcept;

private:
  explicit task(std::coroutine_handle<promise_type> h) noexcept
  : coro_(h)
  {}

  std::coroutine_handle<promise_type> coro_;
};
```

一个 `task` 对象独占（exclusive ownership）持有一个 `std::coroutine_handle`，它对应着调用协程时创建的协程帧。`task` 是一个 RAII 对象，确保当它销毁时，会调用 `.destroy()` 来释放协程帧。

下面我们再展开 `promise_type` 的实现细节。


---

## 实现 `task::promise_type`

在[上一篇文章](https://lewissbaker.github.io/2018/09/05/understanding-the-promise-type)中，我们已经知道，`promise_type` 成员定义了 **Promise** 对象的类型，这个对象会在协程帧中创建，并且负责控制协程的行为。

首先，我们需要实现 `get_return_object()`，用于在协程被调用时构造要返回的 `task` 对象。
这个方法只需要用新创建的协程帧对应的 `std::coroutine_handle` 来初始化 `task` 即可。

我们可以使用 `std::coroutine_handle::from_promise()` 方法，通过 promise 对象来生成这样的句柄。

```cpp
class task::promise_type {
public:
  task get_return_object() noexcept {
    return task{std::coroutine_handle<promise_type>::from_promise(*this)};
  }
```

接下来，我们希望协程在函数体的起始位置（`{`）处 **初始挂起**，这样当返回的 `task` 被等待（`co_await`）时，我们可以从这个点恢复协程的执行。

采用懒启动（lazy start）的好处有很多：

1. **可以在启动协程之前绑定 continuation**（即后续要恢复的协程的 `std::coroutine_handle`）。这样我们就不需要使用线程同步来处理在启动协程和绑定 continuation 之间可能出现的[[竞争条件]]。
2. **可以让 `task` 析构函数无条件销毁协程帧**——我们不用担心协程是否正在另一个线程执行，因为协程在被等待之前是不会执行的；而一旦协程开始执行，调用方所在的协程会被挂起，因此直到协程执行完毕前都不会去调用 `task` 析构函数。这使得编译器更有机会将协程帧的分配优化为在调用者的栈帧中进行（即 [P0981R0](https://wg21.link/P0981R0) 提到的 **Heap Allocation eLision Optimisation, HALO** 优化）。
3. **提升异常安全性**。如果你没有立刻 `co_await` 返回的 `task`，而是做了其他可能抛出异常的操作，导致栈展开并触发 `task` 析构，此时我们可以安全地销毁协程，因为我们知道它还没有开始执行。这样就避免了陷入尴尬的选择：要么分离执行（可能导致悬空引用），要么在析构中阻塞，要么调用 `std::terminate()`，要么出现未定义行为。我在 [CppCon 2019 结构化并发演讲](https://www.youtube.com/watch?v=1Wy5sq3s2rg) 中对这一点有更详细的说明。

为了让协程在起始位置挂起，我们可以定义 `initial_suspend()` 方法，并返回内置类型 `suspend_always`：

```cpp
  std::suspend_always initial_suspend() noexcept {
    return {};
  }
```

然后，我们需要定义 `return_void()` 方法，当执行 `co_return;` 或者协程执行流到达末尾时会调用它。这个方法实际上不需要做任何事，只是为了告诉编译器在该协程类型中允许使用 `co_return;`。

```cpp
  void return_void() noexcept {}
```

我们还需要实现 `unhandled_exception()` 方法，它会在异常逃出协程体时被调用。
在这里，我们可以直接把 task 协程体视为 `noexcept`，如果发生异常就调用 `std::terminate()`：

```cpp
  void unhandled_exception() noexcept {
    std::terminate();
  }
```

最后，当协程执行到闭合花括号 `}` 时，我们希望协程在 **final-suspend 点** 挂起，然后恢复它的 continuation（即等待当前协程完成的那个协程）。

为了实现这一点，我们需要在 promise 中添加一个成员变量，用来保存 continuation 的 `std::coroutine_handle`。
同时，还需要定义一个 `final_suspend()` 方法，该方法返回一个可等待对象（awaitable），在当前协程挂起后恢复 continuation。

**为什么必须等到挂起后再恢复 continuation？**
[[因为 continuation 可能会立即调用 `task` 析构函数]]，而析构函数会调用 `.destroy()` 来销毁协程帧。`.destroy()` 只能作用在**已挂起**的协程上，所以如果在挂起之前就恢复 continuation，就会触发未定义行为。

编译器会在闭合花括号处自动插入 `co_await promise.final_suspend();` 语句。

需要注意的是，在调用 `final_suspend()` 方法时，协程**还没有**进入挂起状态。只有等到返回的 awaitable 的 `await_suspend()` 方法被调用时，协程才会挂起。

```cpp
  struct final_awaiter {
    bool await_ready() noexcept {
      return false;
    }

    void await_suspend(std::coroutine_handle<promise_type> h) noexcept {
      // 协程现在已经在 final-suspend 点挂起
      // 从 promise 中取出 continuation，并恢复它
      h.promise().continuation.resume();
    }

    void await_resume() noexcept {}
  };

  final_awaiter final_suspend() noexcept {
    return {};
  }

  std::coroutine_handle<> continuation;
};
```

好了，这样我们就完成了 `promise_type` 的实现。
接下来，我们只需要实现 `task::operator co_await()` 这一部分即可。

---

## 实现 `task::operator co_await()`

你可能还记得，在[《Understanding operator co\_await()》](https://lewissbaker.github.io/2017/11/17/understanding-operator-co-await) 一文中提到，当编译器在求值一个 `co_await` 表达式时，如果类型定义了 `operator co_await()`，那么编译器会先调用该运算符，然后要求返回的对象必须定义 `await_ready()`、`await_suspend()` 和 `await_resume()` 这三个方法。

当一个协程等待（`co_await`）一个 `task` 时，我们希望：

1. 等待方协程**总是挂起**；
2. 一旦挂起，就将等待方协程的句柄（`std::coroutine_handle`）存储到即将恢复的协程（也就是 `task` 对应的协程）的 promise 中；
3. 然后调用该 `task` 的 `std::coroutine_handle` 的 `.resume()` 方法，从而开始执行该任务。

因此，实现起来就是下面这样相对直接的代码：

```cpp
class task::awaiter {
public:
  bool await_ready() noexcept {
    return false;
  }

  void await_suspend(std::coroutine_handle<> continuation) noexcept {
    // 将等待方协程的句柄保存到 task 的 promise 中
    // 这样在 final_suspend() 中就可以恢复这个协程
    coro_.promise().continuation = continuation;

    // 然后恢复 task 对应的协程
    // 该协程目前挂起在 initial_suspend（即函数体起始位置 `{`）
    coro_.resume();
  }

  void await_resume() noexcept {}

private:
  explicit awaiter(std::coroutine_handle<task::promise_type> h) noexcept
  : coro_(h)
  {}

  std::coroutine_handle<task::promise_type> coro_;
};

task::awaiter task::operator co_await() && noexcept {
  return awaiter{coro_};
}
```

这样，我们就完成了一个可正常工作的 `task` 类型所需的全部代码。

完整代码可以在 Compiler Explorer 查看：
[https://godbolt.org/z/-Kw6Nf](https://godbolt.org/z/-Kw6Nf)


## 栈溢出问题

上面这种 `task` 实现的限制，会在你在协程中写循环并且在循环体中 `co_await` 可能**同步完成**的任务时出现。

例如：

```cpp
task completes_synchronously() {
  co_return;
}

task loop_synchronously(int count) {
  for (int i = 0; i < count; ++i) {
    co_await completes_synchronously();
  }
}
```

对于前面描述的这种简单 `task` 实现来说，当 `count` 为 10、1000 甚至 100’000 时，`loop_synchronously()` 可能都能正常运行。但总会有一个更大的值，会导致这个协程开始崩溃。

例如，参见：[https://godbolt.org/z/gy5Q8q](https://godbolt.org/z/gy5Q8q)，当 `count` 为 1’000’000 时会崩溃。

造成崩溃的原因是 **栈溢出（stack overflow）**。

要理解为什么这段代码会导致栈溢出，我们需要看看代码运行时到底发生了什么，尤其是栈帧（stack-frame）是如何变化的。

---

当 `loop_synchronously()` 协程第一次开始执行时，是因为某个其他协程 `co_await` 了它返回的 `task`。
这会导致等待方协程挂起，并调用 `task::awaiter::await_suspend()`，而该函数会调用 `resume()` 来恢复 `loop_synchronously()` 的协程句柄。

此时，`loop_synchronously()` 刚启动时的栈/堆布局大致如下：

```
           Stack                                                   Heap
+------------------------------+  <-- top of stack   +--------------------------+
| loop_synchronously$resume    | active coroutine -> | loop_synchronously frame |
+------------------------------+                     | +----------------------+ |
| coroutine_handle::resume     |                     | | task::promise        | |
+------------------------------+                     | | - continuation --.   | |
| task::awaiter::await_suspend |                     | +------------------|---+ |
+------------------------------+                     | ...                |     |
| awaiting_coroutine$resume    |                     +--------------------|-----+
+------------------------------+                                          V
|  ....                        |                     +--------------------------+
+------------------------------+                     | awaiting_coroutine frame |
                                                     |                          |
                                                     +--------------------------+
```

> **注意**：当一个协程函数被编译时，编译器通常会将它拆分成两个部分：
>
> 1. **ramp function**：负责构造协程帧、复制参数、构造 promise 对象并生成返回值；
> 2. **协程主体（coroutine body）**：包含用户编写的协程函数体逻辑。
>
> 我在这里用 `$resume` 后缀表示协程主体部分。
>
> 之后的博客文章会更详细介绍这种拆分。

---

接着，当 `loop_synchronously()` 等待 `completes_synchronously()` 返回的 `task` 时：

1. 当前协程挂起，并调用 `task::awaiter::await_suspend()`；
2. `await_suspend()` 方法调用 `resume()` 来恢复 `completes_synchronously()` 协程。

`completes_synchronously()` 会同步执行到结束，并在最终挂起点（final-suspend）挂起；
然后调用 `task::promise::final_awaiter::await_suspend()`，该方法又会调用 `.resume()` 恢复 `loop_synchronously()` 协程。

---

最终，当 `loop_synchronously()` 恢复执行、还没销毁 `completes_synchronously()` 返回的临时 `task` 时，程序的栈/堆状态大致如下：

```
           Stack                                                   Heap
+-------------------------------+ <-- top of stack
| loop_synchronously$resume     | active coroutine -.
+-------------------------------+                   |
| coroutine_handle::resume      |            .------'
+-------------------------------+            |
| final_awaiter::await_suspend  |            |
+-------------------------------+            |  +--------------------------+ <-.
| completes_synchronously$resume|            |  | completes_synchronously  |   |
+-------------------------------+            |  | frame                    |   |
| coroutine_handle::resume      |            |  +--------------------------+   |
+-------------------------------+            '---.                             |
| task::awaiter::await_suspend  |                V                             |
+-------------------------------+ <-- prev top  +--------------------------+   |
| loop_synchronously$resume     |     of stack  | loop_synchronously frame |   |
+-------------------------------+               | +----------------------+ |   |
| coroutine_handle::resume      |               | | task::promise        | |   |
+-------------------------------+               | | - continuation --.   | |   |
| task::awaiter::await_suspend  |               | +------------------|---+ |   |
+-------------------------------+               | - task temporary --|---------'
| awaiting_coroutine$resume     |               +--------------------|-----+
+-------------------------------+                                    V
|  ....                         |               +--------------------------+
+-------------------------------+               | awaiting_coroutine frame |
                                                |                          |
                                                +--------------------------+
```

---

接下来，程序会调用 `task` 的析构函数，销毁 `completes_synchronously()` 协程帧；
然后 `count` 自增，进入下一次循环，再次创建一个新的 `completes_synchronously()` 协程帧并恢复它。

本质上，这导致 `loop_synchronously()` 和 `completes_synchronously()` **互相递归调用**。
每发生一次这样的调用，就会额外消耗一点栈空间；
当循环次数足够多时，栈空间最终会被耗尽，触发栈溢出，从而导致未定义行为（通常是程序直接崩溃）。

[[非常重要!]]

[[gemini的解释]]

---

在这种构造下，在协程中写循环时很容易无意间写出**无界递归**，而且从代码表面上看完全不像递归。

那么，在最初的 Coroutines TS 设计下，这个问题的解决方案会是什么样呢？

## 协程 TS 方案

[[理解 !!!!]]
好，那么我们该如何避免这种**无限递归**的问题呢？

在上面的实现中，我们使用了 `await_suspend()` 返回 **`void`** 的版本。而在 Coroutines TS 里，还存在一个返回 **`bool`** 的 `await_suspend()` 版本——

* 如果返回 `true`，表示协程被挂起，执行会回到调用 `resume()` 的地方；
* 如果返回 `false`，表示协程会**立即继续执行**，而且不会再额外消耗栈空间。

因此，要避免无限的相互递归，我们的目标是在 **`task::awaiter::await_suspend()`** 中，如果任务是**同步完成**的，就返回 `false`，让当前协程直接继续执行，而不是用 `std::coroutine_handle::resume()` 再去递归恢复它。

为了实现一个通用的解决方案，这里有两个关键步骤：

---

### 1. 在 `task::awaiter::await_suspend()` 中

* 先通过 `.resume()` 启动协程执行；
* 当 `.resume()` 返回时，检查协程是否已经执行完成：

  * 如果完成，则返回 `false`，让等待它的协程**立即恢复**；
  * 如果没有完成，则返回 `true`，表示应当回到 `resume()` 的调用者。

---

### 2. 在 `task::promise_type::final_awaiter::await_suspend()` 中

* 这个方法会在协程执行完成时运行。
* 我们需要判断等待它的协程是否（或将会）在 `task::awaiter::await_suspend()` 中返回 `true`：

  * 如果返回 `true`，则需要在这里调用 `.resume()` 恢复等待方；
  * 如果不会返回 `true`，则避免恢复，让 `await_suspend()` 返回 `false` 即可。

---

不过，这里有个额外的复杂情况：
协程可能会**在当前线程启动执行**，然后挂起，再在**另一个线程恢复并完成**，而这一切可能发生在 `.resume()` 调用还没返回之前。
因此，我们需要解决 **步骤 1 和步骤 2 可能并发发生的竞争问题**。

解决办法是使用一个 **`std::atomic`** 值来决定谁赢得这场“比赛”。

---

### 代码实现

```cpp
class task::promise_type {
  ...
  std::coroutine_handle<> continuation;
  std::atomic<bool> ready = false;
};

bool task::awaiter::await_suspend(
    std::coroutine_handle<> continuation) noexcept {
  promise_type& promise = coro_.promise();
  promise.continuation = continuation;
  coro_.resume();
  return !promise.ready.exchange(true, std::memory_order_acq_rel);
}

void task::promise_type::final_awaiter::await_suspend(
    std::coroutine_handle<promise_type> h) noexcept {
  promise_type& promise = h.promise();
  if (promise.ready.exchange(true, std::memory_order_acq_rel)) {
    // 协程不是同步完成的，这里恢复等待方
    promise.continuation.resume();
  }
}
```

在 [Compiler Explorer 示例](https://godbolt.org/z/7fm8Za) 中可以看到，
当执行 `count == 1'000'000` 的情况时，它再也不会崩溃了。

---

这其实就是 `cppcoro::task<T>` [源码实现](https://github.com/lewissbaker/cppcoro/blob/master/include/cppcoro/task.hpp) 采用的办法（在某些平台上现在依然如此），用来避免**无限递归问题**，而且实际效果一直很不错。

🎉 解决了！好像可以发版本了，对吧？嗯……对吧？

## 问题

虽然上面的解决方案确实解决了递归问题，但它也有几个缺点。

首先，它引入了对 `std::atomic` 操作的需求，而原子操作的开销可能相当大。
当挂起等待的协程时，调用方会进行一次原子交换；当被调用方运行到完成时，也会进行一次原子交换。
如果你的应用程序始终只在单线程中运行，那么即使根本不需要线程同步，你也仍然要为这些原子操作付出性能代价。

其次，它引入了额外的分支判断。
一个分支在调用方，用来决定是挂起还是立即恢复协程；另一个分支在被调用方，用来决定是恢复继续执行还是挂起。

需要注意的是，这些额外分支的开销（甚至包括原子操作的开销）通常会被协程中业务逻辑的执行时间所掩盖。
但是，协程一直被宣传为零开销抽象（zero-cost abstraction），甚至有人会利用协程暂停函数执行来避免等待 L1 缓存未命中（可参考 Gor 在 [CppCon 的 nanocoroutines 演讲](https://www.youtube.com/watch?v=j9tlJAqMV7U) 了解更多细节）。

第三，也是可能最重要的一点，它会引入**等待协程恢复时执行上下文的不确定性**。

假设我有如下代码：

```cpp
cppcoro::static_thread_pool tp;

task foo()
{
  std::cout << "foo1 " << std::this_thread::get_id() << "\n";
  // 挂起协程并重新调度到线程池线程上
  co_await tp.schedule();
  std::cout << "foo2 " << std::this_thread::get_id() << "\n";
}

task bar()
{
  std::cout << "bar1 " << std::this_thread::get_id() << "\n";
  co_await foo();
  std::cout << "bar2" << std::this_thread::get_id() << "\n";
}
```

在原始实现中，我们可以保证 `co_await foo()` 之后的代码，会**直接在 `foo()` 完成的同一线程内内联执行**。

例如，一种可能的输出是：

```
bar1 1234
foo1 1234
foo2 3456
bar2 3456
```

然而，在引入原子操作的修改版中，`foo()` 完成和 `bar()` 挂起之间可能会发生竞争，这意味着 `co_await foo()` 之后的代码有可能会在 `bar()` 最初运行的线程上继续执行。

例如，下面这样的输出就有可能发生：

```
bar1 1234
foo1 1234
foo2 3456
bar2 1234
```

对于很多使用场景来说，这种行为差异可能无关紧要。
但是，对于**本身就是为了切换执行上下文**的算法来说，这就可能是个严重问题。

比如，`via()` 算法会等待一个 Awaitable 完成，然后保证接下来的执行发生在指定调度器的执行上下文中。
下面是一个简化版的 `via()` 算法：

```cpp
template<typename Awaitable, typename Scheduler>
task<await_result_t<Awaitable>> via(Awaitable a, Scheduler s)
{
  auto result = co_await std::move(a);
  co_await s.schedule();
  co_return result;
}

task<T> get_value();
void consume(const T&);

task<void> consumer(static_thread_pool::scheduler s)
{
  T result = co_await via(get_value(), s);
  consume(result);
}
```

在原始版本中，`consume()` 总是保证在调度器 `s` 所关联的线程池中执行。
然而，在使用原子操作的修改版中，`consume()` 有可能会在 `s` 所关联的线程池线程中执行，也有可能会在 `consumer()` 协程最初运行的线程中执行。

所以问题来了：
**我们该如何在不引入原子操作开销、额外分支判断、以及执行上下文不确定性的情况下，解决栈溢出问题？**

## 进入 “对称切换（symmetric transfer）”！

[[进入“对称切换"]]
Gor Nishanov 在 2018 年发布的论文 [P0913R0](https://wg21.link/P0913R0) 《Add symmetric coroutine control transfer》（为协程添加对称控制切换）提出了一个解决方案，允许一个协程在挂起时对称地切换到另一个协程，并且**不会**额外消耗栈空间。

这篇论文提出了两个关键改动：

* 允许 `await_suspend()` 返回一个 `std::coroutine_handle<T>`，用来表示执行应该**对称切换**到返回的协程句柄所指向的协程。
* 添加一个 `std::experimental::noop_coroutine()` 函数，该函数返回一个特殊的 `std::coroutine_handle`，可以从 `await_suspend()` 返回它，以挂起当前协程并直接让 `.resume()` 调用返回，而不是切换到另一个协程。

那么，“对称切换”到底是什么意思呢？

当你通过调用某个 `std::coroutine_handle` 的 `.resume()` 来恢复一个协程时，**调用 `.resume()` 的那个函数会依然处于活动栈帧中**，同时被恢复的协程开始执行。当这个协程下一次挂起时，如果 `await_suspend()` 返回 `void`（无条件挂起）或 `true`（条件挂起），那么这次 `.resume()` 调用就会返回。

这可以看作是\*\*“非对称切换”（asymmetric transfer）\*\*——它和普通函数调用的行为一样。调用 `.resume()` 的地方可以是任何函数（可能是协程，也可能不是）。当被恢复的协程挂起并且 `await_suspend()` 返回 `true` 或 `void` 时，执行流程就会回到 `.resume()` 的调用点。

**每次调用 `.resume()` 恢复协程时，都会为该协程的执行创建一个新的栈帧**。

而在\*\*“对称切换”**中，我们只是简单地挂起一个协程，然后恢复另一个协程。两者之间没有隐式的调用者 / 被调用者关系——当一个协程挂起时，它可以切换到**任何\*\*已挂起的协程（包括它自己），并不需要在下次挂起或完成时切回到上一个协程。

---

我们来看一下，当 `awaiter` 使用了对称切换时，编译器是如何将 `co_await` 表达式转化的：

```cpp
{
  decltype(auto) value = <expr>;
  decltype(auto) awaitable =
      get_awaitable(promise, static_cast<decltype(value)&&>(value));
  decltype(auto) awaiter =
      get_awaiter(static_cast<decltype(awaitable)&&>(awaitable));
  if (!awaiter.await_ready())
  {
    using handle_t = std::coroutine_handle<P>;

    //<suspend-coroutine>

    auto h = awaiter.await_suspend(handle_t::from_promise(p));
    h.resume();
    //<return-to-caller-or-resumer>
    
    //<resume-point>
  }

  return awaiter.await_resume();
}
```

---

关键的不同之处在于这里：

```cpp
auto h = awaiter.await_suspend(handle_t::from_promise(p));
h.resume();
//<return-to-caller-or-resumer>
```

在协程状态机被降级（lowering）之后（这个是另一篇文章的主题），`<return-to-caller-or-resumer>` 基本上会变成一个 `return;` 语句——这会让上一次调用 `.resume()` 恢复该协程的地方**直接返回**到它的调用者。

这意味着我们出现了这样一种情况：**在一个函数体（本身就是 `std::coroutine_handle::resume()` 的实现）中调用另一个签名相同的 `std::coroutine_handle::resume()`，并且紧接着执行 `return;`**。

---

有些编译器在开启优化时，会将这种“在返回前调用另一个函数”的模式优化为**尾调用（tail-call）**，前提是满足一定条件。

而尾调用优化正是我们想要的，这样就能避免之前遇到的**栈溢出**问题。但我们不想依赖编译器优化器的“心情”来决定是否进行尾调用，而是希望即使在**未开启优化**时也能保证尾调用转换。

不过，在继续之前，我们先来仔细看看什么是**尾调用（tail-call）**。


### 尾调用（Tail-calls）

[[详细解释！]]

尾调用是指：在调用另一个函数前，当前函数的栈帧（stack-frame）会先被弹出（pop），并且当前函数的返回地址直接变为被调用函数的返回地址——也就是说，被调用函数会直接返回到当前函数的调用者那里。

在 X86/X64 架构上，这通常意味着编译器会生成这样的代码：先弹出当前栈帧，然后用 `jmp` 指令跳转到被调用函数的入口点，而不是用 `call` 指令调用后再在返回时弹出当前栈帧。

不过，这种优化通常只在一些受限的情况下才能做。

具体来说，需要满足以下条件：

* **调用约定**（calling convention）支持尾调用，并且调用方和被调用方的调用约定一致；
* **返回类型一致**；
* **没有需要在调用后销毁的非平凡析构对象**（non-trivial destructors）；
* 调用不在 `try/catch` 块内部。

`symmetric-transfer` 形式的 `co_await`（对称转移）在设计时就考虑到了让协程满足这些要求。我们逐个来看。

---

**调用约定**
当编译器将一个协程转换成机器码时，实际上会把它拆成两部分：

1. **ramp**（坡道函数）：分配并初始化协程帧（coroutine frame）；
2. **body**（主体函数）：包含用户编写的协程体状态机。

协程的函数签名（以及用户指定的调用约定）只影响 ramp 部分；而 body 部分完全由编译器控制，并且不会被用户代码直接调用——它只会被 ramp 函数或者 `std::coroutine_handle::resume()` 调用。

由于 body 部分的调用约定对用户不可见，编译器就可以自由选择支持尾调用的调用约定，并且所有协程主体都会统一使用这种约定。

---

**返回类型一致**
源协程和目标协程的 `.resume()` 方法返回类型都是 `void`，所以这个条件天然满足。

---

**没有非平凡析构对象**
尾调用要求在调用目标函数前释放当前栈帧，这意味着栈上所有对象的生命周期必须在调用前结束。

通常这会成为问题，因为栈上可能有带非平凡析构的对象，它们生命周期尚未结束。

但是，协程在挂起（suspend）时不会退出任何作用域。它的做法是：**所有生命周期跨越挂起点的对象都会放进协程帧中，而不是放在栈上**。

那些生命周期不跨越挂起点的局部变量可以放在栈上，但它们的生命周期会在协程下次挂起前结束，因此在尾调用前已经析构完毕。

所以，这里不会有栈上对象需要在尾调用返回后再析构的问题。

[[非平凡析构函数]]

---

**调用不在 try/catch 块内部**
这个比较棘手，因为每个协程的用户代码外面都有一个**隐式的** `try/catch` 块。

根据标准，协程的结构是这样的：

```cpp
{
  promise_type promise;
  co_await promise.initial_suspend();
  try { F; }
  catch (...) { promise.unhandled_exception(); }
final_suspend:
  co_await promise.final_suspend();
}
```

其中 `F` 是用户编写的协程体。

所以，除 `initial_suspend` 和 `final_suspend` 外的所有 `co_await` 表达式都在这个隐式的 try 块里。

不过，编译器实现会绕过这个问题——它会让 `.resume()` 的调用**在 try 块外部执行**。

> 需要注意的是，当前 C++ 规范并没有明确要求实现这样做，这只是一个非规范性的说明（note）暗示可能需要这样做。未来可能会修订标准来明确这一点。

---

综上，协程在执行 symmetric-transfer（对称转移）时，一般都能满足尾调用的所有要求。编译器会保证这是一个尾调用，不论是否开启优化选项。

这意味着，只要用返回 `std::coroutine_handle` 的 `await_suspend()` 版本，我们就可以挂起当前协程并切换到另一个协程执行，而不会额外消耗栈空间。

这样我们就能写出互相递归恢复（resume）的协程，且递归深度不受栈限制，不会发生栈溢出。

这正是修复 `task` 实现所需要的特性。

## `task` 再探

现在我们已经掌握了新的“对称切换”（symmetric transfer）能力，让我们回头修正一下 `task` 类型的实现。

为此，我们需要修改实现中的两个 `await_suspend()` 方法：

* 第一处修改：当我们 `await` 这个 `task` 时，需要通过**对称切换**来恢复（resume）`task` 协程。
* 第二处修改：当 `task` 协程执行完成时，需要通过**对称切换**来恢复等待它的协程。

---

### 1. 修改 `await` 方向

原来的 `task::awaiter` 方法是这样的：

```cpp
void task::awaiter::await_suspend(
    std::coroutine_handle<> continuation) noexcept {
  // 将 continuation 存储到 task 的 promise 中，
  // 这样 final_suspend() 就能在 task 完成时恢复这个协程。
  coro_.promise().continuation = continuation;

  // 然后恢复 task 协程，它此时正挂起在初始挂起点（也就是花括号的起始处）。
  coro_.resume();
}
```

修改为：

```cpp
std::coroutine_handle<> task::awaiter::await_suspend(
    std::coroutine_handle<> continuation) noexcept {
  // 将 continuation 存储到 task 的 promise 中，
  // 这样 final_suspend() 就能在 task 完成时恢复这个协程。
  coro_.promise().continuation = continuation;

  // 通过返回协程句柄的方式，直接进行尾恢复（tail resume），
  // 恢复 task 协程，它此时正挂起在初始挂起点（也就是花括号的起始处）。
  return coro_;
}
```

---

### 2. 修改返回路径

原来的 `task::promise_type::final_awaiter` 方法是这样的：

```cpp
void task::promise_type::final_awaiter::await_suspend(
    std::coroutine_handle<promise_type> h) noexcept {
  // 协程现在挂起在 final-suspend 点。
  // 从 promise 中取出 continuation 并恢复它。
  h.promise().continuation.resume();
}
```

修改为：

```cpp
std::coroutine_handle<> task::promise_type::final_awaiter::await_suspend(
    std::coroutine_handle<promise_type> h) noexcept {
  // 协程现在挂起在 final-suspend 点。
  // 从 promise 中取出 continuation，并通过对称切换恢复它。
  return h.promise().continuation;
}
```

---

这样，我们就得到了一个 `task` 实现：

* 不会再出现 `void` 返回的 `await_suspend` 版本的**栈溢出问题**
* 也不会出现 `bool` 返回的 `await_suspend` 版本的**非确定性恢复上下文问题**

### 可视化调用栈

让我们回到最初的示例：

```cpp
task completes_synchronously() {
  co_return;
}

task loop_synchronously(int count) {
  for (int i = 0; i < count; ++i) {
    co_await completes_synchronously();
  }
}
```

当 `loop_synchronously()` 协程第一次开始执行时，是因为某个其他协程 `co_await` 了 `loop_synchronously()` 返回的 `task`。
这个调用过程是通过**对称转移**（symmetric transfer）从另一个协程启动的，而那个协程本身又是通过 `std::coroutine_handle::resume()` 恢复的。

因此，当 `loop_synchronously()` 刚开始执行时，调用栈大致如下：

```
           Stack                                                Heap
+---------------------------+  <-- top of stack   +--------------------------+
| loop_synchronously$resume | active coroutine -> | loop_synchronously frame |
+---------------------------+                     | +----------------------+ |
| coroutine_handle::resume  |                     | | task::promise        | |
+---------------------------+                     | | - continuation --.   | |
|     ...                   |                     | +------------------|---+ |
+---------------------------+                     | ...                |     |
                                                  +--------------------|-----+
                                                                       V
                                                  +--------------------------+
                                                  | awaiting_coroutine frame |
                                                  |                          |
                                                  +--------------------------+
```


---

现在，当它执行 `co_await completes_synchronously()` 时，会进行一次**对称转移**到 `completes_synchronously` 协程。

执行过程如下：

1. 调用 `task::operator co_await()`，返回一个 `task::awaiter` 对象；
2. 挂起当前协程，调用 `task::awaiter::await_suspend()`；
3. `await_suspend()` 返回 `completes_synchronously` 协程的 `coroutine_handle`；
4. 执行一次**尾调用**（tail-call）/ 跳转到 `completes_synchronously` 协程，这会先弹出 `loop_synchronously` 的栈帧，再激活 `completes_synchronously` 的帧。

此时，`completes_synchronously` 刚恢复时，调用栈如下：


```
              Stack                                          Heap
                                            .-> +--------------------------+ <-.
                                            |   | completes_synchronously  |   |
                                            |   | frame                    |   |
                                            |   | +----------------------+ |   |
                                            |   | | task::promise        | |   |
                                            |   | | - continuation --.   | |   |
                                            |   | +------------------|---+ |   |
                                            `-, +--------------------|-----+   |
                                              |                      V         |
+-------------------------------+ <-- top of  | +--------------------------+   |
| completes_synchronously$resume|     stack   | | loop_synchronously frame |   |
+-------------------------------+ active -----' | +----------------------+ |   |
| coroutine_handle::resume      | coroutine     | | task::promise        | |   |
+-------------------------------+               | | - continuation --.   | |   |
|     ...                       |               | +------------------|---+ |   |
+-------------------------------+               | task temporary     |     |   |
                                                | - coro_       -----|---------`
                                                +--------------------|-----+
                                                                     V
                                                +--------------------------+
                                                | awaiting_coroutine frame |
                                                |                          |
                                                +--------------------------+
```

> 注意：栈帧数量并没有增加。

---

当 `completes_synchronously` 执行到结尾（`}`）时，会进入 `co_await promise.final_suspend()`。

此时：

1. 挂起 `completes_synchronously`；
2. 调用 `final_awaiter::await_suspend()`，它返回**延续协程**（continuation）的 `std::coroutine_handle`（也就是 `loop_synchronously` 的句柄）；
3. 进行**对称转移**到 `loop_synchronously` 协程。

---

刚恢复 `loop_synchronously` 时，调用栈如下：

```
           Stack                                                   Heap
                                                   +--------------------------+ <-.
                                                   | completes_synchronously  |   |
                                                   | frame                    |   |
                                                   | +----------------------+ |   |
                                                   | | task::promise        | |   |
                                                   | | - continuation --.   | |   |
                                                   | +------------------|---+ |   |
                                                   +--------------------|-----+   |
                                                                        V         |
+----------------------------+  <-- top of stack   +--------------------------+   |
| loop_synchronously$resume  | active coroutine -> | loop_synchronously frame |   |
+----------------------------+                     | +----------------------+ |   |
| coroutine_handle::resume() |                     | | task::promise        | |   |
+----------------------------+                     | | - continuation --.   | |   |
|     ...                    |                     | +------------------|---+ |   |
+----------------------------+                     | task temporary     |     |   |
                                                   | - coro_       -----|---------`
                                                   +--------------------|-----+
                                                                        V
                                                   +--------------------------+
                                                   | awaiting_coroutine frame |
                                                   |                          |
                                                   +--------------------------+
```


接下来，`loop_synchronously` 会执行 `completes_synchronously()` 调用表达式末尾的分号处的临时 `task` 析构函数，这会销毁 `completes_synchronously` 的协程帧，释放内存。于是变成：

```
           Stack                                                   Heap
+---------------------------+  <-- top of stack   +--------------------------+
| loop_synchronously$resume | active coroutine -> | loop_synchronously frame |
+---------------------------+                     | +----------------------+ |
| coroutine_handle::resume  |                     | | task::promise        | |
+---------------------------+                     | | - continuation --.   | |
|     ...                   |                     | +------------------|---+ |
+---------------------------+                     | ...                |     |
                                                  +--------------------|-----+
                                                                       V
                                                  +--------------------------+
                                                  | awaiting_coroutine frame |
                                                  |                          |
                                                  +--------------------------+
```

---

我们又回到执行 `loop_synchronously`，栈帧和协程帧数量与开始时相同。
因此，无论循环多少次，都只会使用**常量空间**，不会发生栈膨胀。

完整的支持对称转移版本 `task` 实现可见：[https://godbolt.org/z/9baieF](https://godbolt.org/z/9baieF)

## 对称传输作为 `await_suspend` 的通用形式

现在我们看到对称传输形式的 `awaitable` 概念的强大和重要性，我想向你展示，这种形式实际上是通用的形式，理论上可以取代 `void` 和 `bool` 返回形式的 `await_suspend()`。

但首先我们需要看看提案 [P0913R0](https://wg21.link/P0913R0) 中添加到协程设计中的另一部分：`std::noop_coroutine()`。

### 终止递归

在协程的对称传输形式中，每次协程挂起时，都会对另一个协程进行对称恢复。这在我们有另一个协程需要恢复时非常好，但有时我们没有另一个协程需要执行，只是需要挂起并让执行返回到 `std::coroutine_handle::resume()` 的调用者。

`void` 返回形式和 `bool` 返回形式的 `await_suspend()` 都允许协程挂起并从 `std::coroutine_handle::resume()` 返回。那么，如何用对称传输形式来做这个呢？

答案是使用一个特殊的内置 `std::coroutine_handle`，它叫做“noop 协程句柄”，可以通过函数 `std::noop_coroutine()` 来获得。

“noop 协程句柄”之所以这样命名，是因为它的 `.resume()` 实现只是立即返回。也就是说，恢复协程时不会做任何操作。通常，它的实现只包含一条 `ret` 指令。

如果 `await_suspend()` 方法返回 `std::noop_coroutine()` 句柄，那么它就不会把执行转移到下一个协程，而是将执行转回到 `std::coroutine_handle::resume()` 的调用者。

### 表示其他形式的 `await_suspend()`

有了这些信息，我们现在可以展示如何使用对称传输形式来表示其他形式的 `await_suspend()`。

#### `void` 返回形式

```cpp
void my_awaiter::await_suspend(std::coroutine_handle<> h) {
  this->coro = h;
  enqueue(this);
}
```

也可以使用 `bool` 返回形式来写：

```cpp
bool my_awaiter::await_suspend(std::coroutine_handle<> h) {
  this->coro = h;
  enqueue(this);
  return true;
}
```

并且可以使用对称传输形式来写：

```cpp
std::noop_coroutine_handle my_awaiter::await_suspend(
    std::coroutine_handle<> h) {
  this->coro = h;
  enqueue(this);
  return std::noop_coroutine();
}
```

#### `bool` 返回形式

```cpp
bool my_awaiter::await_suspend(std::coroutine_handle<> h) {
  this->coro = h;
  if (try_start(this)) {
    // 操作将异步完成。
    // 返回 true 将执行转移到 coroutine_handle::resume() 的调用者。
	// coroutine_hanldle::resume()
    return true;
  }

  // 操作已同步完成。
  // 返回 false 将立即恢复当前协程。
  return false;
}
```

也可以使用对称传输形式来写：

```cpp
std::coroutine_handle<> my_awaiter::await_suspend(std::coroutine_handle<> h) {
  this->coro = h;
  if (try_start(this)) {
    // 操作将异步完成。
    // 返回 std::noop_coroutine() 将执行转移到 coroutine_handle::resume() 的调用者。
	// coroutine_handle::resume()
    return std::noop_coroutine();
  }

  // 操作已同步完成。
  // 返回当前协程的句柄将立即恢复当前协程。
  // the current coroutine
  return h;
}
```

### 为什么有这三种形式？

那么，既然我们有了对称传输形式的 `await_suspend()`，为什么还需要 `void` 和 `bool` 返回形式呢？

原因部分是历史原因，部分是实用性考虑，部分是性能方面的原因。

`void` 返回形式实际上完全可以通过在 `await_suspend()` 中返回 `std::noop_coroutine_handle` 来替代，因为这会向编译器发出等效的信号，表示协程无条件地将执行转移到 `std::coroutine_handle::resume()` 的调用者。

保留 `void` 返回形式的原因，个人认为，部分是因为它在引入对称传输形式之前已经被广泛使用，部分是因为 `void` 形式在无条件挂起的情况下导致更少的代码/输入。

然而，`bool` 返回形式，在某些情况下，相较于对称传输形式，可以在优化方面略微有优势。

考虑以下情况：我们有一个 `bool` 返回形式的 `await_suspend()` 方法，它定义在另一个翻译单元中。在这种情况下，编译器可以在等待协程中生成代码，挂起当前协程，然后在调用 `await_suspend()` 返回后，条件性地恢复它，只需要执行下一块代码。如果 `await_suspend()` 返回 `false`，它知道下一步该执行什么代码。

对于对称传输形式，我们仍然需要表示相同的结果：要么返回到调用者/恢复，要么恢复当前协程。我们需要返回 `std::noop_coroutine()` 或当前协程的句柄，而不是返回 `true` 或 `false`。我们可以将这两个句柄强制转换为 `std::coroutine_handle<void>` 类型并返回它。

然而，现在由于 `await_suspend()` 方法定义在另一个翻译单元中，编译器无法看到返回的句柄引用的是哪个协程，因此当它恢复协程时，可能需要执行一些更昂贵的间接调用，可能还需要一些分支操作来恢复协程，而 `bool` 返回形式则只需要一个分支。

现在，可能我们可以通过某种方式使对称传输版本获得与 `bool` 返回形式相当的性能。例如，我们可以编写代码，使得 `await_suspend()` 在内联函数中定义，但调用一个在外部翻译单元中定义的 `bool` 返回形式的方法，然后有条件地返回适当的句柄。

例如：

```cpp
struct my_awaiter {
  bool await_ready();

  // 理论上，编译器应该能够将此优化为与 bool 返回形式相同，
  // 但目前尚未进行这种优化。
  std::coroutine_handle<> await_suspend(std::coroutine_handle<> h) {
    if (try_start(h)) {
      return std::noop_coroutine();
    } else {
      return h;
    }
  }

  void await_resume();

private:
  // 该方法在外部翻译单元中定义。
  bool try_start(std::coroutine_handle<> h);
}
```

然而，目前的编译器（例如 Clang 10）尚不能将此优化为与等效的 `bool` 返回形式一样高效的代码。话虽如此，除非你在一个非常紧密的循环中等待这个，否则你可能不会注意到差异。

因此，目前的一般规则是：

* 如果你需要无条件地返回到 `.resume()` 调用者，使用 `void` 返回形式。
* 如果你需要有条件地返回到 `.resume()` 调用者或恢复当前协程，使用 `bool` 返回形式。
* 如果你需要恢复另一个协程，使用对称传输形式。

## 总结

C++20 中新增的对称传输功能使得编写互相递归恢复的协程变得更加容易，而无需担心堆栈溢出。这一功能是实现高效且安全的异步协程类型（如本文中展示的 `task` 类型）的关键。

这篇关于对称传输的文章比预期的要长很多。如果你坚持看到这里，感谢你的耐心！希望你觉得这篇文章有用。

在下一篇文章中，我将深入探讨编译器如何将协程函数转化为状态机。

## 感谢

感谢 Eric Niebler 和 Corentin Jabot 对本文草稿提供的反馈。
