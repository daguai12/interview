好的，我会帮你把你提供的这一部分内容完整翻译成中文，保留标题结构和代码原样。

---

* [引言](#introduction)
* [设定场景](#setting-the-scene)
* [定义 `task` 类型](#defining-the-task-type)
* [步骤 1：确定 promise 类型](#step-1-determining-the-promise-type)
* [步骤 2：创建协程状态](#step-2-creating-the-coroutine-state)
* [步骤 3：调用 `get_return_object()`](#step-3-call-get_return_object)
* [步骤 4：初始挂起点](#step-4-the-initial-suspend-point)
* [步骤 5：记录挂起点](#step-5-recording-the-suspend-point)
* [步骤 6：实现 `coroutine_handle::resume()` 和 `coroutine_handle::destroy()`](#step-6-implementing-coroutine_handleresume-and-coroutine_handledestroy)
* [步骤 7：实现 `coroutine_handle<Promise>::promise()` 和 `from_promise()`](#step-7-implementing-coroutine_handlepromisepromise-and-from_promise)
* [步骤 8：协程体的开端](#step-8-the-beginnings-of-the-coroutine-body)
* [步骤 9：降级 `co_await` 表达式](#step-9-lowering-the-co_await-expression)
* [步骤 10：实现 `unhandled_exception()`](#step-10-implementing-unhandled_exception)
* [步骤 11：实现 `co_return`](#step-11-implementing-co_return)
* [步骤 12：实现 `final_suspend()`](#step-12-implementing-final_suspend)
* [步骤 13：实现对称传递（symmetric-transfer）与空操作协程（noop-coroutine）](#step-13-implementing-symmetric-transfer-and-the-noop-coroutine)
* [最后一件事](#one-last-thing)
* [将一切联系起来](#tying-it-all-together)

---

## 引言

本系列关于“理解 C++ 协程”的前几篇博客，介绍了编译器在处理协程以及它的 `co_await`、`co_yield` 和 `co_return` 表达式时所进行的不同种类的转换。这些文章描述了编译器如何将每种表达式“降级”（lowering）为对用户自定义类型上各种自定义点/方法的调用。

1. [协程理论（Coroutine Theory）](https://lewissbaker.github.io/2017/09/25/coroutine-theory)
2. [C++ 协程：理解 `operator co_await`](https://lewissbaker.github.io/2017/11/17/understanding-operator-co-await)
3. [C++ 协程：理解 promise 类型](https://lewissbaker.github.io/2018/09/05/understanding-the-promise-type)
4. [C++ 协程：理解对称传递（Symmetric Transfer）](https://lewissbaker.github.io/2020/05/11/understanding_symmetric_transfer)

不过，这些描述中有一个部分可能会让你觉得意犹未尽。它们在“挂起点”（suspend-point）这个概念上都略过不谈，只是笼统地说“协程在这里挂起”以及“协程在这里恢复”，但并没有真正详细说明这到底意味着什么，或者编译器可能是如何实现它的。

在这篇文章中，我将深入一点，把前面几篇文章中的所有概念组合在一起。我会通过把一个协程“降级”成等价的、没有协程关键字的命令式 C++ 代码，来展示当协程到达挂起点时会发生什么。

需要注意的是，我不会描述某个特定编译器是如何将协程降级成机器码的（编译器在这方面还有额外的优化手段），而是展示一种**可能的**、可移植的 C++ 降级实现方式。

⚠️ 警告：这将是一次相当深入的探讨！

---

## 设定场景

首先，我们假设有一个基本的 `task` 类型，它既是一个可等待对象（awaitable），也是一个协程返回类型。为了简单起见，我们假设这种协程类型允许异步地产生一个 `int` 类型的结果。

在这篇文章中，我们将一步步演示如何将下面这个协程函数降级为不包含 `co_await`、`co_return` 等协程关键字的 C++ 代码，以便更好地理解这意味着什么。

```cpp
// 另一个函数的前向声明。它的具体实现不重要。
task f(int x);

// 一个简单的协程，我们将把它转换成非协程 C++ 代码
task g(int x) {
    int fx = co_await f(x);
    co_return fx * fx;
}
```

---

## 定义 `task` 类型

首先，我们声明一下接下来要使用的 `task` 类。

为了理解协程是如何被降级的，我们不需要知道这个类型中方法的具体实现。降级过程只会在相应位置插入对它们的调用。

这些方法的实现并不复杂，我会把它作为留给读者的练习，作为对前几篇文章的复习。

```cpp
class task {
public:
    struct awaiter;

    class promise_type {
    public:
        promise_type() noexcept;
        ~promise_type();

        struct final_awaiter {
            bool await_ready() noexcept;
            std::coroutine_handle<> await_suspend(
                std::coroutine_handle<promise_type> h) noexcept;
            void await_resume() noexcept;
        };

        task get_return_object() noexcept;
        std::suspend_always initial_suspend() noexcept;
        final_awaiter final_suspend() noexcept;
        void unhandled_exception() noexcept;
        void return_value(int result) noexcept;

    private:
        friend task::awaiter;
        std::coroutine_handle<> continuation_;
        std::variant<std::monostate, int, std::exception_ptr> result_;
    };

    task(task&& t) noexcept;
    ~task();
    task& operator=(task&& t) noexcept;

    struct awaiter {
        explicit awaiter(std::coroutine_handle<promise_type> h) noexcept;
        bool await_ready() noexcept;
        std::coroutine_handle<promise_type> await_suspend(
            std::coroutine_handle<> h) noexcept;
        int await_resume();
    private:
        std::coroutine_handle<promise_type> coro_;
    };

    awaiter operator co_await() && noexcept;

private:
    explicit task(std::coroutine_handle<promise_type> h) noexcept;

    std::coroutine_handle<promise_type> coro_;
};
```

这个 `task` 类型的结构，应该对读过 [C++ 协程：理解对称传递（Symmetric Transfer）](https://lewissbaker.github.io/2020/05/11/understanding_symmetric_transfer) 那篇文章的读者来说很熟悉。

---

## 步骤 1：确定 `promise` 类型

```cpp
task g(int x) {
    int fx = co_await f(x);
    co_return fx * fx;
}
```

当编译器看到这个函数中包含三个协程关键字之一（`co_await`、`co_yield` 或 `co_return`）时，就会开始协程的转换过程。

这里的第一步就是确定该协程要使用的 `promise_type` 类型。

这个类型是通过将返回类型和参数类型代入 `std::coroutine_traits` 模板的模板参数来决定的。

例如，对于我们的函数 `g`，它的返回类型是 `task`，并且有一个类型为 `int` 的参数，编译器会用以下方式查找：

```cpp
std::coroutine_traits<task, int>::promise_type
```

我们先定义一个别名，方便后续引用这个类型：

```cpp
using __g_promise_t = std::coroutine_traits<task, int>::promise_type;
```

**注意**：这里我使用了前导的双下划线来表示**由编译器生成的内部符号**。这类符号是实现保留的，不应该在你自己的代码中使用。

由于我们没有特化 `std::coroutine_traits`，因此会实例化它的主模板，而主模板只是简单地将 `promise_type` 定义为返回类型中嵌套的 `promise_type`。
也就是说，在我们的例子中，它会解析为 `task::promise_type`。

---

## 步骤 2：创建协程状态（coroutine state）

一个协程函数在挂起时，需要保存协程的状态、参数以及局部变量，以便在后续恢复执行时这些内容依然可用。

这个状态，在 C++ 标准中被称为 **协程状态（coroutine state）**，通常是分配在堆上的。

我们先为协程 `g` 定义一个表示协程状态的结构体。

目前我们还不知道这个类型的具体内容，所以先定义一个空的：

```cpp
struct __g_state {
  // to be filled out
};
```

协程状态通常包含以下几类信息：

* `promise` 对象
* 函数参数的副本
* 协程当前挂起点的信息，以及如何恢复/销毁协程
* 任何跨挂起点存活的局部变量或临时变量的存储空间

我们先给它加上 `promise` 对象和参数副本的存储：

```cpp
struct __g_state {
    int x;
    __g_promise_t __promise;

    // to be filled out
};
```

接着，我们需要添加一个构造函数来初始化这些数据成员。

回忆一下：编译器会首先尝试用**参数副本的左值引用**来调用 `promise` 的构造函数，如果可行就这么做；否则会退回到调用 `promise` 类型的默认构造函数。

我们可以写一个简单的辅助函数来完成这个逻辑：

```cpp
template<typename Promise, typename... Params>
Promise construct_promise([[maybe_unused]] Params&... params) {
    if constexpr (std::constructible_from<Promise, Params&...>) {
        return Promise(params...);
    } else {
        return Promise();
    }
}
```

这样，协程状态的构造函数可能看起来像这样：

```cpp
struct __g_state {
    __g_state(int&& x)
    : x(static_cast<int&&>(x))
    , __promise(construct_promise<__g_promise_t>(this->x))
    {}

    int x;
    __g_promise_t __promise;
    // to be filled out
};
```

现在我们有了表示协程状态的初步类型，也可以开始写 `g()` 降级版本的初始实现，让它在堆上分配一个 `__g_state` 实例，并把参数传进去，让它们被拷贝或移动到协程状态里。

这里的一个术语——我称“ramp function”为协程实现中**初始化协程状态并让它准备开始执行协程体**的那部分逻辑。
它就像是进入协程执行的入口匝道（on-ramp）。

```cpp
task g(int x) {
    auto* state = new __g_state(static_cast<int&&>(x));
    // ... implement rest of the ramp function
}
```

注意，我们的 `promise_type` 没有定义自己的 `operator new` 重载，因此这里直接调用的是全局的 `::operator new`。

如果 `promise` 类型**定义了自己的 `operator new`**，那么我们就会调用它，而不是全局的 `::operator new`。
调用前会先检查 `operator new` 是否能用参数列表 `(size, paramLvalues...)` 调用，如果能，就用这个参数列表调用；否则，就只用 `(size)` 作为参数。
让 `operator new` 能访问协程函数的参数列表，这个能力有时被称为**参数预览（parameter preview）**，常用于需要用传进来的分配器来分配协程状态存储的情况。

如果编译器找到了 `__g_promise_t::operator new`，那么降级后的逻辑会变成这样：

```cpp
template<typename Promise, typename... Args>
void* __promise_allocate(std::size_t size, [[maybe_unused]] Args&... args) {
  if constexpr (requires { Promise::operator new(size, args...); }) {
    return Promise::operator new(size, args...);
  } else {
    return Promise::operator new(size);
  }
}

task g(int x) {
    void* state_mem = __promise_allocate<__g_promise_t>(sizeof(__g_state), x);
    __g_state* state;
    try {
        state = ::new (state_mem) __g_state(static_cast<int&&>(x));
    } catch (...) {
        __g_promise_t::operator delete(state_mem);
        throw;
    }
    // ... implement rest of the ramp function
}
```

另外，这个 `promise_type` 也没有定义 `get_return_object_on_allocation_failure()` 静态成员函数。
如果定义了，那么这里的分配就会改为使用 `std::nothrow_t` 形式的 `operator new`，如果返回了 `nullptr`，就会直接返回 `__g_promise_t::get_return_object_on_allocation_failure();`。

也就是说，代码会变成这样：

```cpp
task g(int x) {
    auto* state = ::new (std::nothrow) __g_state(static_cast<int&&>(x));
    if (state == nullptr) {
        return __g_promise_t::get_return_object_on_allocation_failure();
    }
    // ... implement rest of the ramp function
}
```

为了简化接下来的示例，我们将继续使用**最简单的形式**——直接调用全局的 `::operator new` 进行内存分配。

## 第 3 步：调用 `get_return_object()`

接下来，启动函数（ramp function）要做的事情是调用 promise 对象的 `get_return_object()` 方法，以获取启动函数的返回值。

返回值会作为一个局部变量保存，并在启动函数的最后（其他步骤完成之后）返回。

```
task g(int x) {
    auto* state = new __g_state(static_cast<int&&>(x));
    decltype(auto) return_value = state->__promise.get_return_object();
    // ... 实现 ramp function 剩余部分
    return return_value;
}
```

不过，现在有可能在调用 `get_return_object()` 时抛出异常，这种情况下我们需要释放已分配的协程状态。因此，为了稳妥起见，可以将协程状态交给 `std::unique_ptr` 管理，这样一旦后续操作抛出异常，内存也会被释放：

```
task g(int x) {
    std::unique_ptr<__g_state> state(new __g_state(static_cast<int&&>(x)));
    decltype(auto) return_value = state->__promise.get_return_object();
    // ... 实现 ramp function 剩余部分
    return return_value;
}
```

## 第 4 步：初始挂起点（initial-suspend point）

在调用 `get_return_object()` 之后，启动函数会开始执行协程主体，而协程主体执行的第一件事就是初始挂起点。也就是说，会执行 `co_await promise.initial_suspend()`。

理想情况下，我们可以把协程当作“初始挂起”状态，然后通过恢复该挂起协程的方式来启动它。不过，初始挂起点的规范在处理异常和协程状态生命周期时有一些特殊之处。这是在 C++20 发布前不久，为了解决一些潜在问题，对初始挂起点语义做的调整。

在执行初始挂起点时，如果异常是在以下任一位置抛出的：

* 调用 `initial_suspend()`
* 调用返回的可等待对象（awaitable）的 `operator co_await()`（如果定义了）
* 调用 awaiter 的 `await_ready()`
* 调用 awaiter 的 `await_suspend()`

那么，异常会传播回启动函数的调用方，并且协程状态会被自动销毁。

如果异常是在以下位置抛出的：

* 调用 `await_resume()`
* 销毁 `operator co_await()` 返回的对象（如果适用）
* 销毁 `initial_suspend()` 返回的对象

那么，异常会被协程主体捕获，并调用 `promise.unhandled_exception()`。

这意味着在转换这部分代码时需要小心处理：有些逻辑需要放在启动函数里，而有些逻辑需要放在协程主体中。

此外，由于 `initial_suspend()` 和（可选的）`operator co_await()` 返回的对象，其生命周期会跨越一个挂起点（它们在协程挂起前创建，在恢复后销毁），因此它们的存储空间需要放在协程状态中。

在我们的例子中，`initial_suspend()` 返回的类型是 `std::suspend_always`，它是一个空的、可平凡构造的类型。不过，从逻辑上我们仍需要在协程状态中保存该类型的实例，因此我们会加上对应的存储空间，以展示实现方式。

这个对象会在调用 `initial_suspend()` 时构造，因此我们需要一个可以显式控制其生命周期的成员。

为此，先定义一个 `manual_lifetime` 辅助类，它是可平凡构造和销毁的，但允许我们在需要时显式构造/销毁其存储的值。

```
template<typename T>
struct manual_lifetime {
    manual_lifetime() noexcept = default;
    ~manual_lifetime() = default;

    // 禁止拷贝/移动
    manual_lifetime(const manual_lifetime&) = delete;
    manual_lifetime(manual_lifetime&&) = delete;
    manual_lifetime& operator=(const manual_lifetime&) = delete;
    manual_lifetime& operator=(manual_lifetime&&) = delete;

    template<typename Factory>
        requires
            std::invocable<Factory&> &&
            std::same_as<std::invoke_result_t<Factory&>, T>
    T& construct_from(Factory factory) noexcept(std::is_nothrow_invocable_v<Factory&>) {
        return *::new (static_cast<void*>(&storage)) T(factory());
    }

    void destroy() noexcept(std::is_nothrow_destructible_v<T>) {
        std::destroy_at(std::launder(reinterpret_cast<T*>(&storage)));
    }

    T& get() & noexcept {
        return *std::launder(reinterpret_cast<T*>(&storage));
    }

private:
    alignas(T) std::byte storage[sizeof(T)];
};
```

注意：`construct_from()` 采用 lambda 而不是构造函数参数，这样可以利用函数调用返回值初始化变量时的保证性拷贝消除（copy-elision），避免多余的移动构造。

现在可以用 `manual_lifetime` 声明一个数据成员，用来保存 `promise.initial_suspend()` 返回的临时对象。

```
struct __g_state {
    __g_state(int&& x);

    int x;
    __g_promise_t __promise;
    manual_lifetime<std::suspend_always> __tmp1;
    // 其他内容待补充
};
```

`std::suspend_always` 没有定义 `operator co_await()`，因此不需要为其额外保存该调用结果的临时对象。

一旦调用 `initial_suspend()` 构造了这个对象，我们需要调用 `await_ready()`、`await_suspend()` 和 `await_resume()` 来实现 `co_await` 表达式。

在调用 `await_suspend()` 时，我们需要向它传递当前协程的句柄。这里可以调用 `std::coroutine_handle<__g_promise_t>::from_promise()`，并传入 promise 的引用。我们会在后面讨论其内部原理。

另外，这里调用 `.await_suspend(handle)` 的返回类型是 `void`，所以不像返回 `bool` 或 `coroutine_handle` 的版本那样，需要考虑恢复当前协程还是另一个协程。

最后，由于 `std::suspend_always` awaiter 上的所有方法都声明为 `noexcept`，所以不必担心异常。如果可能抛出异常，我们就需要在异常传播出启动函数前销毁临时对象 `std::suspend_always`。

当 `await_suspend()` 成功返回，或者准备开始执行协程主体时，我们进入一个阶段：如果此时抛出异常，就不需要再自动销毁协程状态了。因此我们可以调用 `std::unique_ptr` 的 `release()` 来放弃对协程状态的所有权，防止函数返回时销毁它。

于是，可以将初始挂起表达式的第一部分实现如下：

```
task g(int x) {
    std::unique_ptr<__g_state> state(new __g_state(static_cast<int&&>(x)));
    decltype(auto) return_value = state->__promise.get_return_object();

    state->__tmp1.construct_from([&]() -> decltype(auto) {
        return state->__promise.initial_suspend();
    });
    if (!state->__tmp1.get().await_ready()) {
        //
        // ... 在此挂起协程
        //
        state->__tmp1.get().await_suspend(
            std::coroutine_handle<__g_promise_t>::from_promise(state->__promise));

        state.release();

        // 直接跳到下面的 return 语句
    } else {
        // 协程没有挂起

        state.release();

        //
        // ... 开始执行协程主体
        //
    }
    return __return_val;
}
```

`await_resume()` 的调用以及 `__tmp1` 的析构会出现在协程主体中，因此不会出现在启动函数里。

现在，我们已经有了一个（大部分）可运行的初始挂起点实现，但 ramp function 中仍有几个 TODO 需要解决。为了完成这些 TODO，我们需要先绕个弯，看看协程挂起和恢复的策略。


## 第 5 步：记录挂起点（suspend-point）

当协程挂起时，需要确保它在恢复时能从挂起的同一个控制流位置继续执行。

它还需要跟踪在每个挂起点处哪些具有自动存储期的对象仍然存活，这样在协程被销毁而不是恢复时，就知道需要销毁哪些对象。

一种实现方式是：为协程中的每个挂起点分配一个唯一编号，并将其存储到协程状态的一个整型数据成员中。

当协程挂起时，它会将当前挂起点的编号写入协程状态中；而当协程恢复或销毁时，我们检查这个整数以确定它是在哪个挂起点挂起的。

需要注意，这并不是在协程状态中存储挂起点的唯一方法，但在本文写作时（约 2022 年），三个主流编译器（MSVC、Clang、GCC）都采用了这种方式。另一种可能的方案是为每个挂起点使用单独的恢复/销毁函数指针，不过本文不会探讨这种策略。

因此，我们将扩展协程状态，增加一个整数数据成员来存储挂起点索引，并初始化为 0（我们将其固定用作初始挂起点的值）。

```cpp
struct __g_state {
    __g_state(int&& x);

    int x;
    __g_promise_t __promise;
    int __suspend_point = 0;  // <-- 添加挂起点索引
    manual_lifetime<std::suspend_always> __tmp1;
    // 后续填充
};
```

---

## 第 6 步：实现 `coroutine_handle::resume()` 和 `coroutine_handle::destroy()`

当调用 `coroutine_handle::resume()` 恢复一个协程时，我们需要让它最终调用某个函数来继续执行挂起的协程主体。该被调用的主体函数可以查询挂起点索引，并跳转到控制流中的相应位置。

我们还需要实现 `coroutine_handle::destroy()` 函数，以便在当前挂起点调用适当的逻辑来销毁所有在作用域内的对象，并且还需要实现 `coroutine_handle::done()` 来判断当前挂起点是否是最终挂起点（final-suspend-point）。

`coroutine_handle` 方法的接口并不知道具体的协程状态类型——`coroutine_handle<void>` 类型可以指向 **任意** 协程实例。这意味着我们需要一种方式来屏蔽具体的协程状态类型（类型擦除）。

我们可以通过在协程状态中存储该协程类型的恢复/销毁函数指针来实现这一点，然后让 `coroutine_handle::resume()` / `destroy()` 调用这些函数指针。

`coroutine_handle` 类型还需要能够通过 `coroutine_handle::address()` 和 `coroutine_handle::from_address()` 在 `void*` 和 `coroutine_handle` 之间互相转换。

此外，协程可以通过 **任意** 指向它的 handle 来恢复/销毁——不仅限于最近一次传递给 `await_suspend()` 的 handle。

这些需求使我们需要让 `coroutine_handle` 只保存一个指向协程状态的指针，并把恢复/销毁的函数指针存放在协程状态中，而不是放在 `coroutine_handle` 内部。

另外，由于我们需要 `coroutine_handle` 能够指向任意的协程状态对象，因此各个协程状态类型中函数指针数据成员的布局必须保持一致。

一个直接的做法是让每个协程状态类型都继承自一个包含这些数据成员的基类。

例如，我们可以定义如下类型作为所有协程状态类型的基类：

```cpp
struct __coroutine_state {
    using __resume_fn = void(__coroutine_state*);
    using __destroy_fn = void(__coroutine_state*);

    __resume_fn* __resume;
    __destroy_fn* __destroy;
};
```

这样，`coroutine_handle::resume()` 方法只需调用 `__resume()`，并传递一个指向 `__coroutine_state` 对象的指针即可。`coroutine_handle::destroy()` 同理调用 `__destroy` 函数指针。

对于 `coroutine_handle::done()` 方法，我们选择将空的 `__resume` 函数指针作为处于最终挂起点的标志。这很方便，因为最终挂起点不支持 `resume()`，只支持 `destroy()`。如果有人在最终挂起点调用 `resume()`（这是未定义行为），那么它将调用一个空函数指针，这样很快就会出错并暴露问题。

基于此，我们可以这样实现 `coroutine_handle<void>` 类型：

```cpp
namespace std
{
    template<typename Promise = void>
    class coroutine_handle;

    template<>
    class coroutine_handle<void> {
    public:
        coroutine_handle() noexcept = default;
        coroutine_handle(const coroutine_handle&) noexcept = default;
        coroutine_handle& operator=(const coroutine_handle&) noexcept = default;

        void* address() const {
            return static_cast<void*>(state_);
        }

        static coroutine_handle from_address(void* ptr) {
            coroutine_handle h;
            h.state_ = static_cast<__coroutine_state*>(ptr);
            return h;
        }

        explicit operator bool() noexcept {
            return state_ != nullptr;
        }
        
        friend bool operator==(coroutine_handle a, coroutine_handle b) noexcept {
            return a.state_ == b.state_;
        }

        void resume() const {
            state_->__resume(state_);
        }
        void destroy() const {
            state_->__destroy(state_);
        }

        bool done() const {
            return state_->__resume == nullptr;
        }

    private:
        __coroutine_state* state_ = nullptr;
    };
}
```


## 第 7 步：实现 `coroutine_handle<Promise>::promise()` 和 `from_promise()`

对于更通用的 `coroutine_handle<Promise>` 特化，大多数实现可以直接复用 `coroutine_handle<void>` 的实现。然而，我们还需要能够访问协程状态中的 promise 对象（由 `promise()` 方法返回），并且还需要能够通过对 promise 对象的引用构造一个 `coroutine_handle`。

但是，我们同样不能简单地指向具体的协程状态类型，因为 `coroutine_handle<Promise>` 类型必须能够引用 **任意** promise 类型为 `Promise` 的协程状态。

我们需要定义一个新的协程状态基类，它继承自 `__coroutine_state`，并包含 promise 对象。这样我们就可以让所有使用特定 promise 类型的协程状态类型继承自这个基类。

```cpp
template<typename Promise>
struct __coroutine_state_with_promise : __coroutine_state {
    __coroutine_state_with_promise() noexcept {}
    ~__coroutine_state_with_promise() {}

    union {
        Promise __promise;
    };
};
```

你可能会好奇，为什么我们要把 `__promise` 成员声明在匿名联合（anonymous union）里……

原因是：编译器为特定协程函数生成的派生类中，会包含用于保存参数拷贝的数据成员。而派生类的数据成员默认会在基类数据成员 **之后** 初始化，所以如果将 promise 对象声明为普通数据成员，它会在参数拷贝成员之前被构造。

但是我们需要在 **参数拷贝构造完成之后** 再调用 promise 的构造函数，因为 promise 的构造函数可能需要用到参数拷贝对象的引用。

因此，我们在基类中仅预留一块 promise 对象的存储空间（这样它在协程状态起始位置的偏移量是固定的），而把调用构造函数/析构函数的时机交给派生类控制。将 `__promise` 声明为联合成员可以让我们实现这种控制。

接下来我们更新 `__g_state` 类，让它继承这个新的基类。

```cpp
struct __g_state : __coroutine_state_with_promise<__g_promise_t> {
    __g_state(int&& __x)
    : x(static_cast<int&&>(__x)) {
        // 使用 placement-new 在基类的存储空间中初始化 promise 对象
        ::new ((void*)std::addressof(this->__promise))
            __g_promise_t(construct_promise<__g_promise_t>(x));
    }

    ~__g_state() {
        // 在销毁参数对象之前，必须手动调用 promise 的析构函数
        this->__promise.~__g_promise_t();
    }

    int __suspend_point = 0;
    int x;
    manual_lifetime<std::suspend_always> __tmp1;
    // 后续填充
};
```

现在我们已经定义了 promise 基类，就可以实现 `std::coroutine_handle<Promise>` 类模板了。

大部分实现与 `coroutine_handle<void>` 中的方法基本一致，只是使用 `__coroutine_state_with_promise<Promise>` 指针替代了 `__coroutine_state` 指针。

唯一新增的部分是 `promise()` 和 `from_promise()` 两个函数。

* `promise()` 方法很直接——它返回协程状态中 `__promise` 成员的引用。
* `from_promise()` 方法需要根据 promise 对象的地址推算出协程状态对象的地址。这可以通过从 promise 对象地址中减去 `__promise` 成员的偏移量来实现。

`coroutine_handle<Promise>` 的实现如下：

```cpp
namespace std
{
    template<typename Promise>
    class coroutine_handle {
        using state_t = __coroutine_state_with_promise<Promise>;
    public:
        coroutine_handle() noexcept = default;
        coroutine_handle(const coroutine_handle&) noexcept = default;
        coroutine_handle& operator=(const coroutine_handle&) noexcept = default;

        operator coroutine_handle<void>() const noexcept {
            return coroutine_handle<void>::from_address(address());
        }

        explicit operator bool() const noexcept {
            return state_ != nullptr;
        }

        friend bool operator==(coroutine_handle a, coroutine_handle b) noexcept {
            return a.state_ == b.state_;
        }

        void* address() const {
            return static_cast<void*>(static_cast<__coroutine_state*>(state_));
        }

        static coroutine_handle from_address(void* ptr) {
            coroutine_handle h;
            h.state_ = static_cast<state_t*>(static_cast<__coroutine_state*>(ptr));
            return h;
        }

        Promise& promise() const {
            return state_->__promise;
        }

        static coroutine_handle from_promise(Promise& promise) {
            coroutine_handle h;

            // 已知 __promise 成员的地址，通过减去其偏移量得到协程状态的地址
            h.state_ = reinterpret_cast<state_t*>(
                reinterpret_cast<unsigned char*>(std::addressof(promise)) -
                offsetof(state_t, __promise));

            return h;
        }

        // 直接调用 `coroutine_handle<void>` 的实现

        void resume() const {
            static_cast<coroutine_handle<void>>(*this).resume();
        }

        void destroy() const {
            static_cast<coroutine_handle<void>>(*this).destroy();
        }

        bool done() const {
            return static_cast<coroutine_handle<void>>(*this).done();
        }

    private:
        state_t* state_;
    };
}
```

至此，我们已经定义了协程恢复的机制，现在可以回到 “ramp” 函数，并更新它，以初始化我们在协程状态中新增的函数指针数据成员。


## 第 8 步：协程体的开端

现在我们先提前声明具有正确签名的 `resume`/`destroy` 函数，并更新 `__g_state` 构造函数来初始化协程状态，使得 resume/destroy 函数指针指向它们：

```cpp
void __g_resume(__coroutine_state* s);
void __g_destroy(__coroutine_state* s);

struct __g_state : __coroutine_state_with_promise<__g_promise_t> {
    __g_state(int&& __x)
    : x(static_cast<int&&>(__x)) {
        // 初始化 coroutine_handle 方法所使用的函数指针
        this->__resume = &__g_resume;
        this->__destroy = &__g_destroy;

        // 使用 placement-new 在基类中初始化 promise 对象
        ::new ((void*)std::addressof(this->__promise))
            __g_promise_t(construct_promise<__g_promise_t>(x));
    }

    // ... 省略其余部分
};
```

```cpp
task g(int x) {
    std::unique_ptr<__g_state> state(new __g_state(static_cast<int&&>(x)));
    decltype(auto) return_value = state->__promise.get_return_object();

    state->__tmp1.construct_from([&]() -> decltype(auto) {
        return state->__promise.initial_suspend();
    });
    if (!state->__tmp1.get().await_ready()) {
        state->__tmp1.get().await_suspend(
            std::coroutine_handle<__g_promise_t>::from_promise(state->__promise));
        state.release();
        // 直接跳到 return 语句
    } else {
        // 协程没有挂起，立即开始执行主体
        __g_resume(state.release());
    }
    return return_value;
}
```

至此，ramp 函数已经完成，现在我们可以专注于实现 `g()` 的 resume/destroy 函数。

我们先完成 initial-suspend 表达式的降级（lowering）。

当 `__g_resume()` 被调用且 `__suspend_point` 索引为 0 时，我们需要通过调用 `await_resume()` 恢复 `__tmp1`，然后销毁 `__tmp1`。

```cpp
void __g_resume(__coroutine_state* s) {
    // 我们知道 's' 指向一个 __g_state
    auto* state = static_cast<__g_state*>(s);

    // 根据挂起点索引值跳转到对应位置
    switch (state->__suspend_point) {
    case 0: goto suspend_point_0;
    default: std::unreachable();
    }

suspend_point_0:
    state->__tmp1.get().await_resume();
    state->__tmp1.destroy();

    // TODO: 实现协程体的其余部分
    //
    //  int fx = co_await f(x);
    //  co_return fx * fx;
}
```

当 `__g_destroy()` 被调用且 `__suspend_point` 索引为 0 时，我们只需要销毁 `__tmp1`，然后销毁并释放协程状态即可。

```cpp
void __g_destroy(__coroutine_state* s) {
    auto* state = static_cast<__g_state*>(s);

    switch (state->__suspend_point) {
    case 0: goto suspend_point_0;
    default: std::unreachable();
    }

suspend_point_0:
    state->__tmp1.destroy();
    goto destroy_state;

    // TODO: 在此为其他挂起点添加逻辑

destroy_state:
    delete state;
}
```

---

## 第 9 步：降级 `co_await` 表达式

接下来，我们看看 `co_await f(x)` 表达式的降级过程。

首先我们需要计算 `f(x)`，它返回一个临时的 `task` 对象。

由于该临时 `task` 在语句末尾的分号之前不会被销毁，而该语句中包含了 `co_await` 表达式，因此该 `task` 的生命周期会跨越一个挂起点，所以它必须存储在协程状态中。

当在这个临时 `task` 上求值 `co_await` 表达式时，我们需要调用其 `operator co_await()` 方法，这会返回一个临时的 `awaiter` 对象。该对象的生命周期同样跨越挂起点，因此也必须存储在协程状态中。

我们在 `__g_state` 类型中添加必要的成员：

```cpp
struct __g_state : __coroutine_state_with_promise<__g_promise_t> {
    __g_state(int&& __x);
    ~__g_state();

    int __suspend_point = 0;
    int x;
    manual_lifetime<std::suspend_always> __tmp1;
    manual_lifetime<task> __tmp2;
    manual_lifetime<task::awaiter> __tmp3;
};
```

然后我们更新 `__g_resume()` 函数来初始化这些临时变量，并执行 `co_await` 表达式涉及的 3 个调用：`await_ready`、`await_suspend` 和 `await_resume`。

注意：`task::awaiter::await_suspend()` 方法会返回一个 coroutine handle，因此我们需要生成代码来恢复这个返回的 handle。

另外，在调用 `await_suspend()` 之前必须更新挂起点索引（我们用索引 1 表示这个挂起点），并在跳转表中新增一个条目，保证恢复时跳回正确位置。

```cpp
void __g_resume(__coroutine_state* s) {
    // 我们知道 's' 指向一个 __g_state
    auto* state = static_cast<__g_state*>(s);

    // 根据挂起点索引值跳转到对应位置
    switch (state->__suspend_point) {
    case 0: goto suspend_point_0;
    case 1: goto suspend_point_1; // <-- 新增跳转表条目
    default: std::unreachable();
    }

suspend_point_0:
    state->__tmp1.get().await_resume();
    state->__tmp1.destroy();

    //  int fx = co_await f(x);
    state->__tmp2.construct_from([&] {
        return f(state->x);
    });
    state->__tmp3.construct_from([&] {
        return static_cast<task&&>(state->__tmp2.get()).operator co_await();
    });
    if (!state->__tmp3.get().await_ready()) {
        // 标记挂起点
        state->__suspend_point = 1;

        auto h = state->__tmp3.get().await_suspend(
            std::coroutine_handle<__g_promise_t>::from_promise(state->__promise));
        
        // 在返回前恢复返回的 coroutine handle
        h.resume();
        return;
    }

suspend_point_1:
    int fx = state->__tmp3.get().await_resume();
    state->__tmp3.destroy();
    state->__tmp2.destroy();

    // TODO: 实现
    //  co_return fx * fx;
}
```

注意：局部变量 `int fx` 的生命周期不会跨越挂起点，因此不需要存储在协程状态中，可以直接作为 `__g_resume` 函数的普通局部变量。

我们还需要在 `__g_destroy()` 中新增对应挂起点的销毁逻辑：

```cpp
void __g_destroy(__coroutine_state* s) {
    auto* state = static_cast<__g_state*>(s);

    switch (state->__suspend_point) {
    case 0: goto suspend_point_0;
    case 1: goto suspend_point_1; // <-- 新增跳转表条目
    default: std::unreachable();
    }

suspend_point_0:
    state->__tmp1.destroy();
    goto destroy_state;

suspend_point_1:
    state->__tmp3.destroy();
    state->__tmp2.destroy();
    goto destroy_state;

    // TODO: 在此为其他挂起点添加逻辑

destroy_state:
    delete state;
}
```

到这里，我们已经完成了该语句的实现：

然而，函数 `f(x)` 没有被标记为 `noexcept`，因此它可能抛出异常。同样，`awaiter::await_resume()` 方法也没有标记为 `noexcept`，也可能抛出异常。

当协程体抛出异常时，编译器会生成代码捕获异常，并调用 `promise.unhandled_exception()`，以便 promise 有机会处理该异常。接下来我们将看看这一部分的实现。


## 第 10 步：实现 `unhandled_exception()`

协程定义的规范 [`[dcl.fct.def.coroutine]`](https://eel.is/c++draft/dcl.fct.def.coroutine) 规定，协程的行为等同于其函数体被替换为以下内容：

```
{
    promise-type promise promise-constructor-arguments ;
    try {
        co_await promise.initial_suspend() ;
        function-body
    } catch ( ... ) {
        if (!initial-await-resume-called)
            throw ;
        promise.unhandled_exception() ;
    }
final-suspend :
    co_await promise.final_suspend() ;
}
```

我们已经在 ramp 函数中单独处理了 `initial-await_resume-called` 分支，因此这里不需要再关心它。

现在我们调整 `__g_resume()` 函数，把整个函数体包裹进 try/catch 块中。

注意，我们必须小心地将跳转到正确位置的 `switch` 放在 try 块内部，因为 C++ 不允许使用 `goto` 直接跳进一个 try 块。

另外，我们还必须注意：要在 try/catch 块之外调用 `await_suspend()` 返回的协程句柄的 `.resume()` 方法。
如果从这个 `.resume()` 调用中抛出了异常，那么该异常不应该被当前协程捕获，而是应该向外传播到唤醒此协程的 `resume()` 调用处。
因此，我们可以先在函数顶部声明一个变量来保存这个协程句柄，然后 `goto` 到 try/catch 外部的一个位置，再执行 `.resume()`。

```
void __g_resume(__coroutine_state* s) {
    auto* state = static_cast<__g_state*>(s);

    std::coroutine_handle<void> coro_to_resume;

    try {
        switch (state->__suspend_point) {
        case 0: goto suspend_point_0;
        case 1: goto suspend_point_1; // <-- 新增跳转表项
        default: std::unreachable();
        }

suspend_point_0:
        state->__tmp1.get().await_resume();
        state->__tmp1.destroy();

        //  int fx = co_await f(x);
        state->__tmp2.construct_from([&] {
            return f(state->x);
        });
        state->__tmp3.construct_from([&] {
            return static_cast<task&&>(state->__tmp2.get()).operator co_await();
        });
        
        if (!state->__tmp3.get().await_ready()) {
            state->__suspend_point = 1;
            coro_to_resume = state->__tmp3.get().await_suspend(
                std::coroutine_handle<__g_promise_t>::from_promise(state->__promise));
            goto resume_coro;
        }

suspend_point_1:
        int fx = state->__tmp3.get().await_resume();
        state->__tmp3.destroy();
        state->__tmp2.destroy();

        // TODO: 实现
        //  co_return fx * fx;
    } catch (...) {
        state->__promise.unhandled_exception();
        goto final_suspend;
    }

final_suspend:
    // TODO: 实现
    // co_await promise.final_suspend();

resume_coro:
    coro_to_resume.resume();
    return;
}
```

不过，上面的代码中有一个 bug：
如果 `__tmp3.get().await_resume()` 调用抛出了异常，我们会在捕获异常之前漏掉 `__tmp3` 和 `__tmp2` 的析构调用。

需要注意的是，我们不能简单地捕获异常、调用析构函数再重新抛出异常，因为这会改变析构函数在调用 `std::unhandled_exceptions()` 时的行为。
如果析构函数在异常展开过程中调用了 `std::unhandled_exceptions()`，那么它应该返回非零值，而不是 0。

因此，我们可以定义一个 RAII 辅助类，确保在作用域退出时（包括发生异常时）调用对应对象的析构函数：

```
template<typename T>
struct destructor_guard {
    explicit destructor_guard(manual_lifetime<T>& obj) noexcept
    : ptr_(std::addressof(obj))
    {}

    // 禁止移动
    destructor_guard(destructor_guard&&) = delete;
    destructor_guard& operator=(destructor_guard&&) = delete;

    ~destructor_guard() noexcept(std::is_nothrow_destructible_v<T>) {
        if (ptr_ != nullptr) {
            ptr_->destroy();
        }
    }

    void cancel() noexcept { ptr_ = nullptr; }

private:
    manual_lifetime<T>* ptr_;
};

// 针对平凡析构类型的部分特化
template<typename T>
    requires std::is_trivially_destructible_v<T>
struct destructor_guard<T> {
    explicit destructor_guard(manual_lifetime<T>&) noexcept {}
    void cancel() noexcept {}
};

// 类模板实参推导，简化用法
template<typename T>
destructor_guard(manual_lifetime<T>& obj) -> destructor_guard<T>;
```

有了这个工具类，我们就可以确保协程状态中存储的变量在异常发生时正确销毁。

我们还可以用这个类来管理已有变量的析构，让它们在正常作用域结束时也能自动调用析构：

```
void __g_resume(__coroutine_state* s) {
    auto* state = static_cast<__g_state*>(s);

    std::coroutine_handle<void> coro_to_resume;

    try {
        switch (state->__suspend_point) {
        case 0: goto suspend_point_0;
        case 1: goto suspend_point_1; // <-- 新增跳转表项
        default: std::unreachable();
        }

suspend_point_0:
        {
            destructor_guard tmp1_dtor{state->__tmp1};
            state->__tmp1.get().await_resume();
        }

        //  int fx = co_await f(x);
        {
            state->__tmp2.construct_from([&] {
                return f(state->x);
            });
            destructor_guard tmp2_dtor{state->__tmp2};

            state->__tmp3.construct_from([&] {
                return static_cast<task&&>(state->__tmp2.get()).operator co_await();
            });
            destructor_guard tmp3_dtor{state->__tmp3};

            if (!state->__tmp3.get().await_ready()) {
                state->__suspend_point = 1;

                coro_to_resume = state->__tmp3.get().await_suspend(
                    std::coroutine_handle<__g_promise_t>::from_promise(state->__promise));

                // 协程挂起时作用域不会退出
                // 所以需要取消析构守卫
                tmp3_dtor.cancel();
                tmp2_dtor.cancel();

                goto resume_coro;
            }

            // 不能直接跳转到有非平凡析构对象的作用域
            // 所以这里提前退出析构守卫的作用域并取消析构
            tmp3_dtor.cancel();
            tmp2_dtor.cancel();
        }

suspend_point_1:
        int fx = [&]() -> decltype(auto) {
            destructor_guard tmp2_dtor{state->__tmp2};
            destructor_guard tmp3_dtor{state->__tmp3};
            return state->__tmp3.get().await_resume();
        }();

        // TODO: 实现
        //  co_return fx * fx;
    } catch (...) {
        state->__promise.unhandled_exception();
        goto final_suspend;
    }

final_suspend:
    // TODO: 实现
    // co_await promise.final_suspend();

resume_coro:
    coro_to_resume.resume();
    return;
}
```

现在，我们的协程在出现异常时可以正确销毁局部变量，并在异常传播出协程体时正确调用 `promise.unhandled_exception()`。

值得注意的是，如果 `promise.unhandled_exception()` 自身抛出异常（例如它重新抛出当前异常），则可能需要进行特殊处理。

在这种情况下，协程需要捕获这个异常，将协程标记为停在 final-suspend-point，然后再重新抛出异常。

例如，`__g_resume()` 函数的 catch 块可以这样写：

```
try {
  // ...
} catch (...) {
    try {
        state->__promise.unhandled_exception();
    } catch (...) {
        state->__suspend_point = 2;
        state->__resume = nullptr; // 标记为 final-suspend-point
        throw;
    }
}
```

并且需要在 `__g_destroy` 函数的跳转表中额外加一项：

```
switch (state->__suspend_point) {
case 0: goto suspend_point_0;
case 1: goto suspend_point_1;
case 2: goto destroy_state; // 没有需要析构的变量
                            // 直接销毁协程状态对象
}
```

需要注意的是，这里的 final-suspend-point 不一定等同于 `co_await promise.final_suspend()` 的挂起点。

这是因为 `promise.final_suspend()` 的挂起点通常会包含一些与 `co_await` 表达式相关的临时对象，而这些对象在 `coroutine_handle::destroy()` 被调用时需要销毁。
但是如果 `promise.unhandled_exception()` 抛出异常，这些临时对象就不会存在，因此 `coroutine_handle::destroy()` 也不需要销毁它们。


## 第 11 步：实现 `co_return`

下一步是实现 `co_return fx * fx;` 语句。

与前面的一些步骤相比，这一步相对简单。

`co_return <expr>` 语句会被映射为：

```
promise.return_value(<expr>);
goto final-suspend-point;
```

所以我们可以直接用以下代码替换 TODO 注释：

```
state->__promise.return_value(fx * fx);
goto final_suspend;
```

很简单。


## 第 12 步：实现 `final_suspend()`

代码中最后一个 TODO 就是实现 `co_await promise.final_suspend()` 语句。

`final_suspend()` 方法会返回一个临时的 `task::promise_type::final_awaiter` 类型，它需要被存储在协程状态对象中，并在 `__g_destroy` 中销毁。

这个类型没有自己的 `operator co_await()`，因此我们不需要为该调用的结果额外创建临时对象。

与 `task::awaiter` 类型一样，它也使用返回协程句柄的 `await_suspend()` 形式。因此我们需要确保对返回的句柄调用 `resume()`。

如果协程在 final-suspend-point 没有挂起，那么协程状态会被隐式销毁。所以如果执行到协程的结尾，我们需要删除状态对象。

另外，由于所有 final-suspend 逻辑都要求是 `noexcept`，所以这里我们不需要担心子表达式抛出异常。

首先，在 `__g_state` 类型中添加一个数据成员：

```
struct __g_state : __coroutine_state_with_promise<__g_promise_t> {
    __g_state(int&& __x);
    ~__g_state();

    int __suspend_point = 0;
    int x;
    manual_lifetime<std::suspend_always> __tmp1;
    manual_lifetime<task> __tmp2;
    manual_lifetime<task::awaiter> __tmp3;
    manual_lifetime<task::promise_type::final_awaiter> __tmp4; // <---
};
```

然后我们可以这样实现 final-suspend 表达式的主体：

```
final_suspend:
    // co_await promise.final_suspend
    {
        state->__tmp4.construct_from([&]() noexcept {
            return state->__promise.final_suspend();
        });
        destructor_guard tmp4_dtor{state->__tmp4};

        if (!state->__tmp4.get().await_ready()) {
            state->__suspend_point = 2;
            state->__resume = nullptr; // 标记为 final suspend-point

            coro_to_resume = state->__tmp4.get().await_suspend(
                std::coroutine_handle<__g_promise_t>::from_promise(state->__promise));

            tmp4_dtor.cancel();
            goto resume_coro;
        }

        state->__tmp4.get().await_resume();
    }

    // 如果执行流从协程末尾直接流出，则销毁协程状态
    delete state;
    return;
```

现在我们还需要更新 `__g_destroy` 函数来处理这个新的挂起点：

```
void __g_destroy(__coroutine_state* state) {
    auto* state = static_cast<__g_state*>(s);

    switch (state->__suspend_point) {
    case 0: goto suspend_point_0;
    case 1: goto suspend_point_1;
    case 2: goto suspend_point_2;
    default: std::unreachable();
    }

suspend_point_0:
    state->__tmp1.destroy();
    goto destroy_state;

suspend_point_1:
    state->__tmp3.destroy();
    state->__tmp2.destroy();
    goto destroy_state;

suspend_point_2:
    state->__tmp4.destroy();
    goto destroy_state;

destroy_state:
    delete state;
}
```

现在我们已经完成了 `g()` 协程函数的完整降级实现。

我们搞定了！这就是全部！

或者说……真的是这样吗……

## 第 13 步：实现 symmetric-transfer 和 noop-coroutine

事实证明，我们之前实现的 `__g_resume()` 函数实际上是有问题的。

这些问题在上一篇博文中有更详细的讨论，如果你想更深入地理解这个问题，请参考文章 [C++ Coroutines: Understanding Symmetric Transfer](https://lewissbaker.github.io/2020/05/11/understanding_symmetric_transfer)。

[$expr.await$](https://eel.is/c++draft/expr.await) 的规范中有一个小提示，暗示了我们应该如何处理返回协程句柄类型的 `await_suspend`：

> 如果 *await-suspend* 的类型是 `std::coroutine_handle<Z>`，则会计算 *await-suspend*`.resume()`。
>
> $*注* 1：这会恢复 *await-suspend* 返回的协程。通过这种方式可以连续恢复任意数量的协程，最终将控制流返回到当前协程的调用者或恢复者（[\[dcl.fct.def.coroutine$]\([https://eel.is/c++draft/dcl.fct.def.coroutine)）。—](https://eel.is/c++draft/dcl.fct.def.coroutine%29）。—) *注结束*]

该注释虽然是非规范性的，因此不是强制性的，但它强烈建议编译器在实现时应该使用尾调用来恢复下一个协程，而不是递归恢复。原因是递归恢复下一个协程会很容易在协程互相循环恢复时导致栈无限增长。

我们的问题在于，我们是在 `__g_resume()` 函数体内调用下一个协程的 `.resume()`，然后再返回，这意味着 `__g_resume()` 栈帧要等到下一个协程挂起并返回后才能释放。

编译器可以通过将恢复下一个协程实现为尾调用来解决这一问题。这样编译器会先弹出当前栈帧（保留返回地址），然后执行 `jmp` 到下一个协程的恢复函数。

由于 C++ 没有机制来指定尾调用，我们需要从恢复函数直接返回，以便释放栈空间，然后由调用方恢复下一个协程。

由于下一个协程挂起时也可能需要恢复另一个协程，这种情况可能无限发生，所以调用方需要在循环中恢复协程。

这种循环通常称为“蹦床循环”（trampoline loop），因为我们会从一个协程返回到循环，然后“弹”到下一个协程。

如果我们修改恢复函数的签名，使其返回下一个协程的协程状态指针而不是返回 void，那么 `coroutine_handle::resume()` 就可以立即调用下一个协程的 `__resume()` 函数指针来恢复它。

让我们先修改 `__coroutine_state` 的 `__resume_fn` 签名：

```
struct __coroutine_state {
    using __resume_fn = __coroutine_state* (__coroutine_state*);
    using __destroy_fn = void (__coroutine_state*);

    __resume_fn* __resume;
    __destroy_fn* __destroy;
};
```

然后 `coroutine_handle::resume()` 可以这样写：

```
void std::coroutine_handle<void>::resume() const {
    __coroutine_state* s = state_;
    do {
        s = s->__resume(s);
    } while (/* some condition */);
}
```

接下来的问题是：“条件应该是什么？”

这就是 `std::noop_coroutine()` 出场的地方。

`std::noop_coroutine()` 是一个工厂函数，它返回一个特殊的协程句柄，该句柄的 `resume()` 和 `destroy()` 方法都是 no-op。如果一个协程挂起并从 `await_suspend()` 返回 noop 协程句柄，这就表示没有下一个协程需要恢复，这次调用 `coroutine_handle::resume()` 应该返回给调用者。

因此我们需要实现 `std::noop_coroutine()`，并在 `coroutine_handle::resume()` 中的条件判断中，当 `__coroutine_state` 指针指向 noop 协程状态时退出循环。

一种策略是定义一个静态的 `__coroutine_state` 实例作为 noop 协程状态。`std::noop_coroutine()` 返回的协程句柄指向这个对象，我们可以比较指针地址来判断某个协程句柄是否是 noop 协程。

首先定义这个特殊的 noop 协程状态对象：

```
struct __coroutine_state {
    using __resume_fn = __coroutine_state* (__coroutine_state*);
    using __destroy_fn = void (__coroutine_state*);

    __resume_fn* __resume;
    __destroy_fn* __destroy;

    static __coroutine_state* __noop_resume(__coroutine_state* state) noexcept {
        return state;
    }

    static void __noop_destroy(__coroutine_state*) noexcept {}

    static const __coroutine_state __noop_coroutine;
};

inline const __coroutine_state __coroutine_state::__noop_coroutine{
    &__coroutine_state::__noop_resume,
    &__coroutine_state::__noop_destroy
};
```

然后我们可以实现 `std::coroutine_handle<noop_coroutine_promise>` 特化：

```
namespace std
{
    struct noop_coroutine_promise {};

    using noop_coroutine_handle = coroutine_handle<noop_coroutine_promise>;

    noop_coroutine_handle noop_coroutine() noexcept;

    template<>
    class coroutine_handle<noop_coroutine_promise> {
    public:
        constexpr coroutine_handle(const coroutine_handle&) noexcept = default;
        constexpr coroutine_handle& operator=(const coroutine_handle&) noexcept = default;

        constexpr explicit operator bool() noexcept { return true; }

        constexpr friend bool operator==(coroutine_handle, coroutine_handle) noexcept {
            return true;
        }

        operator coroutine_handle<void>() const noexcept {
            return coroutine_handle<void>::from_address(address());
        }

        noop_coroutine_promise& promise() const noexcept {
            static noop_coroutine_promise promise;
            return promise;
        }

        constexpr void resume() const noexcept {}
        constexpr void destroy() const noexcept {}
        constexpr bool done() const noexcept { return false; }

        constexpr void* address() const noexcept {
            return const_cast<__coroutine_state*>(&__coroutine_state::__noop_coroutine);
        }
    private:
        constexpr coroutine_handle() noexcept = default;

        friend noop_coroutine_handle noop_coroutine() noexcept {
            return {};
        }
    };
}
```

然后我们可以更新 `coroutine_handle::resume()`，在返回 noop 协程状态时退出：

```
void std::coroutine_handle<void>::resume() const {
    __coroutine_state* s = state_;
    do {
        s = s->__resume(s);
    } while (s != &__coroutine_state::__noop_coroutine);
}
```

最后，我们可以更新 `__g_resume()` 函数，使其返回 `__coroutine_state*`。

这只需要更新函数签名，并将：

```
coro_to_resume = ...;
goto resume_coro;
```

替换为

```
auto h = ...;
return static_cast<__coroutine_state*>(h.address());
```

然后在函数的最后（`delete state;` 语句之后）添加：

```
return static_cast<__coroutine_state*>(std::noop_coroutine().address());
```

## 最后一步

细心的读者可能已经注意到，协程状态类型 `__g_state` 实际上比它需要的要大。

4 个临时值的数据成员各自为自己的值预留了存储空间。然而，其中一些临时值的生命周期并不重叠，因此理论上我们可以在协程状态中复用对象的存储空间，让后一个对象在前一个对象生命周期结束后使用这块空间，从而节省内存。

为了实现这一点，我们可以在合适的地方将这些数据成员定义在匿名的 `union` 中。

来看一下这些临时变量的生命周期：

* `__tmp1` —— 只存在于 `co_await promise.initial_suspend();` 语句中
* `__tmp2` —— 只存在于 `int fx = co_await f(x);` 语句中
* `__tmp3` —— 只存在于 `int fx = co_await f(x);` 语句中（嵌套在 `__tmp2` 的生命周期内）
* `__tmp4` —— 只存在于 `co_await promise.final_suspend();` 语句中

由于 `__tmp2` 和 `__tmp3` 的生命周期是重叠的，所以它们必须放在同一个 `struct` 中，因为它们需要同时存在。

然而，`__tmp1` 和 `__tmp4` 的生命周期并不重叠，因此它们可以放在同一个匿名 `union` 中。

因此，我们可以将数据成员定义改为：

```
struct __g_state : __coroutine_state_with_promise<__g_promise_t> {
    __g_state(int&& x);
    ~__g_state();

    int __suspend_point = 0;
    int x;

    struct __scope1 {
        manual_lifetime<task> __tmp2;
        manual_lifetime<task::awaiter> __tmp3;
    };

    union {
        manual_lifetime<std::suspend_always> __tmp1;
        __scope1 __s1;
        manual_lifetime<task::promise_type::final_awaiter> __tmp4;
    };
};
```

接着，由于 `__tmp2` 和 `__tmp3` 现在被嵌套在 `__s1` 对象中，我们需要将它们的引用更新为例如 `state->__s1.tmp2`。除此之外，其他代码保持不变。

这样可以额外节省 16 个字节的协程状态大小，因为我们不再需要为 `__tmp1` 和 `__tmp4` 单独分配存储空间和填充（padding）——尽管它们是空类型，但原本会被填充到指针大小。


## 整合所有内容

好的，现在我们已经得到了为协程函数生成的最终代码：

```
task g(int x) {
    int fx = co_await f(x);
    co_return fx * fx;
}
```

is the following:

```
/////
// The coroutine promise-type

using __g_promise_t = std::coroutine_traits<task, int>::promise_type;

__coroutine_state* __g_resume(__coroutine_state* s);
void __g_destroy(__coroutine_state* s);

/////
// The coroutine-state definition

struct __g_state : __coroutine_state_with_promise<__g_promise_t> {
    __g_state(int&& x)
    : x(static_cast<int&&>(x)) {
        // Initialise the function-pointers used by coroutine_handle methods.
        this->__resume = &__g_resume;
        this->__destroy = &__g_destroy;

        // Use placement-new to initialise the promise object in the base-class
        // after we've initialised the argument copies.
        ::new ((void*)std::addressof(this->__promise))
            __g_promise_t(construct_promise<__g_promise_t>(this->x));
    }

    ~__g_state() {
        this->__promise.~__g_promise_t();
    }

    int __suspend_point = 0;

    // Argument copies
    int x;

    // Local variables/temporaries
    struct __scope1 {
        manual_lifetime<task> __tmp2;
        manual_lifetime<task::awaiter> __tmp3;
    };

    union {
        manual_lifetime<std::suspend_always> __tmp1;
        __scope1 __s1;
        manual_lifetime<task::promise_type::final_awaiter> __tmp4;
    };
};

/////
// The "ramp" function

task g(int x) {
    std::unique_ptr<__g_state> state(new __g_state(static_cast<int&&>(x)));
    decltype(auto) return_value = state->__promise.get_return_object();

    state->__tmp1.construct_from([&]() -> decltype(auto) {
        return state->__promise.initial_suspend();
    });
    if (!state->__tmp1.get().await_ready()) {
        state->__tmp1.get().await_suspend(
            std::coroutine_handle<__g_promise_t>::from_promise(state->__promise));
        state.release();
        // fall through to return statement below.
    } else {
        // Coroutine did not suspend. Start executing the body immediately.
        __g_resume(state.release());
    }
    return return_value;
}

/////
//  The "resume" function

__coroutine_state* __g_resume(__coroutine_state* s) {
    auto* state = static_cast<__g_state*>(s);

    try {
        switch (state->__suspend_point) {
        case 0: goto suspend_point_0;
        case 1: goto suspend_point_1; // <-- add new jump-table entry
        default: std::unreachable();
        }

suspend_point_0:
        {
            destructor_guard tmp1_dtor{state->__tmp1};
            state->__tmp1.get().await_resume();
        }

        //  int fx = co_await f(x);
        {
            state->__s1.__tmp2.construct_from([&] {
                return f(state->x);
            });
            destructor_guard tmp2_dtor{state->__s1.__tmp2};

            state->__s1.__tmp3.construct_from([&] {
                return static_cast<task&&>(state->__s1.__tmp2.get()).operator co_await();
            });
            destructor_guard tmp3_dtor{state->__s1.__tmp3};

            if (!state->__s1.__tmp3.get().await_ready()) {
                state->__suspend_point = 1;

                auto h = state->__s1.__tmp3.get().await_suspend(
                    std::coroutine_handle<__g_promise_t>::from_promise(state->__promise));

                // A coroutine suspends without exiting scopes.
                // So cancel the destructor-guards.
                tmp3_dtor.cancel();
                tmp2_dtor.cancel();

                return static_cast<__coroutine_state*>(h.address());
            }

            // Don't exit the scope here.
            // We can't 'goto' a label that enters the scope of a variable with a
            // non-trivial destructor. So we have to exit the scope of the destructor
            // guards here without calling the destructors and then recreate them after
            // the `suspend_point_1` label.
            tmp3_dtor.cancel();
            tmp2_dtor.cancel();
        }

suspend_point_1:
        int fx = [&]() -> decltype(auto) {
            destructor_guard tmp2_dtor{state->__s1.__tmp2};
            destructor_guard tmp3_dtor{state->__s1.__tmp3};
            return state->__s1.__tmp3.get().await_resume();
        }();

        //  co_return fx * fx;
        state->__promise.return_value(fx * fx);
        goto final_suspend;
    } catch (...) {
        state->__promise.unhandled_exception();
        goto final_suspend;
    }

final_suspend:
    // co_await promise.final_suspend
    {
        state->__tmp4.construct_from([&]() noexcept {
            return state->__promise.final_suspend();
        });
        destructor_guard tmp4_dtor{state->__tmp4};

        if (!state->__tmp4.get().await_ready()) {
            state->__suspend_point = 2;
            state->__resume = nullptr; // mark as final suspend-point

            auto h = state->__tmp4.get().await_suspend(
                std::coroutine_handle<__g_promise_t>::from_promise(state->__promise));

            tmp4_dtor.cancel();
            return static_cast<__coroutine_state*>(h.address());
        }

        state->__tmp4.get().await_resume();
    }

    //  Destroy coroutine-state if execution flows off end of coroutine
    delete state;

    return static_cast<__coroutine_state*>(std::noop_coroutine().address());
}

/////
// The "destroy" function

void __g_destroy(__coroutine_state* s) {
    auto* state = static_cast<__g_state*>(s);

    switch (state->__suspend_point) {
    case 0: goto suspend_point_0;
    case 1: goto suspend_point_1;
    case 2: goto suspend_point_2;
    default: std::unreachable();
    }

suspend_point_0:
    state->__tmp1.destroy();
    goto destroy_state;

suspend_point_1:
    state->__s1.__tmp3.destroy();
    state->__s1.__tmp2.destroy();
    goto destroy_state;

suspend_point_2:
    state->__tmp4.destroy();
    goto destroy_state;

destroy_state:
    delete state;
}

```

要查看最终代码的完整可编译版本，请参见： [https://godbolt.org/z/xaj3Yxabn](https://godbolt.org/z/xaj3Yxabn)

至此，这个关于理解 C++ 协程机制的五篇系列文章就告一段落了。

这可能包含了比你原本想了解的更多的协程信息，但我希望它能帮助你理解协程的底层运行机制，并稍微揭开它的神秘面纱。

感谢你坚持读到最后！

下次再见，
Lewis
