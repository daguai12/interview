# 协程理论（Coroutine Theory）

**发表于 2017 年 9 月 25 日** ([Asymmetric Transfer][1])

这是系列文章的第一篇，聚焦于 C++ Coroutines TS（技术规范），一种被计划在 C++20 标准中引入的新语言特性。([Asymmetric Transfer][1])

在这个系列中，我将介绍 C++ 协程的底层机制，并展示如何凭借它们构建有实用价值的高级抽象，例如 cppcoro 库中提供的抽象。([Asymmetric Transfer][1])

本篇将描述函数和协程之间的差异，并提供一些关于它们所支持操作的理论基础，旨在帮助你建立对 C++ 协程认知的框架。([Asymmetric Transfer][1])

---

## 协程即函数亦是协程（Coroutines are Functions are Coroutines）

协程是对函数的泛化，允许函数在执行过程中被挂起（suspend），并在随后得以恢复（resume）执行。([Asymmetric Transfer][1])

我稍后会更详细解释这句话的含义，但首先想先回顾一下“普通” C++ 函数的工作方式。([Asymmetric Transfer][1])

---

## “普通”函数

一个普通函数可以用两种操作来理解：**调用（Call）** 和 **返回（Return）**（这里广义上也把抛出异常当作返回操作的一种）。([Asymmetric Transfer][1])

* **调用（Call）**：调用操作会创建一个激活帧（activation frame），使调用者挂起，并转而开始执行被调用函数。([Asymmetric Transfer][1])
* **返回（Return）**：返回操作将返回值传递给调用者，销毁被调函数的激活帧，并恢复调用者的执行，从它调用点之后接着执行。([Asymmetric Transfer][1])

下面我们来深入分析一下这些语义细节… ([Asymmetric Transfer][1])

---

### 激活帧（Activation Frames）

什么是“激活帧”？激活帧可被视为存储函数调用当前状态的一块内存区域，其中包括传递给函数的参数值和局部变量值。([Asymmetric Transfer][1])

对于普通函数，激活帧还包含返回地址（也就是函数执行完成后要跳转回调用方的位置）和调用方激活帧的地址。这些信息共同描述了函数调用的“续延”（continuation）：即当函数完成时，哪个函数的哪一处应该继续执行。([Asymmetric Transfer][1])

普通函数的激活帧具备严格嵌套的生命周期，这使得我们可以使用高效的内存分配结构——即“栈”（stack），来分配和回收这些激活帧。([Asymmetric Transfer][1])

这种栈结构非常常见，以至于大多数（或全部）CPU 架构都提供一个专用寄存器（例如在 x64 上是 `rsp` 寄存器）指向栈顶。你只需通过这个寄存器对栈进行加减，就能分配或释放激活帧空间。([Asymmetric Transfer][1])

---

### 调用（Call）操作

当一个函数调用另一个函数时，调用者首先要为自身执行挂起做准备。这通常涉及将当前在 CPU 寄存器中的值保存到内存中，以便稍后恢复（具体由调用约定决定 caller 和 callee 谁负责保存寄存器值，但可以将其视为 Call 操作的一部分）。([Asymmetric Transfer][1])

然后，调用者将参数值存储到新激活帧中，以供被调用函数访问。([Asymmetric Transfer][1])

最后，调用者将恢复点地址写入新激活帧，并将控制权转移到被调用函数的开头。例如在 x86/x64 架构中，`call` 指令会将下一个指令地址压入栈，调整栈寄存器，然后跳转到目标函数。([Asymmetric Transfer][1])

---

### 返回（Return）操作

当函数执行 `return` 语句返回时，它会将返回值（若有）存放在调用者能访问的位置，可能位于调用者或自身的激活帧中（具体方案可能因参数与返回值跨帧情况略有区别）。([Asymmetric Transfer][1])

接着函数销毁激活帧，过程包括：

* 销毁当前作用范围内的局部变量
* 销毁参数对象
* 释放激活帧所占内存

之后恢复调用者的激活帧状态，包括恢复栈指针和寄存器，并跳转回调用者预先存储的恢复点。([Asymmetric Transfer][1])

根据调用约定，有些 Return 逻辑可能在 caller 与 callee 间分担实现。([Asymmetric Transfer][1])

---

## 协程（Coroutines）

协程扩展了函数的概念，在 Call 和 Return 的基础上引入了三个额外的操作：**挂起（Suspend）**、**恢复（Resume）** 以及 **销毁（Destroy）**。([Asymmetric Transfer][1])

* **挂起（Suspend）**：协程在当前执行点被挂起，并将执行权交还给调用者或恢复者（resumer）。此过程不会销毁激活帧，挂起时范围内的对象仍保持存活。([Asymmetric Transfer][1]) 注意协程只能在自身的某些明确挂起点（例如 `co_await` 或 `co_yield`）执行挂起操作。

* **恢复（Resume）**：恢复一个已挂起的协程，从其挂起点继续执行。这需要重新激活协程的激活帧。([Asymmetric Transfer][1])

* **销毁（Destroy）**：在不恢复执行协程的情况下，销毁协程的激活帧。这会销毁挂起点范围内所有对象，并释放内存。([Asymmetric Transfer][1])

---

### 协程的激活帧

由于协程可能被挂起但不销毁激活帧，其生命周期不再严格嵌套，故不能始终使用栈来分配激活帧，通常需要将其分配到堆上。([Asymmetric Transfer][1])

不过，C++ Coroutines TS 提供了一些机制：如果编译器能够证明协程的生命周期严格嵌套于调用者，还能在调用者帧中分配协程帧，从而避免堆分配。([Asymmetric Transfer][1])

协程激活帧可逻辑上拆分为两部分：**协程帧（coroutine frame）**与**栈帧（stack frame）**。前者存储跨挂起点的数据并持续存在，后者则仅在协程执行期间存在，并在挂起时释放。([Asymmetric Transfer][1])

---

### 挂起（Suspend）操作详解

协程在遇到挂起点（`co_await` 或 `co_yield`）时，会：

1. 将寄存器值写入协程帧；
2. 向帧中记录当前挂起点编号，以便后续 Resume 或 Destroy 知道从哪继续，或需要销毁哪些对象；
3. 将协程标记为挂起状态。

随后，还可能执行额外逻辑（例如调度或注册恢复回调），该逻辑通过协程句柄获得的框架控制权可以安排协程后续恢复。([Asymmetric Transfer][1])

接着协程可以选择立即恢复自身或将控制权交回调用者。若交回，**栈帧**部分会弹出释放。([Asymmetric Transfer][1])

---

### 恢复（Resume）操作详解

恢复通过调用协程句柄的 `resume()` 方法进行。这会：

* 分配一个新的栈帧；
* 保存调用者的返回地址；
* 根据协程帧存储的挂起点跳转继续执行。

恢复完成后，若协程再次挂起或完成，该 `resume()` 调用会返回，恢复调用者的执行。([Asymmetric Transfer][1])

---

### 销毁（Destroy）操作详解

当协程不再需要继续执行时，可以调用句柄的 `destroy()` 方法以销毁它。这会：

* 激活协程帧，分配栈帧，保存返回地址；
* 跳转至一个特殊路径——执行挂起点作用域中对象的析构；
* 释放协程帧占用的内存；
* 再恢复调用者执行。([Asymmetric Transfer][1])

---

### 协程的“调用”（Call）

协程的 Call 操作与普通函数类似，但从调用者视角看无差异：调用者分配栈帧、写入参数、写入返回地址，并跳转至协程体。但协程接收到调用后，会在堆上创建协程帧，将参数搬入该帧，以保证其生命周期跨越挂起点。([Asymmetric Transfer][1])

---

### 协程的“返回”（Return）

协程的返回（即执行 `co_return`）与普通函数不同。它会：

1. 将返回值存放在某处（可由用户定义机制控制）；
2. 析构当前挂起点作用域内的局部变量（但参数不一定）；
3. 可执行自定义逻辑，如发布结果或恢复其他协程；
4. 选择执行 Suspend（保持协程帧）或 Destroy（销毁它）；
5. 根据选定路径将控制权交回调用者或恢复者，并释放栈帧。([Asymmetric Transfer][1])

值得注意的是，`co_return` 执行时可能晚于初始调用，因此其处理逻辑与普通函数返回时机不一致。([Asymmetric Transfer][1])

---

## 图示演示

文中还举简例说明协程被调用、挂起再恢复时堆栈与堆内存的布局变化，帮助理解这些操作。([Asymmetric Transfer][1])

为了帮助大家将这些概念可视化，我来逐步演示协程在调用、挂起和恢复过程中的具体变化。

假设我们有一个函数（或协程）`f()`，它调用了另一个协程`x(int a)`。

在调用发生前，内存布局大致如下：

```
STACK                     REGISTERS               HEAP
+----------------+ <-+
|  x()           |   |
| a  = 42        |   |
| ret= f()+0x123 |   |    +------+
+----------------+   +--- | rsp  |
|  f()           |        +------+
+----------------+
| ...            |
|                |
```

当调用`x(42)`时，和普通函数一样，首先会为`x()`创建栈帧：

```
栈（STACK）               寄存器（REGISTERS）        堆（HEAP）
+----------------+ <-+
|  x()的栈帧      |   |
| 参数a = 42      |   |
| 返回地址= f()+0x123|   |    +------+
+----------------+   +--- | rsp  |  （栈指针更新为x()栈帧的顶部）
|  f()的栈帧      |        +------+
+----------------+
| ...            |
|                |
```

接着，当协程`x()`在堆上为协程帧分配内存，并将参数值复制/移动到协程帧后，内存布局会变成下图所示。注意：编译器通常会用一个独立的寄存器存储协程帧的地址（例如MSVC使用rbp寄存器）。

```
STACK                     REGISTERS               HEAP
+----------------+ <-+
|  x()           |   |
| a  = 42        |   |                   +-->  +-----------+
| ret= f()+0x123 |   |    +------+       |     |  x()      |
+----------------+   +--- | rsp  |       |     | a =  42   |
|  f()           |        +------+       |     +-----------+
+----------------+        | rbp  | ------+
| ...            |        +------+
|                |
```

如果协程`x()`调用了另一个普通函数`g()`，内存布局会变成这样：

```
STACK                     REGISTERS               HEAP
+----------------+ <-+
|  g()           |   |
| ret= x()+0x45  |   |
+----------------+   |
|  x()           |   |
| coroframe      | --|-------------------+
| a  = 42        |   |                   +-->  +-----------+
| ret= f()+0x123 |   |    +------+             |  x()      |
+----------------+   +--- | rsp  |             | a =  42   |
|  f()           |        +------+             +-----------+
+----------------+        | rbp  |
| ...            |        +------+
|                |
```

当`g()`返回时，它的栈帧会被销毁，`x()`的栈帧会恢复。假设我们将`g()`的返回值存入协程帧中的局部变量`b`：

```
STACK                     REGISTERS               HEAP
+----------------+ <-+
|  x()           |   |
| a  = 42        |   |                   +-->  +-----------+
| ret= f()+0x123 |   |    +------+       |     |  x()      |
+----------------+   +--- | rsp  |       |     | a =  42   |
|  f()           |        +------+       |     | b = 789   |
+----------------+        | rbp  | ------+     +-----------+
| ...            |        +------+
|                |
```

如果此时`x()`遇到挂起点并挂起执行（但不销毁自身栈帧），执行权会返回给`f()`。

此时`x()`的栈帧会从栈中弹出，但堆上的协程帧会保留。当协程第一次挂起时，会向调用者返回一个值，这个值通常包含指向被挂起协程帧的句柄，用于后续恢复执行。`x()`挂起时还会将自身的恢复点地址（简称RP）存储在协程帧中：

```
STACK                     REGISTERS               HEAP
                                        +----> +-----------+
                          +------+      |      |  x()      |
+----------------+ <----- | rsp  |      |      | a =  42   |
|  f()           |        +------+      |      | b = 789   |
| handle     ----|---+    | rbp  |      |      | RP=x()+99 |
| ...            |   |    +------+      |      +-----------+
|                |   |                  |
|                |   +------------------+
```

这个句柄可以像普通值一样在函数间传递。一段时间后（可能在不同的调用栈甚至不同的线程中），某个函数（比如`h()`）会决定恢复该协程的执行（例如异步I/O操作完成时）。

恢复协程的函数会调用`void resume(handle)`来恢复协程执行。对调用者来说，这看起来就像调用一个带单个参数的普通void函数。

调用`resume()`会创建新的栈帧（记录调用者到`resume()`的返回地址），通过将协程帧地址加载到寄存器来激活协程帧，并从协程帧中存储的恢复点开始执行`x()`：

```
STACK                     REGISTERS               HEAP
+----------------+ <-+
|  x()           |   |                   +-->  +-----------+
| ret= h()+0x87  |   |    +------+       |     |  x()      |
+----------------+   +--- | rsp  |       |     | a =  42   |
|  h()           |        +------+       |     | b = 789   |
| handle         |        | rbp  | ------+     +-----------+
+----------------+        +------+
| ...            |
|                |
``` 

---

## 总结

本文深入阐释了协程如何泛化函数概念：在“调用”和“返回”的基础上增加“挂起”、“恢复”与“销毁”三种操作。作者希望这能帮助读者建立理解协程控制流的正确思维模型。([Asymmetric Transfer][1])

---

如果你还希望我继续翻译后续系列中的文章（比如《理解 operator co\_await》或《理解 promise 类型》），或者希望对某些概念进行详细讲解，随时欢迎告诉我！

[1]: https://lewissbaker.github.io/2017/09/25/coroutine-theory "Coroutine Theory | Asymmetric Transfer"
