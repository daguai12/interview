`io_uring_wait_cqe_nr` 是 `io_uring` 框架中用于阻塞等待指定数量的完成队列项（CQE）的函数，适用于需要批量处理多个异步 I/O 完成事件的场景。

### 函数作用
该函数会阻塞当前线程，直到完成队列（CQ）中积累了至少 `num` 个未处理的 CQE（完成队列项），或被信号中断。它是批量等待异步 I/O 结果的高效接口，避免了对单个 CQE 进行多次等待的开销。

### 代码解析
```c
io_uring_wait_cqe_nr(&m_uring, &cqe, num);
```

- **参数**：
  - `&m_uring`：指向已初始化的 `struct io_uring` 实例的指针，即要等待的 io_uring 对象。
  - `&cqe`：输出参数，指向一个指针，用于接收第一个可用 CQE 的地址。
  - `num`：需要等待的最小 CQE 数量（至少为 1）。

- **返回值**：
  - 成功获取到至少 `num` 个 CQE 时，返回实际可用的 CQE 数量（≥ `num`），此时 `cqe` 指向第一个可用的 CQE。
  - 失败时返回负数错误码（如 `-EINTR` 表示被信号中断，`-EINVAL` 表示参数无效）。

### 工作机制
- 若调用时 CQ 中已有的未处理 CQE 数量 ≥ `num`，函数会立即返回，不会阻塞。
- 否则，函数会阻塞等待，直到 CQ 中的 CQE 数量达到 `num` 或被信号中断。

### 使用场景
适用于批量提交异步 I/O 任务后，需要一次性处理多个结果的场景，例如：
1. 高并发 I/O 场景中，一次性提交大量读/写任务，再批量等待结果以减少系统调用次数。
2. 需控制处理粒度的场景，例如每积累 10 个完成事件就集中处理一次。

### 使用流程
1. 批量提交多个异步 I/O 任务（通过 `io_uring_submit`）。
2. 调用 `io_uring_wait_cqe_nr` 等待至少 `num` 个 CQE 可用。
3. 循环处理从 `cqe` 开始的多个 CQE（数量为返回值），获取每个操作的 `res`（结果）和 `user_data`（关联信息）。
4. 调用 `io_uring_cq_advance` 批量标记这些 CQE 为已处理（参数为处理的 CQE 数量）。

### 注意事项
- 实际返回的 CQE 数量可能大于 `num`（取决于 CQ 中已积累的数量）。
- 需通过返回值确定实际可处理的 CQE 数量，避免越界访问。
- 若只需等待单个 CQE，使用 `io_uring_wait_cqe` 更简洁；若需设置超时，可使用 `io_uring_wait_cqes`。

`io_uring_wait_cqe_nr` 提供了批量等待和处理完成事件的能力，能有效降低高并发场景下的系统调用开销，提升处理效率。