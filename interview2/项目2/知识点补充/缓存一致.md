当锁明显被占用时，如果直接执行`exchange`操作（而没有先做`load`检查），确实会触发缓存失效，这与原子操作的底层实现和CPU缓存一致性协议的工作机制密切相关。


### 关键原因：`exchange`是"写操作"，会修改共享变量
`atomic::exchange(new_value)`是一个**读-改-写复合操作**，它的本质是：
1. 读取原子变量的当前值（`old_value`）
2. 将新值（`new_value`）写入原子变量
3. 返回`old_value`

无论原变量的值是什么（即使已经是`true`，表示锁被占用），`exchange`都会**强制写入一个新值**（这里是`true`）。虽然从逻辑上看，"把`true`改成`true`"似乎是无意义的，但从CPU和缓存的角度，这仍然是一次**写操作**。


### 写操作必然触发缓存一致性协议
现代多核心CPU中，每个核心都有自己的缓存（L1/L2）。当一个核心要修改共享变量（如`lock_`）时，必须通过**缓存一致性协议**（如MESI协议）确保其他核心看到最新值，这个过程会导致：

1. 执行`exchange`的核心会先获取该变量的**独占权限**（Exclusive状态）。
2. 其他核心缓存中如果存在该变量的副本，会被标记为**失效**（Invalid状态）。
3. 其他核心后续访问该变量时，必须重新从内存或更高层级的缓存中加载（缓存失效，cache miss）。


### 举例说明：锁被占用时的`exchange`操作
假设线程A已持有锁（`lock_ = true`），此时线程B执行`try_lock()`：

- 如果没有先做`load`检查，线程B会直接执行`exchange(true)`：
  - 线程B的CPU核心会尝试将`lock_`从`true`改为`true`（逻辑上无意义，但仍是写操作）。
  - 这会触发缓存一致性协议：线程A的CPU缓存中`lock_`的副本会被标记为失效。
  - 线程A后续如果要操作`lock_`（比如释放锁时的`store(false)`），就必须重新加载该变量（缓存失效导致的性能损耗）。

- 而如果先做`load`检查：
  - 线程B通过`load`发现`lock_ = true`（锁被占用），直接返回`false`，不执行`exchange`。
  - 没有写操作，也就不会触发缓存一致性协议，其他核心的缓存不受影响。


### 总结
`exchange`操作即使"写入与原值相同的值"，本质上仍是一次写操作。写操作会触发缓存一致性协议，导致其他核心中该变量的缓存副本失效。这就是为什么即使锁明显被占用，直接执行`exchange`也会造成不必要的缓存失效——因为写操作本身会破坏缓存一致性，迫使其他核心重新加载数据，带来性能开销。

而先用`load(memory_order_relaxed)`做轻量检查，可以过滤掉明显不可能成功的场景，避免无意义的写操作和缓存失效，这是一种典型的"用轻量操作减少重量操作开销"的优化思路。