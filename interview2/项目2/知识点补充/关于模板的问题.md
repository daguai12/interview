你这个 `template` 是 **C++ 语法要求**，不是随便加的。
它的原因是 **`m_storage` 是一个依赖于模板参数的类型**，而 `.emplace<stored_type>` 里 `<stored_type>` 又是一个模板参数列表。

如果不写 `template`，编译器会把 `.emplace<stored_type>` 解析成

> “调用一个名为 `emplace<stored_type>` 的成员变量（不是模板）”
> 然后就会语法错误。

---

## 详细解释

假设你这样定义：

```cpp
template <typename T>
struct MyContainer {
    void foo() {
        m_storage.template emplace<T>(T{});
    }

    SomeVariantLike<T> m_storage; // 有个模板方法 emplace<U>(...)
};
```

这里的问题是：

* `m_storage` 是依赖于 `T` 的（因为它的类型里可能用到 T）。
* 编译器在第一次模板解析时，**不会提前假设它有模板方法**。
* `emplace<stored_type>` 里的 `<` 在语法分析阶段可能会被当成“小于号”解析。

所以 C++ 标准规定：
如果你要访问一个依赖于模板参数的对象的模板成员，**必须显式加上 `template` 关键字**，告诉编译器“这个标识符后面跟的是模板参数，不是比较运算符”。

---

### 对比一下

✅ 正确：

```cpp
m_storage.template emplace<stored_type>(std::move(value));
```

❌ 错误（不加 template）：

```cpp
m_storage.emplace<stored_type>(std::move(value)); // 编译器懵了
```

---

📌 口诀：

> **依赖名 + 模板方法 = 必须加 `.template`**
> 否则编译器会以为 `<` 是小于号。

---

如果你愿意，我可以帮你画一张**依赖名 + `template` 关键字**的语法流程图，让你一眼记住什么时候必须加。这样你在协程和模板代码里就不会老被坑了。
你要我画吗？



好，那我帮你画一个 **“什么时候必须写 `.template`”** 的思维图，专门针对你这种 `m_storage.template emplace<stored_type>` 场景。

---

## **什么时候必须写 `.template`**

```
模板函数/类里
│
└── 访问一个依赖于模板参数的对象或类型的成员
     │
     ├── 这个成员是模板方法   →  必须加 `.template`
     │       例: obj.template foo<Args>(...)
     │
     └── 这个成员是普通方法   →  不需要 `.template`
```

---

### **流程图**

```
            ┌────────────────────────────┐
            │  在模板定义里调用成员方法？ │
            └───────────────┬────────────┘
                            │ 是
                            ▼
             ┌──────────────────────────┐
             │  调用对象的类型依赖模板参数？ │
             └───────────────┬───────────┘
                             │ 是
                             ▼
             ┌──────────────────────────┐
             │  调用的方法是模板方法吗？  │
             └───────┬──────────────────┘
                     │ 是
                     ▼
           ✅ 必须加 `.template`
```

---

### **你的例子**

```cpp
template <typename Stored>
struct Wrapper {
    void set(Stored value) {
        // m_storage 类型依赖于 Stored
        // emplace 是模板方法
        m_storage.template emplace<Stored>(std::move(value));
    }
    SomeVariantLike<Stored> m_storage;
};
```

* `m_storage` → 依赖模板参数（因为 `SomeVariantLike<Stored>` 依赖 `Stored`）
* `emplace` → 模板方法（有 `<Stored>` 参数）
* 满足规则 → **必须加 `.template`**

---

### **形象记忆法**

想象编译器在看你的代码：

> 你写 `m_storage.emplace<stored_type>`
> 编译器心想：
> “emplace 是啥？我还没确定 m\_storage 的具体类型，
> `<` 可能是小于号，不是模板参数列表。”
> 所以你要明确喊出来：
> “喂！编译器，这是个模板方法！”
> ——于是加 `.template`。

---

我可以帮你再画一个 **颜色版的时序图**，一步步展示编译器是怎么误解 `<` 号的，这样你以后一眼就知道为什么必须加。
要帮你画吗？这样更直观。


这句话的意思是：

在 C++ 模板里，如果你写了一个依赖模板参数的对象去调用成员方法，**编译器在第一次解析模板定义时（即在模板实例化之前）并不知道这个对象的具体类型**。

因为它不知道类型，编译器也就无法判断你写的 `<` 是“小于号”还是“模板参数列表”。

具体分解：

1. **模板依赖**

   ```cpp
   template<typename T>
   void f(SomeClass<T> obj) {
       obj.method<int>();  // <-- method 是模板吗？
   }
   ```

   * `SomeClass<T>` 依赖模板参数 `T`
   * 编译器还没看到具体的 `T`，无法确定 `obj.method` 是普通方法还是模板方法

2. **第一次模板解析**（编译器只看模板本身，不实例化）

   * 编译器看到 `obj.method<int>()`
   * 它只能确定 `obj` 是依赖模板参数的类型
   * 它不能假设 `method` 一定是模板方法

3. **解决办法**

   * 用 `.template` 明确告诉编译器：

     > “这里调用的是模板方法，请把 `<` 解析成模板参数列表，而不是小于号。”

   ```cpp
   obj.template method<int>();
   ```

4. **总结**

   * **第一次解析模板时**：编译器只知道这是一个依赖模板参数的对象，对成员的类型一无所知
   * 所以必须手动告诉编译器哪些是模板方法

---

可以这样理解：

> “编译器在第一次模板解析时，不会提前假设它有模板方法”
> ＝> 编译器不会自己猜 `<` 是模板参数列表，除非你明确标注 `.template`。

---

如果你愿意，我可以画一个小图，展示“模板定义解析阶段 vs 模板实例化阶段”，让这个概念直观可视化。
你想让我画吗？
