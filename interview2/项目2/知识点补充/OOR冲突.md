你提到的是C++17引入的**内联变量（inline variables）** 特性，它确实解决了传统C++中在头文件定义变量可能导致的**ODR（One Definition Rule，单一定义规则）** 冲突问题。

具体来说：

1. **传统问题**：在C++17之前，如果在头文件中直接定义全局变量（如`int ginfo;`），当多个源文件包含该头文件时，会导致变量在每个编译单元中都被定义一次，链接时就会出现"多重定义"错误（违反ODR规则）。

2. **内联变量的解决方式**：
   - 用`inline`关键字修饰变量（如`inline int ginfo = 0;`），允许在头文件中直接定义
   - 编译器保证即使被多个源文件包含，链接后整个程序中也只会有一个实例
   - 本质上和内联函数类似，通过允许多次声明但保证单一实例来避免ODR冲突

3. **典型用途**：
   - 定义全局常量或单例实例
   - 作为类的静态成员变量（无需在cpp文件中单独定义）

例如，在头文件中可以这样写：
```cpp
// global.h
inline int ginfo = 42;  // 内联变量定义

class MyClass {
public:
    inline static int s_count = 0;  // 内联静态成员变量
};
```
任何包含`global.h`的源文件都可以直接使用`ginfo`和`MyClass::s_count`，且整个程序中只会有一个实例，不会产生链接冲突。

这一特性极大简化了头文件中全局变量和类静态成员的定义方式，是C++17中非常实用的改进。