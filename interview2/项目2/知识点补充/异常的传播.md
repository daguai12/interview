在 C++ 协程中，异常处理的行为确实与普通函数有明显差异，核心原因在于**协程的执行模型是“暂停 - 恢复”式的，异常传播需要适配协程的生命周期和状态管理**。以下从原理层面拆解“为何协程未捕获异常不会直接向上传播”，以及 C++ 协程如何通过 `promise_type` 控制异常行为。


### 一、普通函数的异常传播：“调用栈链式展开”
普通函数的异常传播依赖**调用栈的“链式展开”**：  
1. 函数 `f()` 抛出异常 → 立即终止 `f()` 的执行。  
2. 回到调用 `f()` 的上层函数 `g()`，检查是否有 `try/catch`。  
3. 若没有，继续向上层函数 `h()` 展开，直到找到 `catch` 或到达程序入口（`main`）。  
4. 若全程无 `catch`，程序调用 `std::terminate` 终止。  

这种行为的本质是**调用栈是“线性的、同步的”**，异常可以沿着调用链（栈帧）回溯。  


### 二、协程的异常传播：“异步暂停 - 恢复”模型的冲突
协程的执行模型是**“暂停 - 恢复”**，其生命周期与调用栈解耦（协程帧在堆上，调用栈可能早已销毁）。如果直接让协程的异常“向上传播”，会面临以下问题：  
1. **调用栈可能已不存在**：  
   协程暂停后，调用 `resume()` 的“调用者”可能不是最初启动协程的函数（比如由 IO 事件驱动恢复），传统的“调用链”已断裂。  
2. **协程的“暂停点”需要精准控制**：  
   异常若直接传播，可能跳过协程的暂停逻辑（如 `co_await` 的唤醒），导致协程状态损坏。  


### 三、C++ 协程如何处理异常？依赖 `promise_type` 的钩子函数
C++ 协程通过 `promise_type`（协程的“状态载体”）定义**异常的捕获、处理和传播规则**，核心钩子是：  
```cpp
struct promise_type {
  // 当协程内部抛出未捕获的异常时，会调用此函数
  void unhandled_exception() {
    // 可选择：
    // 1. 保存异常到 promise（供调用者 later 处理）
    m_exception = std::current_exception();
    // 2. 直接终止程序（类似普通函数）
    // std::terminate();
  }
};
```  

结合你的流程图和 `next()` 函数，异常处理流程是：  
1. 协程执行中抛出异常 → 触发 `promise_type::unhandled_exception()`。  
2. `unhandled_exception()` 可选择**保存异常到 `promise`**（如 `p.m_exception`），而非直接传播。  
3. 调用者通过 `next()` 获取结果时（如 `return p.m_yield;`），可检查 `p.m_exception`，主动 `rethrow`：  
   ```cpp
   if (p.m_exception) {
     std::rethrow_exception(p.m_exception);
   }
   ```  


### 四、“异常不自动向上传播”的设计意图
C++ 协程的设计者选择让异常**通过 `promise` 显式传递**，而非隐式传播，主要是为了：  
1. **适配协程的异步模型**：  
   协程可能在任意时刻被暂停/恢复，调用栈可能频繁变化，隐式传播异常容易导致不可预测的行为。  
2. **赋予开发者控制权**：  
   通过 `promise_type::unhandled_exception()`，开发者可灵活决定：  
   - 保存异常（延迟处理，比如在调用者 `next()` 时再抛出）；  
   - 记录日志后忽略异常；  
   - 直接终止程序（模拟普通函数行为）。  


### 五、结合你的 `next()` 函数看异常流程
你的 `next()` 函数中已有对异常的处理：  
```cpp
if (p.m_execption) {
  std::rethrow_exception(p.m_execption);
}
```  

完整异常流程：  
1. 协程内部抛出异常 → 触发 `promise_type::unhandled_exception()`，保存异常到 `p.m_exception`。  
2. 调用者执行 `next()` → 恢复协程（若未完成），然后检查 `p.m_exception`。  
3. 若有异常，`std::rethrow_exception` 将异常抛回调用者，此时异常才会“向上传播”到调用者的 `try/catch`。  


### 六、总结：为何协程异常不自动传播？
- **执行模型差异**：协程的“暂停 - 恢复”与调用栈解耦，隐式传播异常会破坏状态。  
- **显式控制需求**：通过 `promise_type` 显式处理异常，让开发者能适配异步/暂停场景。  
- **设计意图**：C++ 协程的哲学是“让 `promise` 成为协程与调用者的桥梁”，异常也不例外——通过 `promise` 显式传递，而非隐式依赖调用栈。  


简单来说：**普通函数的异常依赖“调用栈”链式传播，而协程的异常依赖“`promise`”显式传递**。这种设计让协程能适配更复杂的异步场景，代价是需要开发者在 `promise` 中主动处理异常传递。