在 C++ 中，协程被称为“无栈协程”（stackless coroutine），核心原因在于它**不保存完整的调用栈结构**，而是通过编译器生成的状态机和堆内存保存必要的运行状态。这与“有栈协程”（stackful coroutine）形成鲜明对比，后者需要保存完整的调用栈。下面从技术细节展开解释：


### 一、“无栈”的核心含义：不保存完整调用栈
传统的线程或有栈协程在切换时，需要保存**整个调用栈**（包括函数调用链中的局部变量、返回地址、寄存器状态等），因为它们的执行上下文依赖于完整的栈结构。而 C++ 协程的“无栈”指的是：  
**协程暂停时，不复制或保存完整的调用栈，仅保存协程自身的局部状态和执行位置**。


### 二、C++ 协程如何保存状态？依赖“协程帧”和状态机
C++ 协程的运行状态通过以下机制保存，而非完整栈：  

1. **协程帧（Coroutine Frame）**  
   当协程被创建时，编译器会自动生成一个**堆分配的结构体（协程帧）**，用于保存：  
   - 协程的局部变量（如函数内定义的变量）；  
   - 协程的暂停/恢复状态（例如当前执行到哪个暂停点 `co_await`）；  
   - 与协程关联的临时值、返回值或等待对象的引用；  
   - 必要的寄存器状态（如程序计数器 PC，标记下一次恢复时从哪里执行）。  

   这个帧由堆内存分配（而非栈内存），其生命周期独立于调用栈，因此协程暂停后，即使调用栈被销毁，帧仍可保留。


2. **状态机转换**  
   编译器会将协程代码分解为一个**状态机**，每个 `co_await` 或 `co_yield` 对应一个“暂停点”，状态机通过标记当前暂停点来记录执行进度。例如：  
   ```cpp
   task<int> foo() {
       int a = 1;
       co_await bar();  // 暂停点1：保存状态，等待bar完成
       int b = 2;
       co_yield a + b;  // 暂停点2：返回结果，等待再次激活
   }
   ```  
   编译器会将这段代码转换为多个状态（如“初始状态”“暂停点1后”“暂停点2后”），状态机通过协程帧中的标记记录当前处于哪个状态，恢复时直接从对应状态继续执行，无需重建完整栈。


### 三、为何需要额外内存？堆内存用于“协程帧”而非“栈”
用户提到“协程创建需要额外内存”，这部分内存主要用于分配**协程帧**（堆内存），但它与“栈”有本质区别：  
- 栈内存是线性的、连续的，遵循“先进后出”（FILO）规则，用于函数调用链的临时存储；  
- 协程帧是堆上的结构化数据，仅保存协程自身的局部状态和执行位置，不包含完整的调用栈链。  

因此，协程的内存开销源于堆分配的帧，而非复制栈，这也是“无栈”定义的核心：**不依赖或保存完整的调用栈结构**。


### 四、与有栈协程的对比：为什么“无栈”更轻量？
| 特性    | 有栈协程（如某些语言的 `goroutine` 早期实现） | 无栈协程（C++ 协程）              |
| ----- | ----------------------------- | ------------------------- |
| 状态保存  | 完整的调用栈（包括所有函数的局部变量、寄存器）       | 仅协程自身的局部变量和执行位置（协程帧）      |
| 内存开销  | 较大（栈通常需要预分配固定大小，如 8KB）        | 较小（堆分配的帧，大小按需动态确定）        |
| 切换效率  | 较低（需保存/恢复整个栈和寄存器）             | 较高（仅需切换状态机和协程帧）           |
| 上下文依赖 | 依赖完整栈，可在任意函数调用中暂停             | 仅能在协程内部的暂停点（`co_await`）暂停 |


### 总结
C++ 协程被称为“无栈协程”，是因为它**不保存完整的调用栈结构**，而是通过堆分配的“协程帧”和编译器生成的状态机保存必要的执行状态。虽然创建协程需要额外的堆内存（用于协程帧），但这部分内存并非传统意义上的“栈”，因此从定义上属于“无栈”。这种设计让 C++ 协程比有栈协程更轻量，切换效率更高，适合高并发场景。