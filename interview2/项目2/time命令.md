从你提供的程序运行结果来看，这是对两个程序（`func_call` 和 `sys_call`）的执行时间分析，主要反映了**用户态函数调用**和**系统调用**的性能差异。下面详细解释这些指标的含义和对比分析：


### 一、基础概念：`time` 命令输出指标
`time` 命令用于测量程序的执行时间，输出包含三个核心指标（以 `func_call` 为例）：
```
Executed in    6.48 millis    # 总耗时（real time，实际墙上时间）
   usr time    3.91 millis    # 用户态时间：程序在用户空间执行的时间
   sys time    2.66 millis    # 系统态时间：程序在内核空间执行的时间（如系统调用）
```
- **real time**：从程序启动到结束的实际流逝时间（包括等待、调度延迟等）。
- **usr time**：程序在**用户态**（非内核）执行代码的时间（如用户定义的函数、运算等）。
- **sys time**：程序因执行**系统调用**（如 `read`、`getpid` 等）进入**内核态**后，内核为其服务的时间（如权限检查、资源分配等）。


### 二、两个程序的输出对比
#### 1. `./func_call` 分析
- 程序自身打印：`Time spent in user call: 0.548968 seconds`  
  （推测：程序测量了某段**用户态函数调用**的累计耗时，比如循环调用自定义函数）
- `time` 命令总耗时：`6.48 millis`（实际总执行时间极短）  
- `usr time (3.91 millis)` > `sys time (2.66 millis)`  
  说明程序主要在**用户态**执行，内核态操作（系统调用）很少。


#### 2. `./sys_call` 分析
- 程序自身打印：`Time spent in system call: 0.514034 seconds`  
  （推测：程序测量了某段**系统调用**的累计耗时，比如循环调用 `getpid`、`read` 等系统函数）
- `time` 命令总耗时：`90.12 millis`（总时间是 `func_call` 的 14 倍）  
- `sys time (50.98 millis)` > `usr time (39.19 millis)`  
  说明程序频繁进入**内核态**执行，系统调用开销显著。


### 三、关键差异分析
#### 1. 系统调用 vs 用户态函数的开销
- **用户态函数调用**（`func_call`）：  
  用户态函数在用户空间直接执行，无需切换到内核态，开销极低（主要是函数栈帧的创建和销毁）。因此总时间短，且 `sys time` 占比低。

- **系统调用**（`sys_call`）：  
  系统调用需要从用户态切换到内核态（涉及 CPU 权限切换、上下文保存/恢复、内核校验等），这一过程开销较大。因此总时间更长，且 `sys time` 占比高（内核为系统调用服务的时间）。


#### 2. 程序内计时 vs `time` 命令计时的差异
注意到程序自身打印的时间（如 `0.548 秒`）远大于 `time` 命令的总耗时（`6.48 毫秒`），这是因为：  
- 程序内计时：通常是**循环内目标操作的累计耗时**（比如循环 100 万次调用函数/系统调用的总时间）。  
- `time` 命令计时：是**整个程序从启动到退出的总时间**（包括初始化、循环、收尾等所有操作）。  
两者的差异反映了目标操作（函数调用/系统调用）是程序的核心耗时部分，而其他操作（如循环控制、计时逻辑）开销可忽略。


#### 3. 性能数据对比
| 指标                | `func_call`（用户态函数） | `sys_call`（系统调用） | 差异倍数 |
|---------------------|--------------------------|------------------------|----------|
| 总耗时（real time） | 6.48 毫秒                | 90.12 毫秒             | ~14 倍   |
| 用户态时间（usr）   | 3.91 毫秒                | 39.19 毫秒             | ~10 倍   |
| 系统态时间（sys）   | 2.66 毫秒                | 50.98 毫秒             | ~19 倍   |

差异表明：**系统调用的平均开销远高于用户态函数调用**，这也是为什么实际开发中应尽量减少不必要的系统调用（或通过批量操作减少调用次数）。


### 四、总结
1. **用户态 vs 内核态**：用户态操作开销低，系统调用因权限切换和内核处理开销高。  
2. **`time` 命令价值**：通过 `usr time` 和 `sys time` 可快速定位程序耗时瓶颈（是用户态逻辑还是系统调用）。  
3. **性能优化启示**：若程序 `sys time` 占比过高，可能需要优化系统调用（如减少调用次数、使用批量接口）；若 `usr time` 高，则需优化用户态算法或逻辑。

这个对比清晰展示了“用户态操作”和“内核态操作”的性能差异，是理解程序性能瓶颈的重要依据。