`x` 是 **examine** 的缩写。

这个命令是 GDB 中最常用的命令之一，用于\*\*检查（examine）\*\*内存中的内容。

它的基本语法是：

```
x /[N][F][U] <address>
```

  * **`x`**: examine 命令。
  * **`[N]`**: 一个可选的数字，表示要显示多少个单位的内存。
  * **`[F]`**: 一个可选的格式字符，表示如何显示内存内容。
  * **`[U]`**: 一个可选的单位大小字符，表示每个单位有多大。
  * **`<address>`**: 要检查的内存起始地址。

### 常用格式 [F] 和单位 [U]

#### 格式 (Format):

  * `x` - 十六进制 (hexadecimal) (默认)
  * `d` - 有符号十进制 (decimal)
  * `u` - 无符号十进制 (unsigned decimal)
  * `o` - 八进制 (octal)
  * `t` - 二进制 (two)
  * `c` - 字符 (char)
  * `s` - 字符串 (null-terminated string)
  * `i` - 机器指令 (instruction)

#### 单位大小 (Unit Size):

  * `b` - 字节 (byte, 8 bits)
  * `h` - 半字 (halfword, 16 bits)
  * `w` - 字 (word, 32 bits)
  * `g` - 双字 (giant word, 64 bits)

### 简单示例

假设你想查看栈顶（`$rsp`）开始的 4 个 64位整数，并以十六进制显示：

```gdb
(gdb) x/4gx $rsp
```

  * `/4` - 显示 4 个单位。
  * `g` - 每个单位是 64 位 (giant word)。
  * `x` - 以十六进制格式显示。
  * `$rsp` - 从栈顶寄存器的地址开始。

另一个例子，查看某个地址上的字符串：

```gdb
(gdb) x/s 0x4005f4
```

再一个例子，反汇编 `main` 函数的头 5 条指令：

```gdb
(gdb) x/5i main
```

在 GDB (GNU Debugger) 中，`x` 命令的默认单位是 **`w`**，即 **word (字)**。

一个 "word" 的大小通常是 **4 字节 (32 位)**。

所以，如果你只输入 `x <address>`，GDB 会默认执行 `x/1xw <address>`，即：

  * **1**: 显示 1 个单位。
  * **x**: 以十六进制格式显示。
  * **w**: 每个单位是 4 字节。

### 重要特性：GDB 会记住上次的设置

需要特别注意的是，GDB 为了方便使用，会**记住你上次为 `x` 命令指定的单位、格式和数量**。

**举个例子：**

1.  你第一次输入，查看某个地址的 2 个字节：

    ```gdb
    (gdb) x/2b 0x4005f0
    0x4005f0:   0x48    0x89
    ```

    这里你指定了单位是 `b` (byte)。

2.  下一次你再使用 `x` 命令，但**不指定单位**，GDB 会**沿用上次的 `b` (byte)**，而不是回到默认的 `w` (word)。

    ```gdb
    (gdb) x 0x4005f2
    0x4005f2:   0xe7    0x48
    ```

    你会发现它仍然是按字节显示的，而不是按 4 字节的字来显示。格式（十六进制）和数量（2个）也会被记住。

### 总结 GDB `x` 命令的默认值

  * **数量 (Count)**: 默认为 **1**。
  * **格式 (Format)**: 默认为 **`x` (十六进制)**。
  * **单位 (Unit Size)**: 默认为 **`w` (word, 4 字节)**。

但是，这三个设置都会被 GDB **“记住”**，并在下次调用时沿用，直到你明确指定新的设置为止。


# 案例

好的，当然可以。下面我将通过一个简单的C语言程序和一系列GDB调试步骤，由浅入深地为您展示 `x` 命令的多种用法。

### 第一步：准备一个用于演示的C程序

这个程序包含不同类型的变量（整数、字符、数组、指针等），非常适合用来观察内存。

将下面的代码保存为 `demo.c`:

```c
#include <stdio.h>

// 全局变量
int global_int = 0x11223344;
char global_str[] = "GDB is powerful!";

void a_simple_function() {
    // 一个空函数，用来观察指令
}

int main() {
    long long local_long = 0xAABBCCDDEEFF0011;
    short local_shorts[4] = {0x1001, 0x2002, 0x3003, 0x4004};
    char *ptr_to_str = global_str;

    // 我们将在这里设置断点，以观察上述变量
    printf("Breakpoint is set here.\n");

    return 0;
}
```

### 第二步：编译并启动GDB

为了让GDB能够获取到变量名等调试信息，我们需要使用 `-g` 选项来编译。

```bash
# 编译程序
gcc -g -o demo demo.c

# 启动GDB
gdb ./demo
```

进入GDB后，我们在 `printf` 函数后设置一个断点并运行程序，这样当程序暂停时，所有的局部变量都已经初始化好了。

```gdb
# 在 main 函数的第18行设置断点
(gdb) b 18

# 运行程序
(gdb) run
```

现在程序已经停在了断点处，我们可以开始使用 `x` 命令探索内存了。

-----

### GDB `x` 命令使用案例

#### 案例1：基本用法 - 查看变量的原始内存

`x` 命令最基础的用法是查看一个地址的内存，默认以4字节(word)、十六进制(hex)格式显示。

```gdb
# 查看全局变量 global_int 的内存
# &global_int 表示取该变量的地址
(gdb) x &global_int
0x555555558004 <global_int>:	0x11223344
```

**解读**：

  * `x &global_int` 显示了 `global_int` 变量所在地址 `0x555555558004` 的内容。
  * 默认显示1个word（4字节），内容是 `0x11223344`，与我们定义的一致。
  * 注意：在小端序（Little-endian）机器上，内存中实际存储顺序是 `44 33 22 11`，GDB会智能地为你组合成正确的值。

#### 案例2：指定格式 (`F`) - 用不同方式解读内存

我们可以告诉 `x` 命令用不同的格式来解析同一块内存。

```gdb
# 以十进制(d)格式查看 global_int
(gdb) x/d &global_int
0x555555558004 <global_int>:	287454020

# 以二进制(t)格式查看 global_int
(gdb) x/t &global_int
0x555555558004 <global_int>:	00010001001000100011001101000100

# 以字符(c)格式查看 global_int 的第一个字节
(gdb) x/c &global_int
0x555555558004 <global_int>:	68 'D'
```

**解读**：

  * `x/d`：将 `0x11223344` 解释为有符号十进制数。
  * `x/t`：显示其二进制表示。
  * `x/c`：将其内存的第一个字节解释为字符。在小端序机器上，第一个字节是 `0x44`，对应的ASCII码就是字符 'D'。

#### 案例3：查看字符串 (`s`) 和字符数组 (`c`)

`x` 命令是查看字符串内容的利器。

```gdb
# 以字符串(s)格式查看 global_str
(gdb) x/s global_str
0x555555556020 <global_str>:	"GDB is powerful!"

# 以字符(c)格式查看 global_str 的前5个字节
(gdb) x/5c global_str
0x555555556020 <global_str>:	71 'G'	68 'D'	66 'B'	32 ' '	105 'i'
```

**解读**：

  * `x/s` 会一直显示字符，直到遇到 `\0` (字符串结束符) 为止。`global_str` 是一个数组名，它本身就代表了数组的首地址。
  * `x/5c` 则精确地显示了5个字节，并将它们分别解释为字符。

#### 案例4：指定数量 (`N`) 和单位 (`U`) - 查看数组

这是 `x` 命令最灵活的用法，可以精确地控制查看的范围和步长。

```gdb
# 查看 short 类型数组 local_shorts
# /4h 表示查看4个单位，每个单位是半字(h, 2字节)
(gdb) x/4h local_shorts
0x7fffffffdc58:	0x1001	0x2002	0x3003	0x4004

# 同样是 local_shorts，但这次我们按字节(b)查看前8个字节
(gdb) x/8b local_shorts
0x7fffffffdc58:	0x01	0x10	0x02	0x20	0x03	0x30	0x04	0x40
```

**解读**：

  * `x/4h` 的结果与我们定义的数组完全一致。
  * `x/8b` 的结果清晰地展示了小端序的存储方式：`0x1001` 在内存中是 `0x01` 后面跟着 `0x10`。

#### 案例5：检查指针和它指向的内容

`x` 命令可以清晰地区分“指针变量本身的值”和“指针指向地址的内容”。

```gdb
# 查看指针变量 ptr_to_str 本身的值
# 它存的是一个地址，在64位系统上是8字节(g)
(gdb) x/g &ptr_to_str
0x7fffffffdc60:	0x0000555555556020

# 直接使用 ptr_to_str，查看它指向的内容
# 因为它指向一个字符串，所以用 /s 格式
(gdb) x/s ptr_to_str
0x555555556020 <global_str>:	"GDB is powerful!"
```

**解读**：

  * 第一条命令 (`x/g &ptr_to_str`) 查看了 `ptr_to_str` 这个局部变量，它存的值是 `0x...6020`，这正是 `global_str` 的地址。
  * 第二条命令 (`x/s ptr_to_str`) 直接把 `ptr_to_str` 的值（一个地址）拿过来，并从那个地址开始解析成字符串。

#### 案例6：反汇编指令 (`i`)

`x` 命令还可以用来查看函数对应的机器指令。

```gdb
# 查看 a_simple_function 函数的头3条指令
(gdb) x/3i a_simple_function
   0x555555555149 <a_simple_function>:	endbr64 
   0x55555555514d <a_simple_function+4>:	push   %rbp
   0x55555555514e <a_simple_function+5>:	mov    %rsp,%rbp
```

**解读**：

  * `x/3i` 将 `a_simple_function` 函数的起始地址处的内存解释为3条机器指令并显示出来。

-----

通过以上这些案例，你应该对 `x` 命令的强大功能有了全面的了解。它是你在GDB中深入探索程序内部状态不可或缺的工具。