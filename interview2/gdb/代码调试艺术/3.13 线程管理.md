### **3.13 线程管理**

对于现代程序来讲，大多情况下是多个线程在同时工作，从而充分利用系统资源。测试程序也不例外。

为了使示例简单而且不影响功能，我们创建一个名为 `thread_management_example.cpp` 的文件，并新增一个函数来创建线程。

**代码清单：`thread_management_example.cpp`**

```cpp
#include <iostream>
#include <thread>
#include <vector>
#include <chrono>

// 全局变量，所有线程共享
int count = 0;

// 线程函数
void do_work(int thread_id) {
    // 1. 对全局变量执行加1操作
    count++;

    // 2. 打印一些信息
    std::cout << "Thread " << thread_id << " is working, count is " << count << std::endl;

    // 3. 等待3秒
    std::this_thread::sleep_for(std::chrono::seconds(3));

    std::cout << "Thread " << thread_id << " finished." << std::endl;
}

// 创建并启动线程的函数
void start_threads(int thread_num) {
    std::vector<std::thread> threads;
    for (int i = 0; i < thread_num; ++i) {
        // 创建并启动线程
        threads.emplace_back(do_work, i + 1);
    }

    // 等待所有线程结束
    for (auto& t : threads) {
        t.join();
    }
}

int main() {
    // 启动10个线程
    start_threads(10);
    return 0;
}
```

在上面的代码中，`do_work` 是线程函数，它接收一个线程ID，对全局变量 `count` 执行加1操作，然后等待3秒并打印信息。`start_threads` 函数根据输入的 `thread_num` 参数来创建相应数量的线程，并等待所有线程执行结束。

因为用到了线程函数（`std::thread`）和标准库的`vector`，所以需要包含 `<thread>` 和 `<vector>` 等相关头文件。

如果直接使用 `g++ thread_management_example.cpp -o app` 编译链接代码，会链接失败，并提示 `undefined reference to 'pthread_create'`。

**链接失败示例**

```bash
$ g++ thread_management_example.cpp -o app
/tmp/ccXXXXXX.o: In function `std::thread::thread<void (&)(int), int&>(void (&)(int), int&)':
thread_management_example.cpp:(.text._ZSt6threadC2IRFviEJRiEEOT_DpOT0_[_ZSt6threadC2IRFviEJRiEEOT_DpOT0_]+0x3b): undefined reference to `pthread_create'
collect2: error: ld returned 1 exit status
```

这是因为我们在程序中用到了线程函数，但是链接时不包含线程库。我们需要在Makefile或编译命令中添加线程库 `pthread`。

**添加 `pthread` 并成功构建**

```bash
# -lpthread 也可以写为 -pthread
g++ thread_management_example.cpp -o app -lpthread
```

再次执行命令，即可成功构建出可执行文件 `app`。

现在开始用gdb调试多线程程序。启动gdb后，先在 `start_threads` 函数中设置一个断点，以方便观察线程信息。可以把断点设置在 `for` 循环之后、`join` 之前的位置（即第32行），然后执行 `r` 命令，使程序在该行处中断。

```bash
$ gdb ./app
(gdb) b 32
Breakpoint 1 at 0x1234: file thread_management_example.cpp, line 32.
(gdb) r
Starting program: /path/to/app
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
[New Thread 0x7ffff7dae640 (LWP 12345)]
[New Thread 0x7ffff7d2d640 (LWP 12346)]
... (其他线程创建信息) ...
[New Thread 0x7ffff5a2b640 (LWP 12354)]

Breakpoint 1, start_threads (thread_num=10) at thread_management_example.cpp:32
32          for (auto& t : threads) {
```

程序在第32行处中断下来，此时10个子线程已经被创建并开始执行。

### **3.13.1 查看所有线程信息**

使用命令 `info threads` 查看当前进程所有的线程信息。

**查看所有线程**

```gdb
(gdb) info threads
  Id   Target Id         Frame
* 1    Thread 0x7ffff7fbe740 (LWP 12344) "app" main () at thread_management_example.cpp:40
  2    Thread 0x7ffff7dae640 (LWP 12345) "app" 0x00007ffff7ea8bfb in __GI___nanosleep (remaining=0x0, requested_time=0x7ffff7dadc10) at ../sysdeps/unix/sysv/linux/nanosleep.c:28
  3    Thread 0x7ffff7d2d640 (LWP 12346) "app" 0x00007ffff7ea8bfb in __GI___nanosleep (remaining=0x0, requested_time=0x7ffff7d2cc10) at ../sysdeps/unix/sysv/linux/nanosleep.c:28
  4    Thread 0x7ffff7cac640 (LWP 12347) "app" 0x00007ffff7ea8bfb in __GI___nanosleep (remaining=0x0, requested_time=0x7ffff7cabb10) at ../sysdeps/unix/sysv/linux/nanosleep.c:28
  5    Thread 0x7ffff7c2b640 (LWP 12348) "app" 0x00007ffff7ea8bfb in __GI___nanosleep (remaining=0x0, requested_time=0x7ffff7c2ac10) at ../sysdeps/unix/sysv/linux/nanosleep.c:28
  6    Thread 0x7ffff7baa640 (LWP 12349) "app" 0x00007ffff7ea8bfb in __GI___nanosleep (remaining=0x0, requested_time=0x7ffff7ba9c10) at ../sysdeps/unix/sysv/linux/nanosleep.c:28
  7    Thread 0x7ffff7b29640 (LWP 12350) "app" 0x00007ffff7ea8bfb in __GI___nanosleep (remaining=0x0, requested_time=0x7ffff7b28c10) at ../sysdeps/unix/sysv/linux/nanosleep.c:28
  8    Thread 0x7ffff7aa8640 (LWP 12351) "app" 0x00007ffff7ea8bfb in __GI___nanosleep (remaining=0x0, requested_time=0x7ffff7aa7c10) at ../sysdeps/unix/sysv/linux/nanosleep.c:28
  9    Thread 0x7ffff7a27640 (LWP 12352) "app" 0x00007ffff7ea8bfb in __GI___nanosleep (remaining=0x0, requested_time=0x7ffff7a26c10) at ../sysdeps/unix/sysv/linux/nanosleep.c:28
  10   Thread 0x7ffff5a2b640 (LWP 12353) "app" 0x00007ffff7ea8bfb in __GI___nanosleep (remaining=0x0, requested_time=0x7ffff5a2ac10) at ../sysdeps/unix/sysv/linux/nanosleep.c:28
  11   Thread 0x7ffff59aa640 (LWP 12354) "app" 0x00007ffff7ea8bfb in __GI___nanosleep (remaining=0x0, requested_time=0x7ffff59a9c10) at ../sysdeps/unix/sysv/linux/nanosleep.c:28
```

从上面的信息可以看到，当前进程共有11个线程（1个主线程 + 10个工作线程），编号为1\~11。其中1号线程（主线程）前面有一个 `*` 号，表示它是当前GDB正在关注的线程。每个线程信息还包含其执行位置，可以看到2\~11号这10个线程都处于系统 `nanosleep.c` 文件中，因为它们都在调用 `sleep_for` 函数。

### **3.13.2 切换线程**

当前线程很重要，因为很多命令（如 `bt`, `f`, `print`）都是针对当前线程有效的。如果想要查看某个线程的堆栈信息，必须先切换到该线程。切换线程的命令是 `thread 线程ID`。

如果想要切换到2号线程，则执行 `thread 2`（简写为 `t 2`）。

**切换到2号线程**

```gdb
(gdb) thread 2
[Switching to thread 2 (Thread 0x7ffff7dae640 (LWP 12345))]
#0  0x00007ffff7ea8bfb in __GI___nanosleep (remaining=0x0, requested_time=0x7ffff7dadc10) at ../sysdeps/unix/sysv/linux/nanosleep.c:28
28      ../sysdeps/unix/sysv/linux/nanosleep.c: No such file or directory.
(gdb) i threads
  Id   Target Id         Frame
  1    Thread 0x7ffff7fbe740 (LWP 12344) "app" main () at thread_management_example.cpp:40
* 2    Thread 0x7ffff7dae640 (LWP 12345) "app" 0x00007ffff7ea8bfb in __GI___nanosleep (remaining=0x0, requested_time=0x7ffff7dadc10) at ../sysdeps/unix/sysv/linux/nanosleep.c:28
  ... (其他线程信息) ...
```

再次执行 `i threads` 命令，可以看到 `*` 号已经移到了2号线程前面，确认切换成功。现在，可以使用堆栈命令来查看该线程的信息。

**查看2号线程的栈回溯信息**

```gdb
(gdb) bt
#0  0x00007ffff7ea8bfb in __GI___nanosleep (remaining=0x0, requested_time=0x7ffff7dadc10) at ../sysdeps/unix/sysv/linux/nanosleep.c:28
#1  0x00007ffff7ea8b5f in __sleep (seconds=0) at ../sysdeps/posix/sleep.c:55
#2  0x000055555555566f in std::this_thread::sleep_for<long, std::ratio<1l, 1l> >(std::chrono::duration<long, std::ratio<1l, 1l> > const&) ()
#3  0x00005555555554f6 in do_work(int) (thread_id=1) at thread_management_example.cpp:17
#4  0x00005555555558d0 in void std::__invoke_impl<void, void (*)(int), int>(std::__invoke_other, void (*&&)(int), int&&) ()
#5  0x0000555555555869 in std::thread::_Invoker<std::tuple<void (*)(int), int> >::_M_invoke<0ul, 1ul>(std::_Index_tuple<0ul, 1ul>) ()
#6  0x000055555555580a in std::thread::_Invoker<std::tuple<void (*)(int), int> >::operator()() ()
#7  0x00005555555557d3 in std::thread::_State_impl<std::thread::_Invoker<std::tuple<void (*)(int), int> > >::_M_run() ()
#8  0x00007ffff7f40d90 in ?? () from /lib/x86_64-linux-gnu/libstdc++.so.6
#9  0x00007ffff7f93609 in start_thread (arg=<optimized out>) at pthread_create.c:477
#10 0x00007ffff7eb2293 in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:95
```

因为当前栈帧在系统函数 `nanosleep` 中，我们可以执行 `finish` 命令退出 `sleep_for` 函数，回到我们自己的代码 `do_work` 函数中。

**回到`do_work`并查看局部变量**

```gdb
(gdb) finish
Run till exit from #0  0x00007ffff7ea8bfb in __GI___nanosleep (remaining=0x0, requested_time=0x7ffff7dadc10) at ../sysdeps/unix/sysv/linux/nanosleep.c:28
Thread 2 "app" finished.
0x000055555555550a in do_work (thread_id=1) at thread_management_example.cpp:19
19          std::cout << "Thread " << thread_id << " finished." << std::endl;
Value returned is $1 = 0
(gdb) i locals
thread_id = 1
```

执行 `finish` 后，程序停在第19行。这时使用 `i locals` 即可查看到当前线程（2号线程）的局部变量 `thread_id` 的值为1。（注意：线程ID和GDB的线程编号不一定完全对应）。

### **3.13.3 为线程设置断点**

可以通过 `break` (或 `b`) 命令为特定的一个或多个线程设置断点。

例如，要为3号和4号线程在代码第11行处（`count++`）设置断点，可以使用以下命令：

```gdb
(gdb) b 11 thread 3
Breakpoint 2 at 0x5555555554aa: file thread_management_example.cpp, line 11.
(gdb) b 11 thread 4
Breakpoint 3 at 0x5555555554aa: file thread_management_example.cpp, line 11.
```

这会为线程3和线程4在代码11行处设置断点。通过 `info b` 命令也可以查看断点信息，发现只有这两个线程会在此处中断，其他线程执行到这里时不会命中。

**查看断点信息**

```gdb
(gdb) info b
Num     Type           Disp Enb Address            What
1       breakpoint     keep y   0x00005555555556cd in start_threads(int) at thread_management_example.cpp:32
2       breakpoint     keep y   0x00005555555554aa in do_work(int) at thread_management_example.cpp:11
        stop only in thread 3
3       breakpoint     keep y   0x00005555555554aa in do_work(int) at thread_management_example.cpp:11
        stop only in thread 4
```

### **3.13.4 为线程执行命令**

在调试时，可以为一个或多个指定的线程执行命令，而无需手动切换。命令语法为 `thread apply 线程号 命令`。

例如，我们可以为所有线程执行 `print` 命令，查看它们对应的 `thread_id` 变量的值。（注意：此命令只对已进入 `do_work` 函数的线程有效）。

**为指定线程执行命令**

```gdb
# 切换回主线程，让其他线程继续执行直到它们结束
(gdb) t 1
[Switching to thread 1 (Thread 0x7ffff7fbe740 (LWP 12344))]
#0  start_threads (thread_num=10) at thread_management_example.cpp:32
32          for (auto& t : threads) {
(gdb) thread apply 2 3 4 p thread_id
Thread 4 (Thread 0x7ffff7cac640 (LWP 12347)):
$2 = 3
Thread 3 (Thread 0x7ffff7d2d640 (LWP 12346)):
$3 = 2
Thread 2 (Thread 0x7ffff7dae640 (LWP 12345)):
$4 = 1
```

要使所有线程都执行命令，需要将线程号写为 `all`。查看每个线程的栈回溯（`bt`）是一个非常有用的功能，尤其是在大型程序中诊断死锁问题时。

**为所有线程执行bt命令**

```gdb
(gdb) thread apply all bt

Thread 11 (Thread 0x7ffff59aa640 (LWP 12354)):
#0  0x00007ffff7ea8bfb in __GI___nanosleep (remaining=0x0, requested_time=0x7ffff59a9c10) at ../sysdeps/unix/sysv/linux/nanosleep.c:28
#1  0x00007ffff7ea8b5f in __sleep (seconds=0) at ../sysdeps/posix/sleep.c:55
#2  0x000055555555566f in std::this_thread::sleep_for<long, std::ratio<1l, 1l> >(std::chrono::duration<long, std::ratio<1l, 1l> > const&) ()
#3  0x00005555555554f6 in do_work(int) (thread_id=10) at thread_management_example.cpp:17
...

Thread 10 (Thread 0x7ffff5a2b640 (LWP 12353)):
#0  0x00007ffff7ea8bfb in __GI___nanosleep (remaining=0x0, requested_time=0x7ffff5a2ac10) at ../sysdeps/unix/sysv/linux/nanosleep.c:28
#1  0x00007ffff7ea8b5f in __sleep (seconds=0) at ../sysdeps/posix/sleep.c:55
#2  0x000055555555566f in std::this_thread::sleep_for<long, std::ratio<1l, 1l> >(std::chrono::duration<long, std::ratio<1l, 1l> > const&) ()
#3  0x00005555555554f6 in do_work(int) (thread_id=9) at thread_management_example.cpp:17
...

... (其他线程的栈回溯信息) ...

Thread 1 (Thread 0x7ffff7fbe740 (LWP 12344)):
#0  start_threads (thread_num=10) at thread_management_example.cpp:32
#1  0x00005555555555b2 in main () at thread_management_example.cpp:40

```

由于每个线程的栈帧比较多，屏幕上可能无法全部显示。但该命令 `thread apply all bt` 极大地简化了检查所有线程状态的过程，是多线程调试中的一个利器。



# 案例说明

这个现象非常经典，它揭示了 GDB 在多线程调试中的一个重要行为：**默认情况下，当你让一个线程继续执行时，其他所有线程也会一起执行。**

简单来说，其他线程结束是因为在你输入 `finish` 命令后，它们也跟着“自由奔跑”并执行完了自己的所有任务。

-----

### \#\# 事件发生的过程

1.  **初始状态**：你所有的工作线程（包括线程2, 4, 6, 7, 8, 9等）都刚刚完成了3秒的休眠，全部处于“睡醒”状态，准备执行下一行代码。

2.  **你的命令**：你在线程4上输入了 `finish` 命令。这个命令的意思是“继续执行，直到当前函数（`sleep_for`）返回”。

3.  **GDB 的行为**：为了完成 `finish` 命令，GDB需要让程序**恢复运行**。GDB的默认模式（`scheduler-locking off`）是，一旦程序恢复运行，**所有**可以运行的线程都会被操作系统调度，一起向前执行。

4.  **多线程“赛跑”** 🏎️：

      * 就在线程4执行 `sleep_for` 剩余指令的这极短时间内，其他那些同样已经睡醒的线程（线程2, 6, 7, 8, 9等）也开始飞速执行。
      * 它们执行了 `sleep_for` 后面的代码，也就是打印 “finished” 的消息，然后走到了线程函数的末尾，于是就自然退出了。
      * 你看到的 `[Thread ... exited]` 是 GDB 告诉你这个线程已经运行结束并销毁了。

5.  **最终结果**：最后，线程4也完成了 `finish` 的目标，成功地从 `sleep_for` 返回，并停在了你自己写的 `do_work` 函数的第20行。但此时，其他很多线程已经跑完并退出了。

-----

### \#\# 如何只执行当前线程？

如果你希望在调试时，只让当前你关注的线程（比如线程4）执行，而让其他所有线程都保持暂停，你可以使用 GDB 的 **`scheduler-locking`** 命令。

  * **锁定执行**：在执行 `finish`, `next`, `step` 或 `continue` 之前，先输入这个命令：

    ```gdb
    (gdb) set scheduler-locking on
    ```

    这样设置之后，只有你当前选择的线程会动，其他线程都会被 GDB “冻结”。

  * **解除锁定**：当你希望所有线程恢复正常执行时，可以把它关掉：

    ```gdb
    (gdb) set scheduler-locking off
    ```

**总结**：你遇到的情况是 GDB 默认行为导致的“多线程赛跑”。要进行精细的单线程调试，请记得使用 `set scheduler-locking on`。