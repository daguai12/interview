以下是一个展示 GDB 调用堆栈（Call Stack）调试功能的完整案例，涵盖了“获取回溯、切换堆栈帧、检查堆栈帧信息”等操作。我们将通过一个包含多层函数调用的程序，演示如何使用 GDB 分析函数调用关系和堆栈信息。


### 示例程序：`stack_demo.c`
```c
#include <stdio.h>

// 第三层函数：计算两数之和
int add(int a, int b) {
    int sum = a + b;  // 第5行：设置断点
    return sum;
}

// 第二层函数：处理数据并调用 add
int process(int x, int y) {
    int temp = x * 2;          // 第10行
    int result = add(temp, y); // 第11行：调用 add 函数
    return result;
}

// 第一层函数：初始化参数并调用 process
void calculate() {
    int num1 = 3;   // 第17行
    int num2 = 5;   // 第18行
    int total = process(num1, num2);  // 第19行：调用 process 函数
    printf("计算结果：%d\n", total);  // 第20行
}

// 主函数：程序入口
int main() {
    printf("程序开始\n");  // 第26行
    calculate();           // 第27行：调用 calculate 函数
    printf("程序结束\n");  // 第28行
    return 0;
}
```


### 编译程序（带调试信息）
```bash
gcc -g -o stack_demo stack_demo.c
```


### GDB 调试步骤：分析调用堆栈
#### 1. 启动 GDB 并设置断点
```bash
gdb ./stack_demo  # 启动 GDB
```
在 `add` 函数内部（第5行）设置断点，跟踪函数调用流程：
```gdb
(gdb) break stack_demo.c:5  # 在 add 函数的 sum 计算行设断点
Breakpoint 1 at 0x555555555179: file stack_demo.c, line 5.
```


#### 2. 运行程序并触发断点
```gdb
(gdb) run  # 启动程序
Starting program: /home/your_user/stack_demo 
程序开始
```
程序执行到 `add` 函数第5行时触发断点：
```gdb
Breakpoint 1, add (a=6, b=5) at stack_demo.c:5
5        int sum = a + b;
```


#### 3. 获取调用堆栈回溯（`backtrace` 命令）
使用 `backtrace`（可缩写为 `bt`）查看函数调用链，即“程序如何执行到当前位置”：
```gdb
(gdb) backtrace  # 打印调用堆栈
#0  add (a=6, b=5) at stack_demo.c:5
#1  0x00005555555551c7 in process (x=3, y=5) at stack_demo.c:11
#2  0x0000555555555212 in calculate () at stack_demo.c:19
#3  0x0000555555555250 in main () at stack_demo.c:27
```
- 输出解读：  
  `#0` 是当前所在函数（`add`），`#1` 是调用 `add` 的函数（`process`），`#2` 是调用 `process` 的函数（`calculate`），`#3` 是最顶层的 `main` 函数。  
  整个调用链为：`main → calculate → process → add`。


#### 4. 切换堆栈帧（`frame` 命令）
使用 `frame <编号>`（可缩写为 `f <编号>`）切换到指定的堆栈帧，查看不同函数的上下文：
```gdb
(gdb) frame 1  # 切换到 #1 帧（process 函数）
#1  0x00005555555551c7 in process (x=3, y=5) at stack_demo.c:11
11        int result = add(temp, y);
```
此时 GDB 切换到 `process` 函数的调用位置（第11行）。

再切换到 `main` 函数所在的帧：
```gdb
(gdb) frame 3  # 切换到 #3 帧（main 函数）
#3  0x0000555555555250 in main () at stack_demo.c:27
27        calculate();
```


#### 5. 检查当前堆栈帧的详细信息
在任意堆栈帧中，可使用以下命令查看帧的详细信息：

##### （1）`info frame`：查看当前帧的内存地址、寄存器等信息
```gdb
(gdb) frame 1  # 先切换到 process 函数的帧
#1  0x00005555555551c7 in process (x=3, y=5) at stack_demo.c:11
11        int result = add(temp, y);

(gdb) info frame  # 查看该帧的详细信息
Stack level 1, frame at 0x7fffffffdd10:
 rip = 0x5555555551c7 in process (stack_demo.c:11); saved rip = 0x555555555212
 called by frame at 0x7fffffffdd40, caller of frame at 0x7fffffffdd00
 source language c.
 Arglist at 0x7fffffffdd00, args: x=3, y=5
 Locals at 0x7fffffffdd00, Previous frame's sp is 0x7fffffffdd10
 Saved registers:
  rbp at 0x7fffffffdd00, rip at 0x7fffffffdd08
```
- 信息解读：包括当前帧的内存地址（`0x7fffffffdd10`）、指令指针（`rip`）、调用者和被调用者的帧地址，以及保存的寄存器等。


##### （2）`info locals`：查看当前帧的局部变量
```gdb
(gdb) info locals  # 在 process 函数的帧中查看局部变量
temp = 6  # process 函数中 x*2 的结果（3*2=6）
result = 0  # 尚未赋值（此时刚进入 add 函数调用）
```


##### （3）`info args`：查看当前帧的函数参数
```gdb
(gdb) info args  # 查看 process 函数的参数
x = 3  # 传入的第一个参数
y = 5  # 传入的第二个参数
```

切换到 `calculate` 函数的帧（`#2`），检查其局部变量：
```gdb
(gdb) frame 2  # 切换到 calculate 函数
#2  0x0000555555555212 in calculate () at stack_demo.c:19
19        int total = process(num1, num2);

(gdb) info locals  # 查看 calculate 的局部变量
num1 = 3
num2 = 5
total = 0  # 尚未赋值（process 函数还未返回）
```


#### 6. 继续执行并退出调试
```gdb
(gdb) continue  # 继续执行程序
Continuing.
计算结果：11
程序结束
[Inferior 1 (process 12345) exited normally]

(gdb) quit  # 退出 GDB
```


### 总结
本案例通过多层函数调用演示了 GDB 堆栈调试的核心操作：  
- 用 `backtrace` 查看函数调用链（`main → calculate → process → add`）；  
- 用 `frame <编号>` 切换不同的堆栈帧，分析各函数的执行上下文；  
- 用 `info frame`、`info locals`、`info args` 分别查看帧的内存信息、局部变量和参数。  

这些操作在调试复杂程序时非常有用，能帮助定位“函数如何被调用”“参数是否正确传递”“局部变量是否符合预期”等问题。