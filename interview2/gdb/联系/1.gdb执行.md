以下是一个结合 GDB 常用调试操作的完整示例，涵盖了“停止执行、查看位置、单步调试、检查/修改变量、调用函数、从函数返回”等核心功能。我们将通过一个简单的 C 程序演示调试全过程：


### 示例程序：`debug_demo.c`
```c
#include <stdio.h>
#include <unistd.h>

// 辅助函数：计算平方
int square(int num) {
    int result = num * num;  // 第6行：后续将在此处设置断点
    return result;
}

// 主函数：循环计算并打印结果
int main() {
    int count = 0;
    int max = 5;

    printf("程序开始执行...\n");  // 第13行

    while (count < max) {
        int current = count + 1;
        int sq = square(current);  // 第17行：调用平方函数

        printf("第 %d 次循环：%d 的平方是 %d\n", count + 1, current, sq);
        count++;

        sleep(1);  // 第21行：休眠1秒，方便调试中断
    }

    printf("程序执行结束！\n");  // 第24行
    return 0;
}
```


### 编译程序（带调试信息）
```bash
gcc -g -o debug_demo debug_demo.c  # -g 选项添加调试信息
```


### GDB 调试全过程示例
#### 1. 启动 GDB 并运行程序
```bash
gdb ./debug_demo  # 启动 GDB 并加载程序
```
进入 GDB 交互界面后，运行程序：
```gdb
(gdb) run  # 开始执行程序
Starting program: /home/your_user/debug_demo 
程序开始执行...
第 1 次循环：1 的平方是 1
第 2 次循环：2 的平方是 4
```


#### 2. 停止程序执行（Ctrl+C 发送 SIGINT）
程序执行到 `sleep(1)` 时，按 `Ctrl+C` 中断：
```gdb
Program received signal SIGINT, Interrupt.
0x00007ffff7e61250 in nanosleep () from /lib/x86_64-linux-gnu/libc.so.6
```


#### 3. 查看程序停止的位置（`list` 命令）
```gdb
(gdb) list  # 显示当前停止位置附近的代码
16        int current = count + 1;
17        int sq = square(current);
18
19        printf("第 %d 次循环：%d 的平方是 %d\n", count + 1, current, sq);
20        count++;
21
22        sleep(1);  // 程序当前停在这一行（或附近的系统调用）
23    }
24
25    printf("程序执行结束！\n");
```


#### 4. 设置断点（`break` 命令）并继续执行
在 `square` 函数内部设置断点，然后继续执行：
```gdb
(gdb) break debug_demo.c:6  # 在 square 函数的第6行设置断点
Breakpoint 1 at 0x5555555551a9: file debug_demo.c, line 6.

(gdb) continue  # 继续执行程序
Continuing.
第 3 次循环：3 的平方是 9  # 程序执行到下一次循环

Breakpoint 1, square (num=4) at debug_demo.c:6  # 触发断点，停在 square 函数第6行
6        int result = num * num;
```


#### 5. 逐行单步执行（`next` 和 `step` 命令）
- `step` 命令：进入函数调用（若当前行有函数）；
- `next` 命令：跳过函数调用，直接执行下一行。

```gdb
(gdb) step  # 进入 square 函数内部，执行第6行
7        return result;  # 执行完第6行后，自动停在第7行

(gdb) next  # 执行第7行（返回语句），跳过函数内部细节
main () at debug_demo.c:18  # 回到 main 函数的调用处
18
19        printf("第 %d 次循环：%d 的平方是 %d\n", count + 1, current, sq);
```


#### 6. 检查变量值（`print` 命令）
```gdb
(gdb) print count  # 查看循环计数器
$1 = 3  # 当前是第3次循环（count 从0开始）

(gdb) print current  # 查看当前计算的数字
$2 = 4

(gdb) print sq  # 查看 square 函数的返回值
$3 = 16  # 4 的平方是 16
```


#### 7. 修改变量值（`set var` 命令）
临时修改 `max` 的值，让循环提前结束：
```gdb
(gdb) set var max = 4  # 将 max 从5改为4
(gdb) print max  # 验证修改结果
$4 = 4
```


#### 8. 调用程序中的函数（`call` 命令）
直接调用 `square` 函数计算 5 的平方：
```gdb
(gdb) call square(5)  # 调用函数并传入参数
$5 = 25  # 函数返回值为25
```


#### 9. 从函数返回（`finish` 命令）
若当前在函数内部，用 `finish` 执行完函数并返回调用者：
```gdb
(gdb) break square  # 重新在 square 函数入口设断点
Breakpoint 2 at 0x5555555551a0: file debug_demo.c, line 5.

(gdb) continue  # 继续执行，触发断点进入 square 函数
Continuing.
Breakpoint 2, square (num=5) at debug_demo.c:5
5    int result = num * num;

(gdb) finish  # 执行完 square 函数并返回
Run till exit from #0  square (num=5) at debug_demo.c:5
0x000055555555523b in main () at debug_demo.c:17
17        int sq = square(current);
Value returned is $6 = 25  # 函数返回值为25
```


#### 10. 继续执行到程序结束
```gdb
(gdb) continue  # 继续执行剩余代码
Continuing.
第 4 次循环：4 的平方是 16
程序执行结束！
[Inferior 1 (process 12345) exited normally]  # 程序正常退出
```


#### 11. 退出 GDB
```gdb
(gdb) quit  # 退出调试
```


### 总结
这个示例完整演示了 GDB 的核心调试流程：  
- 用 `run` 启动程序，`Ctrl+C` 停止执行；  
- 用 `list` 查看代码位置，`break` 设置断点；  
- 用 `step`/`next` 单步执行，`continue` 继续运行；  
- 用 `print` 检查变量，`set var` 修改变量；  
- 用 `call` 调用函数，`finish` 从函数返回。  

通过这些操作，你可以精准控制程序执行流程，定位并修复代码中的问题。