以下是一个涵盖 GDB 断点所有核心用法的完整案例，通过一个混合 C/C++ 代码的程序，演示“设置、管理、控制断点”的全流程。


### 准备程序：多文件混合代码
#### 1. C 源文件：`break_c.c`（含 C 函数）
```c
// break_c.c
#include <stdio.h>

// C 函数：计算累加和
int c_sum(int start, int end) {
    int sum = 0;
    for (int i = start; i <= end; i++) {  // 第6行：循环累加
        sum += i;
    }
    return sum;  // 第9行：返回结果
}
```

#### 2. C++ 源文件：`break_cpp.cpp`（含 C++ 类函数）
```cpp
// break_cpp.cpp
#include <iostream>
using namespace std;

class MathUtil {
public:
    // C++ 成员函数：计算乘积（重载两个版本）
    int multiply(int a, int b) {  // 版本1：int参数
        return a * b;  // 第8行：整数乘法
    }

    double multiply(double a, double b) {  // 版本2：double参数
        return a * b;  // 第12行：浮点数乘法
    }
};
```

#### 3. 主程序：`main.cpp`（调用 C/C++ 函数）
```cpp
// main.cpp
#include "break_c.c"
#include "break_cpp.cpp"

int main() {
    printf("=== 程序开始 ===\n");  // 第5行：程序入口打印

    // 调用 C 函数
    int c_result = c_sum(1, 5);  // 第8行：调用 c_sum
    printf("C函数累加结果：%d\n", c_result);  // 第9行

    // 调用 C++ 类函数
    MathUtil util;
    int cpp_int_result = util.multiply(3, 4);  // 第12行：调用 int 版本 multiply
    double cpp_double_result = util.multiply(2.5, 4.0);  // 第13行：调用 double 版本 multiply
    printf("C++整数乘法结果：%d\n", cpp_int_result);
    printf("C++浮点数乘法结果：%lf\n", cpp_double_result);  // 第15行

    // 循环测试临时断点
    for (int i = 0; i < 3; i++) {  // 第18行：循环
        printf("循环第 %d 次\n", i + 1);  // 第19行：打印循环次数
    }

    printf("=== 程序结束 ===\n");
    return 0;
}
```


### 编译程序（带调试信息）
```bash
# 编译 C++ 程序，链接 C 和 C++ 代码，生成调试信息
g++ -g -o breakpoint_demo main.cpp break_c.c break_cpp.cpp
```


### GDB 断点调试全流程
#### 1. 启动 GDB 并加载程序
```bash
gdb ./breakpoint_demo  # 启动 GDB 并加载可执行文件
```


#### 2. 在代码行上设置断点（`break` 命令）
##### （1）单文件行断点（默认当前文件）
给主程序第5行（程序开始打印处）设置断点：
```gdb
(gdb) break 5  # 在 main.cpp 第5行设置断点
Breakpoint 1 at 0x55555555522d: file main.cpp, line 5.
```

##### （2）多文件行断点（指定文件名）
给 C 函数 `c_sum` 的循环行（`break_c.c` 第6行）设置断点：
```gdb
(gdb) break break_c.c:6  # 指定文件和行号
Breakpoint 2 at 0x55555555518a: file break_c.c, line 6.
```


#### 3. 在 C 函数上设置断点
给 C 函数 `c_sum` 入口设置断点：
```gdb
(gdb) break c_sum  # 通过函数名设置断点
Breakpoint 3 at 0x55555555517d: file break_c.c, line 4.
```


#### 4. 在 C++ 函数上设置断点（指定重载版本）
C++ 函数 `multiply` 有两个重载版本，通过参数类型指定断点：
```gdb
(gdb) break MathUtil::multiply(int, int)  # 给 int 版本设置断点
Breakpoint 4 at 0x5555555551f6: file break_cpp.cpp, line 8.

(gdb) break MathUtil::multiply(double, double)  # 给 double 版本设置断点
Breakpoint 5 at 0x55555555520c: file break_cpp.cpp, line 12.
```


#### 5. 设置临时断点（`tbreak` 命令）
给循环打印行（`main.cpp` 第19行）设置临时断点（只触发一次）：
```gdb
(gdb) tbreak main.cpp:19  # 临时断点，触发后自动删除
Temporary breakpoint 6 at 0x5555555552c8: file main.cpp, line 19.
```


#### 6. 获取断点列表（`info breakpoints` 命令）
查看所有断点的状态：
```gdb
(gdb) info breakpoints  # 列出所有断点
Num     Type           Disp Enb Address            What
1       breakpoint     keep y   0x000055555555522d in main at main.cpp:5
2       breakpoint     keep y   0x000055555555518a in c_sum at break_c.c:6
3       breakpoint     keep y   0x000055555555517d in c_sum at break_c.c:4
4       breakpoint     keep y   0x00005555555551f6 in MathUtil::multiply(int, int) at break_cpp.cpp:8
5       breakpoint     keep y   0x000055555555520c in MathUtil::multiply(double, double) at break_cpp.cpp:12
6       temporary breakpoint keep y   0x00005555555552c8 in main at main.cpp:19
```
- 字段说明：`Num`（断点编号）、`Enb`（是否启用：`y` 启用，`n` 禁用）、`What`（断点位置）。


#### 7. 禁用断点（`disable` 命令）
禁用 C 函数 `c_sum` 的行断点（编号2）：
```gdb
(gdb) disable 2  # 禁用编号2的断点
(gdb) info breakpoints  # 验证状态变化
Num     Type           Disp Enb Address            What
1       breakpoint     keep y   0x000055555555522d in main at main.cpp:5
2       breakpoint     keep n   0x000055555555518a in c_sum at break_c.c:6  # Enb 变为 n
3       breakpoint     keep y   0x000055555555517d in c_sum at break_c.c:4
...（其他断点状态不变）
```


#### 8. 跳过断点（`ignore` 命令）
让 C++ 整数乘法断点（编号4）跳过前1次触发（只从第2次开始生效）：
```gdb
(gdb) ignore 4 1  # 跳过编号4断点的前1次触发
Will ignore next 1 crossings of breakpoint 4.
```


#### 9. 运行程序并验证断点效果
```gdb
(gdb) run  # 启动程序
Starting program: /home/your_user/breakpoint_demo 

# 触发断点1（main.cpp 第5行）
Breakpoint 1, main () at main.cpp:5
5       printf("=== 程序开始 ===\n");
(gdb) continue  # 继续执行

=== 程序开始 ===

# 触发断点3（c_sum 函数入口）
Breakpoint 3, c_sum (start=1, end=5) at break_c.c:4
4       int sum = 0;
(gdb) continue  # 继续执行（断点2已禁用，不会触发）

# 触发断点4（MathUtil::multiply(int, int)），但被 ignore 跳过1次，直接执行
C函数累加结果：15
# 断点4第1次触发被跳过，直接执行到下一行

# 触发断点5（MathUtil::multiply(double, double)）
Breakpoint 5, MathUtil::multiply (this=0x7fffffffdd30, a=2.5, b=4) at break_cpp.cpp:12
12         return a * b;
(gdb) continue  # 继续执行

C++整数乘法结果：12
C++浮点数乘法结果：10.000000

# 触发临时断点6（main.cpp 第19行，只触发1次）
Temporary breakpoint 6, main () at main.cpp:19
19        printf("循环第 %d 次\n", i + 1);
(gdb) continue  # 继续执行，临时断点触发后自动删除

循环第 1 次
循环第 2 次  # 临时断点已删除，不再触发
循环第 3 次
=== 程序结束 ===
[Inferior 1 (process 12345) exited normally]
```


#### 10. 退出 GDB
```gdb
(gdb) quit  # 退出调试
```


### 案例总结
本案例完整覆盖了 GDB 断点的所有核心用法：  
| 需求                  | 命令示例                                  | 效果说明                                  |
|-----------------------|-------------------------------------------|-------------------------------------------|
| 在行上设置断点        | `break 5` 或 `break break_c.c:6`          | 在指定行或指定文件的行上停止程序          |
| 在 C 函数上设置断点  | `break c_sum`                             | 在 C 函数入口停止程序                     |
| 在 C++ 函数上设置断点| `break MathUtil::multiply(int, int)`       | 指定重载版本，在 C++ 成员函数入口停止     |
| 设置临时断点          | `tbreak main.cpp:19`                      | 只停止一次，触发后自动删除                |
| 获取断点列表          | `info breakpoints`                        | 查看所有断点的编号、状态和位置            |
| 禁用断点              | `disable 2`                               | 临时关闭断点（保留配置，不删除）          |
| 跳过断点              | `ignore 4 1`                              | 忽略断点前 N 次触发，从第 N+1 次开始生效  |

通过这些操作，可灵活控制程序的停止时机，精准定位代码执行中的问题。