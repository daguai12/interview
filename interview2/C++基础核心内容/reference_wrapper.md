å¾ˆå¥½ï¼Œ`std::reference_wrapper` æ˜¯ C++ æ ‡å‡†åº“ä¸­ä¸€ä¸ªéå¸¸é‡è¦ä½†ç»å¸¸è¢«å¿½ç•¥çš„å°å·¥å…·ã€‚å®ƒçš„æ ¸å¿ƒä½œç”¨æ˜¯ï¼š**åŒ…è£…ä¸€ä¸ªå¼•ç”¨ï¼Œä½¿å…¶å¯ä»¥åƒå€¼ä¸€æ ·è¢«å¤åˆ¶ã€ä¼ é€’ï¼Œä½†å®é™…ä»ç„¶æ˜¯å¼•ç”¨è¡Œä¸º**ã€‚

è¿™æ˜¯å®Œç¾è§£å†³ C++ ä¸­å¼•ç”¨ä¸èƒ½æ‹·è´ã€ä¸èƒ½åœ¨å®¹å™¨ä¸­ä½¿ç”¨ã€ä¸èƒ½éšå¼æ•è·çš„é—®é¢˜ã€‚

---

## ğŸ“¦ ä¸€ã€`std::reference_wrapper` æ˜¯ä»€ä¹ˆï¼Ÿ

### å®˜æ–¹å®šä¹‰ï¼ˆç®€åŒ–ç‰ˆï¼‰ï¼š

```cpp
template< class T >
class reference_wrapper {
public:
    // æ„é€ å‡½æ•°
    reference_wrapper(T& ref);

    // æ‹·è´æ„é€ /èµ‹å€¼ç­‰éƒ½å¯ä»¥ï¼Œå’Œæ™®é€šå€¼ä¸€æ ·ä½¿ç”¨

    // è¿”å›å¼•ç”¨
    operator T& () const noexcept;

    // è·å–å¼•ç”¨
    T& get() const noexcept;
};
```

---

## ğŸ§  äºŒã€ä¸ºä»€ä¹ˆéœ€è¦ `reference_wrapper`ï¼Ÿ

### âŒ C++ ä¸­å¼•ç”¨æœ¬èº«æœ‰è¿™äº›é™åˆ¶ï¼š

* å¼•ç”¨ä¸èƒ½è¢«å¤åˆ¶ï¼ˆä½ ä¸èƒ½å­˜å‚¨ `int&` åœ¨å®¹å™¨é‡Œï¼‰ï¼›
* å¼•ç”¨ä¸èƒ½ä½œä¸ºæ¨¡æ¿å‚æ•°ç±»å‹æ¨å¯¼æ—¶ç‹¬ç«‹å­˜åœ¨ï¼›
* å¼•ç”¨åœ¨å‡½æ•°ä¼ å‚ã€çº¿ç¨‹ã€lambda ä¸­å®¹æ˜“è¢«â€œå€¼æ‹·è´â€åƒæ‰ï¼›

---

## âœ… ä¸‰ã€è§£å†³æ–¹å¼ï¼šç”¨ `reference_wrapper`

### å®ƒçš„ä½œç”¨æ˜¯ï¼š

> **æŠŠä¸€ä¸ªå¼•ç”¨åŒ…æˆä¸€ä¸ªå¯æ‹·è´çš„å€¼å¯¹è±¡**ï¼Œå¹¶åœ¨éœ€è¦æ—¶â€œæ¢å¤â€æˆå¼•ç”¨ã€‚

---

## ğŸ§ª å››ã€ç¤ºä¾‹æ¼”ç¤º

### ğŸ”´ æ™®é€šå¼•ç”¨ä¸èƒ½å¤åˆ¶ï¼š

```cpp
int x = 10;
int& r = x;
std::vector<int&> v;  // âŒ é”™è¯¯ï¼šå¼•ç”¨ä¸èƒ½ä½œä¸ºå…ƒç´ ç±»å‹
```

### âœ… ç”¨ `reference_wrapper`ï¼š

```cpp
#include <functional>
#include <vector>

int x = 10;
std::reference_wrapper<int> ref = std::ref(x);  // ç­‰ä»·äº reference_wrapper<int>(x)

std::vector<std::reference_wrapper<int>> v;
v.push_back(ref);      // âœ… å¯ä»¥å¤åˆ¶
v[0].get() = 42;        // å®é™…ä¿®æ”¹ x
```

---

## ğŸ§µ äº”ã€ä¸ `std::thread` è”åŠ¨

å½“ä½ ä½¿ç”¨ `std::thread` æ—¶ï¼š

```cpp
void foo(int& x) { x += 1; }

int num = 10;
std::thread t(foo, num);       // âŒ é”™ï¼šnum è¢«å€¼æ‹·è´ï¼Œfoo(int&) æ— æ³•æ¥æ”¶
std::thread t2(foo, std::ref(num));  // âœ… å¯¹äº†ï¼šå¼•ç”¨åŒ…è£…å™¨è§£åŒ…ä¸º int&
```

---

## ğŸ”§ å…­ã€å®ç°æœºåˆ¶ç®€æï¼ˆå‚è€ƒå®ç°ï¼‰

```cpp
template<typename T>
class reference_wrapper {
private:
    T* ptr;  // å®é™…åªå­˜ä¸€ä¸ªæŒ‡é’ˆ

public:
    reference_wrapper(T& ref) : ptr(std::addressof(ref)) {}

    operator T&() const noexcept { return *ptr; }

    T& get() const noexcept { return *ptr; }

    // å¯è°ƒç”¨æ”¯æŒï¼ˆå¦‚æœ T æ˜¯å‡½æ•°ï¼‰
    template<typename... Args>
    auto operator()(Args&&... args) const {
        return (*ptr)(std::forward<Args>(args)...);
    }
};
```

å®ƒåŸºæœ¬ä¸Šåªæ˜¯ä¸€ä¸ªå°çš„æŒ‡é’ˆå°è£…å™¨ï¼Œå®ƒå¯ä»¥ï¼š

* æ‹·è´ï¼›
* è°ƒç”¨ï¼›
* è‡ªåŠ¨è§£å¼•ç”¨ä¸º `T&`ï¼›

---

## ğŸ“š ä¸ƒã€å¸¸è§ç”¨é€”

| ç”¨æ³•åœºæ™¯          | ä¸¾ä¾‹                                       | è¯´æ˜        |
| ------------- | ---------------------------------------- | --------- |
| `std::thread` | `std::ref(num)`                          | çº¿ç¨‹å‡½æ•°æŒ‰å¼•ç”¨ä¼ å‚ |
| `std::bind`   | `std::bind(f, std::ref(x))`              | ä¿æŒå¯¹å¼•ç”¨çš„ç»‘å®š  |
| STL å®¹å™¨        | `std::vector<std::reference_wrapper<T>>` | å®¹å™¨ä¸­å­˜æ”¾å¼•ç”¨   |
| lambda ä¸­å¼•ç”¨æ•è·  | é—´æ¥åŒ…è£…å¼•ç”¨ç»•è¿‡é—­åŒ…å¤åˆ¶                             |           |

---

## ğŸ¯ æ€»ç»“ä¸€å¥è¯ï¼š

> `std::reference_wrapper<T>` è®©ä½ å¯ä»¥ **åƒä¼ å€¼ä¸€æ ·ä¼ å¼•ç”¨**ï¼Œæ˜¯ C++ ä¸­**å¼•ç”¨è¯­ä¹‰å’Œå€¼è¯­ä¹‰èåˆçš„å…³é”®å·¥å…·**ã€‚

---

å¦‚æœä½ æƒ³ç»§ç»­æ·±å…¥ï¼Œæˆ‘å¯ä»¥å¸¦ä½ çœ‹ä¸‹å®ƒçš„ `operator()` é‡è½½æ˜¯å¦‚ä½•æ”¯æŒå‡½æ•°å¯¹è±¡çš„å¼•ç”¨è°ƒç”¨ï¼Œæˆ–è€…ä¸¾ä¾‹è¯´æ˜å®ƒåœ¨ `std::function`ã€`std::bind` ä¸­çš„åº”ç”¨ã€‚æ˜¯å¦æ„Ÿå…´è¶£ï¼Ÿ
