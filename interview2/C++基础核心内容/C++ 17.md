# std::optional
## 🌟 一、`std::optional` 是什么？

`std::optional<T>` 是 C++17 引入的一个模板类，用于表示**一个可能包含或不包含值的对象**。

你可以把它理解为一个可以“为空”的普通值类型，是 C++ 标准库对“值可能不存在”的一种**类型安全**的表示方式。类似于其他语言中的 `Maybe`（Haskell）、`Option`（Rust）、`Optional`（Java）。

---

## 📦 二、头文件与命名空间

```cpp
#include <optional>  // 头文件
using namespace std; // 或使用 std::optional
```

---

## 🧠 三、用途：为什么要用 `std::optional`？

### ✅ 用于代替裸指针或特殊值表示“无值”

* 传统写法：

  ```cpp
  int findUserId(std::string name) {
      if (name == "admin") return 0;
      return -1; // -1 表示未找到
  }
  ```

  这种方式有歧义：`-1` 是有效值吗？如果返回值是字符串或结构体，用什么表示“无”？

* `std::optional` 版本：

  ```cpp
  std::optional<int> findUserId(std::string name) {
      if (name == "admin") return 0;
      return std::nullopt; // 明确表示“无值”
  }
  ```

---

## ✨ 四、基本使用示例

```cpp
#include <iostream>
#include <optional>

std::optional<int> divide(int a, int b) {
    if (b == 0) return std::nullopt; // 返回“无值”
    return a / b;                    // 返回结果
}

int main() {
    auto result = divide(10, 2);
    if (result) {
        std::cout << "Result: " << *result << "\n";
    } else {
        std::cout << "Division by zero.\n";
    }

    auto r2 = divide(5, 0);
    std::cout << "r2.has_value(): " << r2.has_value() << "\n";
}
```

---

## 📚 五、常用成员函数和操作

### ✅ 创建

```cpp
std::optional<int> o1;              // 空 optional（无值）
std::optional<int> o2 = 5;          // 含值
std::optional<int> o3 = std::nullopt; // 显式无值
```

### ✅ 判断是否有值

```cpp
if (opt.has_value()) { ... }
if (opt) { ... } // 与上面等价，常用写法
```

### ✅ 访问值

```cpp
*opt          // 解引用
opt.value()   // 若无值则抛出 std::bad_optional_access
opt.value_or(默认值)  // 若无值，则返回默认值
```

### ✅ 修改值

```cpp
opt.emplace(42); // 设置新值
opt.reset();     // 设为空值
```

### ✅ 比较

```cpp
std::optional<int> a = 5;
std::optional<int> b = std::nullopt;

std::cout << (a > b);  // true，因为有值 > 无值
```

---

## 🧩 六、使用场景

### ✅ 1. 表示函数的返回值可能为空

```cpp
std::optional<std::string> findUsername(int id);
```

### ✅ 2. 替代 nullptr/null 或 sentinel 特殊值

```cpp
std::optional<User> getUser(); // 更安全
```

### ✅ 3. 用于延迟初始化

```cpp
std::optional<Config> config;
if (load_config) {
    config.emplace(readConfig());
}
```

### ✅ 4. 用于值的“暂存”

```cpp
std::optional<std::string> cache;
```

---

## ⚠️ 七、注意事项

1. `value()` 访问无值会抛异常（`std::bad_optional_access`）：

   ```cpp
   std::optional<int> o;
   int x = o.value(); // ❌ 会抛异常
   ```

2. `optional<T>` 本质上会额外占用空间来记录是否有值（大概是 `sizeof(T) + 1` 字节）。

3. 不支持引用类型（不能 `std::optional<T&>`），但可以用 `std::reference_wrapper<T>` 代替：

   ```cpp
   std::optional<std::reference_wrapper<int>> oref;
   ```

---

## 🔍 八、与 `std::unique_ptr`/裸指针的比较

| 特点     | `std::optional<T>` | `T*`（裸指针） |
| ------ | ------------------ | --------- |
| 是否拥有对象 | 是                  | 否         |
| 值语义    | 是                  | 否         |
| 空状态    | `std::nullopt`     | `nullptr` |
| 安全性    | 高，类型明确、不会悬空        | 低，可能悬空    |
| 内存分配   | 无（值内存）             | 需要分配（堆）   |

---

## 🛠 九、C++20 中的新特性（扩展）

C++20 为 `std::optional` 添加了 `operator<=>(three-way comparison)` 支持，可以用于排序、比较大小。

```cpp
std::optional<int> a = 3;
std::optional<int> b = std::nullopt;

std::cout << (a <=> b == std::strong_ordering::greater) << "\n"; // true
```

---

## ✅ 十、总结

| 特性   | 描述                                                                |
| ---- | ----------------------------------------------------------------- |
| 定义   | `std::optional<T>` 表示一个“可能有值”的对象                                  |
| 状态   | 两种：有值 / 无值                                                        |
| 常用操作 | `has_value()`、`value()`、`value_or()`、`*opt`、`reset()`、`emplace()` |
| 应用   | 安全地表示函数可能返回“无结果”的情况                                               |
| 替代   | 替代裸指针、magic number（如 `-1`）等不安全的“空状态”表示方式                          |

---

如果你想我进一步讲解某个实际例子（如如何配合结构体、如何与函数模板结合、或与 `std::variant`、`std::expected` 比较等），也可以继续问我！
