1. 将文件传输到 gaia.cs.umass.edu 的客户端计算机（源）使用的 IP 地址和 TCP 端口号是什么？ 要回答这个问题，最简单的方法是使用“所选数据包 标头的详细信息”视窗，选择 HTTP 讯息并探索用于携带此 HTTP 讯息的 TCP 数据包的详细信息（如果你不确定是哪一个 Wireshark 视窗。请参阅 “Getting Started with Wireshark”实验中的图 2 ）

SOURCE IP: 10.128.217.63
SOURCE PORT: 12289

2. gaia.cs.umass.edu 的 IP 地址是什么？ 在哪个端口号上发送和接收此连接的 TCP 区段？

IP: 128.119.245.12
PORT: 80

3. 用于在客户端计算机与gaia.cs.umass.edu之间建立TCP连接的TCP SYN段的序列号是什么？（注意：这是TCP段本身携带的“原始”序列号；不是Wireshark窗口中“编号（No.）”列里的数据包编号。要记住，在TCP或UDP中不存在“数据包编号”这种说法；正如你所知，TCP中有序列号，这就是我们这里要找的。另外注意，这不是相对于本次TCP会话起始序列号的相对序列号。）此TCP段中，是什么标识该段为SYN段？本次会话中的TCP接收方能否使用选择性确认（让TCP的功能更接近“选择重传”接收方，参见教材3.4.5节 ）？

建立连接的SYN序列号为：  2691817259
标志位FLag中的SYN标志位置为1，将该段标识为SYN包。
本次会话接收方使用选择性确认。

4. gaia.cs.umass.edu发送给客户端计算机、用于回复SYN的SYNACK段的序列号是什么？段中的什么标识该段为SYNACK段？SYNACK段中确认（Acknowledgement）字段的值是多少？gaia.cs.umass.edu是如何确定该值的？ 

SYN: 926594962
ACK 标志位来标识
ACK: 2691817259
如果是三次握手，这该字段的值为，发送方SYN + 1。如果，已经成功建立了连接，则该字段的值为SYN + 接收到的数据。

5. 包含HTTP POST命令头部的TCP段的序列号是什么？要找到POST消息头部，你需要深入查看Wireshark窗口底部的数据包内容字段，寻找在其数据（DATA）字段中包含ASCII文本“POST”的段 。此TCP段的有效载荷（数据）字段中包含多少字节的数据？传输的文件alice.txt中的所有数据是否都装入了这个单个段中？
TCP序列号为：2691817260。
包含754字节的数据。
没有都装入。

6. 将包含HTTP“POST”的TCP段视为TCP连接数据传输部分的第一个段。  
    - TCP连接数据传输部分的第一个段（包含HTTP POST的那个段）是在什么时间发送的？  
    - 该第一个包含数据的段的ACK是在什么时间收到的？  
    - 该第一个包含数据的段的往返时间（RTT）是多少？ 
    - 第二个包含数据的TCP段及其ACK的RTT值是多少？ 
    - 在收到第二个包含数据的段的ACK后，估计的往返时间（EstimatedRTT ）值是多少？假设在收到第二个段的ACK后进行此计算时，EstimatedRTT的初始值等于第一个段测得的RTT，然后使用教材242页的EstimatedRTT公式计算，且α = 0.125。  
    注意：Wireshark有个很好的功能，可绘制发送的每个TCP段的RTT。在“已捕获数据包列表”窗口中选择一个从客户端发送到gaia.cs.umass.edu服务器的TCP段。然后选择：统计（Statistics）->TCP流图（TCP Stream Graph）->往返时间图（Round Trip Time Graph）。 

(1) Arrival Time: Jun 23, 2025 16:15:44.808727000 中国标准时间
(2) 丢包了不知道
(3) 丢包了不知道
(4) 查看SEQ/ACK analysis字段
(5)

7. 前四个包含数据的TCP段中，每个段的长度（头部加有效载荷）是多少？ 

除了第一个是749字节
都是1340字节

8. 在这前四个包含数据的TCP段中，gaia.cs.umass.edu向客户端通告的最小可用缓冲区空间是多少？对于这前四个包含数据的段，接收方缓冲区空间不足是否曾限制过发送方？ 
都是65280

9. 跟踪文件中是否有重传的段？为回答此问题，你在跟踪文件中检查了什么？ 

有重传的段。

10. 在从客户端发送到gaia.cs.umass.edu的前十 个包含数据的段中，接收方在一个ACK中通常确认多少数据？在这前十 个包含数据的段中，你能否识别出接收方确认每隔一个收到的段的情况（参见教材表3.2 ）？ 

ACK通常确认1300个数据。

11. 该TCP连接的吞吐量（每单位时间传输的字节数）是多少？说明你是如何计算该值的。

12. 使用“时间 - 序列图（史蒂文斯）”绘图工具，查看从客户端发送到gaia.cs.umass.edu服务器的段的序列号与时间关系图。观察在t = 0.025、t = 0.053、t = 0.082和t = 0.1左右发送的“数据包组”。说明这看起来TCP是否处于慢启动阶段、拥塞避免阶段或其他某个阶段。图6展示了对此数据的一个略有不同的视图。

13. 这些“数据包组”似乎具有一定的周期性。关于周期，你能得出什么结论？ 

14. 针对你从自己的计算机向gaia.cs.umass.edu传输文件时采集的跟踪数据，回答上述两个问题。







# 问题补充

## 问题3

要理解 “本次会话中的 TCP 接收方能否使用选择性确认（让 TCP 的功能更接近‘选择重传’接收方，参见教材 3.4.5 节 ）” 这句话，需要拆解几个关键概念，结合 TCP 可靠传输的逻辑来理解：  


### 一、核心概念拆解  
#### 1. **TCP 可靠传输的基础逻辑**  
TCP 要实现 “可靠传输”，核心依赖 **序列号（Sequence Number）** 和 **确认号（Acknowledgment Number）**：  
- 发送方按序给数据分段编号（序列号），接收方通过确认号告诉发送方 “我收到了哪些数据”；  
- 若发送方发现某段数据未被确认，会触发 **重传**，但早期 TCP 是 “累积确认” 机制（收到乱序包时，只确认到最后一个连续包的序列号）。  


#### 2. **“选择重传”（Selective Repeat）的理想逻辑**  
- 在理想的 “选择重传” 协议里（常作为运输层理论模型），接收方可以：  
  - 识别并缓存 **乱序到达的数据包**（即使中间有丢包，后面的包也能先存着）；  
  - 单独确认 **每个正确接收的数据包**（不管是否连续），让发送方只重传 **真正丢失的包**，而非重传所有后续包。  
- 优点：减少不必要的重传，提升传输效率；缺点：实现复杂（需要缓存、单独确认等机制）。  


#### 3. **TCP 的 “选择性确认”（SACK，Selective Acknowledgment）**  
- 为了让 TCP 更接近 “选择重传” 的效率，TCP 引入了 **SACK 选项**：  
  - 接收方在 TCP 头部的选项字段里，主动告诉发送方：“我收到了哪些不连续的数据包”（比如中间丢了一个包，但后面的包到了）；  
  - 发送方根据 SACK 信息，**只重传丢失的那部分数据**，而非重传所有后续包，这就是让 TCP “更像选择重传接收方” 的关键。  


### 二、回到问题的实际含义  
“本次会话中的 TCP 接收方能否使用选择性确认” 本质是在问：  
→ **抓包的这个 TCP 连接里，双方是否协商启用了 SACK 选项？**  

如果启用了 SACK：  
- 接收方可以主动报告 “乱序接收的数据包范围”，发送方据此精准重传，效率更高（接近选择重传）；  
- 你需要在 Wireshark 里检查 TCP 连接建立的 **SYN/SYN - ACK 包**，看是否包含 `SACK permitted` 选项（客户端发 SYN 时带 `SACK permitted`，服务器回 SYN - ACK 时也确认支持 ）。  

如果没启用 SACK：  
- 接收方只能用 “累积确认”（收到乱序包时，只确认最后一个连续包的序列号），发送方可能重传更多不必要的数据，效率更低。  


### 三、如何用 Wireshark 验证？  
1. **找 TCP 连接建立的包**：过滤 `tcp.flags.syn == 1`，找到客户端发的 SYN 包和服务器回的 SYN - ACK 包。  
2. **检查 SACK 选项**：  
   - 在 SYN 包的 TCP 头部选项里，看是否有 `SACK permitted`（客户端请求支持 SACK ）；  
   - 在 SYN - ACK 包的 TCP 头部选项里，看是否也包含 `SACK permitted`（服务器同意支持 ）。  
3. **结论**：如果双方都带了 `SACK permitted`，则本次会话支持选择性确认（SACK），更接近 “选择重传” 逻辑；如果没有，则不支持，只能用累积确认。  


简单说，这句话就是让你通过抓包验证 TCP 连接是否启用 SACK，理解 TCP 从 “累积确认” 到 “接近选择重传” 的优化逻辑 。核心是看连接协商阶段是否开启了 SACK 选项，这决定了接收方能否 “选择性确认” 乱序包，让传输更高效。


## 问题7

在Wireshark中分析TCP缓冲区空间和流量控制问题，可以按照以下步骤操作：


### **1. 定位前四个包含数据的TCP段**
- **筛选TCP数据流**：  
  右键点击HTTP POST请求对应的TCP包 → **Follow** → **TCP Stream**，确保只查看目标TCP连接的数据包。  
- **识别数据段**：  
  在TCP流中，排除SYN、ACK等控制包，只关注携带实际数据的段（即`Len > 0`的TCP包）。


### **2. 查看通告窗口大小（Advertised Window）**
TCP接收方通过`Window Size`字段通告自己的可用缓冲区空间（单位：字节）。在Wireshark中：  
- 展开TCP数据包详情 → **Transmission Control Protocol** → **Window size value**（相对值）。  
- 真实缓冲区大小 = `Window size value` × **Window Scale Factor**（窗口缩放因子，需在TCP握手阶段查找）。  


### **3. 查找最小可用缓冲区空间**
- **步骤**：  
  1. 找到服务器（`gaia.cs.umass.edu`）发送的前四个数据段。  
  2. 查看每个段对应的ACK包（客户端回复的确认包）中的`Window size value`字段。  
  3. 将`Window size value`乘以窗口缩放因子（通常在初始SYN包中设置），得到真实缓冲区大小。  
  4. 比较这四个值，找出最小值。  

- **示例**：  
  若四次ACK的`Window size value`分别为`5000`、`4500`、`4000`、`4200`，窗口缩放因子为`2^3=8`，则最小缓冲区空间为`4000 × 8 = 32,000`字节。


### **4. 判断接收方缓冲区是否限制发送方**
- **关键指标**：  
  - **窗口缩小（Window Shrinking）**：若接收方通告的窗口大小逐渐减小，可能表示缓冲区接近满。  
  - **零窗口（Zero Window）**：若`Window size value`为0，发送方必须暂停发送，直到收到窗口更新通知（Window Update）。  

- **Wireshark操作**：  
  1. 在TCP流图中，观察窗口大小随时间的变化趋势：  
     - 选择**Statistics** → **TCP Stream Graph** → **Window Scaling Graph**。  
  2. 检查是否存在`[Window Full]`或`[Zero Window]`标记：  
     - 若数据包详情中显示此类标记，说明发送方因接收方缓冲区不足而受限。  


### **5. 使用显示过滤器快速定位**
- **筛选服务器发送的数据段**：  
  ```plaintext
  ip.src == gaia.cs.umass.edu && tcp.len > 0
  ```  
- **筛选客户端回复的ACK及其窗口大小**：  
  ```plaintext
  ip.dst == gaia.cs.umass.edu && tcp.flags.ack == 1 && tcp.window_size_value
  ```  
- **筛选窗口为零的情况**：  
  ```plaintext
  tcp.window_size_value == 0
  ```  


### **总结**
- **最小可用缓冲区**：通过分析客户端ACK中的`Window size value`并结合窗口缩放因子计算得出。  
- **是否受限**：观察窗口大小变化趋势及是否出现零窗口或窗口缩小情况。  

若前四个数据段中，客户端通告的窗口大小持续减小甚至归零，则说明接收方缓冲区曾限制发送方；反之，若窗口保持稳定或增大，则未受限。

## 问题7

在Wireshark中查询前四个包含数据的TCP段长度（头部+有效载荷），可按以下步骤操作：


### **1. 筛选TCP数据流并定位数据段**
- **筛选目标TCP流**：  
  右键点击HTTP POST请求对应的TCP包 → **Follow** → **TCP Stream**，确保只查看目标连接的数据包。  
- **排除控制包（如SYN、ACK）**：  
  在TCP流中，仅关注`Len > 0`的数据包（即携带数据的段）。


### **2. 查看每个TCP段的总长度**
有两种方式获取TCP段的完整长度（头部 + 有效载荷）：

#### **方法一：查看Frame总长度（最直接）**
- 展开数据包详情中的**Frame**层，找到：  
  ```
  Frame X: Y bytes on wire (Y octets)
  ```  
  其中`Y`即为整个TCP段的总长度（包括链路层、网络层和传输层的所有开销）。


#### **方法二：计算IP层和TCP层的长度**
- **IP层总长度**：  
  展开**Internet Protocol Version 4** → **Total Length**（单位：字节），表示IP包的总大小（包括IP头部和TCP段）。  
- **TCP头部长度**：  
  展开**Transmission Control Protocol** → **Header Length**（单位：32位字），需转换为字节：  
  ```plaintext
  TCP头部长度（字节） = Header Length × 4
  ```  
- **TCP段总长度**：  
  ```plaintext
  TCP段总长度 = IP Total Length - IP Header Length + TCP Header Length
  ```  


### **3. 快速提取前四个数据段的长度**
- **使用显示过滤器**：  
  ```plaintext
  tcp.len > 0 && ip.src == gaia.cs.umass.edu
  ```  
  此过滤条件仅显示服务器发送的、包含数据的TCP段。  
- **排序并提取前四个**：  
  按时间戳排序后，前四个符合条件的数据包即为所求。  


### **示例**
假设前四个数据段的Frame长度分别为：  
1. `Frame 100: 66 bytes`  
2. `Frame 102: 546 bytes`  
3. `Frame 104: 546 bytes`  
4. `Frame 106: 546 bytes`  

则它们的总长度分别为 **66、546、546、546 字节**。


### **注意事项**
- **Frame长度 vs. TCP段长度**：  
  - Frame长度包含链路层头部（如以太网头部，通常为14字节），而TCP段长度仅包含IP和TCP层。  
  - 若需精确计算TCP段长度（不含链路层），应使用方法二。  
- **HTTP载荷长度**：  
  若需单独查看HTTP有效载荷，可展开**Hypertext Transfer Protocol** → **[Payload length]**，但这通常不包含TCP和IP头部。

通过以上步骤，可快速定位并获取前四个TCP数据段的完整长度。



## 问题8

要在 Wireshark 中检查跟踪文件里是否有 TCP 重传段，可通过以下 **3 种核心方法** 实现，从简单到进阶逐步分析：  


### 方法 1：用 Wireshark 内置的重传过滤词（最简单）
直接在 Wireshark 的**显示过滤器**中输入：  
```tcp.analysis.retransmission```  
按下回车，Wireshark 会自动筛选出所有被判定为 **TCP 重传** 的数据包。  

- **原理**：Wireshark 会检查 TCP 序列号、确认号逻辑，当发现 “**已经发送过的序列号，又被重新发送**”（且不符合正常乱序、快速重传等逻辑）时，标记为 `retransmission`。  
- **优点**：一键筛选，适合快速排查。  


### 方法 2：手动验证 TCP 序列号（精准确认）
如果想手动验证（或理解重传的本质），可按以下步骤：  

1. **找 TCP 数据流**：  
   用 `tcp.stream eq X`（`X` 是流编号，在 Wireshark 中点击 TCP 包，在 `TCP` -> `Stream index` 看值 ）过滤出要分析的 TCP 连接。  

2. **按时间顺序看序列号**：  
   TCP 序列号（`tcp.seq`）是单调递增的（正常传输时，`下一个序列号 = 前一个序列号 + 数据长度` ）。  
   - 如果发现 **相同的序列号重复出现**（且不是 TCP 快速重传的正常重试 ），则可能是重传。  
   - 结合 `tcp.ack`（确认号），如果旧序列号的包，确认号却没覆盖它，说明之前的传输可能丢失，触发了重传。  


### 方法 3：用 “TCP 重传图” 可视化分析
Wireshark 提供了可视化的重传分析工具：  

1. 选中任意一个属于目标 TCP 流的包（确保在你要分析的连接里 ）。  
2. 点击顶部菜单：`Statistics` -> `TCP Stream Graph` -> `Retransmission Graph`。  
3. **看图表**：  
   - 如果图表里有“垂直向上的线段”或“重复的点”，代表有重传。  
   - 鼠标悬停可看具体包的信息，包括重传的序列号、时间等。  


### 检查逻辑总结（回答问题时要说明）
要确认是否有重传段，本质是检查 **“TCP 序列号的重复传输且无正常确认”**，对应 Wireshark 里的操作：  
1. 先用 `tcp.analysis.retransmission` 快速筛选；  
2. 再手动核对序列号、确认号逻辑，或用重传图辅助验证；  
3. 如果有符合 “已发序列号重复出现、且无正常 ACK 覆盖” 的包，就说明存在重传。  


举个实际场景：  
- 过滤出 `tcp.analysis.retransmission` 的包后，点开会看到 `[TCP Retransmission]` 标记，同时看 `Info` 列会显示 `[Retransmission]`，结合序列号能确认是对之前某包的重传 → 这就说明跟踪文件里有重传段。  

这样就能完整回答 “是否有重传段” 以及 “检查了什么（序列号逻辑 + Wireshark 过滤/图表）” 啦～


---
时序列图使用方式
### 4. 实际运行中的TCP拥塞控制

现在我们来分析客户端向服务器发送数据的单位时间流量。为了避免手动从Wireshark窗口的原始数据中进行繁琐计算，我们将使用Wireshark的TCP图形工具之一——时间序列图（史蒂文斯）——来可视化数据。

**操作步骤：**
1. 在Wireshark的"捕获数据包列表"窗口中，选择一个客户端发送的TCP段，该段对应于从客户端向gaia.cs.umass.edu传输alice.txt文件的操作。
2. 依次点击菜单：**Statistics（统计）→ TCP Stream Graph（TCP流图）→ Time-Sequence-Graph(Stevens)（时间序列图（史蒂文斯））**。
3. 你应该会看到一个类似于图5的图表。该图是基于数据包跟踪文件tcp-wireshark-trace1-1中的捕获数据生成的。你可能需要调整坐标轴的显示区间（放大、缩小或拖动），以使你的图表与图5相似。


![图5](https://i.imgur.com/9BZJx0L.png)  
**图5：TCP段的序列号-时间关系图（史蒂文斯格式）**

**图表说明：**
- 图中的每个点表示一个已发送的TCP段，横轴为发送时间，纵轴为该段的序列号。
- 垂直堆叠的一组点表示发送方连续发送的一系列数据包（有时称为"数据包舰队"）。这些数据包通常在一个RTT（往返时间）内被快速发送，体现了TCP的滑动窗口机制。


### 关键分析点
- **慢启动阶段**：如果观察到数据包舰队的规模随时间呈指数级增长（例如1→2→4→8个包），则表明TCP处于**慢启动**状态（拥塞窗口`cwnd`每次确认后增加1）。
- **拥塞避免阶段**：当舰队规模增长变为线性（例如每次增加1个包），则表明TCP进入**拥塞避免**状态（`cwnd`每RTT增加1）。
- **丢包与重传**：如果图表中出现序列号突然回退或重复发送相同序列号的情况，可能表示发生了丢包并触发了快速重传或超时重传。

通过分析这种时间序列图，可以直观地观察TCP拥塞控制算法的动态行为，包括窗口增长、拥塞检测和恢复过程。