# 13.1 fork系统调用

1. **`fork` 的作用和返回值**
    
    - `fork()` 用于创建新进程，每次调用都会返回两次：
        
        - 在父进程中返回子进程的 PID。
            
        - 在子进程中返回 0。
            
        - 失败时返回 -1，并设置 `errno`。
            
2. **进程复制机制**
    
    - `fork` 复制当前进程，并在内核进程表中创建一个新的进程表项。
        
    - 复制的内容包括堆栈指针、寄存器等，但部分属性会被修改，如：
        
        - 新进程的 `PID` 重新分配。
            
        - 继承但清除信号处理函数等。
            
3. **数据复制方式（写时复制，Copy-on-Write）**
    
    - 子进程的代码和父进程完全相同，并复制父进程的数据（堆、栈、静态数据）。
        
    - 但数据采用**写时复制**策略，即只有在进程修改数据时才会分配新内存并复制数据，从而提高效率。
        
4. **文件描述符和引用计数**
    
    - 父进程中打开的文件在子进程中仍然打开，且文件描述符的引用计数增加 1。
        
    - 其他资源（如当前工作目录、用户根目录等）的引用计数也相应增加。
        
5. **优化建议**
    
    - `fork` 适用于需要创建新进程但希望避免大量不必要的内存复制的场景。
        
    - 若进程使用大量内存，频繁 `fork` 可能带来开销，应合理利用写时复制机制。

***
# 13.2 exec系列系统调用

`exec` 系列系统调用用于在当前进程中执行新的程序，替换当前进程的代码和数据，但保留进程 ID（PID）。它们通常与 `fork` 结合使用，以创建一个新进程后执行不同的程序。

### **`exec` 系列调用的主要函数**

Linux 提供了多个 `exec` 变体，它们的主要区别在于参数的传递方式：

| 函数       | 参数类型                                              | 描述                                |
| -------- | ------------------------------------------------- | --------------------------------- |
| `execl`  | `char *path, char *arg0, ..., NULL`               | 以路径方式指定可执行文件，参数以可变参数列表提供          |
| `execv`  | `char *path, char *argv[]`                        | 以路径方式指定可执行文件，参数以数组形式提供            |
| `execle` | `char *path, char *arg0, ..., NULL, char *envp[]` | 在 `execl` 基础上允许指定环境变量             |
| `execve` | `char *path, char *argv[], char *envp[]`          | 在 `execv` 基础上允许指定环境变量             |
| `execlp` | `char *file, char *arg0, ..., NULL`               | 以文件名（而非完整路径）查找可执行文件（查找 `PATH` 变量） |
| `execvp` | `char *file, char *argv[]`                        | 与 `execlp` 类似，但参数以数组形式提供          |


### **`exec` 调用的特点**

1. **不会创建新进程**  
    `exec` 直接替换当前进程的代码段和数据段，不改变进程 ID（PID）。
    
2. **文件描述符继承**  
    调用 `exec` 后，原进程打开的文件描述符不会关闭（除非被 `FD_CLOEXEC` 标记）。
    
3. **环境变量的继承**
    
    - `execle` 和 `execve` 允许指定新的环境变量。
        
    - 其他 `exec` 调用会默认继承当前进程的环境变量。
        
4. **通常与 `fork` 结合使用**
    
    - `fork` 生成新进程，`exec` 在子进程中调用以执行新的程序。
        
    - 例如，`shell` 执行命令时会 `fork` 一个子进程，然后 `exec` 该命令的可执行文件。
        


### **示例代码**

使用 `execlp` 在子进程中执行 `ls -l` 命令：

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main() {
    printf("Before exec\n");

    execlp("ls", "ls", "-l", NULL);

    // exec 成功执行后，以下代码不会运行
    perror("exec failed");
    return 1;
}
```

如果 `execlp` 成功执行，则 `ls -l` 会替换当前进程，`printf("Before exec")` 之后的代码不会执行。如果 `exec` 失败，则 `perror` 会输出错误信息。


### **`fork` + `exec` 组合示例**

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main() {
    pid_t pid = fork();

    if (pid == 0) {  // 子进程
        printf("Child process executing ls -l\n");
        execlp("ls", "ls", "-l", NULL);
        perror("exec failed");
        exit(1);
    } else if (pid > 0) {  // 父进程
        printf("Parent process, child PID: %d\n", pid);
        wait(NULL);  // 等待子进程完成
    } else {
        perror("fork failed");
    }

    return 0;
}
```

**运行结果**（示例）：

```
Parent process, child PID: 1234
Child process executing ls -l
total 8
-rwxr-xr-x 1 user user  1234 Apr  4 10:00 a.out
-rw-r--r-- 1 user user   567 Apr  4 10:00 test.c
```


### **总结**

- `exec` 系列用于替换当前进程的代码，不创建新进程。
    
- `exec` 失败时返回 `-1`，否则不会返回（因为成功执行后进程已替换）。
    
- 适用于 `fork` 后的子进程，以运行不同的程序。
    
- 选择合适的 `exec` 变体：
    
    - 需要 `PATH` 查找可执行文件 → `execlp` / `execvp`
        
    - 需要传递环境变量 → `execle` / `execve`
        
    - 参数是变长列表 → `execl`
        
    - 参数是数组 → `execv`
        

## **execle和execlp 主要区别总结**

| **功能**     | **execle**                  | **execlp**                     |
| ---------- | --------------------------- | ------------------------------ |
| **执行文件路径** | 必须提供完整路径，如 `/bin/ls`        | 只需提供程序名，如 `ls`，会自动查找 `PATH` 变量 |
| **环境变量**   | 允许传递自定义 `envp[]`，不会继承当前进程环境 | 继承当前进程的环境变量，无法指定自定义环境变量        |
| **适用场景**   | 需要控制环境变量时使用                 | 让程序自动查找可执行文件路径时使用              |
|            |                             |                                |

**选择建议：**

- **如果需要控制环境变量**（如修改 `PATH`、`LD_LIBRARY_PATH`）→ **用 `execle`**。
    
- **如果想让系统自动查找可执行文件**（如 `ls`、`gcc`）→ **用 `execlp`**。

***

# 13.3 处理僵尸进程和孤儿进程


在 Linux/Unix 进程管理中，**孤儿进程**（Orphan Process）和 **僵尸进程**（Zombie Process）是两种特殊的进程状态，通常与 **`fork()`** 和 **`wait()`** 相关。


## **1. 孤儿进程（Orphan Process）**

### **定义**

当**父进程先于子进程退出**时，子进程就变成了**孤儿进程**。

- 孤儿进程不会被终止，而是由 **`init` 进程（PID=1）或 `systemd` 进程接管，并成为它的子进程。
    
- `init/systemd` 负责等待（`wait()`）这些孤儿进程，防止它们变成僵尸进程。
    

### **示例代码**

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main() {
    pid_t pid = fork();

    if (pid > 0) {
        printf("Parent process exiting, PID: %d\n", getpid());
        exit(0);  // 父进程先退出，子进程变成孤儿进程
    } else if (pid == 0) {
        sleep(3);  // 让子进程存活更久
        printf("Orphan process running, PID: %d, Parent PID: %d\n", getpid(), getppid());
    } else {
        perror("fork failed");
    }

    return 0;
}
```

### **运行结果**

```
Parent process exiting, PID: 1234
Orphan process running, PID: 1235, Parent PID: 1
```

- 子进程的 `PPID` 变成了 `1`（`init`/`systemd` 进程）。
    
- 这个子进程就是 **孤儿进程**，由 `init/systemd` 进程接管。
    

---

## **2. 僵尸进程（Zombie Process）**

### **定义**

当**子进程退出后，父进程没有调用 `wait()` 读取其退出状态**，该子进程的**进程表项仍然保留**，但进程本体已终止，这种进程称为 **僵尸进程**。

- 僵尸进程不会消耗 CPU 或内存，但会占用 **进程表项**（有限资源）。
    
- **如果父进程退出，僵尸进程会自动被 `init/systemd` 进程清理。**
    
- **如果大量僵尸进程累积，可能导致系统资源枯竭！**
    

### **示例代码**

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main() {
    pid_t pid = fork();

    if (pid > 0) {  // 父进程
        printf("Parent process, PID: %d\n", getpid());
        sleep(10);  // 父进程不调用 wait()，子进程变成僵尸进程
    } else if (pid == 0) {  // 子进程
        printf("Child process exiting, PID: %d\n", getpid());
        exit(0);  // 退出但父进程未调用 wait()，进入僵尸状态
    } else {
        perror("fork failed");
    }

    return 0;
}
```

### **运行步骤**

1. `fork()` 生成子进程，子进程 **立刻退出**。
    
2. 父进程 **不调用 `wait()`**，导致子进程进程表项未被清理，进入 **僵尸状态**。
    
3. **用 `ps` 命令查看：**
    
    ```
    $ ps -aux | grep defunct
    ```
    
    看到类似：
    
    ```
    user   1235  0.0  0.0  0  0 ?    Z    00:00   0:00 [child] <defunct>
    ```
    
    `Z` 表示 **僵尸进程**。
    

---

## **3. 如何避免僵尸进程？**

### **方法 1：父进程调用 `wait()`**

```c
pid_t pid = fork();
if (pid > 0) {
    wait(NULL);  // 回收子进程，防止变成僵尸进程
}
```

**缺点：** `wait()` 是阻塞的，可能影响父进程运行。

---

### **方法 2：使用 `SIGCHLD` 信号+`waitpid()`**

父进程可以**捕获 `SIGCHLD` 信号**，在子进程退出时自动回收：

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>

void handle_sigchld(int sig) {
    while (waitpid(-1, NULL, WNOHANG) > 0);  // 回收所有子进程
}

int main() {
    signal(SIGCHLD, handle_sigchld);  // 注册 SIGCHLD 处理函数

    if (fork() == 0) {  // 子进程
        printf("Child process exiting\n");
        exit(0);
    }

    sleep(5);  // 模拟父进程继续运行
    printf("Parent process exiting\n");
    return 0;
}
```

- `signal(SIGCHLD, handle_sigchld)` 让父进程在子进程退出时执行 `waitpid()`，非阻塞地回收子进程，防止僵尸进程。
    

---

## **4. 孤儿进程 vs 僵尸进程 总结**

|**对比项**|**孤儿进程（Orphan Process）**|**僵尸进程（Zombie Process）**|
|---|---|---|
|**产生原因**|**父进程先退出**，子进程仍在运行|**子进程先退出**，但父进程未 `wait()`|
|**处理方式**|`init/systemd` 进程接管，不会积累|父进程必须 `wait()` 清理，否则会积累|
|**影响**|无害，正常运行|占用进程表项，影响系统资源|
|**如何避免**|无需处理|`wait()`、`SIGCHLD` 信号处理|

---

## **5. 什么时候会出现大量僵尸进程？**

1. **父进程没有 `wait()` 子进程**
    
    - 服务器端程序创建多个子进程处理请求，但忘记 `wait()` 。
        
    - 解决方案：使用 `waitpid()` 或 `SIGCHLD` 处理。
        
2. **父进程阻塞（如陷入死循环）**
    
    - 父进程不终止，但也不调用 `wait()` 。
        
    - 解决方案：检查主循环逻辑，适当 `wait()` 。
        
3. **多线程程序 fork() 子进程**
    
    - 线程模型可能导致 `wait()` 逻辑混乱，部分子进程无法回收。
        
    - 解决方案：使用 `pthread_atfork()` 或 **专门的管理进程** 处理 `wait()` 。
        

---

## **6. 结论**

- **孤儿进程** 由 `init/systemd` 进程接管，无害。
    
- **僵尸进程** 如果未被 `wait()` 处理，可能导致系统资源耗尽，应使用 `wait()` 或 `SIGCHLD` 信号处理。
    
- **生产环境中，必须防止僵尸进程积累**，避免服务器异常。
    

***

# 13.5 信号量

### **Linux 信号量（Semaphore）详解**

信号量（Semaphore）是 Linux 进程同步和互斥的重要机制，主要用于**解决临界区问题**，防止多个进程或线程同时访问共享资源，从而导致数据不一致。

---

## **1. 信号量的类型**

Linux 提供了两种主要的信号量：

1. **系统 V 信号量**（System V Semaphores）：使用 `semget`、`semop`、`semctl` 等系统调用，适用于进程间同步。
    
2. **POSIX 信号量**（POSIX Semaphores）：使用 `sem_init`、`sem_wait`、`sem_post`、`sem_destroy`，支持**进程内同步（线程同步）和进程间同步**。
    

---

## **2. 系统 V 信号量**

### **2.1 主要系统调用**

|**函数**|**作用**|
|---|---|
|`semget()`|创建或获取一个信号量集合|
|`semop()`|执行 P（等待）或 V（信号）操作|
|`semctl()`|获取/设置信号量值，删除信号量|

### **2.2 系统 V 信号量的使用**

#### **1️⃣ 创建信号量**

```c
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>
#include <stdio.h>

int main() {
    key_t key = ftok("/tmp", 'a');  // 生成唯一键值
    int semid = semget(key, 1, IPC_CREAT | 0666);  // 创建1个信号量
    if (semid == -1) {
        perror("semget failed");
        return 1;
    }
    printf("Semaphore ID: %d\n", semid);
    return 0;
}
```

- `semget()` 创建信号量集合（可以包含多个信号量）。
    
- `IPC_CREAT` 选项用于创建新的信号量。
    

---

#### **2️⃣ 设置信号量初值**

```c
#include <sys/sem.h>
#include <stdio.h>

int main() {
    key_t key = ftok("/tmp", 'a');
    int semid = semget(key, 1, IPC_CREAT | 0666);

    // 初始化信号量为 1（可用）
    union semun {
        int val;
        struct semid_ds *buf;
        unsigned short *array;
    } arg;
    arg.val = 1;

    if (semctl(semid, 0, SETVAL, arg) == -1) {
        perror("semctl failed");
        return 1;
    }
    printf("Semaphore initialized\n");
    return 0;
}
```

- `semctl(semid, 0, SETVAL, arg)` 设置信号量值。
    
- `arg.val = 1` 让信号量初始值为 `1`，表示资源可用。
    

---

#### **3️⃣ P（等待）操作**

```c
#include <sys/sem.h>
#include <stdio.h>

int main() {
    key_t key = ftok("/tmp", 'a');
    int semid = semget(key, 1, 0666);

    struct sembuf sop;
    sop.sem_num = 0;  // 第 0 个信号量
    sop.sem_op = -1;  // P 操作，等待资源
    sop.sem_flg = 0;

    printf("Waiting for semaphore...\n");
    semop(semid, &sop, 1);  // 执行 P 操作
    printf("Got semaphore!\n");

    return 0;
}
```

- `semop()` 进行 P 操作（`sem_op = -1`），如果信号量为 `0`，进程会阻塞等待。
    

---

#### **4️⃣ V（释放）操作**

```c
struct sembuf sop;
sop.sem_num = 0;
sop.sem_op = 1;  // V 操作，释放资源
sop.sem_flg = 0;

semop(semid, &sop, 1);
printf("Semaphore released\n");
```

- `sem_op = 1`，执行 V 操作，释放信号量。
    

---

#### **5️⃣ 删除信号量**

```c
semctl(semid, 0, IPC_RMID);
printf("Semaphore deleted\n");
```

- `IPC_RMID` 选项用于删除信号量。
    

---

## **3. POSIX 信号量**

### **3.1 主要系统调用**

| **函数**          | **作用**            |
| --------------- | ----------------- |
| `sem_init()`    | 初始化信号量（用于线程同步）    |
| `sem_open()`    | 创建/打开信号量（用于进程间同步） |
| `sem_wait()`    | P 操作（等待）          |
| `sem_post()`    | V 操作（释放）          |
| `sem_destroy()` | 销毁信号量             |
| `sem_close()`   | 关闭已打开的信号量         |
| `sem_unlink()`  | 删除命名信号量           |

---

### **3.2 线程同步示例**

```c
#include <stdio.h>
#include <pthread.h>
#include <semaphore.h>

sem_t sem;

void *worker(void *arg) {
    sem_wait(&sem);  // P 操作
    printf("Thread %ld is working...\n", (long)arg);
    sleep(2);
    sem_post(&sem);  // V 操作
    return NULL;
}

int main() {
    pthread_t t1, t2;

    sem_init(&sem, 0, 1);  // 初始化信号量，值为1
    pthread_create(&t1, NULL, worker, (void *)1);
    pthread_create(&t2, NULL, worker, (void *)2);

    pthread_join(t1, NULL);
    pthread_join(t2, NULL);
    
    sem_destroy(&sem);  // 销毁信号量
    return 0;
}
```

- `sem_init(&sem, 0, 1)`：初始化信号量，初值 `1`，线程间共享。
    
- `sem_wait()`：P 操作，获取信号量。
    
- `sem_post()`：V 操作，释放信号量。
    

---

### **3.3 进程间同步示例**

#### **1️⃣ 创建命名信号量**

```c
sem_t *sem = sem_open("/mysem", O_CREAT, 0666, 1);
```

- `"/mysem"` 是信号量名称。
    
- `O_CREAT` 创建信号量，初值 `1`。
    

#### **2️⃣ P 操作**

```c
sem_wait(sem);
```

#### **3️⃣ V 操作**

```c
sem_post(sem);
```

#### **4️⃣ 关闭和删除信号量**

```c
sem_close(sem);
sem_unlink("/mysem");
```

---

## **4. 系统 V vs POSIX 信号量**

|**特性**|**系统 V 信号量**|**POSIX 信号量**|
|---|---|---|
|**API 复杂度**|复杂（`semget`、`semop`、`semctl`）|简单（`sem_init`、`sem_wait`、`sem_post`）|
|**进程间同步**|适用|适用（使用 `sem_open`）|
|**线程同步**|不支持|支持|
|**性能**|较低（系统调用多）|高（用户态操作）|

---

## **5. 结论**

- **系统 V 信号量** 适用于**进程间同步**，但 API 复杂，推荐使用 POSIX 信号量。
    
- **POSIX 信号量** 更简单，支持**线程同步**，是现代 Linux 推荐的方式。
    

如果是**多线程**编程，优先使用 **POSIX 信号量**。如果需要在**多个进程间共享**信号量，可以使用**POSIX 进程间信号量（`sem_open`）**。

***

# 13.6 共享内存

## **13.6.1`shmget` 系统调用详解**

`shmget` 是 **System V 共享内存（Shared Memory）** 的系统调用之一，用于**创建或获取一个共享内存段**，多个进程可以通过这个共享内存段进行**高效的进程间通信（IPC）**。


#### **1. `shmget` 函数原型**

```c
#include <sys/ipc.h>
#include <sys/shm.h>

int shmget(key_t key, size_t size, int shmflg);
```

#### **参数说明**

| **参数**   | **作用**                     |
| -------- | -------------------------- |
| `key`    | 共享内存的唯一标识（可以用 `ftok()` 生成） |
| `size`   | 共享内存的大小（字节）                |
| `shmflg` | 标志位，控制共享内存的创建和权限           |

#### **返回值**

- 成功：返回**共享内存 ID**（`shmid`）。
    
- 失败：返回 `-1`，并设置 `errno`。
    

### **2. `shmget` 的 `shmflg` 选项**

| **标志位**     | **作用**                           |
| ----------- | -------------------------------- |
| `IPC_CREAT` | 如果共享内存不存在，则创建                    |
| `IPC_EXCL`  | 与 `IPC_CREAT` 一起使用，确保唯一性（防止重复创建） |
| `0666`      | 设置共享内存的读写权限（与文件权限类似）             |

### **3. `shmget` 的使用示例**

#### **示例：创建共享内存**

```c
#include <stdio.h>
#include <sys/ipc.h>
#include <sys/shm.h>

#define SHM_SIZE 1024  // 共享内存大小

int main() {
    key_t key = ftok("/tmp", 'a');  // 生成唯一 key
    if (key == -1) {
        perror("ftok failed");
        return 1;
    }

    int shmid = shmget(key, SHM_SIZE, IPC_CREAT | 0666);  // 创建共享内存
    if (shmid == -1) {
        perror("shmget failed");
        return 1;
    }

    printf("Shared memory created, ID: %d\n", shmid);
    return 0;
}
```

#### **运行**

```
Shared memory created, ID: 12345
```

- `ftok("/tmp", 'a')` 生成唯一 `key`。
    
- `shmget()` 创建 **1KB** 的共享内存段。
    
***
## 补充： ftok()函数详解

### **`ftok()` 函数详解**

`ftok()` 是一个用于 **生成 IPC（进程间通信） 关键字** 的函数，它常用于 **System V 共享内存（shm）、消息队列（msg）和信号量（sem）**。它可以根据**文件路径和项目 ID** 生成一个唯一的 `key_t` 类型键值，确保多个进程可以使用相同的 IPC 资源。


### **1. `ftok()` 函数原型**

```c
#include <sys/types.h>
#include <sys/ipc.h>

key_t ftok(const char *pathname, int proj_id);
```

#### **参数**

|**参数**|**作用**|
|---|---|
|`pathname`|现有的**文件路径**（文件必须存在）|
|`proj_id`|**项目 ID**，范围 `0-255`，用户自定义的标识符|

#### **返回值**

- 成功：返回 **key_t** 类型的键值（用于 `shmget()`、`msgget()`、`semget()`）。
    
- 失败：返回 `-1`，并设置 `errno`。
    

### **2. `ftok()` 的作用**

- `ftok()` 生成的 key 是基于 `pathname` 和 `proj_id` 计算的**唯一标识符**。
    
- **相同的 `pathname` 和 `proj_id`，在不同进程中生成的 `key_t` 相同**，可以让不同进程访问同一个 IPC 资源。
    


### **3. `ftok()` 计算 key 的方式**

Linux 通常使用如下方式计算 `key_t`：

1. `pathname` 对应的**i-node 编号**（文件系统中的唯一标识）。
    
2. `proj_id` 作为低 8 位。
    
3. 通过特定算法组合成 `key_t` 值。
    

📌 **注意**：

- **如果 `pathname` 对应的文件被删除，生成的 key 可能会变**（因为 i-node 变了）。
    
- **不同的 `proj_id` 可以生成不同的 key**，即使 `pathname` 相同。
    


### **4. `ftok()` 使用示例**

#### **示例 1：生成 key 并创建共享内存**

```c
#include <stdio.h>
#include <sys/ipc.h>
#include <sys/shm.h>

#define SHM_SIZE 1024  // 共享内存大小

int main() {
    key_t key = ftok("/tmp", 'a');  // 生成 key
    if (key == -1) {
        perror("ftok failed");
        return 1;
    }
    
    int shmid = shmget(key, SHM_SIZE, IPC_CREAT | 0666);  // 创建共享内存
    if (shmid == -1) {
        perror("shmget failed");
        return 1;
    }

    printf("Shared memory created with key: %d, ID: %d\n", key, shmid);
    return 0;
}
```

**运行**

```
Shared memory created with key: 12345, ID: 67890
```

📌 **注意**

- `ftok("/tmp", 'a')` 生成 key。
    
- `shmget()` 使用该 key 创建共享内存。
    
- **不同进程可以使用相同 key 访问该共享内存**。
    

### 3 **示例 2：使用 `ftok()` 生成不同 IPC 资源**

```c
key_t shm_key = ftok("/tmp", 'A');  // 用于共享内存
key_t sem_key = ftok("/tmp", 'B');  // 用于信号量
key_t msg_key = ftok("/tmp", 'C');  // 用于消息队列
```

📌 **这样，多个 IPC 资源可以基于同一个文件，但 `proj_id` 不同**，不会冲突。

 

### **5. `ftok()` 可能失败的情况**

#### **❌ `ftok()` 返回 `-1` 的原因**

| **原因**               | **解决方案**                      |
| -------------------- | ----------------------------- |
| `pathname` 不存在       | 确保 `pathname` 指向的文件存在         |
| 没有读权限                | 赋予 `pathname` 读权限（`chmod +r`） |
| `proj_id` 超过 `0-255` | 选择 `0-255` 之间的数               |

---

### **6. `ftok()` vs `random key`**

有时开发者会**不用 `ftok()`，而是自己生成 key**：

```c
key_t key = 12345;  // 直接定义 key
```

**对比 `ftok()`：**

|**方法**|**优点**|**缺点**|
|---|---|---|
|`ftok()`|**自动生成** key，避免冲突|**需要文件存在**|
|手动 `key_t`|**不依赖文件**|**可能 key 冲突**|

📌 **建议**

- **单机**：`ftok()` 更安全，避免 key 冲突。
    
- **跨机**（不同机器上）: `ftok()` **不可用**，需要手动 key。
    


### **7. 总结**

- `ftok()` 用于**生成唯一的 IPC 关键字**，供 `shmget()`、`msgget()`、`semget()` 使用。
    
- `pathname` 需要是**存在的文件**，**不能删除**，否则 key 可能变化。
    
- **相同 `pathname` 和 `proj_id` 在不同进程中生成的 key 相同**，用于 IPC 共享。
    
- `proj_id` **应在 `0-255` 之间**，不同 `proj_id` 可生成**不同 IPC 资源**。
    

如果要创建多个 IPC 资源（共享内存、信号量、消息队列），可以：

```c
key_t key1 = ftok("/tmp", 'A');
key_t key2 = ftok("/tmp", 'B');
key_t key3 = ftok("/tmp", 'C');
```

这样，**不同 IPC 资源不会冲突**。🚀

***
## **13.6.2 `shmat` 和 `shmdt` 详解**

在 **System V 共享内存（Shared Memory）** 机制中，`shmat()` 和 `shmdt()` 是两个关键的系统调用：

- **`shmat()`**：将共享内存**映射**到进程的地址空间，使进程可以访问它。
    
- **`shmdt()`**：解除共享内存的映射，使进程不再访问它。
    

这两个调用是 `shmget()` 之后的**必要步骤**，否则进程无法使用共享内存。


### **1. `shmat()` - 将共享内存映射到进程**

#### **函数原型**

```c
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/shm.h>

void *shmat(int shmid, const void *shmaddr, int shmflg);
```

#### **参数**

| **参数**    | **作用**                            |
| --------- | --------------------------------- |
| `shmid`   | 共享内存段的 ID（由 `shmget()` 返回）        |
| `shmaddr` | 指定共享内存的挂接地址（通常设为 `NULL`，让系统自动分配）  |
| `shmflg`  | 标志位，通常设为 `0`（读写），`SHM_RDONLY`（只读） |

#### **返回值**

- 成功：返回共享内存的**指针**（地址）。
    
- 失败：返回 `(void *) -1`，并设置 `errno`。
    


#### **2. `shmdt()` - 解除共享内存映射**

#### **函数原型**

```c
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/shm.h>

int shmdt(const void *shmaddr);
```

#### **参数**

| **参数**    | **作用**                        |
| --------- | ----------------------------- |
| `shmaddr` | 共享内存的指针地址（之前 `shmat()` 返回的地址） |

#### **返回值**

- 成功：返回 `0`。
    
- 失败：返回 `-1`，并设置 `errno`。
    

📌 **注意**

- `shmdt()` **不会删除** 共享内存，只是解除映射。
    
- 如果**所有进程都 `shmdt()` 了共享内存，且没有 `shmctl()` 删除它，它仍然存在**（直到系统重启或被手动删除）。
    


### **3. `shmat()` 和 `shmdt()` 的完整示例**

#### **进程 1（写入共享内存）**

```c
#include <stdio.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <string.h>

#define SHM_SIZE 1024  // 共享内存大小

int main() {
    key_t key = ftok("/tmp", 'A');  // 生成 key
    int shmid = shmget(key, SHM_SIZE, IPC_CREAT | 0666);  // 获取共享内存
    if (shmid == -1) {
        perror("shmget failed");
        return 1;
    }

    // 挂接共享内存
    char *shmaddr = (char *)shmat(shmid, NULL, 0);
    if (shmaddr == (void *)-1) {
        perror("shmat failed");
        return 1;
    }

    // 写入数据
    strcpy(shmaddr, "Hello, Shared Memory!");
    printf("Written to shared memory: %s\n", shmaddr);

    // 解除映射
    shmdt(shmaddr);
    return 0;
}
```


#### **进程 2（读取共享内存）**

```c
#include <stdio.h>
#include <sys/ipc.h>
#include <sys/shm.h>

#define SHM_SIZE 1024

int main() {
    key_t key = ftok("/tmp", 'A');
    int shmid = shmget(key, SHM_SIZE, 0666);  // 仅获取已存在的共享内存
    if (shmid == -1) {
        perror("shmget failed");
        return 1;
    }

    // 挂接共享内存
    char *shmaddr = (char *)shmat(shmid, NULL, 0);
    if (shmaddr == (void *)-1) {
        perror("shmat failed");
        return 1;
    }

    // 读取数据
    printf("Read from shared memory: %s\n", shmaddr);

    // 解除映射
    shmdt(shmaddr);
    return 0;
}
```


#### **进程 3（删除共享内存）**

```c
#include <sys/ipc.h>
#include <sys/shm.h>
#include <stdio.h>

int main() {
    key_t key = ftok("/tmp", 'A');
    int shmid = shmget(key, 1024, 0666);
    if (shmid == -1) {
        perror("shmget failed");
        return 1;
    }

    shmctl(shmid, IPC_RMID, NULL);  // 删除共享内存
    printf("Shared memory deleted\n");
    return 0;
}
```


### **4. `shmat()` 参数详细解释**

#### **1️⃣ `shmaddr = NULL`（推荐）**

```c
char *shmaddr = (char *)shmat(shmid, NULL, 0);
```

- 让**系统自动选择映射地址**（更安全）。
    
- 适用于大多数情况。
    

#### **2️⃣ 指定 `shmaddr` 地址**

```c
char *shmaddr = (char *)shmat(shmid, (void *)0x50000000, 0);
```

- 指定固定地址（不推荐）。
    
- 可能与进程的内存布局冲突，导致 `shmat()` 失败。
    


### **5. `shmflg` 标志**

| **标志**       | **作用**                              |
| ------------ | ----------------------------------- |
| `0`          | 默认（读写）                              |
| `SHM_RDONLY` | 以**只读模式**挂接                         |
| `SHM_RND`    | 地址向下取整到 `SHMLBA`（Linux 通常为 4096 字节） |

#### **示例：只读模式**

```c
char *shmaddr = (char *)shmat(shmid, NULL, SHM_RDONLY);
```

- 进程可以读取共享内存，但**不能修改**。
    


### **6. `shmdt()` 细节**

#### **`shmdt()` 只是解除映射，不删除共享内存**

```c
shmdt(shmaddr);
```

- 进程**不再访问**共享内存。
    
- 但**共享内存仍然存在**，可以被其他进程使用。
    
- 需要 `shmctl(shmid, IPC_RMID, NULL);` **删除共享内存**。
    

### **7. `shmat()` / `shmdt()` vs `mmap()`**

| **特性**    | **`shmat()` / `shmdt()`（System V）** | **`mmap()`（POSIX）** |
| --------- | ----------------------------------- | ------------------- |
| **进程间通信** | 是（共享内存）                             | 是（文件映射）             |
| **使用方式**  | `shmget()` + `shmat()`              | `mmap()`            |
| **可移植性**  | System V 兼容                         | POSIX 兼容            |
| **内存持久化** | 否                                   | 可能（文件映射）            |
| **灵活性**   | 低（固定 `shmget()`）                    | 高（可映射文件或匿名）         |

### **8. 总结**

- `shmat(shmid, NULL, 0)` **映射共享内存**，返回地址。
    
- `shmdt(shmaddr)` **解除映射**，但不删除共享内存。
    
- **要删除共享内存**，必须调用 `shmctl(shmid, IPC_RMID, NULL);`。
    
- 共享内存适用于**进程间通信（IPC）**，比消息队列和管道更快。 

***
## **13.6.3 shmctl() 详解**

`shmctl()` 是 Linux System V **共享内存（Shared Memory）** 相关的 **控制系统调用**，用于**管理共享内存段**。它可以用于**查询信息、修改权限和删除共享内存**。


### **1. `shmctl()` 函数原型**

```c
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/shm.h>

int shmctl(int shmid, int cmd, struct shmid_ds *buf);
```

### **2. 参数详解**

|**参数**|**作用**|
|---|---|
|`shmid`|**共享内存段 ID**（由 `shmget()` 返回）|
|`cmd`|**控制命令**（指定操作类型，如删除、修改权限等）|
|`buf`|**数据结构指针**（用于存储或修改共享内存的信息）|


### **3. `cmd`（控制命令）可选值**

| **`cmd`**    | **作用**                       |
| ------------ | ---------------------------- |
| `IPC_STAT`   | 获取共享内存的信息，存入 `buf`           |
| `IPC_SET`    | 修改 `buf` 结构中的共享内存属性（如权限）     |
| `IPC_RMID`   | **删除共享内存**                   |
| `SHM_LOCK`   | 锁定共享内存，防止被交换到磁盘（仅 root 用户可用） |
| `SHM_UNLOCK` | 解锁共享内存                       |


### **4. `struct shmid_ds` 结构体**

`shmctl()` 用 `struct shmid_ds` 结构体存储共享内存的信息：

```c
struct shmid_ds {
    struct ipc_perm shm_perm;   // 共享内存权限
    size_t shm_segsz;           // 共享内存大小（字节）
    pid_t shm_lpid;             // 最后操作该共享内存的进程 ID
    pid_t shm_cpid;             // 创建该共享内存的进程 ID
    shmatt_t shm_nattch;        // 当前附加到该共享内存的进程数
    time_t shm_atime;           // 最后一次 `shmat()` 时间
    time_t shm_dtime;           // 最后一次 `shmdt()` 时间
    time_t shm_ctime;           // 共享内存创建时间
};
```

📌 **重点字段解释**

- **`shm_segsz`**：共享内存大小（字节）。
    
- **`shm_nattch`**：当前有多少个进程连接到这块共享内存。
    
- **`shm_perm.mode`**：共享内存的访问权限（如 `0666`）。
    
- **`shm_perm.uid / shm_perm.gid`**：创建者用户 ID 和组 ID。
    


## **5. `shmctl()` 使用示例**

### **示例 1：获取共享内存信息（`IPC_STAT`）**

```c
#include <stdio.h>
#include <sys/ipc.h>
#include <sys/shm.h>

int main() {
    key_t key = ftok("/tmp", 'A');
    int shmid = shmget(key, 1024, 0666);
    if (shmid == -1) {
        perror("shmget failed");
        return 1;
    }

    struct shmid_ds buf;
    if (shmctl(shmid, IPC_STAT, &buf) == -1) {
        perror("shmctl IPC_STAT failed");
        return 1;
    }

    printf("Shared Memory Size: %ld bytes\n", buf.shm_segsz);
    printf("Attached Processes: %ld\n", buf.shm_nattch);
    printf("Last attach time: %ld\n", buf.shm_atime);
    printf("Last detach time: %ld\n", buf.shm_dtime);
    
    return 0;
}
```

📌 **功能**

- **查询** 共享内存信息，如大小、当前连接进程数、最近访问时间。
    

### **示例 2：修改共享内存权限（`IPC_SET`）**

```c
#include <stdio.h>
#include <sys/ipc.h>
#include <sys/shm.h>

int main() {
    key_t key = ftok("/tmp", 'A');
    int shmid = shmget(key, 1024, 0666);
    if (shmid == -1) {
        perror("shmget failed");
        return 1;
    }

    struct shmid_ds buf;
    if (shmctl(shmid, IPC_STAT, &buf) == -1) {
        perror("shmctl IPC_STAT failed");
        return 1;
    }

    buf.shm_perm.mode = 0644;  // 修改权限为 0644（所有者可读写，其他人只读）
    if (shmctl(shmid, IPC_SET, &buf) == -1) {
        perror("shmctl IPC_SET failed");
        return 1;
    }

    printf("Shared memory permissions changed to 0644\n");
    return 0;
}
```

📌 **功能**

- 先用 `IPC_STAT` 获取信息，然后**修改权限**。
    

### **示例 3：删除共享内存（`IPC_RMID`）**

```c
#include <stdio.h>
#include <sys/ipc.h>
#include <sys/shm.h>

int main() {
    key_t key = ftok("/tmp", 'A');
    int shmid = shmget(key, 1024, 0666);
    if (shmid == -1) {
        perror("shmget failed");
        return 1;
    }

    if (shmctl(shmid, IPC_RMID, NULL) == -1) {
        perror("shmctl IPC_RMID failed");
        return 1;
    }

    printf("Shared memory deleted.\n");
    return 0;
}
```

📌 **功能**

- **删除共享内存段**，但：
    
    - **仍然连接的进程不会立即受到影响**，只有当所有进程 `shmdt()` 后，内存才会真正释放。
        

### **6. `shmctl()` 失败的可能原因**

| **错误码 (`errno`)** | **可能原因**               | **解决方案**                        |
| ----------------- | ---------------------- | ------------------------------- |
| `EINVAL`          | `shmid` 无效             | 确保 `shmid` 正确，使用 `shmget()` 获取  |
| `EACCES`          | 无权限访问                  | 运行 `chmod` 赋予权限                 |
| `EFAULT`          | `buf` 指针非法             | 确保 `buf` 指向有效 `struct shmid_ds` |
| `EPERM`           | 非 root 用户尝试 `SHM_LOCK` | 以 root 身份运行                     |


### **7. `shmctl()` vs `shmdt()` vs `shmget()`**

|**函数**|**作用**|
|---|---|
|`shmget()`|创建共享内存|
|`shmat()`|进程**连接**共享内存|
|`shmdt()`|进程**断开**共享内存|
|`shmctl(IPC_STAT)`|获取共享内存信息|
|`shmctl(IPC_SET)`|修改共享内存权限|
|`shmctl(IPC_RMID)`|**删除共享内存**|


### **8. `shmctl()` 相关的系统命令**

**Linux 提供了 `ipcs` 和 `ipcrm` 命令来管理共享内存：**

### **查看共享内存**

```sh
ipcs -m
```

📌 **示例输出**

```
------ Shared Memory Segments ------
key        shmid      owner      perms      bytes      nattch     
0x12345678 56789      user       666        1024       1
```

- `shmid`：共享内存 ID
    
- `bytes`：大小
    
- `nattch`：当前连接的进程数
    

### **删除共享内存**

```sh
ipcrm -m 56789
```

📌 `56789` 是 `shmid`，相当于 `shmctl(shmid, IPC_RMID, NULL);`。


### **9. 总结**

✅ `shmctl()` 主要用于：

- **查询共享内存信息**（`IPC_STAT`）
    
- **修改权限**（`IPC_SET`）
    
- **删除共享内存**（`IPC_RMID`）
    

如果想**删除共享内存**：

- 代码调用：`shmctl(shmid, IPC_RMID, NULL);`
    
- 命令行调用：`ipcrm -m <shmid>`
    

**使用 `shmat()` 连接共享内存的进程必须 `shmdt()` 后，删除才生效**！🚀

***

## **13.6.4 POSIX 共享内存（Shared Memory）详解**

POSIX 共享内存（`shm_open` / `shm_unlink`）是 **进程间通信（IPC）** 的一种方式，它比 System V 共享内存更**简单、可移植**，并且可以使用**文件描述符**来管理。


### **1. POSIX 共享内存 vs. System V 共享内存**

| **特性**     | **POSIX 共享内存**            | **System V 共享内存**            |
| ---------- | ------------------------- | ---------------------------- |
| **创建方式**   | `shm_open()`              | `shmget()`                   |
| **映射方式**   | `mmap()`                  | `shmat()`                    |
| **删除方式**   | `shm_unlink()`            | `shmctl(IPC_RMID)`           |
| **命名方式**   | 以**文件路径**命名（如`/shm_test`） | 用**`key_t`** 生成 `shmid`      |
| **进程访问方式** | 使用 **文件描述符**              | 直接使用 `shmid`                 |
| **清理**     | **持久化**，进程退出后仍然存在         | 进程退出后可能仍然存在，必须 `shmctl()` 删除 |

POSIX 共享内存是**文件系统友好的方式**，**与 `mmap()` 结合使用**，更现代、更灵活。


### **2. POSIX 共享内存相关的系统调用**

|**函数**|**作用**|
|---|---|
|`shm_open()`|创建或打开共享内存对象（返回文件描述符）|
|`ftruncate()`|设置共享内存大小|
|`mmap()`|将共享内存映射到进程地址空间|
|`munmap()`|解除映射|
|`shm_unlink()`|删除共享内存对象|


### **3. POSIX 共享内存的使用流程**

### **📌 进程 1（写入共享内存）**

```c
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>      // O_* 常量
#include <sys/mman.h>   // mmap, shm_open
#include <unistd.h>     // ftruncate, close
#include <string.h>

#define SHM_NAME "/shm_test"
#define SHM_SIZE 1024

int main() {
    // 1️⃣ 创建或打开共享内存对象
    int shm_fd = shm_open(SHM_NAME, O_CREAT | O_RDWR, 0666);
    if (shm_fd == -1) {
        perror("shm_open failed");
        return 1;
    }

    // 2️⃣ 设置共享内存大小
    if (ftruncate(shm_fd, SHM_SIZE) == -1) {
        perror("ftruncate failed");
        return 1;
    }

    // 3️⃣ 映射共享内存到进程地址空间
    void *shm_ptr = mmap(0, SHM_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, shm_fd, 0);
    if (shm_ptr == MAP_FAILED) {
        perror("mmap failed");
        return 1;
    }

    // 4️⃣ 写入共享内存
    strcpy((char *)shm_ptr, "Hello, POSIX Shared Memory!");
    printf("Written to shared memory: %s\n", (char *)shm_ptr);

    // 5️⃣ 解除映射
    munmap(shm_ptr, SHM_SIZE);
    
    // 6️⃣ 关闭文件描述符（但共享内存仍然存在）
    close(shm_fd);

    return 0;
}
```


#### **📌 进程 2（读取共享内存）**

```c
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>      // O_* 常量
#include <sys/mman.h>   // mmap, shm_open
#include <unistd.h>     // close

#define SHM_NAME "/shm_test"
#define SHM_SIZE 1024

int main() {
    // 1️⃣ 打开共享内存对象
    int shm_fd = shm_open(SHM_NAME, O_RDONLY, 0666);
    if (shm_fd == -1) {
        perror("shm_open failed");
        return 1;
    }

    // 2️⃣ 映射共享内存到进程地址空间（只读模式）
    void *shm_ptr = mmap(0, SHM_SIZE, PROT_READ, MAP_SHARED, shm_fd, 0);
    if (shm_ptr == MAP_FAILED) {
        perror("mmap failed");
        return 1;
    }

    // 3️⃣ 读取数据
    printf("Read from shared memory: %s\n", (char *)shm_ptr);

    // 4️⃣ 解除映射
    munmap(shm_ptr, SHM_SIZE);
    
    // 5️⃣ 关闭文件描述符
    close(shm_fd);

    return 0;
}
```


#### **📌 进程 3（删除共享内存）**

```c
#include <stdio.h>
#include <fcntl.h>      
#include <sys/mman.h>   

#define SHM_NAME "/shm_test"

int main() {
    // 删除共享内存
    if (shm_unlink(SHM_NAME) == -1) {
        perror("shm_unlink failed");
        return 1;
    }

    printf("Shared memory deleted.\n");
    return 0;
}
```


### **4. 详细解释 `shm_open()` / `shm_unlink()`**

#### **1️⃣ `shm_open()` - 创建/打开共享内存**

```c
int shm_fd = shm_open("/shm_test", O_CREAT | O_RDWR, 0666);
```

|**参数**|**作用**|
|---|---|
|`"/shm_test"`|共享内存名称（必须以 `/` 开头，类似文件路径）|
|`O_CREAT`|如果不存在，则创建|
|`O_RDWR`|以读写模式打开|
|`0666`|设定权限（所有用户可读写）|

🔹 **返回值**：文件描述符（用于 `mmap()`）。


#### **2️⃣ `ftruncate()` - 设置共享内存大小**

```c
ftruncate(shm_fd, 1024);
```

- `shm_open()` 只是创建了**文件**，但默认大小是 0，必须用 `ftruncate()` 设置大小。
    


#### **3️⃣ `mmap()` - 映射共享内存**

```c
void *shm_ptr = mmap(0, 1024, PROT_READ | PROT_WRITE, MAP_SHARED, shm_fd, 0);
```

|**参数**|**作用**|
|---|---|
|`0`|让系统自动选择地址|
|`1024`|共享内存大小|
|`PROT_READ|PROT_WRITE`|
|`MAP_SHARED`|共享映射（其他进程可见）|
|`shm_fd`|共享内存文件描述符|
|`0`|偏移量（一般为 0）|

🔹 **返回值**：映射到进程地址空间的指针。


#### **4️⃣ `shm_unlink()` - 删除共享内存**

```c
shm_unlink("/shm_test");
```

- 类似 `unlink()`，**删除共享内存对象**（所有进程关闭后才真正释放）。
    


### **5. 适用场景**

✅ **POSIX 共享内存适用于**

- **多进程数据共享**（比管道、消息队列更快）
    
- **服务器-客户端模型**（多个进程读取同一内存）
    
- **高效 IPC（Inter-Process Communication）**
    
- **更现代的 Linux 应用**
    


### **6. 总结**

|**步骤**|**函数**|
|---|---|
|**创建/打开共享内存**|`shm_open()`|
|**设置大小**|`ftruncate()`|
|**映射内存**|`mmap()`|
|**读写数据**|直接使用指针操作|
|**解除映射**|`munmap()`|
|**关闭文件描述符**|`close()`|
|**删除共享内存**|`shm_unlink()`|

POSIX 共享内存**更易用、更现代**，适用于**高性能多进程通信**！🚀

***

# 13.7 消息队列


### 🌟 一、基本概念

POSIX 消息队列（Message Queue）是基于 **名字命名** 的，允许进程间以**先进先出**的方式传递**结构化消息**，适合有优先级、结构化需求的通信。

---

### 📚 二、相关头文件

```c
#include <mqueue.h>     // POSIX 消息队列主头文件
#include <fcntl.h>      // O_CREAT 等常量定义
#include <sys/stat.h>   // mode_t 权限设置
```

---

### 🧱 三、主要函数及参数

---

#### 1. `mqd_t mq_open(const char *name, int oflag, mode_t mode, struct mq_attr *attr);`

- **功能**：打开或创建一个消息队列。
    
- **参数说明**：
    
    - `name`：消息队列名，必须以 `/` 开头，例如 `"/myqueue"`。
        
    - `oflag`：
        
        - `O_RDONLY`：只读
            
        - `O_WRONLY`：只写
            
        - `O_RDWR`：可读可写
            
        - `O_CREAT`：如果不存在则创建
            
        - `O_EXCL`：与 `O_CREAT` 一起用，若已存在则失败
            
    - `mode`：权限，例如 `0666` 表示用户、组、其他都有读写权限。
        
    - `attr`：可选，设置队列属性，若为 NULL 使用默认值。
        
        ```c
        struct mq_attr {
            long mq_flags;    // 0：阻塞；O_NONBLOCK：非阻塞
            long mq_maxmsg;   // 最大消息数
            long mq_msgsize;  // 每条消息的最大大小
            long mq_curmsgs;  // 当前消息数（只读）
        };
        ```
        

---

#### 2. `int mq_send(mqd_t mqdes, const char *msg_ptr, size_t msg_len, unsigned int msg_prio);`

- **功能**：发送消息。
    
- **参数说明**：
    
    - `mqdes`：由 `mq_open` 返回的描述符。
        
    - `msg_ptr`：消息内容。
        
    - `msg_len`：消息长度，不能超过 `mq_msgsize`。
        
    - `msg_prio`：优先级（0 是默认，值越大优先级越高）。
        

---

#### 3. `ssize_t mq_receive(mqd_t mqdes, char *msg_ptr, size_t msg_len, unsigned int *msg_prio);`

- **功能**：接收消息。
    
- **参数说明**：
    
    - `msg_ptr`：用于存放接收到的消息。
        
    - `msg_len`：缓冲区大小，应 ≥ `mq_msgsize`。
        
    - `msg_prio`：若不为 NULL，会返回消息的优先级。
        

---

#### 4. `int mq_close(mqd_t mqdes);`

- **功能**：关闭队列描述符。
    
- **mq_unlink(name)`：删除消息队列（类似` unlink` 删除文件）**。
    

---

#### 5. `int mq_getattr(mqd_t mqdes, struct mq_attr *attr);`

#### 6. `int mq_setattr(mqd_t mqdes, const struct mq_attr *newattr, struct mq_attr *oldattr);`

---

### 📌 四、完整示例

#### **发送者（sender.c）**

```c
#include <stdio.h>
#include <mqueue.h>
#include <string.h>

int main() {
    mqd_t mq;
    struct mq_attr attr = {
        .mq_flags = 0,
        .mq_maxmsg = 10,
        .mq_msgsize = 256,
        .mq_curmsgs = 0
    };

    mq = mq_open("/testmq", O_CREAT | O_WRONLY, 0644, &attr);

    if (mq == -1) {
        perror("mq_open");
        return 1;
    }

    char msg[] = "Hello POSIX MQ!";
    mq_send(mq, msg, strlen(msg) + 1, 0);

    mq_close(mq);
    return 0;
}
```

#### **接收者（receiver.c）**

```c
#include <stdio.h>
#include <mqueue.h>

int main() {
    mqd_t mq = mq_open("/testmq", O_RDONLY);
    if (mq == -1) {
        perror("mq_open");
        return 1;
    }

    char buffer[256];
    unsigned int prio;
    mq_receive(mq, buffer, sizeof(buffer), &prio);

    printf("Received: %s (prio: %u)\n", buffer, prio);

    mq_close(mq);
    mq_unlink("/testmq");  // 删除队列
    return 0;
}
```

---

### 🧩 五、注意事项

- 消息队列名必须以 `/` 开头，不能包含其他 `/`。
    
- 默认大小（mq_msgsize）是有限制的（比如 8192 字节）。
    
- 发送方和接收方应共享同一个名字。
    
- Linux 上 POSIX MQ 默认存储于 `/dev/mqueue/`。
    

***

# 13.8 IPC命令

`ipc` 命令是 Linux 系统中用来显示或操作进程间通信（IPC）资源的一个工具。它主要用于查看和管理：

- **共享内存（Shared Memory）**
    
- **消息队列（Message Queue）**
    
- **信号量（Semaphore）**
    

---

## 🧰 一、命令格式

```bash
ipc [选项] <子命令>
```

注意：有些系统中该命令可能名为 `ipcs` 和 `ipcrm`（`ipc` 是一种抽象理解，实际上是多个命令组合）。

---

## 📌 二、常用命令

### 1. `ipcs`：查看系统当前 IPC 对象

```bash
ipcs            # 查看所有类型的 IPC
ipcs -m         # 查看共享内存段（memory）
ipcs -q         # 查看消息队列（queue）
ipcs -s         # 查看信号量（semaphore）
```

🔍 输出示例：

```bash
------ Message Queues --------
key        msqid      owner      perms      used-bytes   messages    
0x00000000 32768      user       644        0            0           
```

字段解释：

- `key`：由 ftok 生成的 key 值
    
- `msqid`：系统为消息队列分配的 ID
    
- `owner`：拥有者用户名
    
- `perms`：权限（如 644）
    
- `messages`：当前消息数量
    

---

### 2. `ipcrm`：删除 IPC 对象

- 删除共享内存：
    

```bash
ipcrm -m <shmid>
```

- 删除消息队列：
    

```bash
ipcrm -q <msqid>
```

- 删除信号量：
    

```bash
ipcrm -s <semid>
```

你可以先用 `ipcs` 获取对象 ID，再用 `ipcrm` 删除。

---

## 🧪 三、实际案例

### 创建并查看消息队列

1. 写一个创建队列的程序，运行后用：
    

```bash
ipcs -q
```

查看是否创建成功。

### 删除孤立 IPC 资源

有时候进程异常退出会留下资源，使用：

```bash
ipcs -m   # 找出孤立共享内存段
ipcrm -m <shmid>
```

清理干净。

---

## 📄 四、常见问题

- IPC 对象创建后不会自动删除（需手动或程序退出时处理）。
    
- 如果报错如 `No space left on device`，可能是 IPC 对象太多未释放。
    
- 权限问题时，使用 `sudo ipcs` 或 `sudo ipcrm`。
    

---

# 13.9在进程间传递文件描述符

## 前置知识:

`struct msghdr` 是 POSIX 标准下用于 **`sendmsg()` / `recvmsg()`** 系统调用中，用于描述**消息头**的数据结构，常用于：

- 发送或接收带有**辅助数据**（control message，如文件描述符、IP信息等）的消息
    
- 支持 **scatter/gather I/O**（分散读、集中写）
    
- Unix 域套接字、原始 socket 编程、高级 socket 编程等场景

## 🧱 `struct msghdr` 结构体定义（glibc 中）：

```c
struct msghdr {
    void         *msg_name;       // 目标地址 / 源地址（可以为 NULL）
    socklen_t     msg_namelen;    // 地址长度
    struct iovec *msg_iov;        // 数据缓冲区数组（I/O向量）
    int           msg_iovlen;     // 缓冲区数量
    void         *msg_control;    // 控制消息（辅助数据）
    socklen_t     msg_controllen; // 控制消息长度
    int           msg_flags;      // 接收标志（仅用于 recvmsg）
};
```

## 📝 各字段详细解释：

| 字段名              | 类型               | 用途                                                              |
| ---------------- | ---------------- | --------------------------------------------------------------- |
| `msg_name`       | `void *`         | 目标地址或源地址（如 `struct sockaddr_in *`），可为 `NULL` 表示不关心地址            |
| `msg_namelen`    | `socklen_t`      | 地址长度，单位是字节                                                      |
| `msg_iov`        | `struct iovec *` | 指向一组 `iovec`，每个 `iovec` 代表一块缓冲区（用于支持 scatter/gather I/O）        |
| `msg_iovlen`     | `int`            | `iovec` 数组中的元素个数                                                |
| `msg_control`    | `void *`         | 指向控制信息（control message），用于传递辅助数据                                |
| `msg_controllen` | `socklen_t`      | 控制信息缓冲区的长度（单位是字节）                                               |
| `msg_flags`      | `int`            | **仅在 `recvmsg` 返回时设置**，表示接收到的额外信息，如 `MSG_TRUNC`, `MSG_CTRUNC` 等 |

## 📦 相关结构体：`struct iovec`

`msg_iov` 指向的是一组 `struct iovec`：

```c
struct iovec {
    void  *iov_base;  // 缓冲区起始地址
    size_t iov_len;   // 缓冲区长度
};
```


`struct cmsghdr` 是 **POSIX 标准**中用于在 `msghdr` 结构体中的 `msg_control` 区域中传递“控制消息”（**control message**）的结构体，用于描述 **辅助数据**，比如：

- **发送/接收文件描述符**
    
- **传递 socket 选项（如 TTL, TOS）**
    
- **接收原始 IP 头信息**
    
- **接收多播接口、错误信息等**
    

是底层 socket 编程中处理 **带外数据** 的关键结构。


## 🧱 `struct cmsghdr` 定义（glibc 中）

```c
struct cmsghdr {
    socklen_t cmsg_len;    // 控制消息的总长度，包括 cmsghdr + 数据
    int       cmsg_level;  // 协议层级（如 SOL_SOCKET）
    int       cmsg_type;   // 控制消息的类型（如 SCM_RIGHTS）
    // 后面紧跟着控制数据（通过 CMSG_DATA() 宏访问）
};
```


## 📌 字段解释：

| 字段名          | 类型          | 说明                                               |
| ------------ | ----------- | ------------------------------------------------ |
| `cmsg_len`   | `socklen_t` | 整个控制消息的长度（包括 `cmsghdr` 和附加数据），单位是字节              |
| `cmsg_level` | `int`       | 协议层级，常用的是 `SOL_SOCKET`                           |
| `cmsg_type`  | `int`       | 消息类型，如 `SCM_RIGHTS`（传输文件描述符）、`SCM_CREDENTIALS` 等 |
| 控制数据         | -           | 实际的数据（如文件描述符、认证信息），紧跟在 `cmsghdr` 后面              |


## 📦 常用宏函数（都在 `<sys/socket.h>` 中定义）

### `CMSG_SPACE(len)`

> 申请控制消息缓冲区所需的总空间，包含结构体和必要的对齐填充。

```c
char control[CMSG_SPACE(sizeof(int))];  // 控制区申请
```

### `CMSG_LEN(len)`

> 实际的控制消息长度，不包含 padding，只用于设置 `cmsg_len` 字段。

```c
cmsg->cmsg_len = CMSG_LEN(sizeof(int));
```

### `CMSG_FIRSTHDR(&msghdr)`

> 获取第一个 `cmsghdr` 指针。

```c
struct cmsghdr *cmsg = CMSG_FIRSTHDR(&msg);
```

### `CMSG_NXTHDR(&msghdr, cmsg)`

> 获取下一个控制消息。

### `CMSG_DATA(cmsg)`

> 获取控制数据区的指针（如用于读写文件描述符等）。

```c
int fd = *((int *) CMSG_DATA(cmsg));
```

```c
#include <asm-generic/socket.h>
#include <sys/socket.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <assert.h>
#include <stdio.h>
#include <fcntl.h>

static const int CONTROL_LEN = CMSG_LEN(sizeof(int));

//发送文件描述符,fd参数是用来传递信息的UNIX域socket,fd_to_send参数是带发送的文件描述符
void send_fd(int fd,int fd_to_send)
{
  struct iovec iov[1];
  struct msghdr msg;
  char buf[0];

  iov[0].iov_base = buf;
  iov[0].iov_len = 1;
  msg.msg_name = NULL;
  msg.msg_namelen = 0;
  msg.msg_iov = iov;
  msg.msg_iovlen = 1;

  cmsghdr cm;
  cm.cmsg_len = CONTROL_LEN;
  cm.cmsg_level = SOL_SOCKET;
  cm.cmsg_type = SCM_RIGHTS;
  *(int*)CMSG_DATA(&cm) = fd_to_send;
  msg.msg_control = &cm;
  msg.msg_controllen = CONTROL_LEN;

  sendmsg(fd,&msg,0);
}

//接受目标文件
int recv_fd(int fd)
{
  struct iovec iov[1];
  struct msghdr msg;
  char buf[0];

  iov[0].iov_base = buf;
  iov[0].iov_len = 1;

  msg.msg_name = NULL;
  msg.msg_namelen = 0;
  msg.msg_iov = iov;
  msg.msg_iovlen = 1;

  cmsghdr cm;
  msg.msg_control = &cm;
  msg.msg_controllen = CONTROL_LEN;

  recvmsg(fd,&msg,0);
  int fd_to_read = *(int*)CMSG_DATA(&cm);
  return fd_to_read;
}

int main()
{
  int pipefd[2];
  int fd_to_pass = 0;

  //创建父子进程见的管道，文件描述符pipefd[0]和pipefd[1]
  int ret = socketpair(PF_UNIX,SOCK_DGRAM,0,pipefd);
  assert(ret != -1);

  pid_t pid = fork();
  assert(pid >= 0);

  if(pid == 0)
  {
    close(pipefd[0]);
    fd_to_pass = open("test.txt",O_RDWR,0666);
    //子进程通过管道文件描述符发送到父进程。如果文件test.txt打开失败，则子进程将标准输入文件描述符发送到子进程
    send_fd(pipefd[1],(fd_to_pass > 0) ? fd_to_pass : 0);
    close(fd_to_pass);
    exit(0);
  }

  close(pipefd[1]);
  fd_to_pass = recv_fd(pipefd[0]);
  char buf[1024];
  memset(buf,'\0',1024);
  read(fd_to_pass,buf,1024);
  printf("I got fd %d and data %s\n",fd_to_pass,buf);
  close(fd_to_pass);
}
```


# 补充 char buf[0]，占位符

好的！那我们用**通俗易懂的例子**来说明 `char buf[0]` 和 `char buf[1]` 的区别，并通过几个**简单直白的例子**来帮助你理解它们的实际用法和意义。

---

## 🧠 先来解释：`char buf[0]` vs `char buf[1]`

这两个写法看起来奇怪，其实它们都不是拿来直接存东西的，而是：

> 📌 用作**“占位符”**，代表 **结构体后面会跟着变长数据**，通过动态内存分配。

区别在于：

|写法|说明|
|---|---|
|`char buf[1]`|传统写法，为了向后兼容老编译器。默认就有一个字节空间，稍微不严谨。|
|`char buf[0]`|更现代的写法，**没有实际空间**，必须搭配动态分配。更安全。|

---

## ✅ 示例 1：存储一段变长名字的数据结构

假设你要存人的信息，但名字长度不固定，怎么办？

```c
struct Person {
    int age;
    char name[0]; // 不是真正的数组，占位符！
};
```

### 使用方式：

```c
int namelen = strlen("Alice") + 1;
struct Person *p = malloc(sizeof(struct Person) + namelen);
p->age = 18;
strcpy(p->name, "Alice");

printf("Name: %s, Age: %d\n", p->name, p->age);
```

### ✅ 为什么这样好？

这样可以：

- 用一块连续内存保存所有数据（避免多次 malloc）
    
- 节省内存、提高访问效率
    

---

## ✅ 示例 2：发一个结构体 + 数据块

比如我们定义一个消息头，后面是消息正文：

```c
struct Message {
    int type;
    int length;
    char data[0]; // 占位，实际数据跟在结构体后面
};
```

### 用法：

```c
const char *text = "hello world!";
int len = strlen(text) + 1;

struct Message *msg = malloc(sizeof(struct Message) + len);
msg->type = 1;
msg->length = len;
strcpy(msg->data, text);

printf("Message: %s\n", msg->data);
```

---

## ✅ 示例 3：带变长数组的协议包

想象一个简单的协议包，头部固定，数据可变：

```c
struct Packet {
    uint8_t version;
    uint8_t command;
    uint16_t length;
    char payload[0];
};
```

通过：

```c
struct Packet *pkt = malloc(sizeof(struct Packet) + data_len);
memcpy(pkt->payload, data, data_len);
```

---

## 💡 总结：什么时候用？

你会用 `char buf[0]` 或 `char buf[1]`，当你需要：

1. 在结构体后面**追加变长数据**
    
2. 使用一块 malloc 出来的内存保存结构体和它后面的数据
    
3. 避免多次 malloc，提高性能
    
