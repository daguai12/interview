
# `EncodeZigzag()`
## 🔹 函数定义

```cpp
static uint32_t EncodeZigzag32(const int32_t& v)
```

* **作用**：将一个有符号的 32 位整数 `v` 编码成一个 **无符号的 32 位整数**，使用的是 **ZigZag 编码**。
* **用途**：ZigZag 编码是 Protocol Buffers 等序列化协议中常用的一种整数编码方式，它的作用是把**有符号整数**转换为**无符号整数**，以便更有效地使用变长编码（比如 Varint）。
* `static`：限定此函数只在当前编译单元中可见。
* `uint32_t`：返回值类型，表示返回的是一个无符号 32 位整数。
* `const int32_t& v`：参数是一个有符号 32 位整数的引用，`const` 表示不可修改。

---

## 🔹 函数逻辑

### 情况 1：`v < 0`

```cpp
return ((uint32_t)(-v)) * 2 - 1;
```

* 举例：如果 `v = -5`
* `-v = 5`，转换为 `uint32_t` 是 `5`
* `5 * 2 - 1 = 9`

→ 结果：`-5` 被编码成 `9`

---

### 情况 2：`v >= 0`

```cpp
return v * 2;
```

* 举例：如果 `v = 5`
* `5 * 2 = 10`

→ 结果：`5` 被编码成 `10`

---

## 🔹 总结：ZigZag 编码规则

| 原始整数 `v` | 编码后结果 |
| -------- | ----- |
| 0        | 0     |
| -1       | 1     |
| 1        | 2     |
| -2       | 3     |
| 2        | 4     |
| ...      | ...   |

> 公式表示为：

```cpp
EncodeZigzag32(v) = (v << 1) ^ (v >> 31)
```

而你给出的写法是这个公式的等价形式，逻辑上是一样的。

---

## ✅ 使用 ZigZag 编码的原因

在变长编码中（如 Varint）：

* 小的无符号整数编码后占用更少空间。
* 如果直接对有符号整数使用 Varint，负数会变得非常大。
* ZigZag 编码可以将绝对值小的负数也编码为小的无符号数，**优化空间占用**。



# `DecodeZigzag()`

## 🔧 函数定义

```cpp
static int32_t DecodeZigzag32(const int32_t& v) {
    return (v >> 1) ^ -(v & 1);
}
```

### 函数作用：

这是 **ZigZag 解码函数**，将一个无符号整型 `v`（本质上是 `uint32_t` 类型，但这里用 `int32_t` 接收）**还原为原始的有符号整数**。

它是前面你提到的 `EncodeZigzag32` 的逆操作。

---

## 🧠 背景知识：ZigZag 编码原理回顾

ZigZag 的编码方式：

```cpp
EncodeZigzag32(x) = (x << 1) ^ (x >> 31)
```

它的映射关系如下：

| 原始值 | ZigZag 编码值（v） |
| --- | ------------- |
| 0   | 0             |
| -1  | 1             |
| 1   | 2             |
| -2  | 3             |
| 2   | 4             |
| ... | ...           |

---

## 📘 解码公式拆解

```cpp
return (v >> 1) ^ -(v & 1);
```

我们逐步解析这个表达式：

### ✨ 第一步：`v >> 1`

将编码值右移一位，相当于除以 2。

* 如果原值是非负数，ZigZag 编码是 `v = x * 2`，那么 `v >> 1 = x`
* 如果原值是负数，ZigZag 编码是 `v = (-x) * 2 - 1`，那么 `v >> 1 = -x`

但此时还不能区分正负。

---

### ✨ 第二步：`v & 1`

判断最低位是否为 `1`（即奇数）

* 如果 `v` 是奇数（最低位是 1），说明原始是负数
* 如果 `v` 是偶数（最低位是 0），说明原始是正数

---

### ✨ 第三步：`-(v & 1)`

如果原始是负数 → `v & 1 == 1` → `-1`

如果原始是正数 → `v & 1 == 0` → `0`

---

### ✨ 第四步：整体异或操作

```cpp
(v >> 1) ^ -(v & 1)
```

* 如果是正数：相当于 `x ^ 0 = x`
* 如果是负数：相当于 `(-x) ^ -1`
  由于 `-1` 在二进制中是全 1，进行异或后得到补码表示的负数。

---

## ✅ 举个例子理解

### 例 1：`v = 4`

```cpp
v = 4 => 原始值应该是 2

(v >> 1) = 2
(v & 1) = 0 → -(0) = 0
=> 2 ^ 0 = 2 ✅
```

### 例 2：`v = 3`

```cpp
v = 3 => 原始值应该是 -2

(v >> 1) = 1
(v & 1) = 1 → -(1) = -1
=> 1 ^ -1 = -2 ✅
```

解释：

```
1    = 0b00000001
-1   = 0b11111111 (补码)

1 ^ -1 = 0b00000001 ^ 0b11111111 = 0b11111110 = -2 (补码)
```

---

## ✅ 总结

```cpp
int32_t DecodeZigzag32(const int32_t& v) {
    return (v >> 1) ^ -(v & 1);
}
```

* 右移 1 位 → 得到“绝对值”
* `(v & 1)` 检测符号
* `-(v & 1)` → -1（负数）或 0（正数）
* 用异或重建负号（补码）
