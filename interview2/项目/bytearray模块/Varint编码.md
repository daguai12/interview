## 🔧 函数定义

```cpp
void ByteArray::writeUint32(uint32_t value)
```

这是 `ByteArray` 类的一个成员函数，用于将一个 `uint32_t` 整数使用 **Varint 编码格式** 写入 `ByteArray` 中。

---

## 💡 背景知识：Varint 编码原理

Varint 将整数按 **每 7 位一组** 编码，每个字节的第 8 位（最高位）是 continuation bit：

* **高位为 1**：后面还有字节
* **高位为 0**：这是最后一个字节

例如：

* `1` → `0x01`（1 字节）
* `300` → `0xAC 0x02`（2 字节）

---

## 🔍 逐行详解代码

```cpp
uint8_t tmp[5];
```

* 定义一个最多 5 字节的临时数组，用于保存编码后的字节。
* 为什么最多 5 个？因为 `uint32_t` 是 32 位，而 Varint 每次编码 7 位 → 最多 5 字节能覆盖 35 位。

```cpp
uint8_t i = 0;
```

* 用于记录当前写了几个字节。

```cpp
while(value >= 0x80) {
    tmp[i++] = (value & 0x7F) | 0x80;
    value >>= 7;
}
```

### 🔄 分析这个循环逻辑：

* **条件 `value >= 0x80` (即 ≥ 128)**：

  * 表示当前值还不止 7 位，要继续分组。
* **`(value & 0x7F)`**：

  * 取最低 7 位有效数据。
* **`| 0x80`**：

  * 设置最高位为 `1`（告诉解码器“后面还有”）。
* **`value >>= 7`**：

  * 舍弃已经编码的 7 位，继续处理高位。

这个循环会不断把整数拆成 7 位一组，直到只剩下最后的那一组。

```cpp
tmp[i++] = value;
```

* 最后一个字节，`value` 的剩余部分一定小于 128（即最高位为 0）
* 所以直接保存，无需设置 continuation bit（高位为 0）

---

### 📤 写入数据

```cpp
write(tmp, i);
```

调用 `ByteArray::write(const void* buf, size_t size)`，把这 `i` 个字节写入 ByteArray 的底层缓冲区。

---

## ✅ 举个例子

假设 `value = 300`

```text
300 = 0b 00000001 00101100
     = 0b 100101100

按 7 位分组：
- 第1组：00101100 (0x2C) → 加高位1 → 0xAC
- 第2组：00000010 (0x02) → 高位为0 → 0x02

写入结果：0xAC 0x02
```

---

## 🧠 总结

该函数的作用是将一个 `uint32_t` 类型的整数 **以 Varint 格式编码并写入 ByteArray**，实现要点：

| 步骤 | 说明                  |
| -- | ------------------- |
| 1  | 循环处理，每 7 位打包        |
| 2  | 中间字节设置高位为 1         |
| 3  | 最后一个字节高位为 0         |
| 4  | 写入所有编码字节到 ByteArray |

---

如果你还需要 `readUint32()`（解码函数）的详细分析，我也可以帮你拆解那部分。是否需要？
