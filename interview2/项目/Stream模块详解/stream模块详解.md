#  `readFixSize()`
我们来**逐行逐句详细分析** Sylar 框架中 `Stream::readFixSize()` 这个函数的实现逻辑：

```cpp
int Stream::readFixSize(void* buffer, size_t length)
```

### 🔧 函数签名解释：

* `Stream::readFixSize` 是 `Stream` 类的成员函数。
* 它的目的是从流中**精确读取 `length` 字节数据**到 `buffer` 中——直到读完为止。
* 返回值为实际读取的字节数，如果失败则返回负值（由 `read()` 的返回决定）。

---

### 📌 逐行详解：

```cpp
size_t offset = 0;
```

* 表示已经成功读取到 `buffer` 中的数据偏移量。
* 初始为 0，之后每次读取都会把数据“追加”到 `buffer + offset` 位置。

---

```cpp
int64_t left = length;
```

* 表示还剩下多少字节需要读取。
* 初始为 `length`，之后每读取一段就减去相应的长度，直到变成 0 为止。

---

```cpp
while(left > 0) {
```

* 主循环逻辑：**只要还有数据未读完，就继续调用 `read()` 尝试读取。**
* 这也说明该函数是阻塞性质的：**它会尝试多次 `read()`，直到读满或出错**。

---

```cpp
    int64_t len = read((char*)buffer + offset, left);
```

* 调用虚函数 `read()` 从流中读取最多 `left` 字节的数据到 `buffer + offset` 处。
* `buffer` 是 `void*` 类型，先转换为 `(char*)`，是因为偏移操作必须是字节为单位。
* `offset` 控制每次读入的新位置，`left` 是本次还能读的最大字节数。

---

```cpp
    if(len <= 0) {
        return len;
    }
```

* ⚠️ 错误或流结束判断：

  * 如果 `read()` 返回 0（表示对端关闭连接）或负数（表示出错），**立刻返回该值**。
  * ✅ 保证了只要一旦失败就立刻退出。

---

```cpp
    offset += len;
    left -= len;
```

* 更新：

  * 将偏移量加上本次读到的 `len`；
  * 剩余长度 `left` 减去 `len`，直到全部读取完成为止。

---

```cpp
}
```

* 循环继续，直到 `left == 0`，也就是已经读满。

---

```cpp
return length;
```

* 如果 `read()` 多次调用都成功，最终返回你一开始期望读取的长度 `length`。

---

### ✅ 总结作用

* 这是一个“**读满为止**”的辅助函数，在 `read()` 本身可能一次读不全的情况下（如套接字、管道、流式文件），保证调用者拿到完整的数据块。
* 这种语义在网络协议（如读取报文头、读取固定长度的数据包）中非常常见。

---

### 🚨 注意事项

* 如果 `read()` 是非阻塞的，调用 `readFixSize()` 会造成高 CPU 占用或提前返回，这种情况应结合 `epoll/select` 等 IO 多路复用机制使用。
* 如果底层流关闭了（返回 0），那本函数会中途退出并返回 0（即使还没读满）。


