# A typical stack frame

右侧的图1展示了典型栈帧的可能结构。在这些示意图中，栈向上增长，编号较小的内存地址位于顶部。  

假设我们有一个原型为`int foo(int arg1, int arg2, int arg3);`的函数`foo`，且该函数包含两个本地`int`变量（此处假设`sizeof(int)`为4字节）。当主函数调用`foo`且程序控制仍在`foo`函数内部时，栈的内容如下所示。此时，主函数是“调用者”，`foo`是“被调用者”。  

`ESP`寄存器被`foo`用于指向栈顶，`EBP`寄存器则作为“基址指针”。主函数传递给`foo`的参数以及`foo`中的局部变量，都可以通过相对于基址指针的偏移量来引用。  

此处采用的约定是：被调用者可以在返回前修改`EAX`、`ECX`和`EDX`寄存器的值。因此，如果调用者需要保留这些寄存器的值，必须在调用子例程前显式地将其保存在栈上。相反，被调用者必须恢复`EBX`、`ESI`和`EDI`寄存器的值。如果被调用者修改了这些寄存器，则必须先将受影响的寄存器保存在栈上，并在返回前恢复其原始值。  

传递给`foo`的参数会被压入栈中。最后一个参数先压入，因此最终第一个参数位于栈顶。`foo`中声明的局部变量以及临时变量均存储在栈上。  

4字节或更小的返回值存储在`EAX`寄存器中。如果需要返回超过4字节的值，调用者会向被调用者传递一个“额外”的第一个参数，该参数是存储返回值的地址。例如，在C语言中，函数调用`x = foo(a, b, c);`会被转换为（仅当函数返回值超过4字节时）：`foo(&x, a, b, c);`  

下面我们逐步分析函数调用过程中栈帧的建立与销毁流程：

![[Pasted image 20250628154140.png]]

# The caller's actions before the function call

在我们的示例中，调用者是主函数（main），它即将调用函数`foo`。在函数调用前，主函数正将`ESP`和`EBP`寄存器用于自身的栈帧。  

首先，主函数将寄存器`EAX`、`ECX`和`EDX`的内容压入栈中。这是一个可选步骤，仅在需要保留这3个寄存器的内容时执行。  

接下来，主函数将`foo`的参数逐个压入栈中，且按“最后一个参数先压栈”的顺序。例如，若函数调用为：  
```c
a = foo(12, 15, 18);
```  
对应的汇编语言指令可能为：  
```assembly
push    dword 18  ; 压入最后一个参数18
push    dword 15  ; 压入中间参数15
push    dword 12  ; 压入第一个参数12
call    foo       ; 调用foo函数
```  
最后，主函数执行子例程调用指令`call`。当`call`指令执行时，`EIP`寄存器的内容会被压入栈中。由于`EIP`寄存器指向主函数中的下一条指令，此时栈顶存储的是函数的返回地址。`call`指令执行后，程序将跳转到标签`foo`处开始执行。  

图2展示了`call`指令执行后的栈内容。图2及后续图示中的红线表示触发函数调用流程的指令执行前的栈顶位置。我们将看到，当整个函数调用完成后，栈顶会恢复到该位置。

![[Pasted image 20250628154223.png]]
# The callee's actions after function call

当被调用者`foo`函数获得程序控制权时，它必须完成三件事：建立自己的栈帧、为局部存储分配空间，以及根据需要保存寄存器`EBX`、`ESI`和`EDI`的内容。

首先，`foo`需要建立自己的栈帧。此时`EBP`寄存器仍指向主函数的栈帧位置，这个值必须被保存。因此，`EBP`会被压入栈中，然后将`ESP`的值赋给`EBP`。这样一来，函数参数可以通过相对于`EBP`的偏移量来引用，同时释放栈指针`ESP`以供其他操作使用。因此，几乎所有C函数都以这两条指令开头：

```assembly
push    ebp        ; 保存调用者的EBP值
mov     ebp, esp   ; 设置新的基址指针，指向当前栈顶
```

得到的栈结构如图3所示。注意，在这种方案中，第一个参数的地址是`EBP + 8`，因为主函数的`EBP`和返回地址在栈上各占4字节。
![[Pasted image 20250628154335.png]]
接下来，`foo`必须为其局部变量分配空间，同时也要为可能需要的临时存储分配空间。例如，`foo`中的某些C语句可能包含复杂表达式，其子表达式的中间值必须存储在某个位置。这些位置通常称为临时存储，因为它们可被下一个复杂表达式重复使用。为便于说明，假设`foo`有2个`int`类型的局部变量（每个占4字节），并需要额外12字节的临时存储空间。这20字节的空间可通过将栈指针减去20来分配：  
```assembly
sub     esp, 20  ; 为局部变量和临时存储分配20字节
```  
此时，局部变量和临时存储可通过基址指针`EBP`的偏移量来引用。最终的栈结构如图4所示。  

现在可以执行`foo`函数的主体代码。这可能涉及将数据压入栈或从栈弹出，因此栈指针`ESP`可能会上下移动，但`EBP`寄存器保持固定。这种设计的优势在于：无论函数内进行多少次压栈或弹栈操作，始终可以通过`[EBP + 8]`来引用第一个参数。  

`foo`函数的执行可能还会涉及调用其他函数，甚至递归调用自身。但只要在这些调用返回时恢复`EBP`寄存器，就可以继续通过`EBP`的偏移量来引用参数、局部变量和临时存储。

![[Pasted image 20250628154429.png]]

# 被调用者返回前的操作  

在将控制权交还给调用者之前，被调用者`foo`必须首先完成两件事：将返回值存入`EAX`寄存器，以及恢复`EBX`、`ESI`和`EDI`寄存器的值。  

- **处理返回值**：如前所述，若返回值不超过4字节，直接存入`EAX`；若超过4字节，则调用者会传递一个额外的指针参数（存储返回值的地址），此时函数无需返回值（由调用者指定存储位置）。  

- **恢复寄存器**：若`foo`修改了`EBX`、`ESI`、`EDI`寄存器，需在函数开始时将其原值压栈保存。此时若`ESP`指针指向图4中的正确位置，可通过弹栈操作恢复这些寄存器的值。因此，在`foo`函数体执行过程中，必须确保压栈和弹栈操作的次数平衡，避免`ESP`指针偏移。  

完成上述两步后，`foo`的局部变量和临时存储已无需使用，可通过以下指令销毁栈帧：  
```assembly
mov     esp, ebp  ; 将ESP指向当前EBP（释放局部变量空间）
pop     ebp       ; 弹出调用者的EBP，恢复调用者栈帧基址
```  
执行后，栈结构与图2完全一致。此时可执行返回指令`ret`，该指令会将栈顶的返回地址弹出并存入`EIP`寄存器，栈状态如图5所示。  

i386指令集中的`leave`指令等价于上述`mov esp, ebp`和`pop ebp`两条指令。因此，C函数通常以如下指令结尾：  
```assembly
leave             ; 销毁当前栈帧，恢复调用者栈帧基址
ret               ; 弹出返回地址并跳转
```

![[Pasted image 20250628154512.png]]
# 调用者在返回后的操作

当程序控制权返回给调用者（在本例中为`main`函数）时，栈的状态如图5所示。此时，传递给`foo`的参数通常已不再需要。我们可以通过将栈指针`ESP`加上12（即3个参数 × 4字节/参数），一次性从栈中弹出所有3个参数：
```assembly
add     esp, 12  ; 释放3个参数占用的12字节栈空间
```
随后，调用者`main`应将存储在`EAX`中的返回值保存到适当位置。例如，如果返回值要赋值给一个变量，则可将`EAX`的内容移至该变量的内存地址。

最后，如果`main`在调用函数前将`EAX`、`ECX`和`EDX`寄存器的值保存在栈上，则可以通过弹栈操作恢复这些寄存器的值。这会使栈顶恢复到函数调用开始前的原始位置（即图2至图5中红线所示的位置）。


# 知识补充

这些寄存器是x86-64架构中的通用寄存器（General-Purpose Registers, GPRs），在64位模式下使用。每个寄存器的用途和命名规则如下：


### **1. `%rax` - 累加器寄存器（Accumulator Register）**
- **用途**：
  - 存储**函数返回值**（默认返回值寄存器）。
  - 用于**算术和逻辑运算**（如乘法、除法的默认操作数）。
  - 在系统调用中保存**系统调用号**（如Linux中，`%rax`存储`syscall`编号）。
- **扩展**：`%eax`（32位）、`%ax`（16位）、`%al`（低8位）、`%ah`（高8位）。


### **2. `%rbx` - 基址寄存器（Base Register）**
- **用途**：
  - 作为**内存寻址的基址**（如数组或结构体的基地址）。
  - 被调用者保存寄存器（Callee-Saved），即函数调用时需由被调用函数自行保存和恢复其值。
- **扩展**：`%ebx`（32位）、`%bx`（16位）、`%bl`（低8位）、`%bh`（高8位）。


### **3. `%rcx` - 计数器寄存器（Counter Register）**
- **用途**：
  - 用于**循环计数**（如`rep`指令的迭代次数）。
  - 在64位系统调用中保存**第四个参数**（Linux ABI）。
  - 在移位/循环移位操作中保存**移位次数**。
- **扩展**：`%ecx`（32位）、`%cx`（16位）、`%cl`（低8位）、`%ch`（高8位）。


### **4. `%rdx` - 数据寄存器（Data Register）**
- **用途**：
  - 用于**乘除法运算**（与`%rax`配合，如64位乘法结果存于`%rdx:%rax`）。
  - 在64位系统调用中保存**第三个参数**（Linux ABI）。
  - 用于I/O操作（如`in`/`out`指令）。
- **扩展**：`%edx`（32位）、`%dx`（16位）、`%dl`（低8位）、`%dh`（高8位）。


### **5. `%rsi` - 源索引寄存器（Source Index Register）**
- **用途**：
  - 在内存操作（如`movs`、`stos`）中作为**源操作数地址**。
  - 在函数调用中传递**第二个参数**（Linux/Windows ABI）。
- **扩展**：`%esi`（32位）、`%si`（16位）、`%sil`（低8位）。


### **6. `%rdi` - 目标索引寄存器（Destination Index Register）**
- **用途**：
  - 在内存操作（如`movs`、`stos`）中作为**目标操作数地址**。
  - 在函数调用中传递**第一个参数**（Linux/Windows ABI）。
- **扩展**：`%edi`（32位）、`%di`（16位）、`%dil`（低8位）。


### **调用约定中的角色**
在x86-64 System V ABI（Linux/macOS）中：
- **参数传递**：`%rdi`、`%rsi`、`%rdx`、`%rcx`、`%r8`、`%r9`（依次传递第1至6个参数，更多参数通过栈传递）。
- **返回值**：`%rax`（≤64位）或`%rdx:%rax`（≥65位）。
- **被调用者保存**：`%rbx`、`%rbp`、`%r12`~`%r15`（函数需自行保存和恢复）。
- **调用者保存**：`%rax`、`%rcx`、`%rdx`、`%rsi`、`%rdi`、`%r8`~`%r11`（函数可直接使用，无需保存）。


### **注意事项**
- **64位 vs 32位**：64位寄存器名以`r`开头（如`%rax`），32位以`e`开头（如`%eax`）。使用32位寄存器会自动清零高32位。
- **Windows差异**：Windows ABI使用`%rcx`、`%rdx`、`%r8`、`%r9`传递前四个参数，与Linux不同。
- **系统调用**：Linux系统调用使用`%rax`存系统调用号，`%rdi`~`%r9`传参，与函数调用略有区别。

通过这些寄存器，CPU可以高效地处理数据、传递参数和返回结果，是汇编编程和理解程序执行的基础。


----

在 **Linux 系统中**，函数或系统调用的参数传递使用的寄存器取决于所使用的 **CPU 架构** 和 **调用约定（Calling Convention）**。

下面以主流的 **x86\_64（也叫 AMD64）架构** 为例，说明 Linux 下常见的参数传递寄存器。

## ✅ 一、Linux 下 x86\_64 架构的函数调用参数寄存器

Linux 遵循的是 **System V AMD64 ABI**，这是 Linux 下 x86\_64 平台的标准调用约定。

### 📌 前 6 个整数类（整型、指针）参数用以下寄存器：

| 参数位置  | 寄存器名  |
| ----- | ----- |
| 第 1 个 | `rdi` |
| 第 2 个 | `rsi` |
| 第 3 个 | `rdx` |
| 第 4 个 | `rcx` |
| 第 5 个 | `r8`  |
| 第 6 个 | `r9`  |

👉 第 7 个及之后的参数，会通过**栈**传递。

### 📌 浮点类型参数用：

* `xmm0` \~ `xmm7`（用于 `float`、`double`）

---

## ✅ 二、系统调用参数寄存器（Linux 系统调用）

Linux 中的 **系统调用（syscall）** 使用的是 **内核定义的约定**，略有不同。

| 参数位置    | 使用的寄存器 |
| ------- | ------ |
| 系统调用号   | `rax`  |
| 第 1 个参数 | `rdi`  |
| 第 2 个参数 | `rsi`  |
| 第 3 个参数 | `rdx`  |
| 第 4 个参数 | `r10`  |
| 第 5 个参数 | `r8`   |
| 第 6 个参数 | `r9`   |

📌 特别注意：

* 系统调用第 4 个参数不是 `rcx`，而是 `r10`
* `rcx` 是 `syscall` 指令本身用来保存返回地址的，不能用于参数传递

---

## 🧠 举个例子：Linux 系统调用 `write`

```c
ssize_t write(int fd, const void *buf, size_t count);
```

使用 `syscall` 的时候，参数和寄存器对应如下：

| 参数         | 寄存器   |
| ---------- | ----- |
| 系统调用号（`1`） | `rax` |
| `fd`       | `rdi` |
| `buf`      | `rsi` |
| `count`    | `rdx` |

汇编调用可能如下：

```asm
mov rax, 1       ; syscall number for write
mov rdi, 1       ; fd = 1 (stdout)
mov rsi, msg     ; buffer address
mov rdx, 13      ; buffer length
syscall
```

---

## ✅ 三、总结速查表

| 情况                  | 参数寄存器（整数/指针）                                     |
| ------------------- | ------------------------------------------------ |
| C/C++ 函数调用（x86\_64） | `rdi`, `rsi`, `rdx`, `rcx`, `r8`, `r9`           |
| Linux 系统调用（x86\_64） | `rdi`, `rsi`, `rdx`, `r10`, `r8`, `r9`（号在 `rax`） |

---

如果你使用的是 ARM 架构、32 位 x86、RISC-V 等架构，它们的寄存器规则会有所不同。如果你需要这些平台的说明，我也可以详细讲解。需要吗？
