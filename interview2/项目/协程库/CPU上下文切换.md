Linux是一个多任务操作系统，它可以运行远超于CPU数量的任务。但是，这些任务并不是同时运行，而是操作系统在很短的时间内分配CPU时间片给他们运行。

而在每个任务运行前，CPU都需要知道任务从哪里加载、又从哪里开始运行，也就是说，需要系统事先帮它设置好**CPU寄存器和程序计数器**

CPU寄存器是，CPU内置的，内存极小，但是速度极快的内存。而程序计数器，则是用来存储CPU当前正在执行的指令，或者是要执行的下一条指令位置。它们都是CPU在运行任何任务之前，必须依赖的环境，因此也叫做**CPU的上下文**

**CPU上下文切换**就是将前一个任务的CPU上下文保存起来，然后加载新任务的上下文到这些寄存器和程序计数器中,最后再跳转到程序计数器所指的新位置,运行新任务。


# 进程上下文切换

## 系统调用

Linux按照特权等级，把进程运行的空间分为**内核空间**和**用户空间**。CPU的特权等级分别为 Ring01 和 Ring03。

`内核空间`:具有最高权限可以直接访问所有资源。
`用户空间`:只能访问受限的资源，要访问内存等硬件资源，需要通过系统调用陷入到内核态，才能访问该资源。

CPU 寄存器里保存着原来用户态度的指令位置，需要先保存起来。接着，为了执行内核态代码，CPU 寄存器需要更新为内核态指令的新位置。最后才是跳转到内核态运行内核任务。

而系统调用接收后，CPU 寄存器需要**恢复**原来保存的用户态，然后再切换到用户空间，继续运行进程。**所以，一次系统调用的过程，发送了两次CPU上下文的切换。**

但是，**系统调用通常称为特权模式切换，而不是上下文切换**

## 进程上下文切换

进程是由内核管理和调度的，进程的切换只能再内核态进行。进程的上下文切换包括了虚拟内存，栈，全局变量等用户空间的资源,还包括内核堆，栈，寄存器等内核空间的状态。

因此，进程的上下文切换相比系统调用多了一步。保存进程的内核状态和CPU寄存器之前，需要将进程的虚拟内存、栈等保存下来；而加载了一个进程的内核态，还需要刷新进程的虚拟内存和用户栈。

> 另外，我们知道， Linux 通过 TLB（Translation Lookaside Buffer）来管理虚拟内存到物理内存的映射关系。当虚拟内存更新后，TLB 也需要刷新，内存的访问也会随之变慢。特别是在多处理器系统上，缓存是被多个处理器共享的，刷新缓存不仅会影响当前处理器的进程，还会影响共享缓存的其他处理器的进程。

Linux为每个CPU都维护了一个就绪队列，将活跃进程按照优先级和等待CPU的时间排序，然后选择最需要CPU的进程，也就是优先级别最高和等待CPU时间最长的进程来运行。

 **什么时候会发送进程的调度？**
最容易想到的是，当一个进程执行完成之后，会将之前所占用的CPU释放出来，这个时候再从就绪队列里，拿一个新的进程来运行。

**其他情况下发送调度的情况**

1. 为了保证所有进程可以得到公平调度，CPU 时间被划分为一段段的时间片，这些时间片再被轮流分配给各个进程。这样，当某个进程的时间片耗尽了，就会被系统挂起，切换到其它正在等待 CPU 的进程运行。
2. 进程在系统资源不足（比如内存不足）时，要等到资源满足后才可以运行，这个时候进程也会被挂起，并由系统调度其他进程运行。
3. 当进程通过睡眠函数 sleep 这样的方法将自己主动挂起时，自然也会重新调度。
4. 当有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行。
5. 发生硬件中断时，CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序

# 线程上下文切换

线程与进程最大的区别在于，**线程是调度的基本单位，而进程则是资源拥有的基本单位**。所以，内核中的任务调度，实际上的调度对象时线程；而进程只是给线程提供了虚拟内存、全局变量等资源。所以，可以这样理解线程:
1. 当进程只有一个线程的时候，进程就等于线程。
2. 当进程拥有多个线程时，这些线程会共享相同的虚拟内存和全局变量等资源。这些资源在上下文切换时，不需要修改。 
**另外，线程也有自己的私有数据，比如栈和寄存器等，这些在上下文切换的时候是需要保存的。**

所以线程的上下文切换可以分为两种：
1. 当线程属于两个不同的进程时，因为资源不共享，线程的切换就和进程的上下文切换一样。
2. 前后两个线程属于同一个进程。此时，因为虚拟内存时共享的，所以在在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享数据。



# 中断上下文切换

跟进程上下文不同，中断上下文切换并步设计到进程的用户态。所以，即便中断过程打断了一个正在处在用户态的进程，也不要保存和回鹘这个进程的虚拟内存、全局变量等用户态资源。中断上下文，其中只包括内核态中断服务程序执行所必需的状态，包括CPU寄存器、内核堆栈、硬件中断参数等。

**对同一个CPU来说，中断处理比进程拥有更高的优先级**，所以中断上下文并不会和进程上下文切换同时发送。同样道理，由于中断会打断正常进程的调度和执行，所以大部分中断处理程序都短小精悍，以便尽可能快的执行结束。

另外，跟进程上下文切换一样，中断上下文切换也需要消耗 CPU，切换次数过多也会耗费大量的 CPU，甚至严重降低系统的整体性能。所以，当你发现中断次数过多时，就需要注意去排查它是否会给你的系统带来严重的性能问题