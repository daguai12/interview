# 有栈协程

实现一个协程的关键点在于如何保存、恢复和切换上下文。已知函数运行在调用栈上；如果将一个函数作为协程，我们很自然地联想到，保存上下文即是保存从这个函数及其嵌套函数的（连续的）栈帧存储的值，以及此时寄存器存储的值；恢复上下文即是将这些值分别重新写入对应的栈帧的寄存器；而切换上下文无非是保存当前正在运行的函数的上下文，恢复下一个将要运行的上下文。

## ✅ 一、基本概念

### 🧱 有栈协程（Stackful Coroutine）：

每个协程拥有**自己的独立执行栈**（函数调用栈），当挂起时，会保存该栈上的上下文（比如局部变量、返回地址等），下一次恢复时从之前的调用点继续执行。

> 类似“暂停游戏”，把所有状态（位置、道具）都保存，恢复时完全回到那个状态。

---

### 🧾 无栈协程（Stackless Coroutine）：

没有独立的栈，每次执行协程都从**函数开头开始**，通过一个**状态机**保存和恢复状态（状态保存在堆结构中）。不能随时挂起，只能在特定点（比如 `yield` 语句）挂起/恢复。

> 类似“按流程走的剧本”，每次进入只执行当前状态对应的动作，然后跳到下一个状态。

---

## 🧠 二、实现原理对比

| 特性    | 有栈协程                       | 无栈协程             |
| ----- | -------------------------- | ---------------- |
| 执行栈   | 每个协程有自己的栈                  | 共享栈或无栈，状态存在堆上    |
| 控制流保存 | 保存/恢复栈指针、指令地址等上下文          | 用状态变量保存“执行到了哪一步” |
| 恢复方式  | 从任意挂起点恢复，接着执行              | 从函数开头，根据状态机跳转    |
| 实现机制  | 可能用汇编、setjmp/longjmp、手动切栈等 | 通常由编译器自动生成状态机代码  |

---

## 🎯 三、简单例子（伪代码）

### 🔁 有栈协程（可以嵌套调用）：

```c++
void coroutine() {
    print("A");
    yield();    // 暂停点
    print("B");
}
```

恢复时会从 `yield()` 的下一行继续执行。

---

### 🔂 无栈协程（状态机）：

```c++
int state = 0;
void coroutine() {
    switch(state) {
        case 0: print("A"); state = 1; return;
        case 1: print("B"); state = 2; return;
    }
}
```

每次调用 `coroutine()` 都从头执行，但通过 `state` 跳到不同逻辑。

---

## ⚖️ 四、优缺点对比

| 对比维度  | 有栈协程                        | 无栈协程                     |
| ----- | --------------------------- | ------------------------ |
| 灵活性   | 高，可嵌套调用任意函数                 | 低，无法挂起函数内部（必须“打平”）       |
| 性能    | 快，切换上下文开销小                  | 更快，通常只更新状态字段             |
| 实现复杂度 | 高（需要栈管理、切换逻辑）               | 较低（状态机形式）                |
| 内存占用  | 每个协程独立栈，内存较大                | 无栈，占用小，适合大量协程            |
| 可读性   | 好，结构更像普通函数                  | 差，逻辑分散在状态机中              |
| 编译器支持 | 不一定有（如 C++ Boost.Coroutine） | 很多语言内建支持（如 Python async） |

---

## 📌 五、使用场景举例

| 场景                 | 推荐协程类型 | 说明             |
| ------------------ | ------ | -------------- |
| 高并发、轻量任务（如 I/O）    | ✅ 无栈协程 | 数量多，占用小        |
| 复杂流程控制（如游戏脚本）      | ✅ 有栈协程 | 嵌套调用、暂停恢复、逻辑清晰 |
| 编译器 async/await 支持 | ✅ 无栈协程 | 编译器自动转状态机      |
| 自己写协程调度器           | ✅ 有栈协程 | 灵活切栈，可控性强      |

---

## 🧩 总结一句话：

* **有栈协程**：像“暂停游戏”，随时保存/恢复，功能强但内存大。
* **无栈协程**：像“按剧本执行”，状态机跳转，高效但不灵活。

---

如果你正在学 C++、Python、Rust 等语言，我还可以举几个实际的代码例子来演示协程在这些语言中的表现方式，要不要看看？
