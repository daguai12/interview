# 智能指针的循环引用（原因、演示与解决方案）

你贴的例子说明得很清楚：当用 `std::shared_ptr` 双向相互持有时，会形成引用环（cycle），引用计数永远不会降到 0，导致对象析构函数 **不会被调用 → 内存泄漏**。下面把原理、修复方法、示例代码和常见注意点一股脑儿说清楚。

---

## 为什么会泄漏（简短结论）

`shared_ptr` 用引用计数来管理生命周期：只有当**所有** `shared_ptr` 的引用计数都降为 0 时对象才会被销毁。若对象 A 用 `shared_ptr` 持有对象 B，同时 B 又用 `shared_ptr` 持有 A，就会形成环：

```
A(shared_ptr) ---> B(shared_ptr) ---> A(shared_ptr)
```

在该环中每个对象的引用计数至少为 1（互相保持），即使外部 `shared_ptr` 都离开作用域，计数仍然不为 0，对象永远不会被释放。

---

## 解决办法：把环中“非拥有者”的那一侧改为 `weak_ptr`

`std::weak_ptr<T>` 是对 `shared_ptr` 管理对象的**弱引用**：

* 它 **不增加**引用计数（`use_count` 不变）。
* 它不能直接解引用，需调用 `lock()` 得到一个 `shared_ptr`（如果对象尚存），或检查 `expired()`。
* 因此把环中“不应该拥有对象生命周期”的方向改成 `weak_ptr`，就能打破循环，让引用计数正常归零、对象析构。

---

## 修正版示例（将 `_pPre` 改为 `weak_ptr`）

```cpp
#include <iostream>
#include <memory>

template <typename T>
class Node {
public:
    Node(const T& value)
    : _value(value) {
        std::cout << "Node()" << std::endl;
    }
    ~Node() {
        std::cout << "~Node() this: " << this << std::endl;
    }

    // 用 weak_ptr 打破循环
    std::weak_ptr<Node<T>> _pPre;        // 非拥有者，用 weak_ptr
    std::shared_ptr<Node<T>> _pNext;     // 拥有者，用 shared_ptr
    T _value;
};

void Funtest() {
    auto sp1 = std::make_shared<Node<int>>(1);
    auto sp2 = std::make_shared<Node<int>>(2);

    std::cout << "sp1.use_count: " << sp1.use_count() << std::endl; // 1
    std::cout << "sp2.use_count: " << sp2.use_count() << std::endl; // 1

    sp1->_pNext = sp2;            // sp2 引用 +1
    sp2->_pPre = sp1;             // 但这是 weak_ptr，不会增加 sp1 的 use_count

    std::cout << "sp1.use_count: " << sp1.use_count() << std::endl; // 1
    std::cout << "sp2.use_count: " << sp2.use_count() << std::endl; // 2 (sp1->_pNext)
    
    // 访问 pPre 时需要 lock()
    if (auto upstream = sp2->_pPre.lock()) {
        std::cout << "sp2._pPre points to: " << upstream.get() << std::endl;
    } else {
        std::cout << "sp2._pPre expired\n";
    }
}

int main() {
    Funtest();
    std::cout << "after Funtest end\n";
    return 0;
}
```

**期望输出片段（关键点）**：

* 程序结束时会看到 `~Node()` 被调用（说明没有内存泄漏）。
* `sp1.use_count` 在赋值后仍为 1（`_pPre` 是弱指针，不增加计数）。

---

## 其他可行的打破环的方法

1. **手动断开**：在合适时机把某个 `shared_ptr` 成员 `reset()`，手动破环（可行但容易出错且难维护）。
2. **设计上避免双向 `shared_ptr`**：如果可以，尽量只用单向拥有关系，把另一侧用普通裸指针或 `weak_ptr` 表示非拥有关系。
3. **`enable_shared_from_this`**：当对象内部需要生成指向自身的 `shared_ptr` 时，使用 `std::enable_shared_from_this<T>` 能确保得到的 `shared_ptr` 与已有控制块一致（避免出现两个独立控制块的问题）。

---

## `weak_ptr` 使用小贴士

* `weak_ptr::lock()` 返回 `shared_ptr<T>`：如果对象已经被释放，返回的 `shared_ptr` 为空（可检查）。
* `weak_ptr` 的 `use_count()` 返回当前拥有者的数量（等同于对应 `shared_ptr` 的 `use_count()`）。
* `weak_ptr` 常用于：缓存、观察者模式、双向关系中的“回指”、避免循环引用。

---

## 多线程注意

在多线程场景中，用 `weak_ptr::lock()` 获取 `shared_ptr` 是安全的（原子获取）；但获取后仍需正确同步访问对象内部状态（对象成员的并发访问需要其它同步手段）。

---

## 小结（一句话）

当 `shared_ptr` 形成引用环时会导致对象永不析构。**推荐的修复方式**是把“非拥有方”改用 `std::weak_ptr`（或在合适时手动 `reset()`），并在需要访问时用 `lock()` 临时获得 `shared_ptr`。这样既保留指向关系，也不会阻止对象析构。

---

要不要我把你原来的完整示例（你给的那段）替换成上面修正后的版本，并加上注释逐行解释 `use_count` 的变化与 `weak_ptr::lock()` 行为？或者我直接给一些常见设计模式（比如父子关系、观察者）中如何恰当使用 `weak_ptr` 的范例？
