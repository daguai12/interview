å¥½â€”â€”ä¸€æ¬¡æŠŠ **C++11** çš„ä¸»è¦æ–°ç‰¹æ€§è®²æ¸…æ¥šã€è®²æ˜ç™½ã€å¸¦ä¸Šä¾‹å­ä¸å¸¸è§å‘ã€‚å†…å®¹æŒ‰ã€Œè¯­è¨€ç‰¹æ€§ã€å’Œã€Œæ ‡å‡†åº“/è¿è¡Œæ—¶ï¼ˆå¹¶å‘ã€å®¹å™¨ç­‰ï¼‰ã€ä¸¤å¤§å—æ¥ç»„ç»‡ï¼Œä¾¿äºè®°å¿†ä¸å¤ä¹ ã€‚å‡†å¤‡å¥½ç¬”å’Œé”®ç›˜ï¼Œå¼€å§‹å§ ğŸ§ âœï¸

# C++11 æ–°ç‰¹æ€§ï¼ˆè¯¦å°½ç‰ˆï¼‰

---

## ä¸€ã€è¯­è¨€å±‚é¢ï¼ˆè¯­æ³• / ç±»å‹ / ç¼–è¯‘å™¨è¡Œä¸ºï¼‰

### 1. `auto`ï¼ˆç±»å‹æ¨å¯¼ï¼‰

ç¼–è¯‘å™¨æ ¹æ®åˆå§‹åŒ–è¡¨è¾¾å¼æ¨æ–­å˜é‡ç±»å‹ï¼Œå‡å°‘å†—é•¿ç±»å‹å£°æ˜ã€‚

```cpp
auto i = 42;            // int
auto p = foo();         // æ¨æ–­è¿”å›ç±»å‹
auto it = vec.begin();  // è¿­ä»£å™¨ç±»å‹è‡ªåŠ¨æ¨æ–­
```

**æ³¨æ„**ï¼šæœªåˆå§‹åŒ–çš„ `auto x;` ä¼šæŠ¥é”™ï¼›`auto` å¸¸ç”¨äºæ¨¡æ¿ã€è¿­ä»£å™¨ã€å¤æ‚ç±»å‹ã€‚

---

### 2. `decltype`ï¼ˆè¡¨è¾¾å¼ç±»å‹æ¨æ–­ï¼‰

è¿”å›è¡¨è¾¾å¼çš„ç±»å‹ï¼ˆåŒ…æ‹¬å·¦å€¼/å³å€¼å±æ€§ï¼‰ã€‚

```cpp
int x = 0;
decltype(x) y = x;  // y çš„ç±»å‹ä¸º int
decltype((x)) z = x; // z æ˜¯ int& ï¼ˆæ³¨æ„é¢å¤–çš„æ‹¬å·ï¼‰
```

---

### 3. Lambda è¡¨è¾¾å¼ï¼ˆåŒ¿åå‡½æ•°ï¼‰

å‡½æ•°å¯¹è±¡çš„è½»é‡è¯­æ³•ï¼Œæ”¯æŒæ•è·ã€mutableã€è¿”å›ç±»å‹ç­‰ã€‚

```cpp
auto sum = [](int a, int b){ return a + b; };
std::sort(v.begin(), v.end(), [](int a,int b){ return a<b; });
int cap = 10;
auto f = [cap](int x){ return x + cap; }; // å€¼æ•è·
```

---

### 4. åŸºäºèŒƒå›´çš„ `for`ï¼ˆrange-forï¼‰

éå†å®¹å™¨æ›´ç®€æ´ã€‚

```cpp
for (auto &v : vec) { /* ... */ }
```

---

### 5. `nullptr`

ä¸“ç”¨ç©ºæŒ‡é’ˆå¸¸é‡ï¼ˆæ›¿æ¢ `NULL`ï¼‰ã€‚

```cpp
void f(int*);
f(nullptr); // æ˜ç¡®æ˜¯ç©ºæŒ‡é’ˆ
```

---

### 6. å¼ºç±»å‹æšä¸¾ï¼ˆ`enum class`ï¼‰

é˜²æ­¢éšå¼è½¬æ¢å¹¶é™åˆ¶ä½œç”¨åŸŸã€‚

```cpp
enum class Color { Red, Green };
Color c = Color::Red; // ä¸ä¼šå’Œæ•´æ•°äº’æ¢
```

---

### 7. `override` / `final`

ç”¨äºæ ‡æ³¨è™šå‡½æ•°è¦†å†™ä¸ç¦æ­¢è¦†å†™ï¼Œå¸®åŠ©æ£€æµ‹é”™è¯¯ã€‚

```cpp
struct Base { virtual void f(); };
struct D : Base { void f() override; };
struct E final {};
```

---

### 8. `constexpr`

åœ¨ç¼–è¯‘æœŸæ±‚å€¼çš„å¸¸é‡è¡¨è¾¾å¼ï¼ˆC++11 ç‰ˆæœ¬åŠŸèƒ½å—é™ï¼Œä½†å¾ˆæœ‰ç”¨ï¼‰ã€‚

```cpp
constexpr int square(int x){ return x*x; }
int arr[square(3)]; // ç¼–è¯‘æœŸå¯ç”¨
```

---

### 9. `static_assert`

ç¼–è¯‘æœŸæ–­è¨€ï¼Œå¢å¼ºç±»å‹/æ¨¡æ¿æ£€æŸ¥ã€‚

```cpp
static_assert(sizeof(int) == 4, "need 4-byte int");
```

---

### 10. å³å€¼å¼•ç”¨ä¸ç§»åŠ¨è¯­ä¹‰ï¼ˆ`T&&`ã€`std::move`ã€`std::forward`ï¼‰

C++11 çš„æ ¸å¿ƒæ”¹è¿›ä¹‹ä¸€ï¼šæ›´ä½æˆæœ¬åœ°ç§»åŠ¨èµ„æºï¼ˆé¿å…ä¸å¿…è¦æ‹·è´ï¼‰ã€‚

```cpp
struct S {
  std::vector<int> v;
  S(S&& other) : v(std::move(other.v)) {} // ç§»åŠ¨æ„é€ 
};
```

`std::move` å°†å¯¹è±¡è½¬æ¢ä¸ºå³å€¼ï¼Œ`std::forward` ç”¨äºå®Œç¾è½¬å‘ï¼ˆæ¨¡æ¿ä¸­è½¬å‘å·¦/å³å€¼ï¼‰ã€‚

**å¸¸è§å‘**ï¼šä½¿ç”¨ `std::move` åä¸è¦å†ä½¿ç”¨è¢«ç§»åŠ¨å¯¹è±¡ä¸­å¯èƒ½å·²â€œè¢«æ¸…ç©ºâ€çš„èµ„æºï¼ˆé™¤éä½ çŸ¥é“åæœï¼‰ã€‚

---

### 11. `= delete` / `= default`

æ§åˆ¶ç‰¹æ®Šæˆå‘˜å‡½æ•°çš„ç”Ÿæˆæˆ–åˆ é™¤ã€‚

```cpp
struct NoCopy {
  NoCopy(const NoCopy&) = delete;         // ç¦æ­¢æ‹·è´
  NoCopy& operator=(const NoCopy&) = delete;
  NoCopy(NoCopy&&) = default;             // ä½¿ç”¨é»˜è®¤çš„ç§»åŠ¨æ„é€ 
};
```

---

### 12. ç»Ÿä¸€åˆå§‹åŒ–ï¼ˆbrace initï¼‰ä¸ `std::initializer_list`

ç»Ÿä¸€çš„èŠ±æ‹¬å·åˆå§‹åŒ–è¯­æ³•ï¼Œé˜²æ­¢çª„åŒ–è½¬æ¢ï¼ˆä¸”é€‚ç”¨äº aggregatesï¼‰ã€‚

```cpp
int x{3};
std::vector<int> v{1,2,3};
struct P { int a; double b; } p{1, 2.0};
```

å¹¶ä¸”å¯ä»¥æ¥å— `std::initializer_list` æ„é€ ã€‚

---

### 13. å˜å‚æ¨¡æ¿ï¼ˆVariadic templatesï¼‰

è®©æ¨¡æ¿æ¥å—ä»»æ„æ•°é‡çš„å‚æ•°ï¼ˆæ¯”å¯å˜å‚å®å¼ºå¾ˆå¤šï¼‰ã€‚

```cpp
template<typename... Args>
void printAll(Args... args){ /* é€’å½’å±•å¼€æˆ–æŠ˜å è¡¨è¾¾å¼ï¼ˆæŠ˜å æ˜¯ C++17ï¼‰*/ }
```

---

### 14. åˆ«åæ¨¡æ¿ / `using`ï¼ˆæ›¿ä»£ `typedef`ï¼‰

æ›´ç›´è§‚çš„ç±»å‹åˆ«åè¯­æ³•ã€‚

```cpp
template<typename T>
using Vec = std::vector<T>;
Vec<int> v; // ç­‰åŒäº std::vector<int>
```

---

### 15. å§”æ‰˜æ„é€ ï¼ˆDelegating constructorsï¼‰

ä¸€ä¸ªæ„é€ å‡½æ•°å¯ä»¥è°ƒç”¨åŒç±»å†…çš„å¦ä¸€ä¸ªæ„é€ å‡½æ•°ï¼Œå‡å°‘é‡å¤ä»£ç ã€‚

```cpp
struct S {
  S(): S(0) {}          // å§”æ‰˜åˆ° S(int)
  S(int x) { /* ... */ }
};
```

---

### 16. åç½®è¿”å›ç±»å‹ï¼ˆtrailing return typeï¼‰

åœ¨å¤æ‚æ¨¡æ¿åœºæ™¯ä¸­æ›´å¥½åœ°æŒ‡å®šè¿”å›ç±»å‹ã€‚

```cpp
template<class A, class B>
auto add(A a, B b) -> decltype(a+b) { return a+b; }
```

---

### 17. `noexcept`

å£°æ˜å‡½æ•°åœ¨å¼‚å¸¸å®‰å…¨æ–¹é¢çš„ä¿è¯ï¼ˆå¯ä»¥è¢«ç¼–è¯‘å™¨å’Œå®¹å™¨åˆ©ç”¨è¿›è¡Œä¼˜åŒ–ï¼‰ã€‚

```cpp
void f() noexcept { /* ä¸æŠ›å¼‚å¸¸ */ }
```

---

### 18. å¯¹é½/Unicode ç­‰å°æ”¹è¿›

* `alignof`, `alignas`ï¼ˆç±»å‹å¯¹é½æ§åˆ¶ï¼‰ã€‚
* æ–°çš„å­—ç¬¦ç±»å‹ï¼š`char16_t`, `char32_t` ä¸å¯¹åº”çš„å­—ç¬¦ä¸²å­—é¢é‡ `u""`, `U""`, ä»¥åŠ `u8""`ï¼ˆUTF-8 å­—ç¬¦ä¸²ï¼‰ã€‚

---

### 19. ç”¨æˆ·å­—é¢é‡ï¼ˆuser-defined literalsï¼‰

è‡ªå®šä¹‰å­—é¢é‡ï¼Œä¾‹å¦‚æ‰‹å†™ `operator"" _km`ã€‚

```cpp
long double operator"" _km(long double x) { return x * 1000.0; }
auto dist = 3.5_km;
```

---

### 20. `[[noreturn]]` ç­‰å±æ€§ï¼ˆæœ€å°é›†åˆï¼‰

C++11 å¼•å…¥ç»Ÿä¸€å±æ€§è¯­æ³• `[[attr]]`ï¼Œä¾‹å¦‚ `[[noreturn]]`ï¼ˆæ ‡è®°å‡½æ•°ä¸è¿”å›ï¼‰ã€‚

---

## äºŒã€æ ‡å‡†åº“ / è¿è¡Œæ—¶ï¼ˆC++11 å¾ˆå¤šæ–°å¢æˆ–æ ‡å‡†åŒ–çš„åº“ï¼‰

### 1. å¤šçº¿ç¨‹æ”¯æŒï¼ˆé‡å¤§æ–°å¢ï¼‰

* `<thread>`ï¼š`std::thread`ã€‚
* `<mutex>`ï¼š`std::mutex`, `std::recursive_mutex` ç­‰ã€‚
* `<condition_variable>`ï¼š`std::condition_variable`ã€‚
* `<future>`ï¼š`std::future`, `std::promise`, `std::async`ã€‚
* `<atomic>`ï¼š`std::atomic<T>` ä¸å†…å­˜åºï¼ˆmemory\_orderï¼‰ã€‚

è¿™äº›æŠŠå¹¶å‘æ”¯æŒä»å¹³å°ç‰¹å®šçš„æ‰©å±•å˜ä¸ºæ ‡å‡†åº“çš„ä¸€éƒ¨åˆ†ã€‚

ç¤ºä¾‹ï¼š

```cpp
#include <thread>
#include <iostream>
void tfunc(){ std::cout<<"hi\n"; }
std::thread t(tfunc);
t.join();
```

---

### 2. æ™ºèƒ½æŒ‡é’ˆä¸å†…å­˜ç®¡ç†

* `std::unique_ptr`ï¼ˆç‹¬å æ‰€æœ‰æƒï¼Œè½»é‡ï¼‰
* `std::shared_ptr`ï¼ˆå…±äº«æ‰€æœ‰æƒï¼‰
* `std::weak_ptr`ï¼ˆé…åˆ shared\_ptr é˜²æ­¢å¾ªç¯å¼•ç”¨ï¼‰
* `std::make_shared`ï¼ˆæ›´é«˜æ•ˆåœ°åˆ›å»º shared\_ptrï¼‰

```cpp
auto p = std::make_shared<int>(42);
std::unique_ptr<Foo> u(new Foo);
// C++14 ä¹‹åæœ‰ std::make_uniqueï¼ˆC++11 æ²¡æœ‰ï¼‰
```

---

### 3. `std::move` / `std::forward`ï¼ˆåº“å‡½æ•°ï¼‰

è¾…åŠ©ç§»åŠ¨è¯­ä¹‰ä¸å®Œç¾è½¬å‘ã€‚

---

### 4. å®¹å™¨ä¸å·¥å…·

* `std::array<T,N>`ï¼ˆå›ºå®šå¤§å°æ•°ç»„ç±»å‹ï¼‰
* `std::tuple`ï¼ˆå¤šå…ƒç»„ï¼‰ + `std::get`, `std::tie`
* `unordered_map`, `unordered_set`ï¼ˆå“ˆå¸Œå®¹å™¨ï¼Œè¢«æ­£å¼æ ‡å‡†åŒ–ï¼‰
* `std::begin`, `std::end`ï¼ˆé€šç”¨æ¥å£ï¼‰
* `std::to_string` ç­‰å®ç”¨å‡½æ•°

---

### 5. æ­£åˆ™è¡¨è¾¾å¼ï¼ˆ`<regex>`ï¼‰

æ ‡å‡†åº“æ”¯æŒçš„æ­£åˆ™ã€‚

---

### 6. æ—¶é—´åº“ï¼ˆ`<chrono>`ï¼‰

å¼ºç±»å‹çš„æ—¶é—´ç‚¹ã€æ—¶é’Ÿä¸æ—¶é—´æ®µï¼Œæ›¿ä»£è„†å¼±çš„ `time_t` ç”¨æ³•ã€‚

```cpp
using namespace std::chrono;
auto t1 = system_clock::now();
auto d = duration_cast<milliseconds>(t1 - t0);
```

---

### 7. `std::function`ã€`std::bind`ï¼ˆå‡½æ•°å¯¹è±¡/é€‚é…ï¼‰

æ ‡å‡†åŒ–å‡½æ•°å°è£…ä¸ç»‘å®šå·¥å…·ï¼ˆTR1 å¼•å…¥ï¼ŒC++11 æˆä¸ºæ ‡å‡†ï¼‰ã€‚

---

### 8. `std::array`, `std::tuple`, `std::initializer_list`

æ›´ä¸°å¯Œçš„å®¹å™¨ä¸åˆå§‹åŒ–æ”¯æŒï¼ˆè§ä¸Šæ–‡ï¼‰ã€‚

---

### 9. `type_traits`ã€`<utility>` ç­‰å¼ºåŒ–å…ƒç¼–ç¨‹æ”¯æŒ

æä¾›å¤§é‡åˆ¤æ–­ç±»å‹ç‰¹æ€§çš„å·¥å…·ï¼ˆ`is_integral`, `is_same` ç­‰ï¼‰ï¼Œæ˜¯ç°ä»£æ¨¡æ¿ç¼–ç¨‹çš„åŸºçŸ³ã€‚

---

### 10. `std::regex`, `std::random`ï¼ˆéšæœºåº“ï¼‰

æ ‡å‡†åŒ–æ­£åˆ™ä¸æ›´å¼ºçš„éšæœºæ•°è®¾æ–½ï¼ˆ`<random>` æ˜¯ C++11 çš„é‡è¦è¡¥å……ï¼‰ã€‚

---

## ä¸‰ã€å¸¸è§ä¾‹å­ï¼ˆå¿«é€Ÿä¸Šæ‰‹ï¼‰

### lambda + ç®—æ³•ï¼š

```cpp
std::vector<int> v{3,1,4};
std::sort(v.begin(), v.end(), [](int a, int b){ return a < b; });
```

### ç§»åŠ¨è¯­ä¹‰ï¼ˆé¿å…é¢å¤–æ‹·è´ï¼‰ï¼š

```cpp
std::vector<int> make_vec(){ std::vector<int> tmp{1,2,3}; return tmp; }
std::vector<int> v = make_vec(); // åˆ©ç”¨ç§»åŠ¨ / RVOï¼ˆè¿”å›å€¼ä¼˜åŒ–ï¼‰
```

### çº¿ç¨‹ + futureï¼š

```cpp
#include <future>
auto fut = std::async([](){ return 42; });
int result = fut.get();
```

---

## å››ã€ä¸ºä»€ä¹ˆè¿™äº›æ”¹å˜å¾ˆé‡è¦ï¼ˆæ€»ç»“ä»·å€¼ç‚¹ï¼‰

1. **æ€§èƒ½**ï¼šç§»åŠ¨è¯­ä¹‰å¤§å¹…å‡å°‘ä¸å¿…è¦æ‹·è´ï¼ˆå¯¹å®¹å™¨/èµ„æºå¯†é›†å‹åº”ç”¨å°¤å…¶æ˜¾è‘—ï¼‰ã€‚
2. **å¹¶å‘**ï¼šæ ‡å‡†çº¿ç¨‹/åŸå­/é”ç­‰è®©è·¨å¹³å°å¹¶å‘ç¼–ç¨‹å˜å¾—å¯ç§»æ¤ä¸”è§„èŒƒã€‚
3. **è¡¨è¾¾åŠ›**ï¼šlambdaã€autoã€decltypeã€ç»Ÿä¸€åˆå§‹åŒ–ç­‰è®©ä»£ç æ›´ç®€æ´ã€å¯è¯»æ€§æ›´å¥½ã€‚
4. **ç±»å‹å®‰å…¨**ï¼š`enum class`ã€`nullptr`ã€`override` ç­‰å‡å°‘å¸¸è§é”™è¯¯ã€‚
5. **å…ƒç¼–ç¨‹ä¸åº“æ”¯æŒ**ï¼š`type_traits`ã€å˜å‚æ¨¡æ¿ç­‰å¢å¼ºæ¨¡æ¿ç¼–ç¨‹èƒ½åŠ›ï¼Œåº“ç”Ÿæ€æ›´åŠ ä¸°å¯Œã€‚

---

## äº”ã€å­¦ä¹ è·¯çº¿ä¸å¸¸è§å‘

**å­¦ä¹ è·¯çº¿ï¼ˆå»ºè®®ï¼‰**ï¼š

1. æŒæ¡ `auto`ã€èŒƒå›´ `for`ã€lambdaï¼ˆçŸ­æœŸè§æ•ˆï¼‰
2. ç†è§£å³å€¼å¼•ç”¨ä¸ `std::move`ï¼ˆéœ€è¦ä¸€å®šç»ƒä¹ ï¼‰
3. å­¦ä¼š `unique_ptr` / `shared_ptr` ä¸ `=delete`/`=default`
4. ç†Ÿæ‚‰çº¿ç¨‹/mutex/future/atomicï¼ˆå¹¶å‘é—®é¢˜å¾ˆé‡è¦ï¼‰
5. è¿›é˜¶ï¼šå˜å‚æ¨¡æ¿ã€`decltype`ã€`constexpr`ã€ç±»å‹ç‰¹æ€§

**å¸¸è§å‘**ï¼š

* è¯¯ç”¨ `std::move`ï¼ˆæŠŠè¿˜ä¼šç”¨çš„å¯¹è±¡â€œç§»åŠ¨èµ°â€å¯¼è‡´æœªå®šä¹‰è¡Œä¸ºæˆ–ç©ºæ•°æ®ï¼‰
* å¿½ç•¥å¼‚å¸¸ä¿è¯ä¸ `noexcept`ï¼ˆå½±å“å®¹å™¨æˆ–åº“çš„è¡Œä¸ºï¼‰
* å¯¹ `auto` çš„ç±»å‹è¯¯åˆ¤ï¼ˆä¾‹å¦‚ `auto x = {1,2}` ä¼šæ¨æ–­ä¸º `std::initializer_list<int>`ï¼‰
* Lambda æ•è·æ—¶å¯¹æ•è·æ–¹å¼ï¼ˆå€¼/å¼•ç”¨ï¼‰çš„æ··æ·†å¯¼è‡´æ‚¬ç©ºå¼•ç”¨

---

## å…­ã€è¡¥å……ï¼ˆç®€æ´æ¸…å•ï¼‰

* è¯­è¨€ï¼š`auto`, `decltype`, lambda, range-for, `nullptr`, `enum class`, `override`/`final`, `constexpr`, `static_assert`, rvalue refs/move, `=delete`/`=default`, delegating ctors, uniform init, variadic templates, user-defined literals, `noexcept`, attributesã€‚
* åº“ï¼š`<thread>`, `<mutex>`, `<future>`, `<atomic>`, `<chrono>`, smart pointers (`unique_ptr`, `shared_ptr`), `std::move`/`std::forward`, `std::array`, `std::tuple`, `<regex>`, `<random>`, `type_traits`ã€‚

---

å¦‚æœä½ æƒ³ï¼Œæˆ‘å¯ä»¥ï¼š

* é’ˆå¯¹ **æŸä¸€é¡¹**ï¼ˆæ¯”å¦‚ç§»åŠ¨è¯­ä¹‰ / lambda / å¹¶å‘ï¼‰åšé€è¡Œé€å¥çš„æ·±å…¥è®²è§£å’Œæ›´å¤šç¤ºä¾‹ï¼›
* æˆ–è€…ç»™ä½ ä¸€ä¸ª **ç»ƒä¹ é¢˜é›†**ï¼ˆå«å‚è€ƒç­”æ¡ˆï¼‰æ¥å·©å›ºè¿™äº›ç‰¹æ€§ã€‚

ä½ é€‰å“ªä¸€é¡¹å…ˆæ·±å…¥ï¼Ÿ ğŸ˜„
