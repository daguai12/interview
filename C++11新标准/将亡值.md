# 概念速览（一句话）

* **左值（lvalue）**：表示“有身份的对象/可取地址的实体”，通常可以出现在赋值语句左边。
* **将亡值（xvalue，expiring value）**：一种特殊的右值，表示“即将被销毁/可以搬走资源”的对象，用于移动语义。
* **纯右值（prvalue，pure rvalue）**：普通右值，表示一个临时值或字面值，不再有命名的身份（例如字面量、按值返回的临时对象）。
  另外还有复合类别：**glvalue = lvalue ∪ xvalue**，**rvalue = prvalue ∪ xvalue**。理解这些是掌握移动语义、引用绑定和重载解析的基础。

---

# 详细解释 + 直观判定法

## 左值（lvalue）

* 含义：表达式指向一个具名或可地址的对象/函数，有**持久身份**（you can take its address）。
* 常见例子：

  * 变量名：`int a;` 中的 `a` 是左值。
  * 解引用：`*p`（当 `p` 指向对象）是左值。
  * 函数返回左值引用：`int& f(); f()` 是左值（因为返回引用）。
* 能绑定的引用：可以绑定到 `T&`（非常量左值引用）或 `const T&`（常量引用）。
* 示例：

  ```cpp
  int x = 1;
  x = 2;      // 左值可以出现在赋值左边
  int& r = x; // 绑定到左值引用
  ```

## 将亡值（xvalue，Expiring Value / 将亡值）

* 含义：一种特殊的 **可搬移的右值**，语义上表示“这个对象的资源可以被窃取／移动”，它仍然代表一个具体的对象（有地址/状态），但其生命周期是“即将结束”的。
* 常见导致 xvalue 的情形：

  * 对象被 `std::move` 后：`std::move(x)` 是 xvalue。
  * 函数返回 **右值引用**（`T&&`）时：例如 `T&& f(); f()` 是 xvalue。
  * 对类类型的右值调用成员并取得成员的结果（复杂场景），或对将亡对象做成员访问时（这些更高级，不必死记）。
* 能绑定的引用：可以绑定到 `T&&`（右值引用）或 `const T&`（常量左值引用也可绑定）。
* 用途：是实现移动语义（移动构造、移动赋值）的基础；当表达式是 xvalue 时，移动构造函数会被优先选择。
* 示例：

  ```cpp
  std::string s = "hello";
  std::string t = std::move(s); // std::move(s) 是 xvalue，t 用移动构造接管 s 的资源
  ```

## 纯右值（prvalue，Pure Rvalue / 纯右值）

* 含义：通常表示**临时值**或**纯粹的值**，没有可寻址的身份。它经常用于初始化临时对象或直接作为表达式的值。
* 常见例子：

  * 字面值：`42`, `3.14`, `'a'` 是 prvalue。
  * 按值返回的函数：`T f();`（返回 `T`）时调用 `f()` 得到 prvalue（注意 C++17 后有“弃权到临时”上的微小语义变化，但类别仍是 prvalue）。
  * 临时对象构造：`std::string("hi")` 是 prvalue。
* 能绑定的引用：

  * 可以绑定到 `const T&`（并触发临时延长，延长到引用的生命周期）；
  * 也可以绑定到 `T&&`（右值引用）。
* 示例：

  ```cpp
  int foo();          // returns int by value
  int x = foo();      // foo() 是 prvalue，用来初始化 x
  const int& r = 1+2; // prvalue 绑定到 const T&，临时寿命被延长到 r 的寿命
  ```

---

# 为什么区分它们很重要（3 个常见场景）

1. **引用绑定规则不同**

   * `T&` 只能绑定左值。
   * `const T&` 可以绑定左值和右值（包括 prvalue/xvalue），并对 prvalue 有延长寿命的效果。
   * `T&&`（右值引用）可绑定到 prvalue 或 xvalue，但不能绑定到普通左值（除非用 `std::move` 强制转换）。
2. **移动语义与效率**

   * 当表达式是 xvalue 或 prvalue 时，移动构造（`T(T&&)`) 可能被调用，从而允许“窃取”资源（比拷贝更快）。`std::move` 将左值转换为 xvalue，通知编译器可以移动它的资源。
3. **重载解析（lvalue/rvalue 重载）**

   * 你可以写两个重载 `void f(const T&)` 和 `void f(T&&)`；传入左值会调用前者，传入右值/将亡值会调用后者，从而实现在不同语义下的不同处理（例如拷贝 vs 移动）。

示例（重载）：

```cpp
void g(const std::string&); // for lvalues (avoid modifying)
void g(std::string&&);      // for rvalues (can move from it)

std::string s = "x";
g(s);           // 调用 g(const&)，不窃取 s
g(std::string("y")); // 调用 g(std::string&&)，可以移动构造
g(std::move(s)); // std::move(s) 是 xvalue -> 调用右值重载
```

---

# C++17 的微妙点（简短）

* C++17 改变了 prvalue 的“临时物化（materialization）”规则：prvalue 不再总是立即物化为可寻址的临时对象，编译器可以更高效地直接初始化最终对象（称为 prvalue 的“复制省略/直接构造”变化）。但从程序员角度，值类别（prvalue/xvalue/lvalue）和绑定规则的直观用法没有本质改变——理解上面的概念就够用了。

---

# 快速判定清单（看到表达式时怎么判断）

1. **是命名的变量 / 可取地址的表达式？** → 很可能是 **左值**。
2. **是字面量或临时对象或按值返回？** → 通常是 **纯右值 (prvalue)**。
3. **是 `std::move(expr)`、`static_cast<T&&>(expr)`、或函数返回 `T&&`？** → **将亡值 (xvalue)**。
4. **否则，判断它是否可以被移动（会优先调用移动构造）→ xvalue/prvalue。**

---

# 结语（实战建议）

* 记住：**左值 = 有名字/有身份；将亡值 = 可以被移动的右值；纯右值 = 临时值**。
* 写移动语义相关代码时：**用 `std::move` 明确表示“我允许你移动”**，并用 `T&&` 接收将亡值以实现高效移动。
* 对临时的引用绑定要小心临时寿命问题（`const T&` 可以延长临时寿命）。

如果你愿意，我可以：

* 给出一组易错示例（例如错误地返回对局部对象的引用、滥用 `std::move` 导致悬空等）并解释为什么错；
* 或者生成一张表格 / 速查卡（PDF/Markdown）方便你随手查阅。要哪一种？
