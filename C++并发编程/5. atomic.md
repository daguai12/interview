-----

### **1. 基础认识**

`std::atomic` 是 C++11 引入的，用于在多线程环境中实现低级别同步的工具集，定义在头文件 `<atomic>` 中。

#### **1.1 什么是原子操作**

##### **原子性（不可分割性）**

**原子操作 (Atomic Operation)** 是指一个从其他线程的角度来看**不可分割**的操作。这个操作要么完全执行完毕，要么完全没有执行，不存在一个“中间”状态被其他线程观察到。它的执行过程不会被任何其他线程打断。

这个“全有或全无”的特性是并发编程的基石。

以经典的银行转账为例，从账户 A 转 100 元到账户 B，这包含两个步骤：

1.  账户 A 扣款 100 元。
2.  账户 B 存款 100 元。

如果这两步不是一个原子操作，那么在步骤 1 完成后、步骤 2 开始前，系统崩溃或发生线程切换，就会导致 100 元“凭空消失”，造成账目不一致。将整个转账过程作为一个原子操作，就能保证这两个步骤要么一起成功，要么一起失败回滚。

在 C++ 中，`counter++` 这样的操作就不是原子的，它至少包含三步：

1.  **读取** `counter` 的当前值到寄存器。
2.  在寄存器中对值进行**加一**操作。
3.  将寄存器中的新值**写回** `counter` 的内存地址。

在这三步之间的任何时刻，都可能发生线程切换，导致其他线程读取到旧的值，从而产生竞争条件。

##### **为什么需要原子操作（避免数据竞争，保证并发安全）**

1.  **避免数据竞争 (Data Races)**：
    当两个或多个线程并发地访问同一个非原子变量，并且其中至少有一个是写入操作时，就会发生数据竞争。根据 C++ 标准，任何数据竞争都会导致**未定义行为 (Undefined Behavior)**。这意味着程序可能会崩溃、产生错误结果，或者表面上看起来正常运行但内部状态已损坏。原子操作通过确保对共享变量的访问是互斥的、不可分割的，从而从根本上消除了数据竞争。

2.  **保证并发安全 (Concurrency Safety)**：
    原子操作是构建更高级别并发原语（如锁、信号量）和无锁数据结构的基础。相比于使用互斥锁 (`std::mutex`)，对单个变量的原子操作通常**性能更高**，因为它往往被直接编译为一条特殊的 CPU 指令（如 x86 上的 `LOCK INC`），避免了操作系统内核的介入和线程上下文切换的开销。

#### **1.2 `std::atomic` 概述**

##### **模板类 `std::atomic<T>`**

`std::atomic` 是一个模板类，它对类型 `T` 进行封装，为该类型提供了一套保证原子性的成员函数。当你创建一个 `std::atomic<T>` 的对象时，你就可以通过它的接口来安全地在多线程中读写它。

```cpp
#include <atomic>

std::atomic<bool> data_ready(false);
std::atomic<int> counter(0);
std::atomic<long long> large_counter(0);
```

##### **与 `volatile` 的区别**

这是一个非常重要且容易混淆的概念！**`volatile` 和 `std::atomic` 用于解决完全不同的问题。**

  * **`volatile`**:

      * **作用**：告诉**编译器**，这个变量的值可能在任何时候被程序之外的因素改变（例如：硬件寄存器、另一个进程修改的共享内存、中断服务例程）。因此，编译器**不能**对这个变量的读写操作进行优化（比如不能将它缓存在 CPU 寄存器中，每次都必须从主内存中读取）。
      * **保证**：只保证了对编译器的可见性，防止了编译器的优化。
      * **不保证**：**不保证**原子性，**不保证**能解决 CPU 指令重排，也**不保证**在一个多核 CPU 上的跨核心内存可见性。
      * **结论**：`volatile` 是用来与硬件或特殊内存区域打交道的，**不能**用于线程同步。

  * **`std::atomic`**:

      * **作用**：告诉**编译器和 CPU**，对这个变量的操作必须是原子的。
      * **保证**：保证了原子性、提供了控制指令顺序和跨线程内存可见性的机制（通过内存序）。
      * **结论**：`std::atomic` 是专为**多线程同步**设计的。

**一句话总结：`volatile` 防止编译器乱来，`std::atomic` 防止其他线程乱来。**

##### **可原子化的类型（整型、指针、部分自定义类型）**

  * **原生支持**：C++ 标准保证 `std::atomic` 对所有内置整型（`int`, `char`, `long` 等）、`bool`、以及指针类型 `T*` 提供了高效的特化版本。这些版本通常是**无锁的 (lock-free)**，意味着它们由专门的 CPU 指令实现，而不需要动用操作系统级别的锁。
  * **自定义类型**：你也可以使用 `std::atomic<MyStruct>`，但需要满足一个前提：`MyStruct` 必须是**可平凡复制的 (Trivially Copyable)**。这意味着它没有复杂的构造/析构/拷贝/移动逻辑，内存布局就像一个简单的 C 结构体。
      * 对于这些自定义类型，`std::atomic` **不保证**是无锁的。如果 `sizeof(MyStruct)` 大于硬件支持的原子读写大小，编译器可能会使用一个内部的互斥锁来模拟原子性，这时的性能会比真正的无锁操作差。你可以通过 `my_atomic.is_lock_free()` 来检查一个原子对象在当前平台上是否是无锁的。

#### **1.3 基本接口**

`std::atomic` 的接口都带有一个可选的 `memory_order` 参数，我们暂时使用默认值（最强的 `memory_order_seq_cst`），在后续章节再深入探讨内存序。

##### **`load()` / `store()`**

这是最基础的原子读和原子写操作。

```cpp
std::atomic<int> foo(10);

// 原子地写入 20
foo.store(20); 

// 原子地读取当前值
int current_val = foo.load(); // current_val = 20
```

赋值和读取操作符 `operator=` 和 `operator T()` 通常被重载为调用 `store()` 和 `load()`。

```cpp
foo = 30; // 等效于 foo.store(30)
int val = foo; // 等效于 int val = foo.load()
```

##### **`exchange()`**

原子地用一个新值替换当前值，并返回**被替换前的旧值**。

```cpp
std::atomic<int> bar(5);
int old_value = bar.exchange(10);

// old_value 的值是 5
// bar 的新值是 10
```

这是一个非常有用的“获取并设置”操作。

##### **`compare_exchange_strong()` vs `compare_exchange_weak()`**

比较并交换 (Compare-and-Swap, CAS) 是原子操作中最强大、最核心的构建块。

**接口**：`bool compare_exchange_strong(T& expected, T desired);`
**注意**：`expected` 是一个**引用**，而且是非 `const` 的！

**工作逻辑**：

1.  原子地比较 `atomic` 对象的**当前值**和 `expected` 的值。
2.  **如果相等**：就将 `atomic` 对象的值修改为 `desired`，并返回 `true`。
3.  **如果不相等**：操作失败，**将 `atomic` 对象的当前值加载到 `expected` 中**，并返回 `false`。

<!-- end list -->

```cpp
std::atomic<int> baz(100);
int expected = 100; // 我们期望 baz 的当前值是 100

// 尝试将 baz 从 100 更新为 101
bool success = baz.compare_exchange_strong(expected, 101);

// if (success) -> baz 现在是 101, expected 仍然是 100
// if (!success) -> baz 的值没变, 但 expected 的值被更新成了 baz 的当前值
```

**`strong` vs `weak`**

  * **`compare_exchange_strong`**: 保证只有在值不相等时才返回 `false`。

  * **`compare_exchange_weak`**: 可能**伪失败 (spurious failure)**。即，即使值相等，它也可能返回 `false`。

      * **为什么会有 `weak`？** 在某些 CPU 架构上（如 LL/SC 指令对），`weak` 版本的实现可以更高效。如果一个 CAS 操作在中间被中断（比如线程上下文切换），它可能会失败。
      * **如何使用 `weak`？** 因为它可能伪失败，所以它**几乎总是被用在一个循环中**。

    <!-- end list -->

    ```cpp
    int expected = baz.load();
    int desired;
    do {
        desired = compute_new_value(expected);
    } while (!baz.compare_exchange_weak(expected, desired));
    ```

    对于大多数情况，使用 `strong` 更简单、更不容易出错。只有在性能极致要求的循环中，才考虑使用 `weak`。

-----

### **扩展接口**

除了上述核心接口，`std::atomic` 还为整型和指针类型提供了一套非常方便的“读-改-写”操作。

##### **`fetch_add()` / `fetch_sub()`**

原子地对当前值进行加/减操作，并返回**操作前的旧值**。

```cpp
std::atomic<int> counter(10);

// 增加 5, 返回 10
int old1 = counter.fetch_add(5); // old1 = 10, counter = 15

// 减少 3, 返回 15
int old2 = counter.fetch_sub(3); // old2 = 15, counter = 12
```

##### **`fetch_and()` / `fetch_or()` / `fetch_xor()`**

原子地对当前值进行按位与/或/异或操作，并返回**操作前的旧值**。

```cpp
std::atomic<int> flags(0b1100);

// old_flags = 0b1100, flags = 0b1110
int old_flags = flags.fetch_or(0b0010); 
```

##### **重载的操作符 (Overloaded Operators)**

为了方便使用，`std::atomic` 为整型和指针类型重载了常见的操作符，它们是对 `fetch_*` 系列函数的封装。

  * **前缀/后缀自增自减**

      * `++counter` (前缀): 调用 `fetch_add(1)`，但返回**新值**。
      * `counter++` (后缀): 调用 `fetch_add(1)`，返回**旧值**。
      * `--counter`, `counter--` 同理。

  * **复合赋值**

      * `counter += 5` 调用 `fetch_add(5)`。
      * `counter -= 5` 调用 `fetch_sub(5)`。
      * `flags &= mask`, `flags |= mask`, `flags ^= mask` 分别调用 `fetch_and`, `fetch_or`, `fetch_xor`。

这些重载的操作符使得 `std::atomic` 变量在代码中可以像普通变量一样使用，但背后却提供了强大的线程安全保证。

**例如，我们的线程安全计数器可以写得非常自然：**

```cpp
std::atomic<int> safe_counter(0);

void thread_func() {
    for (int i = 0; i < 1000; ++i) {
        safe_counter++; // 简洁、安全、高效
    }
}
```


# 案例

### **3. 常见并发模式中的 `atomic` 用法**

`std::atomic` 不仅仅是单个变量的线程安全封装，更是构建复杂并发模式的底层基石。

#### **3.1 自旋锁 (Spinlock)**

**概念**：
自旋锁是一种非阻塞锁。当一个线程尝试获取一个已经被占用的自旋锁时，该线程不会被操作系统挂起（休眠），而是在一个循环中“旋转”，持续检查锁是否被释放。

**与 `std::mutex` 的对比**：

  * **`std::mutex`**：是阻塞锁。等待的线程会进入休眠状态，放弃 CPU，等待操作系统唤醒。适用于锁占用时间较长的情况。
  * **`Spinlock`**：是忙等锁。等待的线程会持续占用 CPU 时间。适用于锁占用时间**极短**（通常只有几条指令）的场景，因为此时忙等的 CPU 开销可能比线程上下文切换的开销要小。

##### **使用 `std::atomic_flag` / `compare_exchange` 实现**

`std::atomic_flag` 是 C++ 标准库中唯一保证始终无锁 (lock-free) 的原子类型，它提供了实现自旋锁所需的最基本操作。

**实现1：使用 `std::atomic_flag` (推荐)**

```cpp
#include <atomic>

class Spinlock {
private:
    std::atomic_flag flag = ATOMIC_FLAG_INIT; // C++17及之前
    // C++20: std::atomic_flag flag{};

public:
    void lock() {
        // test_and_set: 原子地检查 flag，如果为 false，则将其设为 true 并返回 false；
        // 如果为 true，则不做任何事并返回 true。
        // 当锁被其他线程持有时 (flag=true)，循环会一直持续，形成“自旋”。
        while (flag.test_and_set(std::memory_order_acquire)) {
            // 在 C++20 中，可以加入 CPU 暂停指令或 flag.wait(true) 来优化能耗
        }
    }

    void unlock() {
        // 原子地将 flag 设为 false，释放锁。
        // 使用 release 语义，确保在锁被释放前，临界区内的所有内存写入
        // 对下一个获得锁的线程可见。
        flag.clear(std::memory_order_release);
    }
};
```

**实现2：使用 `std::atomic<bool>` 和 CAS**

```cpp
#include <atomic>

class SpinlockCAS {
private:
    std::atomic<bool> locked{false};

public:
    void lock() {
        bool expected = false;
        // 尝试用 true 替换 false。
        // 如果替换成功 (locked 原本是 false)，则获得锁，循环结束。
        // 如果替换失败 (locked 已经是 true)，则继续循环。
        // 使用 weak 是因为在循环中，伪失败没有影响，且可能性能更高。
        while (!locked.compare_exchange_weak(expected, true, std::memory_order_acquire)) {
            expected = false; // 每次失败后重置 expected 的值
        }
    }

    void unlock() {
        locked.store(false, std::memory_order_release);
    }
};
```

#### **3.2 计数器 (Atomic Counter)**

这是 `std::atomic` 最直接、最常见的用途，用于在多线程环境中安全地进行计数。

##### **原子加减 `fetch_add()` / `fetch_sub()`**

```cpp
#include <iostream>
#include <thread>
#include <vector>
#include <atomic>

std::atomic<int> atomic_counter{0};
int normal_counter = 0;

void safe_increment() {
    for(int i = 0; i < 10000; ++i) {
        // fetch_add 原子地将值加1，并返回加法前的旧值。
        // 这是一个读-改-写操作。
        atomic_counter.fetch_add(1, std::memory_order_relaxed);
    }
}

void unsafe_increment() {
    for(int i = 0; i < 10000; ++i) {
        normal_counter++;
    }
}

int main() {
    std::vector<std::thread> threads;
    for(int i = 0; i < 10; ++i) {
        threads.emplace_back(safe_increment);
    }
    for(auto& t : threads) {
        t.join();
    }
    std::cout << "Atomic counter final value: " << atomic_counter.load() << std::endl; // 必定是 100000

    threads.clear();
    for(int i = 0; i < 10; ++i) {
        threads.emplace_back(unsafe_increment);
    }
    for(auto& t : threads) {
        t.join();
    }
    std::cout << "Normal counter final value: " << normal_counter << std::endl; // 几乎不可能是 100000
}
```

**内存序选择**：对于一个纯粹的计数器，我们通常只关心它最终的计数值，而不关心它与其他数据的同步。因此，使用最弱的 `std::memory_order_relaxed` 可以给编译器和 CPU 最大的优化空间，从而获得最佳性能。

#### **3.3 单例模式（双重检查锁定 DCLP）**

双重检查锁定模式 (Double-Checked Locking Pattern, DCLP) 旨在实现线程安全的、延迟初始化的单例。

**问题**：在 C++11 之前，由于指令重排，DCLP 是有问题的。一个线程可能看到一个非空的指针，但指针指向的对象却还没有被完全构造！

##### **`atomic` 在内存可见性上的作用**

`std::atomic` 配合 `acquire-release` 内存序可以完美地解决这个问题。

```cpp
#include <atomic>
#include <mutex>

class Singleton {
private:
    Singleton() = default;
    ~Singleton() = default;
public:
    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;

    static Singleton* get_instance() {
        // 第一次检查：无锁，高性能。
        // 使用 acquire 语义加载，确保如果读到非空指针，
        // 那么构造函数的所有写入都对当前线程可见。
        Singleton* ptr = instance.load(std::memory_order_acquire);
        if (ptr == nullptr) {
            std::lock_guard<std::mutex> lock(mtx);
            // 第二次检查：有锁，防止竞争
            ptr = instance.load(std::memory_order_relaxed); // 在锁内，用 relaxed 即可
            if (ptr == nullptr) {
                ptr = new Singleton();
                // 使用 release 语义存储，确保 Singleton 的构造
                // 在指针被发布给其他线程之前完成。
                instance.store(ptr, std::memory_order_release);
            }
        }
        return ptr;
    }

private:
    static std::atomic<Singleton*> instance;
    static std::mutex mtx;
};

std::atomic<Singleton*> Singleton::instance{nullptr};
std::mutex Singleton::mtx;
```

  * **`release` store**：`instance.store(ptr, ...)` 就像一道屏障，它保证 `new Singleton()` 的所有内存写入（即对象的构造）都发生在 `ptr` 被赋新值**之前**，并且这些写入会“释放”给其他线程。
  * **`acquire` load**：`instance.load(..., acquire)` 是另一道屏障，它保证如果当前线程看到了非空的 `ptr`，那么它也一定能看到 `ptr` 指向的那个被完整构造的对象。

**现代 C++ 替代方案**：虽然 DCLP 是学习 `atomic` 的绝佳例子，但在 C++11 及以后，实现线程安全的单例有更简单、更推荐的方式——**Meyers' Singleton**：

```cpp
class SingletonModern {
public:
    static SingletonModern& get_instance() {
        // 静态局部变量的初始化在 C++11 中是线程安全的
        static SingletonModern instance;
        return instance;
    }
private:
    SingletonModern() = default;
    // ... 删除拷贝和赋值 ...
};
```

这种方式更简洁、更安全，应该作为首选。

#### **3.4 生产者-消费者模型**

虽然复杂的生产者-消费者队列通常使用 `mutex` 和 `condition_variable` 来实现（因为它涉及到线程的阻塞和唤醒），但 `atomic` 是构建**无锁队列 (Lock-Free Queue)** 的核心。

无锁队列不使用互斥锁，而是通过 CAS（`compare_exchange`）原子操作来处理并发的入队和出队，以获得极高的性能。这是一个非常高级的主题，我们这里展示一个**最简化**的单生产者-单消费者 (SPSC) 无锁环形缓冲区的思想。

**核心思想**：

  * 生产者只修改 `tail` 指针，消费者只修改 `head` 指针。
  * `atomic` 的内存序用来保证生产者写入的数据能安全地被消费者看到。

<!-- end list -->

```cpp
#include <atomic>
#include <array>

template <typename T, size_t Size>
class SPSCQueue {
private:
    std::array<T, Size> buffer_;
    // head 由消费者修改，tail 由生产者修改
    std::atomic<size_t> head_{0};
    std::atomic<size_t> tail_{0};

public:
    bool try_push(T value) {
        const auto current_tail = tail_.load(std::memory_order_relaxed);
        const auto next_tail = (current_tail + 1) % Size;

        // 如果队列满了（tail 的下一格是 head），则入队失败
        if (next_tail == head_.load(std::memory_order_acquire)) {
            return false;
        }

        buffer_[current_tail] = std::move(value);
        
        // 使用 release 语义更新 tail，确保数据写入先于 tail 更新
        // 并且对消费者可见
        tail_.store(next_tail, std::memory_order_release);
        return true;
    }

    bool try_pop(T& value) {
        const auto current_head = head_.load(std::memory_order_relaxed);

        // 如果队列为空
        if (current_head == tail_.load(std::memory_order_acquire)) {
            return false;
        }

        value = std::move(buffer_[current_head]);
        
        // 使用 release 语义更新 head，通知生产者此槽位已空闲
        head_.store((current_head + 1) % Size, std::memory_order_release);
        return true;
    }
};
```

**警告**：编写正确的无锁数据结构极其困难，需要对内存模型有深刻的理解。在实际项目中，应优先使用经过严格测试的库（如 `boost::lockfree`），或使用更简单的基于锁的并发数据结构。此示例仅用于教学，展示 `atomic` 和内存序在其中扮演的关键角色。


# 疑惑
这是一个非常好的问题，它触及了无锁编程和内存序的核心细节。你的担心——关于指令重排——是完全正确的，这也是在并发编程中必须时刻警惕的问题。

简单来说，这里可以使用 `relaxed` 是安全的，主要基于以下两个关键原因：

1.  这是一个**单消费者 (Single-Consumer)** 队列，`head_` 索引**只会被消费者线程自己修改**。
2.  真正的**跨线程同步点**在于读取由生产者修改的 `tail_` 指针，并且这个读取使用了 `acquire` 语义，它提供了足够的内存屏障。

下面我们来详细分解这个过程。

-----

### **详细解析**

#### **1. `head_` 的“所有权”与线程内一致性**

在这个单生产者-单消费者 (SPSC) 模型中，我们有一个严格的规则：

  * **生产者**：只写入 `buffer_`，只修改 `tail_`。
  * **消费者**：只读取 `buffer_`，只修改 `head_`。

因此，对于消费者线程来说，`head_` 是它的“私有”索引（尽管是原子的）。在 `try_pop` 函数内部，任何对 `head_` 的读取，都是为了获取**这个线程自己上一次修改后的值**。

一个线程内部的指令执行，即使有重排，也会保证其**数据依赖性**。`head_.load(std::memory_order_relaxed)` 只是为了原子地、无撕裂地读取 `head_` 的值，它不需要与其他线程就 `head_` 的状态进行同步。因此，`relaxed` 提供的最弱保证（仅原子性）已经足够了。

#### **2. 真正的同步点：`tail_.load(std::memory_order_acquire)`**

消费者需要知道的唯一一件来自“外部世界”（即生产者线程）的事情是：“生产者到底把数据写到了哪里？” 这个信息是通过 `tail_` 指针传递的。

  * **生产者**在写入数据后，会执行 `tail_.store(next_tail, std::memory_order_release)`。这个 **`release`** 操作就像一道屏障，它保证：

    1.  所有在 `store` 之前的内存写入（特别是写入 `buffer_` 的数据）都已经完成。
    2.  这些写入会“释放”给其他线程，对它们变得可见。

  * **消费者**在检查队列是否为空时，执行 `tail_.load(std::memory_order_acquire)`。这个 **`acquire`** 操作是与生产者的 `release` 配对的另一道屏障，它保证：

    1.  如果 `load` 操作看到了生产者写入的新值，那么生产者在 `release` 之前的所有内存写入（即 `buffer_` 中的数据）在此 `load` 操作之后，对消费者来说都是可见的。
    2.  在 `acquire` 之后的任何内存操作（比如 `value = std::move(buffer_[current_head]);`）都**不能**被重排到这个 `acquire` 操作**之前**。

#### **3. 指令重排分析（回答你的核心问题）**

现在我们来正面回答你的问题：“难道不怕 `head_.load` 和 `tail_.load` 的顺序被重排吗？”

假设编译器或 CPU 真的将它们重排了：

**原始顺序:**

```cpp
const auto current_head = head_.load(std::memory_order_relaxed);
if (current_head == tail_.load(std::memory_order_acquire)) { /* ... */ }
```

**重排后的等效逻辑:**

```cpp
const auto current_tail = tail_.load(std::memory_order_acquire);
const auto current_head = head_.load(std::memory_order_relaxed);
if (current_head == current_tail) { /* ... */ }
```

**这种重排会破坏逻辑吗？答案是：不会。**

因为 `if` 判断是在**两个值都被加载之后**才发生的。无论 `current_head` 和 `current_tail` 谁先被加载到寄存器中，最终用于比较的都是这两个值。

**关键在于 `acquire` 屏障的位置**。这道屏障的核心作用是**约束后续的内存访问**，而不是约束它之前的 `relaxed` load。

```cpp
// ...
if (current_head == tail_.load(std::memory_order_acquire)) {
    // 队列为空，返回
    return false;
}

// 只有在 if 判断为 false 时才会执行到这里
// acquire 屏障保证了这行代码的内存访问是安全的
value = std::move(buffer_[current_head]);
```

`acquire` 屏障确保了，只要 `tail_.load` 操作发生了，并且我们决定要读取 `buffer_`，那么这次读取就一定能看到生产者已经准备好的数据。`head_.load` 即使被重排到 `tail_.load` 之后，也只是影响了 `if` 判断中 `current_head` 变量的值，但这个值对于消费者线程来说始终是一致的，所以 `if` 判断的逻辑依然正确。

### **一个比喻**

你可以把 `acquire` load 想象成一道门。只有通过了这扇门（成功读取了 `tail_` 的新值并确认队列非空），你才能确保门另一边（生产者线程）准备好的所有东西（`buffer_` 里的数据）对你来说都是安全可见的。

至于你在开门之前是在看自己的手表（读取 `head_`）还是在整理自己的衣服，顺序并不重要。重要的是，**你不能在开门之前就伸手去拿门另一边的东西**，而 `acquire` 屏障正是防止了这种情况的发生。

### **结论**

1.  `head_.load(std::memory_order_relaxed)` 是安全的，因为 `head_` 只被当前消费者线程修改，不需要跨线程同步。
2.  `tail_.load(std::memory_order_acquire)` 是必需的，它是消费者与生产者之间的同步点，确保了数据的可见性。
3.  `head_` 和 `tail_` 的加载顺序即使被重排，也不会影响“队列是否为空”这一判断的最终正确性。
4.  `acquire` 屏障最关键的作用是保证了在它之后的**数据读取** (`buffer_[current_head]`) 不会被重排到屏障之前，从而避免了读取到尚未准备好的数据。

这种优化是 SPSC 队列的典型特征。如果这是一个多消费者 (MPMC) 队列，`head_` 会被多个消费者线程修改，那么对 `head_` 的操作就需要更强的原子原语（如 `compare_exchange`）和更强的内存序了。