好 👍，你卡在 **「为什么栈帧会层层叠加」** 这里，我来用更细的“函数调用视角”帮你拆开。

---

## 1. 普通函数调用 vs 协程 resume

先想象一个普通函数：

```cpp
void foo() {
    bar();  // 调用 bar
    // ... bar 返回之后才会继续执行 foo
}
```

执行的时候：

* `foo()` 的栈帧先建立。
* 调用 `bar()` → 新建一个 **bar 栈帧**，压在 `foo` 上面。
* `bar()` 结束 → bar 的栈帧弹出，CPU 返回到 `foo` 的下一行。

👉 这是“**调用 → 返回**”的正常模式，栈帧不会无限堆叠，因为每次函数调用完都会弹出。

---

## 2. 协程里的 `await_suspend` 调用链

来看你例子里的片段（简化）：

```cpp
task loop_synchronously() {
    for (...) {
        co_await completes_synchronously();
    }
}
```

当 `loop_synchronously` 执行到 `co_await` 时：

1. 它进入 **`task::awaiter::await_suspend`**，这里会调用 `.resume()` 来启动 `completes_synchronously`。
2. `.resume()` 是一个**普通函数调用**，所以此时的栈情况是：

```
栈顶
+------------------------+
| completes_synchronous$resume |
+------------------------+
| coroutine_handle::resume     |
+------------------------+
| task::awaiter::await_suspend |
+------------------------+
| loop_synchronously$resume    |
+------------------------+
```

看到没有？
**`await_suspend` 还没有返回**，它就调用了下一个 `.resume()`，于是新的栈帧就叠在上面了。

---

## 3. 为什么不会弹掉

关键点在这里：

* `await_suspend()` 并没有“return”回到 `loop_synchronously`；
* 它是“正在执行中”，然后**同步调用**了 `resume()`，所以它的栈帧必须保留，等以后 `resume()` 结束时再返回。

也就是说：

* 普通函数 `A -> B`：B 结束，栈帧弹掉，回到 A。
* 协程里的 `await_suspend`：在 A 还没 return 的时候，A 就先调用了 B，所以 A 的栈帧必须留着，等 B 完成后再回到 A。

---

## 4. 循环时的递归效果

现在加上循环：

1. 第一次 `co_await` → `await_suspend()` → 调用 `completes_synchronously$resume` → 它 `final_suspend` 时又调用 `loop_synchronously$resume`。
2. 注意！这个 **新的 `loop_synchronously$resume`** 不是“旧的继续”，而是通过 `resume()` 又同步压栈了一层。

于是栈就像这样：

```
栈顶
| loop_synchronously$resume (第2次) |
| coroutine_handle::resume          |
| final_awaiter::await_suspend      |
| completes_synchronously$resume    |
| coroutine_handle::resume          |
| task::awaiter::await_suspend      |
| loop_synchronously$resume (第1次) |
```

每次循环都会再加一层，完全像递归。

---

## 5. 为什么 **看起来不是递归，实际上是递归**

* 表面：`for (int i=0; i<count; i++) co_await ...;`
* 实际：
  每次 `co_await` 等价于“当前 `resume` 调用下一个 `resume`”，所以逻辑上就是：

```
loop$resume()
  -> await_suspend()
    -> completes$resume()
      -> final_suspend()
        -> loop$resume()   // 再次调用自己！
```

这就是“隐式递归”。
因为 `.resume()` 是普通函数调用，**不会清栈**，所以栈帧层层堆叠，直到爆掉。

---

## 6. 如果有 symmetric transfer

如果 runtime/编译器支持对称转移：

* 在 `await_suspend` 调用 `.resume()` 的时候，不是“压栈调用”，而是“直接跳转”。
* 相当于告诉 CPU：当前函数别保留了，直接转到目标 resume。
* 那么栈帧就不会一层层叠加，始终只有一个。

---

✅ 所以总结你的问题：

> **为什么栈帧会层层叠加？**

因为：

1. `await_suspend` 里用的是普通函数调用 `.resume()`；
2. 普通函数调用必须把调用者的栈帧留着，等被调函数返回时再继续；
3. 但在协程链里，`resume()` 不会马上返回（而是继续 co\_await 链），所以新的 `resume` 一直往上叠；
4. 每次循环一次，就像隐式递归一样，导致栈帧无限积累。

---

要不要我帮你画一个 **“一次 co\_await” vs “两次循环 co\_await” 的栈对比图**（ASCII/plantuml）？这样你能直观看到“哦，原来栈帧真的是叠上去了”。
