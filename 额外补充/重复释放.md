# 错误代码
## 示例代码

```cpp
#include <coroutine>
#include <iostream>
#include <stdexcept>

struct Task {
    struct promise_type {
        // 自定义内存分配，方便观察协程帧的分配/释放
        static void* operator new(std::size_t size) {
            std::cout << "[promise_type::operator new] 分配协程帧, 大小 = " << size << "\n";
            return ::operator new(size);
        }
        static void operator delete(void* ptr, std::size_t size) noexcept {
            std::cout << "[promise_type::operator delete] 释放协程帧, 大小 = " << size << "\n";
            ::operator delete(ptr);
        }

        Task get_return_object() {
            return Task{ std::coroutine_handle<promise_type>::from_promise(*this) };
        }

        // 危险点：这里故意抛异常
        auto initial_suspend() {
            std::cout << "initial_suspend: 抛出异常！\n";
            throw std::runtime_error("init suspend failed");
            return std::suspend_never{};
        }

        std::suspend_never final_suspend() noexcept { return {}; }
        void return_void() {}
        void unhandled_exception() { std::cout << "unhandled_exception\n"; }
    };

    std::coroutine_handle<promise_type> handle;
    Task(std::coroutine_handle<promise_type> h) : handle(h) {}

    // RAII 析构时调用 destroy()
    ~Task() {
        if (handle) {
            std::cout << "Task 析构，调用 handle.destroy()\n";
            handle.destroy();
        }
    }
};

Task bad_coro() {
    co_return; // 永远不会执行到这里，因为 initial_suspend 已经抛异常
}

int main() {
    try {
        std::cout << "调用 bad_coro()\n";
        auto t = bad_coro();
        std::cout << "bad_coro() 调用成功\n"; // 永远不会执行
    } catch (const std::exception& e) {
        std::cout << "捕获异常: " << e.what() << "\n";
    }
    std::cout << "main 结束\n";
}
```

---

## 运行过程分析

1. **调用 `bad_coro()`**

   * 协程帧分配成功 → 调用 `promise_type::operator new`。
   * `promise.get_return_object()` 返回 `Task`。
   * 接下来执行 `co_await promise.initial_suspend()`。

2. **`initial_suspend()` 抛异常**

   * 异常立即冒出（注意：此时不在 try/catch 范围内）。
   * 协程帧销毁 → 调用 `operator delete`。
   * 异常继续抛回到调用方。

3. **返回对象 `Task` 析构**

   * 栈展开过程中，局部变量 `t`（返回对象）析构。
   * 它的析构函数里调用了 `handle.destroy()`。
   * 但是此时协程帧已经在异常传播时被释放过一次。
   * 就会导致 **重复释放** → 未定义行为（可能直接崩溃）。

---

## 可能的输出（取决于编译器）

```
调用 bad_coro()
[promise_type::operator new] 分配协程帧, 大小 = 64
initial_suspend: 抛出异常！
[promise_type::operator delete] 释放协程帧, 大小 = 64
Task 析构，调用 handle.destroy()
捕获异常: init suspend failed
main 结束
```

这里虽然看起来正常，但实际上 `Task 析构 → handle.destroy()` 已经在释放一块无效的内存了（**未定义行为**，有的编译器可能直接段错误）。

---

## 总结

这段代码正好印证了你那段话：

* `initial_suspend()` 在 try/catch 之外执行
* 如果它抛异常 → 协程帧会先被释放
* 返回对象还会析构 → `handle.destroy()` 又释放一次
* **导致协程帧被重复释放**（未定义行为）

所以才要求 **`initial_suspend()` 应该是 `noexcept`**，通常用 `suspend_always` 或 `suspend_never` 就行。

# 正确代码


## 修复版代码

```cpp
#include <coroutine>
#include <iostream>

struct Task {
    struct promise_type {
        static void* operator new(std::size_t size) {
            std::cout << "[promise_type::operator new] 分配协程帧, 大小 = " << size << "\n";
            return ::operator new(size);
        }
        static void operator delete(void* ptr, std::size_t size) noexcept {
            std::cout << "[promise_type::operator delete] 释放协程帧, 大小 = " << size << "\n";
            ::operator delete(ptr);
        }

        Task get_return_object() {
            return Task{ std::coroutine_handle<promise_type>::from_promise(*this) };
        }

        // ✅ 修复：返回一个 noexcept 的 awaitable
        std::suspend_always initial_suspend() noexcept {
            std::cout << "initial_suspend: 挂起 (不会抛异常)\n";
            return {};
        }

        std::suspend_never final_suspend() noexcept { return {}; }
        void return_void() {}
        void unhandled_exception() { std::cout << "unhandled_exception\n"; }
    };

    std::coroutine_handle<promise_type> handle;
    Task(std::coroutine_handle<promise_type> h) : handle(h) {}

    ~Task() {
        if (handle) {
            std::cout << "Task 析构，调用 handle.destroy()\n";
            handle.destroy();
        }
    }
};

Task good_coro() {
    std::cout << "协程体执行中\n";
    co_return;
}

int main() {
    std::cout << "调用 good_coro()\n";
    auto t = good_coro(); // initial_suspend 不会抛异常
    std::cout << "main 结束\n";
}
```

---

## 运行结果（示例）

```
调用 good_coro()
[promise_type::operator new] 分配协程帧, 大小 = 64
initial_suspend: 挂起 (不会抛异常)
main 结束
Task 析构，调用 handle.destroy()
[promise_type::operator delete] 释放协程帧, 大小 = 64
```

---

## 修复点解读

1. `initial_suspend()` **返回 `std::suspend_always` 且声明为 `noexcept`**

   * 这样可以保证绝不会抛出异常。
   * 避免了「协程帧被释放一次 + Task 析构时又 destroy 一次」的情况。

2. 当 `good_coro()` 被调用时：

   * 协程帧分配成功
   * `initial_suspend()` 执行，挂起但不会出错
   * 协程安全地返回给调用者

3. 当 `Task` 析构时：

   * 只会调用一次 `handle.destroy()`，释放协程帧，流程正常。

---

✅ 所以实践经验就是：

* `initial_suspend()` 和 `final_suspend()` 都应该是 `noexcept`。
* 推荐用 `std::suspend_never`（立即启动）或 `std::suspend_always`（延迟启动），这两个标准类型都保证 `noexcept`。

---

要不要我再给你写一个 **对比演示**：一个用 `suspend_never`（协程立刻运行），一个用 `suspend_always`（协程需要手动 resume 才运行），让你直观看到差异？
