
### 1️⃣ 返回调用者

> 当协程函数到达第一个 `<return-to-caller-or-resumer>` 点（或者没有此类点，则协程执行完成时），会将 `get_return_object()` 返回的返回对象返回给调用者。

解释：

* `<return-to-caller-or-resumer>` 点就是协程“第一次挂起点”或者协程体执行完毕的位置。
* 协程创建时，编译器会生成一个 `promise_type` 对象，并调用：

```cpp
auto ret_obj = promise.get_return_object();
```

* **返回对象** (`ret_obj`) 是你调用协程函数时真正得到的值，它可能是一个 `Task`、`std::future`、或者自定义类型。
* 当协程到达第一个挂起点（或者执行完毕），这个返回对象就会被交给调用者。

简单理解：**协程函数返回给调用者的不是“协程体本身”，而是 promise 生成的返回对象**。

---

### 2️⃣ 返回对象类型不需要和协程函数返回类型一致

```cpp
Task my_coroutine() { ... }
```

* 函数声明返回 `Task`，但是 `promise.get_return_object()` 返回的对象类型可以不同。
* 如果类型不同，编译器会做隐式类型转换。
* 例子：

```cpp
struct MyPromise {
    std::shared_ptr<int> get_return_object() { return std::make_shared<int>(42); }
};
Task my_coroutine() { co_return; }  // Task 是协程函数返回类型
```

这里 `get_return_object()` 返回 `std::shared_ptr<int>`，编译器会尝试将它转换成 `Task`（如果 Task 有相应构造函数或转换操作）。

---

### 3️⃣ Clang 和 MSVC 的行为差异

> Clang 的协程实现（截至 5.0）会将转换延迟到返回对象返回时，而 MSVC（2017 Update 3）在调用 `get_return_object()` 后立即进行转换。

* **Clang**：先拿到返回对象（可能是 `MyPromise::get_return_object()` 的类型），**延迟做类型转换**，直到把值真正返回给调用者。

* **MSVC**：在调用 `get_return_object()` 时就立即做类型转换。

* **意义**：延迟转换允许一些“有趣的用例”，例如你可以在协程内通过 `co_await` 或其他方式改变返回对象的类型，Clang 的延迟策略会更灵活。

---

### 4️⃣ Coroutines TS 的标准规定

> Coroutines TS 并未明确规定行为，但 MSVC 计划将实现改为类似 Clang，以支持一些有趣的用例。

* TS（Technical Specification）阶段没有严格规定**返回对象类型转换的时间点**
* MSVC 的未来计划是采用 **延迟转换**，和 Clang 保持一致

---

### ✅ 总结

1. **协程函数真正返回给调用者的是 `get_return_object()` 生成的对象**
2. 返回对象类型可以和协程函数声明的返回类型不同，编译器会做隐式转换
3. **Clang** 延迟转换到返回时，\*\*MSVC（旧版本）\*\*立即转换
4. 延迟转换更灵活，允许一些特殊用例

---

如果你愿意，我可以画一张**协程创建 → get\_return\_object → 返回对象 → 调用者**的流程图，让返回对象和类型转换的过程更直观。

你希望我画吗？
