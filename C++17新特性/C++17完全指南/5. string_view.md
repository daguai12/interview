### Chapter 19: 字符串视图

#### 19.1 和 std::string 的不同之处

和 `std::string` 相比，`std::string_view` 对象有以下特点：

  * **只读性**: 底层的字符序列是只读的。没有任何操作可以修改视图指向的字符。你只能对视图本身进行操作，如赋予一个新值、交换值、或将其缩小为原字符序列的一个子序列。
  * **非空字符终止**: `std::string_view` 不保证其指向的字符序列以空字符 (`\0`) 终止。因此，它不能被当然地视作一个 NTBS (null-terminated byte string)。
  * **`data()` 可能返回 `nullptr`**: 一个默认构造的 `std::string_view` 的 `data()` 成员函数会返回 `nullptr`。
  * **无分配器支持**: `std::string_view` 本身不进行任何内存分配，因此没有分配器的概念。

**重要提示**：由于 `data()` 可能返回 `nullptr` 且字符序列可能不以空字符结尾，在使用 `operator[]` 或 `data()` 之前，应当总是先通过 `size()` 检查其长度（除非你已经明确知道其状态）。

#### 19.2 使用字符串视图

`std::string_view` 主要有两个应用场景：

1.  **重用已有数据**: 当你已经拥有了一块分配好或映射好的字符序列（如内存映射文件），并且希望在不产生额外内存分配的情况下使用这些数据时。
2.  **提升函数性能**: 当你需要编写一个接收字符串作为参数并以**只读**方式使用它们的函数时，使用 `std::string_view` 可以显著提升性能，特别是当函数逻辑不依赖于结尾的空字符时。

一个典型的例子是用 `std::string_view` 来封装和操作字符串字面量，赋予它类似 `std::string` 的API：

```cpp
std::string_view hello{"hello world"};
```

**注意**：`std::string_view` 并非“更好的 `std::string`”。不恰当的使用会导致性能问题甚至运行时错误。程序逻辑必须保证在 `string_view` 的生命周期内，其底层的字符序列始终有效。

#### 19.3 使用字符串视图作为参数

将函数参数声明为 `std::string_view` 可以避免不必要的内存分配，尤其是在传递字符串字面量或短字符串时。

**示例1：`printElems`**

```cpp
#include <iostream>
#include <string_view>
#include <vector>

template <typename T>
void printElems(const T& coll, std::string_view prefix = {})
{
    // 检查 data() 以排除 nullptr 的情况
    if (prefix.data()) {
        std::cout << prefix;
    }

    for (const auto& elem : coll) {
        std::cout << ' ' << elem;
    }
    std::cout << '\n';
}
```

如果此处的 `prefix` 参数类型是 `const std::string&`，当调用 `printElems(my_vector, "Elements:")` 时，会创建一个临时的 `std::string` 对象，这可能涉及一次堆内存分配（除非触发短字符串优化SSO）。而使用 `std::string_view` 则完全没有这个开销，因为它仅仅是指向字符串字面量的指针和长度。

**示例2：`asInt`**
将字符串转换为整数时，使用 `string_view` 需要放弃 `std::stoi()`（因为它要求一个 `std::string` 对象），转而使用更底层的 `std::from_chars()`，以避免创建临时 `string` 的开销。

```cpp
#include <optional>
#include <string_view>
#include <charconv> // for from_chars()
#include <iostream>

// 尝试将 string_view 转换为 int
std::optional<int> asInt(std::string_view sv)
{
    int val;
    // 把字符序列读入 int
    auto [ptr, ec] = std::from_chars(sv.data(), sv.data() + sv.size(), val);

    // 如果有错误码，就返回空值
    if (ec != std::errc{}) {
        return std::nullopt;
    }
    return val;
}
```

`std::from_chars()` 直接操作字符范围（由 `data()` 指针和 `size()` 确定），完全避免了内存分配。即使是默认构造的 `string_view`（`data()` 为 `nullptr`, `size()` 为 0），`nullptr` 到 `nullptr+0` 也是一个有效的空范围。

#### 19.3.1 字符串视图有害的一面

`std::string_view` 的行为更接近于原生字符指针，远比 `std::string&` 更危险。它既不拥有数据，也不延长其所指向数据的生命周期。

**致命陷阱：不要将临时 `string` 赋值给 `string_view`**

```cpp
std::string retString(); // 假设这是一个返回临时 string 的函数

// 运行时错误：
std::string_view sv = retString(); 
// 在这条语句结束时，retString() 返回的临时 string 对象已经被销毁。
// sv 现在是一个“悬挂视图”，指向一块无效的内存。

std::cout << sv << '\n'; // 未定义行为，很可能导致程序崩溃！
```

这个问题与 `const char* p = retString().c_str();` 的危险性如出一辙。

**危险实践的延伸：**

  * **不要返回指向临时对象的视图**

    ```cpp
    // 非常危险
    std::string_view substring(const std::string& s, std::size_t idx = 0);

    // 调用时：
    auto sub = substring("very nice", 5); // "very nice" 是一个临时 string
    // 临时 string 在表达式结束后销毁，sub 成为悬挂视图
    ```

  * **当返回值是 `string_view` 时，不要返回一个类成员 `string`**

    ```cpp
    class Person {
        std::string name;
    public:
        // 不要这样做
        std::string_view getName() const { return name; }
    };

    // 调用时：
    Person createPerson(); // 返回一个临时的 Person 对象
    auto n = createPerson().getName(); // createPerson() 返回的临时对象在这行代码结束时销毁
    // 此时 name 成员也被销毁，n 成为悬挂视图
    std::cout << "name: " << n << '\n'; // 运行时错误
    ```

  * **泛型函数模板返回类型的问题**

    ```cpp
    std::string operator+ (std::string_view sv1, std::string_view sv2) {
        return std::string(sv1) + std::string(sv2); // 返回一个临时的 string
    }

    template <typename T>
    T concat (const T& x, const T& y) {
        return x + y;
    }

    // 调用时：
    std::string_view hi = "hi";
    auto xy = concat(hi, hi); // T被推导为std::string_view，xy也是std::string_view
    // operator+ 返回的临时 string 被销毁，xy 成为悬挂视图
    std::cout << xy << '\n'; // 运行时错误
    ```

    **改进**：将 `concat` 的返回类型改为 `auto`，编译器会自动推导出正确的返回类型 `std::string`。

  * **破坏 `std::move` 优化**
    如果一个类的构造函数接受 `string_view` 来初始化一个 `string` 成员，那么 `std::move` 的优化将会失效。

    ```cpp
    class Person {
        std::string name;
    public:
        // 不要这样做：
        Person (std::string_view n) : name {n} {} 
    };

    std::string s = "Joe";
    Person p{std::move(s)}; // s 首先被隐式转换为 string_view (无开销)
                           // 然后 name 成员通过这个 view 重新构造，导致一次新的内存分配和拷贝
                           // move 的意义完全丧失
    ```

    **正确做法**：构造函数应该接受 `std::string` by-value，然后 `std::move` 到成员中。

    ```cpp
    class Person {
        std::string name;
    public:
        Person (std::string n) : name{std::move(n)} {}
    };
    ```

#### 安全使用字符串视图的总结

为了安全地使用 `std::string_view`，请遵循以下规则：

  * **不要在最终需要 `std::string` 的 API 中使用 `string_view` 作为中间环节。**
      * 不要用 `string_view` 形参来初始化 `string` 成员。
      * 不要把 `string_view` 作为调用链的一环，如果链条的终点是 `string` 的话。
  * **不要返回 `string_view`。**
      * 除非它只是转发一个输入的 `string_view` 参数，或者你能通过命名等方式明确标记其危险性。
  * **函数模板永远不应该返回泛型参数的类型 `T`。**
      * 应该返回 `auto`。
  * **永远不要用一个函数的返回值来初始化 `string_view`。**
  * **不要把返回泛型类型 `T` 的函数模板的返回值赋给 `auto`。**
      * 这意味着 “Almost Always Auto” (AAA) 原则不完全适用于 `string_view`。

**如果这些规则太过复杂或难以遵守，那么就完全不要使用 `std::string_view`，除非你非常清楚自己在做什么。**


### 19.4 字符串视图类型和操作

本节详细描述 `std::string_view` 的具体类型定义和相关操作。

#### 19.4.1 字符串视图的具体类型

在头文件 `<string_view>` 中，C++标准库为 `std::basic_string_view<>` 模板提供了四种常用的特化版本：

  * **`std::string_view`**: 最常用的版本，针对 `char` 类型。
    ```cpp
    namespace std {
      using string_view = basic_string_view<char>;
    }
    ```
  * **`std::wstring_view`**: 针对宽字符 `wchar_t`。
  * **`std::u16string_view`**: 针对 `char16_t` (UTF-16)。
  * **`std::u32string_view`**: 针对 `char32_t` (UTF-32)。

这些类型的接口和行为模式完全相同，因此本书中提到的 “string view” 泛指以上任何一种类型。

#### 19.4.2 字符串视图的操作

`std::string_view` 提供了丰富的操作接口，如下表所示：

| 操作 | 效果 |
| :--- | :--- |
| **构造函数** | 创建或拷贝一个字符串视图 |
| **析构函数** | 销毁一个字符串视图 |
| **`=`** | 赋予新值 |
| **`swap()`** | 交换两个字符串视图的值 |
| **`==`, `!=`, `<`, `<=`, `>`, `>=`, `compare()`** | 比较字符串视图 |
| **`empty()`** | 返回字符串视图是否为空 |
| **`size()`, `length()`** | 返回字符的数量 |
| **`max_size()`** | 返回可能的最大字符数 |
| **`[]`, `at()`** | 访问一个字符 |
| **`front()`, `back()`** | 访问第一个或最后一个字符 |
| **`<<`** | 将值写入输出流 |
| **`copy()`** | 把内容拷贝或写入到字符数组 |
| **`data()`** | 返回 `nullptr` 或常量字符数组（不保证以空字符终止） |
| **查找函数** | 查找子字符串或字符 |
| **`begin()`, `end()`** | 提供普通迭代器支持 |
| **`cbegin()`, `cend()`** | 提供常量迭代器支持 |
| **`rbegin()`, `rend()`** | 提供反向迭代器支持 |
| **`crbegin()`, `crend()`** | 提供常量反向迭代器支持 |
| **`substr()`** | 返回子字符串 |
| **`remove_prefix()`** | 移除开头的若干字符 |
| **`remove_suffix()`** | 移除结尾的若干字符 |
| **`hash<>`** | 计算哈希值的函数对象的类型 |

*表 19.1: 字符串视图的操作*

**构造与初始化**

创建 `string_view` 的方式多样，但需注意以下几点：

1.  **默认构造**: 默认构造的 `string_view` 是空的，其 `data()` 返回 `nullptr`，`size()` 返回 `0`。此时通过 `operator[]` 访问是无效的。

    ```cpp
    std::string_view sv;
    auto p = sv.data();  // p 为 nullptr
    // std::cout << sv[0]; // 错误：无效访问
    ```

2.  **从C风格字符串（NTBS）创建**: 视图的 `size()` 将不包含末尾的 `\0`。访问 `sv[sv.size()]` 是未定义行为。

    ```cpp
    std::string_view sv{"hello"};
    std::cout << sv.size(); // 输出 5
    // std::cout << sv[5];      // 未定义行为
    // std::cout << sv.at(5);    // 抛出 std::out_of_range 异常
    ```

    虽然 `sv.data()` 可能恰好指向一个以 `\0` 结尾的内存区域，但这并非 `string_view` 的保证。

3.  **包含 `\0`**: 你可以显式指定长度，将 `\0` 作为视图的一部分。

    ```cpp
    std::string_view sv{"hello", 6}; // 明确包含 '\0'，共6个字符
    std::cout << sv.size(); // 输出 6
    std::cout << sv[5];     // OK，访问到 '\0'
    ```

4.  **从 `std::string` 创建**: `std::string` 提供了到 `std::string_view` 的隐式转换。但 `string` 保证的结尾 `\0` 对于 `string_view` 而言仍然是界外数据。

5.  **使用字面量后缀 `sv`**:

    ```cpp
    using namespace std::literals;
    auto s = "hello"sv; // s 的类型是 std::string_view
    ```

6.  **编译期初始化**: `string_view` 可以在编译期用字符串字面量初始化。

    ```cpp
    constexpr std::string_view hello = "Hello World!";
    ```

**关于结尾的空字符 (`\0`)**

理解 `string_view` 不保证以 `\0` 结尾至关重要。你可能会遇到两种看似带有 `\0` 的迷惑场景：

1.  **视图之后恰好有 `\0`**: 用字符串字面量初始化时，视图本身大小为5，但其指向的内存之后紧跟着一个 `\0`。`std::string_view sv1{"hello"};`
2.  **`\0` 是视图的一部分**: 明确指定长度，将 `\0` 包含进来。`std::string_view sv2{"hello", 6};`

这两种方式都可能导致混淆。目前C++标准库尚未提供一种既能保证以 `\0` 结尾又无需拷贝字符的视图类型。

**哈希支持**

C++标准库保证，对于值相同的 `std::string` 和 `std::string_view`，它们的哈希值也相同。

**修改字符串视图**

`string_view` 本身是只读的，但视图变量自身可以被修改：

  * **赋值与交换**: 你可以给 `string_view` 赋予新值，或交换两个 `string_view` 的值。
    ```cpp
    std::string_view sv1 = "hey";
    std::string_view sv2 = "world";
    sv1.swap(sv2);
    ```
  * **缩小视图范围**: `remove_prefix()` 和 `remove_suffix()` 可以修改视图的起点和终点，实现“切片”效果。
    ```cpp
    std::string_view sv = "I like my kindergarten";
    sv.remove_prefix(2);    // 视图变为 " like my kindergarten"
    sv.remove_suffix(8);  // 视图变为 " like my kind"
    std::cout << sv;      // 打印出： like my kind
    ```

**不支持 `operator+`**

`string_view` 之间不能直接使用 `+` 进行拼接。必须显式地将至少一个 `string_view` 转换为 `std::string`。

```cpp
std::string_view sv1 = "hello";
std::string_view sv2 = "world";
// auto s1 = sv1 + sv2; // 编译错误

auto s2 = std::string(sv1) + std::string(sv2); // OK
```

`string_view` 没有到 `string` 的隐式转换，因为这个过程涉及内存分配，开销较大，需要程序员显式进行。

#### 19.4.3 其他类型对字符串视图的支持

理论上，任何只读且不依赖 `\0` 结尾的字符串参数都可以用 `string_view` 替代。目前C++标准库在以下几个重要方面提供了支持：

  * **与 `std::string` 的互操作**:
      * 可以用 `string_view` **显式**构造 `std::string`。
      * `string` 的赋值、拼接、插入、替换、比较、查找等操作都接受 `string_view` 作为参数。
      * `string` 可以**隐式**转换为 `string_view`。
  * **与 `std::quoted` 的配合**: 可以将 `string_view` 传递给 `std::quoted` 来进行带引号的流输出。
  * **与文件系统路径 (`std::filesystem::path`) 的配合**: 可以用 `string_view` 初始化、拼接或比较路径。

然而，其他一些标准库组件，如正则表达式库 (`<regex>`)，目前仍然缺乏对 `string_view` 的直接支持。


### 19.5 在 API 中使用字符串视图

`std::string_view` 因其开销小且能与 `std::string` 兼容，看似是作为函数字符串参数的更优选择。然而，在实际应用中，必须考虑一些重要的细节。

首先，只有当函数对参数的使用满足以下约束时，`std::string_view` 才是有意义的：

  * **它不需要结尾有空字符 (`\0`)。** 如果需要将参数传递给一个只接受 `const char*` 且没有长度参数的C风格函数，则不满足此条件。
  * **它不会违反传入参数的生命周期。** 这通常意味着接收函数只会在传入值的生命周期内使用该视图。
  * **调用者不会更改底层字符的所有权。** 例如，在视图的生命周期内，不应销毁、修改或释放其指向的内存。
  * **它可以正确处理 `nullptr` 的情况。**

此外，需要注意同时提供 `std::string` 和 `std::string_view` 的函数重载可能会导致调用歧义：

```cpp
void foo(const std::string&);
void foo(std::string_view);

foo("hello"); // 编译错误：调用有歧义
```

最后，请务必牢记前文提到的警告：

  * **不要把临时字符串的返回值赋给字符串视图。**
  * **通常不要返回字符串视图。**
  * **不要在调用链的末端使用字符串视图来初始化或重设 `std::string` 的值。**

#### 19.5.1 使用字符串视图代替 string

**示例1：改进 `print` 函数**

考虑以下打印时间点的函数：

**修改前 (使用 `std::string`)**

```cpp
void print(const std::string& prefix, const std::chrono::system_clock::time_point& tp)
{
    auto rawtime{std::chrono::system_clock::to_time_t(tp)};
    std::string ts{std::ctime(&rawtime)}; // std::ctime 不是线程安全的
    ts.resize(ts.size() - 1);           // 去掉末尾的换行符
    std::cout << prefix << ts;
}
```

**修改后 (使用 `std::string_view`)**

```cpp
void print(std::string_view prefix, const std::chrono::system_clock::time_point& tp)
{
    auto rawtime{std::chrono::system_clock::to_time_t(tp)};
    std::string_view ts{std::ctime(&rawtime)}; // 注意：不是线程安全的
    ts.remove_suffix(1);                      // 去掉末尾的换行符
    std::cout << prefix << ts;
}
```

**分析**：

1.  **`prefix` 参数**: 将 `const std::string& prefix` 改为 `std::string_view prefix` 是一个简单且有效的优化。当调用者传入字符串字面量时，可以避免创建临时 `std::string` 对象所带来的内存分配开销。注意 `string_view` 是以值传参的，因为它本身非常轻量（一个指针+一个长度），拷贝开销极小。
2.  **`ts` 变量**: `std::ctime()` 返回一个指向静态内部缓冲区的 `char*`。使用 `std::string_view` 来封装这个结果是可行的，但**必须极其小心**。这个静态缓冲区的内容只在下一次调用 `ctime()` 或 `asctime()` 之前有效。在多线程环境中，这会引发竞争条件和严重问题（当然，即使使用 `std::string` 构造，`ctime` 本身的线程不安全问题依然存在）。

**示例2：改进 `toString` 函数**

如果函数需要返回一个拼接后的字符串，代码如下：

```cpp
std::string toString(std::string_view prefix, const std::chrono::system_clock::time_point& tp)
{
    auto rawtime{std::chrono::system_clock::to_time_t(tp)};
    std::string_view ts{std::ctime(&rawtime)}; // 注意：不是线程安全的
    ts.remove_suffix(1);                      // 去掉末尾的换行符
    
    // 无法直接用 operator+ 连接两个 string_view
    return std::string{prefix} + std::string{ts}; 
}
```

**分析**：由于 `std::string_view` 没有重载 `operator+`，我们必须显式地将其中至少一个（或两个）转换为 `std::string` 才能进行拼接。这会触发内存分配，抵消了一部分 `string_view` 带来的性能优势。

**示例3：使用 `string_view` 提升并行算法性能**

在排序一个字符串集合时，如果排序规则是基于子串，`string_view` 的优势会非常明显。

**使用 `std::string::substr()` (较慢)**

```cpp
// sort(coll.begin(), coll.end(), ... ); // 假设为并行算法
sort(std::execution::par, coll.begin(), coll.end(),
    [] (const auto& a, const auto& b) {
        return a.substr(2) < b.substr(2);
    });
```

**分析**：`std::string::substr()` 会**返回一个全新的 `std::string` 对象**，每次比较都涉及两次内存分配和数据拷贝，性能开销巨大。

**使用 `std::string_view::substr()` (快得多)**

```cpp
// sort(coll.begin(), coll.end(), ... ); // 假设为并行算法
sort(std::execution::par, coll.begin(), coll.end(),
    [] (const auto& a, const auto& b) {
        return std::string_view{a}.substr(2) < std::string_view{b}.substr(2);
    });
```

**分析**：`std::string_view::substr()` **不会进行任何内存分配**。它只是返回一个新的 `string_view` 对象，其内部指针和长度指向原始字符串的相应部分。这个操作的开销几乎为零，因此在性能上远超前者。