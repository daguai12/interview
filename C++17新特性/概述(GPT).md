ğŸ‘Œ å¥½çš„ï¼Œæˆ‘å¸®ä½ æ•´ç†ä¸€ä»½ **C++17 æœ€å€¼å¾—å­¦ä¹ ã€é¢è¯•å¸¸è€ƒçš„æ–°ç‰¹æ€§æ¸…å•**ï¼Œä¸ä»…ä»…åˆ—å‡ºåå­—ï¼Œè¿˜ä¼šå‘Šè¯‰ä½  **ä¸ºä»€ä¹ˆé‡è¦**ã€**åœ¨å“ªäº›åœºæ™¯ä¼šç”¨åˆ°**ã€‚æˆ‘æŠŠå®ƒä»¬åˆ†æˆå‡ ç±»æ¥è®²ï¼š

---

# ğŸ”¹ ä¸€ã€è¯­è¨€å±‚é¢æ”¹è¿›ï¼ˆè¯­æ³•ç³– & æ ¸å¿ƒè¯­ä¹‰å˜åŒ–ï¼‰

### 1. **ç»“æ„åŒ–ç»‘å®šï¼ˆStructured Bindingsï¼‰**

```cpp
std::map<int, std::string> m{{1, "one"}, {2, "two"}};
for (auto& [key, value] : m) {
    std::cout << key << " = " << value << '\n';
}
```

* å¯ä»¥ç›´æ¥æŠŠ tuple / pair / struct è§£åŒ…æˆå¤šä¸ªå˜é‡ã€‚
* è¯»æ€§å¤§å¹…æå‡ï¼ŒSTL éå†æ—¶ç‰¹åˆ«å¸¸ç”¨ã€‚
* é¢è¯•é«˜é¢‘ç‚¹ã€‚

---

### 2. **`if constexpr`ï¼ˆç¼–è¯‘æœŸåˆ†æ”¯ï¼‰**

```cpp
template<typename T>
void print(T t) {
    if constexpr(std::is_integral_v<T>)
        std::cout << "int: " << t << "\n";
    else
        std::cout << "other: " << t << "\n";
}
```

* ç±»ä¼¼ `if`ï¼Œä½†åœ¨ç¼–è¯‘æœŸåˆ¤æ–­ï¼Œä¸æ»¡è¶³åˆ†æ”¯çš„ä»£ç ä¸ä¼šç”Ÿæˆã€‚
* å†™æ¨¡æ¿å…ƒç¼–ç¨‹éå¸¸å…³é”®ï¼ˆæ›¿ä»£ `enable_if` çš„å¾ˆå¤šåœºæ™¯ï¼‰ã€‚

---

### 3. **å†…è”å˜é‡ï¼ˆinline variablesï¼‰**

```cpp
struct X { static inline int counter = 0; };
```

* é™æ€æˆå‘˜å˜é‡å¯ä»¥åœ¨ç±»å†…ç›´æ¥å®šä¹‰åˆå§‹åŒ–ã€‚
* é¿å… ODRï¼ˆOne Definition Ruleï¼‰é—®é¢˜ã€‚
* å¤§å¤§ç®€åŒ–äº†å¤´æ–‡ä»¶é‡Œçš„å¸¸é‡å®šä¹‰ã€‚

---

### 4. **`[[nodiscard]]` å±æ€§**

```cpp
[[nodiscard]] int compute();
compute(); // âš ï¸ ç¼–è¯‘å™¨ä¼šè­¦å‘Šç»“æœè¢«ä¸¢å¼ƒ
```

* ç”¨æ¥æ ‡è®°â€œå‡½æ•°è¿”å›å€¼å¿…é¡»ä½¿ç”¨â€ã€‚
* å¢å¼ºä»£ç å®‰å…¨æ€§ï¼Œé˜²æ­¢é”™è¯¯è¢«å¿½è§†ã€‚

---

### 5. **`constexpr` æ›´å¼ºå¤§**

* C++17 å…è®¸åœ¨ `constexpr` å‡½æ•°é‡Œç”¨ `if`ã€å¾ªç¯ç­‰ã€‚
* å¯ä»¥å†™çœŸæ­£çš„ç¼–è¯‘æœŸç®—æ³•ï¼ˆæ¯”å¦‚è®¡ç®—è´¨æ•°è¡¨ï¼‰ã€‚
* å¾ˆå¤šåº“åˆ©ç”¨å®ƒæå‡æ€§èƒ½ã€‚

---

### 6. **`__has_include` é¢„å¤„ç†å™¨**

```cpp
#if __has_include(<filesystem>)
#include <filesystem>
#endif
```

* æ¡ä»¶åŒ…å«å¤´æ–‡ä»¶ï¼Œè·¨å¹³å°ç¼–ç¨‹éå¸¸æœ‰ç”¨ã€‚

---

---

# ğŸ”¹ äºŒã€æ ‡å‡†åº“é‡å¤§æ–°å¢

### 7. **`std::optional<T>`**

```cpp
std::optional<int> get() {
    return {}; // å¯èƒ½è¿”å›ç©º
}
```

* è¡¨ç¤ºâ€œå¯èƒ½æœ‰å€¼ï¼Œä¹Ÿå¯èƒ½æ²¡æœ‰å€¼â€ã€‚
* æ›¿ä»£ `NULL`ã€é”™è¯¯è¿”å›ç ï¼Œæ›´å®‰å…¨ã€‚
* é¢è¯•æ—¶å¸¸è¢«é—®ï¼šç›¸æ¯”æŒ‡é’ˆã€`std::variant`ï¼Œæœ‰ä»€ä¹ˆä¸åŒï¼Ÿ

---

### 8. **`std::variant<Ts...>`**

```cpp
std::variant<int, std::string> v;
v = 42;
v = "hello";
```

* ç±»å‹å®‰å…¨çš„è”åˆä½“ï¼ˆä»£æ›¿ `union`ï¼‰ã€‚
* é…åˆ `std::visit` ä½¿ç”¨ï¼Œå¼ºåˆ¶å¤„ç†æ‰€æœ‰ç±»å‹åˆ†æ”¯ã€‚
* é¢è¯•è€ƒç‚¹ï¼šæ€ä¹ˆé¿å… `bad_variant_access`ã€‚

---

### 9. **`std::any`**

```cpp
std::any a = 42;
a = std::string("hi");
```

* å¯å­˜æ”¾ä»»æ„ç±»å‹ï¼Œè¿è¡Œæ—¶ç±»å‹å®‰å…¨æ£€æŸ¥ã€‚
* ç±»ä¼¼â€œç±»å‹æ“¦é™¤â€å®¹å™¨ï¼Œä½†æ¯” `void*` å®‰å…¨ã€‚
* å¸¸è€ƒï¼š`any_cast` å’Œ `dynamic_cast` çš„åŒºåˆ«ã€‚

---

### 10. **`std::string_view`**

```cpp
void print(std::string_view s) {
    std::cout << s << "\n";
}
```

* **è½»é‡çº§åªè¯»å­—ç¬¦ä¸²è§†å›¾**ï¼Œä¸æ‹·è´æ•°æ®ã€‚
* åœ¨å¤§è§„æ¨¡å­—ç¬¦ä¸²å¤„ç†ï¼ˆæ—¥å¿—ã€è§£æå™¨ï¼‰é‡Œæ˜¾è‘—æå‡æ€§èƒ½ã€‚
* é¢è¯•å¸¸è€ƒï¼šç”Ÿå‘½å‘¨æœŸé™·é˜±ï¼ˆä¸èƒ½è¿”å›ä¸´æ—¶ `string` çš„ viewï¼‰ã€‚

---

### 11. **`std::filesystem`**

```cpp
namespace fs = std::filesystem;
for (auto& p : fs::directory_iterator(".")) {
    std::cout << p.path() << "\n";
}
```

* æ–‡ä»¶ç³»ç»Ÿåº“ï¼ˆéå†ç›®å½•ã€æ“ä½œæ–‡ä»¶è·¯å¾„ã€æ–‡ä»¶çŠ¶æ€æ£€æŸ¥ï¼‰ã€‚
* ä»¥å‰è¦é  Boostï¼Œç°åœ¨æ ‡å‡†åŒ–äº†ã€‚
* å®æˆ˜é‡Œç»å¸¸ç”¨æ¥åšé…ç½®ã€æ—¥å¿—ã€å¤‡ä»½ã€‚

---

---

# ğŸ”¹ ä¸‰ã€å¹¶å‘ä¸å†…å­˜æ¨¡å‹

### 12. **`std::shared_mutex`**

```cpp
std::shared_mutex m;
void read() {
    std::shared_lock lock(m); // è¯»å…±äº«é”
}
void write() {
    std::unique_lock lock(m); // å†™ç‹¬å é”
}
```

* å¤šè¯»å•å†™é”ï¼Œæé«˜è¯»å¯†é›†åœºæ™¯æ€§èƒ½ã€‚
* é¢è¯•ä¼šé—®ï¼šå’Œ `std::mutex` çš„åŒºåˆ«ï¼Ÿä»€ä¹ˆæ—¶å€™ç”¨ï¼Ÿ

---

### 13. **`std::scoped_lock`**

```cpp
std::mutex m1, m2;
{
    std::scoped_lock lock(m1, m2); // è‡ªåŠ¨é¿å…æ­»é”
}
```

* å¯ä»¥ä¸€æ¬¡æ€§é”å¤šä¸ªäº’æ–¥é‡ï¼Œé¿å…æ­»é”ã€‚
* æ¯” `std::lock_guard` æ›´å¼ºã€‚

---

### 14. **å¹¶è¡Œç®—æ³•ï¼ˆParallel STLï¼‰**

```cpp
#include <execution>
std::vector<int> v(1000);
std::sort(std::execution::par, v.begin(), v.end());
```

* STL ç®—æ³•å¯ä»¥ç›´æ¥å¹¶è¡Œæ‰§è¡Œã€‚
* ç®€åŒ–äº†å¤šçº¿ç¨‹è®¡ç®—ä»£ç ã€‚

---

---

# ğŸ”¹ å››ã€å…¶ä»–å®ç”¨æ”¹è¿›

### 15. **æŠ˜å è¡¨è¾¾å¼ï¼ˆFold Expressionsï¼‰**

```cpp
template<typename... Args>
auto sum(Args... args) {
    return (args + ...); // C++17 æŠ˜å è¡¨è¾¾å¼
}
```

* æŠŠå¯å˜å‚æ•°å±•å¼€æˆä¸€ä¸ªè¿ç®—å¼ï¼Œå†™æ¨¡æ¿æ—¶éå¸¸ç®€æ´ã€‚
* é¢è¯•é«˜é¢‘ï¼šå¦‚ä½•å®ç° `sum(1,2,3,4)=10`ã€‚

---

### 16. **ç±»æ¨¡æ¿å®å‚æ¨å¯¼ï¼ˆCTADï¼‰**

```cpp
std::pair p(1, 2.0); // è‡ªåŠ¨æ¨å¯¼ä¸º std::pair<int, double>
```

* ä¸ç”¨å†å†™ `<int,double>`ï¼Œç¼–è¯‘å™¨è‡ªåŠ¨æ¨å¯¼ã€‚
* STL å®¹å™¨ï¼ˆ`vector`, `map`ï¼‰ä¹Ÿèƒ½å°‘å†™æ¨¡æ¿å‚æ•°ã€‚

---

### 17. **`std::byte`**

```cpp
std::byte b{0x1F};
```

* æä¾›ä¸€ç§ä¸å’Œ `char`/`unsigned char` æ··æ·†çš„å­—èŠ‚ç±»å‹ã€‚
* ç”¨äºåº•å±‚å†…å­˜æ“ä½œï¼Œæ›´æ¸…æ™°ã€‚

---

---

# ğŸ”¹ äº”ã€é¢è¯•æœ€å¸¸é—® Top 5

å¦‚æœä½ æ—¶é—´æœ‰é™ï¼Œå»ºè®® **é‡ç‚¹æŒæ¡**ï¼š

1. **ç»“æ„åŒ–ç»‘å®š**ï¼ˆstructured bindingsï¼‰
2. **`if constexpr`**
3. **`std::optional` / `std::variant` / `std::any`**ï¼ˆä¸€å¥—ï¼‰
4. **`std::string_view`**
5. **æŠ˜å è¡¨è¾¾å¼**ï¼ˆæ¨¡æ¿ + å¯å˜å‚æ•°ï¼‰

è¿™å‡ ä¸ªå‡ ä¹æ˜¯ C++17 çš„â€œæ‹›ç‰Œç‰¹æ€§â€ï¼Œé¢è¯•å®˜éå¸¸å–œæ¬¢è€ƒã€‚

---

è¦ä¸è¦æˆ‘å¸®ä½ åšä¸€ä¸ª **å­¦ä¹ è·¯çº¿å›¾**ï¼ˆæ¯”å¦‚ï¼šå…ˆå­¦ C++11 çš„æ™ºèƒ½æŒ‡é’ˆ â†’ å†å­¦ C++14 æ³›å‹ lambda â†’ å†è¿›é˜¶åˆ° C++17 çš„ variant/optionalï¼‰ï¼Œè¿™æ ·å¯ä»¥å¾ªåºæ¸è¿›åœ°æŒæ¡ï¼Ÿ
