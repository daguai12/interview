### `add_dependencies` 的核心思想

想象一下做蛋糕的步骤：

1.  **烤蛋糕胚 (任务A)**
2.  **给蛋糕抹奶油 (任务B)**

你绝对不可能在烤好蛋糕胚**之前**就去抹奶油。任务B**依赖于**任务A的完成。

在 CMake 中，`add_dependencies` 就是用来定义这种**任务先后顺序**的命令。它告诉 CMake：“嘿，在开始处理目标B之前，你必须确保目标A已经彻彻底底地完成了。”

它建立的是**目标与目标之间**的依赖关系，不关心文件级别的细节，只关心整个任务的完成顺序。

-----

### 案例：一个程序生成代码，另一个程序使用它

这是最能体现 `add_dependencies` 用处的经典场景。我们将创建两个小程序：

1.  **`generate_file`**: 一个C++程序，它的唯一作用是运行起来后，创建一个名为 `message.h` 的头文件。
2.  **`say_hello`**: 另一个C++程序，它会 `#include "message.h"` 并打印里面的内容。

**显而易见**：我们必须先成功编译并**运行** `generate_file`，生成 `message.h` 之后，才能开始**编译** `say_hello`。否则，编译器会因为找不到 `message.h` 而报错。

`add_dependencies` 就是我们实现这个正确顺序的“遥控器”。

#### 第1步：创建项目文件

在你的项目文件夹中，创建以下三个文件：

**1. `generate_file.cpp`**
这个程序的功能就是用 C++ 的文件流，在它被执行的目录下创建一个头文件。

```cpp
// generate_file.cpp
#include <fstream>

int main() {
    std::ofstream header_file("message.h");
    if (header_file.is_open()) {
        header_file << "// This file was generated by the generate_file program\n";
        header_file << "#pragma once\n";
        header_file << "#include <string>\n";
        header_file << "const std::string SECRET_MESSAGE = \"Hello from a generated file!\";\n";
        header_file.close();
    }
    return 0;
}
```

**2. `say_hello.cpp`**
这个程序会包含上面即将被创建的 `message.h` 文件。

```cpp
// say_hello.cpp
#include <iostream>
#include "message.h" // 关键：依赖于那个被生成的文件

int main() {
    std::cout << "The main application says:" << std::endl;
    std::cout << SECRET_MESSAGE << std::endl;
    return 0;
}
```

**3. `CMakeLists.txt`**
这是我们的“总指挥”，它将使用 `add_dependencies` 来编排整个构建流程。

```cmake
cmake_minimum_required(VERSION 3.10)
project(DependenciesExample)

# --- 阶段 1: 定义我们的两个程序 ---

# 目标A: 定义那个用来生成文件的工具程序
add_executable(generate_file generate_file.cpp)

# 目标B: 定义我们的主程序
add_executable(say_hello say_hello.cpp)


# --- 阶段 2: 告诉 CMake 如何运行工具程序 ---

# 我们用 add_custom_target 创建一个“动作”，这个动作就是去运行 generate_file
# 注意：这个命令会在构建目录（比如 build/）下运行
add_custom_target(
  run_generator_action  # 给这个“动作”起个名字
  # COMMAND $<TARGET_FILE:generate_file> 是一个特殊的语法，
  # 它会获取 generate_file 编译后的可执行文件路径
  COMMAND $<TARGET_FILE:generate_file>
  COMMENT "Running code generator to create message.h"
)


# --- 阶段 3: 使用 add_dependencies 设置依赖关系 (!!本案例的核心!!) ---

# 告诉 CMake：say_hello 这个目标，依赖于 run_generator_action 这个目标的完成。
add_dependencies(say_hello run_generator_action)


# --- 阶段 4: 告知编译器去哪里找头文件 ---

# 因为 message.h 是在构建目录下生成的，所以需要将构建目录添加到
# say_hello 的头文件搜索路径中
target_include_directories(say_hello PRIVATE ${CMAKE_CURRENT_BINARY_DIR})
```

#### 第2步：分析 `CMakeLists.txt` 的魔法

1.  我们定义了两个普通的可执行目标：`generate_file` 和 `say_hello`。
2.  我们创建了一个自定义目标 `run_generator_action`。它的唯一工作就是在命令行里执行我们刚刚编译好的 `generate_file` 程序。
3.  **`add_dependencies(say_hello run_generator_action)`** 是最关键的一行。它建立了一条规则：
      * 当 CMake 准备构建 `say_hello` 时，它会检查其依赖项。
      * 它发现 `say_hello` 依赖于 `run_generator_action`。
      * 于是，CMake 会**暂停**构建 `say_hello`，转而去处理 `run_generator_action`。
      * CMake 发现 `run_generator_action` 需要运行 `generate_file` 这个程序，而这个程序还没被编译。
      * 因此，CMake 会先去**编译 `generate_file.cpp`**，生成 `generate_file` 可执行文件。
      * 编译成功后，CMake 回来**执行 `run_generator_action`** 的 `COMMAND`，也就是运行 `./generate_file`，此时 `message.h` 文件就被创建出来了。
      * `run_generator_action` 任务完成。
      * 现在，CMake 终于可以**回头继续构建 `say_hello`** 了。当它编译 `say_hello.cpp` 时，`#include "message.h"` 可以成功找到文件，整个项目构建成功！

#### 第3步：构建并运行

```bash
# 1. 创建并进入构建目录
mkdir build
cd build

# 2. 生成构建系统
cmake ..

# 3. 执行构建
cmake --build .
```

在构建输出中，你会清晰地看到这个执行顺序：首先编译 `generate_file`，然后运行 `run_generator_action`，最后才编译 `say_hello`。

#### 第4步：运行你的程序

构建成功后，在 `build` 文件夹里会有一个可执行文件 `say_hello`。运行它：

```bash
# 在 build 目录下执行
./say_hello
```

**输出结果：**

```
The main application says:
Hello from a generated file!
```

### 关键 takeaway

> `add_dependencies` 是一个简单而强大的工具，它不关心文件内容或链接细节，只负责**保证一个目标的构建和执行过程，在另一个目标开始构建之前，已经全部完成**。它是编排复杂构建顺序的“交通警察”。