#  一
好的，完全没问题！我们接着刚才的简单案例，来看看 `ALL` 和 `DEPENDS` 这两个“高级参数”是如何让 `add_custom_target` 变得更强大的。

这两个参数解决的是“**什么时候**”执行我们的自定义目标的问题。

1.  **`ALL`** - 解决 “**要不要自动执行？**”
2.  **`DEPENDS`** - 解决 “**执行前需要先完成什么？**”

-----

### 案例一：`ALL` 参数 - 让它自动运行

还记得我们之前的 `say_hello` 目标吗？每次都需要我们手动输入 `cmake --build . --target say_hello` 才能运行，有点麻烦。如果我们希望每次编译项目时，它都能自动执行，就像一个“构建小彩蛋”一样，那该怎么办呢？

这时候 `ALL` 就派上用场了。

#### 1\. "之前" 的 `CMakeLists.txt` (需要手动执行)

```cmake
cmake_minimum_required(VERSION 3.10)
project(AllExample)

# 一个普通的可执行文件目标，代表我们项目的主程序
add_executable(my_app main.cpp)

# 自定义目标：每次构建都打印当前 Git 分支和 Commit 信息
# 注意：这里还没有 ALL
add_custom_target(git_version_info
  COMMAND git log -1 --pretty=format:"Building from Git commit: %h on branch %d"
  COMMAND ${CMAKE_COMMAND} -E echo "" # 只是为了换行好看
  COMMENT "Fetching Git version info..."
  VERBATIM  # 推荐加上，确保命令参数被正确处理
)
```

*(为了运行这个例子，请确保你的项目文件夹是一个 git 仓库。如果没有，只需运行 `git init` 和 `git commit --allow-empty -m "Initial commit"` 即可。并创建一个空的 `main.cpp` 文件。)*

**如何运行：**

```bash
# 生成构建文件
mkdir build && cd build
cmake ..

# 1. 只构建主程序
cmake --build . 
# 你会发现，只会编译 my_app，根本不会执行 git_version_info

# 2. 必须手动指定目标名
cmake --build . --target git_version_info
# 现在，"Fetching Git version info..." 的信息才被打印出来
```

#### 2\. "之后" 的 `CMakeLists.txt` (使用 `ALL` 自动执行)

我们只改动一个地方：在 `add_custom_target` 的名字后面加上 `ALL`。

```cmake
cmake_minimum_required(VERSION 3.10)
project(AllExample)

add_executable(my_app main.cpp)

# 唯一的区别在这里！添加了 ALL 关键字
add_custom_target(git_version_info ALL
  COMMAND git log -1 --pretty=format:"Building from Git commit: %h on branch %d"
  COMMAND ${CMAKE_COMMAND} -E echo ""
  COMMENT "Fetching Git version info..."
  VERBATIM
)
```

**如何运行：**

```bash
# （建议先删除 build 目录，重新来过）
# rm -rf build && mkdir build && cd build
# cmake ..

# 只需执行默认构建命令
cmake --build . 
```

**你会看到什么？**
这次的输出会不一样！你会先看到 `Fetching Git version info...` 和相应的 Git 信息被打印出来，然后才会看到编译 `my_app` 的过程。

```
[ 50%] Fetching Git version info...
Building from Git commit: a1b2c3d on branch (HEAD, main)
[ 50%] Built target git_version_info
[100%] Building CXX object CMakeFiles/my_app.dir/main.cpp.o
[100%] Linking CXX executable my_app
[100%] Built target my_app
```

**小结 `ALL`:**

> **不加 `ALL`**：目标是个“懒人”，喊它名字（`--target <name>`）它才动。
> **加上 `ALL`**：目标是个“劳模”，每次一开工（默认构建），它就主动干活。

-----

### 案例二：`DEPENDS` 参数 - 保证正确的执行顺序

假设我们有两个任务：

1.  **任务A (`create_dir`)**: 创建一个用于存放配置文件的 `config` 文件夹。
2.  **任务B (`copy_config`)**: 把一个 `config.txt` 文件复制到这个 `config` 文件夹里。

显而易见，**任务A必须在任务B之前完成**。如果顺序反了，复制文件时文件夹还不存在，就会报错。`DEPENDS` 就是用来保证这个顺序的。

#### 1\. 准备工作

在你的项目根目录（`CMakeLists.txt` 旁边）创建一个名为 `config.txt` 的文件，里面随便写点东西，比如 `setting=true`。

#### 2\. "错误" 的 `CMakeLists.txt` (没有 `DEPENDS`)

```cmake
cmake_minimum_required(VERSION 3.10)
project(DependsExample)

# 任务A: 创建目录
add_custom_target(create_dir ALL
    COMMAND ${CMAKE_COMMAND} -E make_directory "${CMAKE_CURRENT_BINARY_DIR}/config"
    COMMENT "Creating config directory..."
)

# 任务B: 复制文件
add_custom_target(copy_config ALL
    COMMAND ${CMAKE_COMMAND} -E copy
        "${CMAKE_SOURCE_DIR}/config.txt"
        "${CMAKE_CURRENT_BINARY_DIR}/config/"
    COMMENT "Copying config.txt..."
)
```

**问题在哪里？**
我们虽然定义了两个目标，但没有告诉 CMake 它们之间有任何关系。当并行构建时（例如 `make -j4`），CMake 可能会试图同时执行它们，这很可能导致 `copy_config` 因为 `config` 目录不存在而失败。

#### 3\. "正确" 的 `CMakeLists.txt` (使用 `DEPENDS`)

我们来告诉 `copy_config`：你必须**依赖于** `create_dir` 的完成。

```cmake
cmake_minimum_required(VERSION 3.10)
project(DependsExample)

# 任务A: 创建目录 (保持不变)
add_custom_target(create_dir ALL
    COMMAND ${CMAKE_COMMAND} -E make_directory "${CMAKE_CURRENT_BINARY_DIR}/config"
    COMMENT "Creating config directory..."
)

# 任务B: 复制文件，并声明其依赖
add_custom_target(copy_config ALL
    COMMAND ${CMAKE_COMMAND} -E copy
        "${CMAKE_SOURCE_DIR}/config.txt"
        "${CMAKE_CURRENT_BINARY_DIR}/config/"
    COMMENT "Copying config.txt..."
    
    # 关键在这里！告诉 CMake，这个目标依赖于 create_dir
    DEPENDS create_dir
)
```

**如何运行：**

```bash
# （建议先删除 build 目录，重新来过）
# rm -rf build && mkdir build && cd build
# cmake ..

# 执行默认构建
cmake --build .
```

**你会看到什么？**
CMake 现在知道了它们俩的“辈分”。它会分析依赖关系，并确保 `create_dir` 总是比 `copy_config` 先执行。输出的顺序将永远是正确的：

```
[ 50%] Creating config directory...
[ 50%] Built target create_dir
[100%] Copying config.txt...
[100%] Built target copy_config 
```

这样，`config.txt` 总能被成功地复制到 `build/config/` 目录下，绝不会出错。

**小结 `DEPENDS`:**

> `DEPENDS` 就像是在任务之间连线，告诉 CMake：“**嘿，必须等线那头的任务干完了，我这个才能开工！**” 它定义了任务的先后顺序。


# 二

好的，这是一个非常常见的需求。`add_custom_target` 非常适合用来执行各种脚本，比如代码生成、资源打包、或者部署任务。

我们就以一个最典型的场景为例：**用一个 Python 脚本来生成一个包含构建信息的 C++ 头文件** (例如：构建时间、构建主机名等)。主程序将包含这个头文件，并把这些信息打印出来。

这个案例将清晰地展示 `add_custom_target` 如何与项目的编译流程结合起来。

-----

### 场景：运行Python脚本生成 `build_info.h`

**目标：**

1.  创建一个 Python 脚本 `generate_header.py`。
2.  创建一个 `add_custom_target` 来运行这个脚本。
3.  脚本会生成一个 `build_info.h` 文件。
4.  我们的 C++ 程序 `my_app` 会包含并使用这个头文件。

#### 第1步：创建项目文件

首先，在你的项目文件夹中创建以下三个文件：

**1. `generate_header.py` (Python 脚本)**
这个脚本获取当前时间，并将其写入一个 C++ 头文件。

```python
# generate_header.py
import datetime
import sys

# 获取输出文件的路径，这是从 CMake 传递过来的第一个参数
output_filename = sys.argv[1] 

# 获取当前时间
now = datetime.datetime.now()
timestamp = now.strftime("%Y-%m-%d %H:%M:%S")

# C++ 头文件的内容
header_content = f"""
#ifndef BUILD_INFO_H
#define BUILD_INFO_H

#include <string>

// 定义一个包含构建时间的字符串常量
const std::string BUILD_TIMESTAMP = "{timestamp}";

#endif // BUILD_INFO_H
"""

# 将内容写入文件
with open(output_filename, "w") as f:
    f.write(header_content)

print(f"Generated {output_filename} with timestamp: {timestamp}")
```

**2. `main.cpp` (C++ 主程序)**
这个程序很简单，就是包含我们即将生成的头文件，并打印里面的信息。

```cpp
// main.cpp
#include <iostream>
#include "build_info.h" // <-- 关键：包含由脚本生成的文件

int main() {
    std::cout << "Hello from my application!" << std::endl;
    std::cout << "This application was built at: " << BUILD_TIMESTAMP << std::endl;
    return 0;
}
```

**3. `CMakeLists.txt` (构建脚本)**
这是我们的核心，它将把所有东西串联起来。

```cmake
cmake_minimum_required(VERSION 3.10)
project(RunScriptExample)

# 步骤1: 找到 Python 解释器，这是跨平台的最好方式
find_package(PythonInterp REQUIRED)

# 步骤2: 定义我们的主程序目标
add_executable(my_app main.cpp)

# 步骤3: 定义运行脚本的自定义目标
add_custom_target(
  generate_header_target ALL  # 使用 ALL 让它在默认构建时自动运行
  
  # 定义要执行的命令
  # 格式: python脚本路径 输出文件路径
  COMMAND ${PYTHON_EXECUTABLE} ${CMAKE_CURRENT_SOURCE_DIR}/generate_header.py
          "${CMAKE_CURRENT_BINARY_DIR}/build_info.h"
          
  # 设置工作目录，确保脚本知道在哪里生成文件
  WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}
  
  COMMENT "Running Python script to generate build_info.h..."
  VERBATIM
)

# 步骤4: 建立依赖关系 (!!最关键的一步!!)
# 告诉 CMake：在编译 my_app 之前，必须先完成 generate_header_target 目标
add_dependencies(my_app generate_header_target)

# 步骤5: 告知编译器去哪里寻找生成的头文件
# 因为 build_info.h 生成在构建目录，我们需要把这个目录添加到头文件搜索路径中
target_include_directories(my_app PRIVATE ${CMAKE_CURRENT_BINARY_DIR})

```

#### 第2步：分析 `CMakeLists.txt` 的关键点

  * **`find_package(PythonInterp REQUIRED)`**: 帮我们找到系统里的 `python` 命令，并存放在 `PYTHON_EXECUTABLE` 变量中。这样就不需要硬编码 `python` 或 `python3`，更具移植性。
  * **`add_custom_target(generate_header_target ...)`**:
      * 我们给这个“运行脚本”的动作起名叫 `generate_header_target`。
      * `COMMAND` 部分是核心，它调用 Python 解释器，后面跟着脚本文件和我们想传递给脚本的参数（这里是输出文件的完整路径）。
      * `${CMAKE_CURRENT_BINARY_DIR}/build_info.h` 表示我们希望在构建目录（例如 `build/`）下生成 `build_info.h`，而不是污染源码目录。
  * **`add_dependencies(my_app generate_header_target)`**: 这是魔法发生的地方。它建立了明确的执行顺序。CMake看到这条命令后就会明白：“哦，`my_app` 依赖 `generate_header_target`。所以我必须先运行Python脚本，等它成功执行完毕后，才能开始编译 `main.cpp`。” 如果没有这一行，编译 `main.cpp` 时就会因为找不到 `build_info.h` 而失败。
  * **`target_include_directories(...)`**: 仅仅生成了文件还不够，我们还得告诉编译器去哪里找它。这行代码就是告诉编译器：“编译 `my_app` 时，除了默认路径，也请到构建目录（`${CMAKE_CURRENT_BINARY_DIR}`）里找找头文件。”

#### 第3步：构建并运行

现在，你的文件夹里应该有这三个文件。打开终端，开始构建：

```bash
# 1. 创建构建目录并进入
mkdir build
cd build

# 2. 运行 CMake 生成构建系统
cmake ..

# 3. 执行构建
# 因为我们用了 ALL，所以直接构建就行，不需要指定 target
cmake --build .
```

在构建过程中，你会看到类似下面的输出：

```
[ 33%] Running Python script to generate build_info.h...
Generated /path/to/your/project/build/build_info.h with timestamp: 2025-09-30 10:46:50
[ 33%] Built target generate_header_target
[ 66%] Building CXX object CMakeFiles/my_app.dir/main.cpp.o
[100%] Linking CXX executable my_app
[100%] Built target my_app
```

可以看到，CMake **先运行了我们的Python脚本**，然后才开始编译 `main.cpp`。

#### 第4步：运行你的程序

构建成功后，在 `build` 文件夹里会有一个可执行文件 `my_app`。运行它：

```bash
# 在 build 目录下执行
./my_app
```

**输出结果：**

```
Hello from my application!
This application was built at: 2025-09-30 10:46:50
```

成功了！程序打印出了由Python脚本在构建时动态生成的时间戳。如果你重新运行 `cmake --build .`，这个时间戳还会更新。

# 三
好的，当然可以。下面我们来看一个使用 `add_custom_target` 运行 Bash 脚本的案例。

这个场景也非常实用：在编译项目的同时，运行一个脚本来**打包资源文件**。假设我们有一个 `assets` 目录，里面存放了一些文本资源，我们希望在构建时自动将它们打包成一个 `assets.tar.gz` 压缩文件。

-----

### 场景：运行Bash脚本打包资源文件

**目标：**

1.  创建一个 `assets` 目录和一些资源文件。
2.  创建一个 Bash 脚本 `package_assets.sh`，用来执行打包命令。
3.  创建一个 `add_custom_target` 来运行这个脚本。
4.  脚本会在构建目录中生成一个 `assets.tar.gz` 文件。

#### 第1步：创建项目文件

首先，在你的项目文件夹中创建如下的目录和文件结构：

```
.
├── assets/
│   ├── asset1.txt
│   └── asset2.txt
├── package_assets.sh   <-- 我们的 Bash 脚本
├── main.cpp
└── CMakeLists.txt
```

**1. `assets/asset1.txt` 和 `assets/asset2.txt`**
随便在里面写点内容即可。

  * `asset1.txt`: `Hello from asset 1.`
  * `asset2.txt`: `This is asset 2.`

**2. `package_assets.sh` (Bash 脚本)**
这个脚本接收两个参数：资源所在的目录和输出的压缩包路径。它使用 `tar` 命令来完成压缩。

```bash
#!/bin/bash

# package_assets.sh

# 立即退出如果任何命令失败
set -e

# 从 CMake 接收参数
ASSETS_SOURCE_DIR=$1
OUTPUT_ARCHIVE_PATH=$2

echo "--- Running Asset Packaging Script ---"
echo "Source directory: ${ASSETS_SOURCE_DIR}"
echo "Output archive: ${OUTPUT_ARCHIVE_PATH}"

# 使用 tar 命令创建 .tar.gz 压缩包
# -c: create an archive
# -z: compress with gzip
# -f: specify the output file
# -C: change to the specified directory before performing any operations
tar -czf "${OUTPUT_ARCHIVE_PATH}" -C "${ASSETS_SOURCE_DIR}" .

echo "Successfully created ${OUTPUT_ARCHIVE_PATH}"
echo "------------------------------------"
```

> **重要提示：** 在 Linux 或 macOS 系统中，你需要给这个脚本添加可执行权限。在终端中运行：
>
> ```bash
> chmod +x package_assets.sh
> ```

**3. `main.cpp` (C++ 主程序)**
这个程序与打包过程无关，只是用来模拟一个真实的项目构建。

```cpp
// main.cpp
#include <iostream>

int main() {
    std::cout << "Application finished building." << std::endl;
    std::cout << "Check the build directory for the 'assets.tar.gz' file." << std::endl;
    return 0;
}
```

**4. `CMakeLists.txt` (构建脚本)**
这里我们将设置 `add_custom_target` 来调用我们的 Bash 脚本。

```cmake
cmake_minimum_required(VERSION 3.10)
project(RunBashScriptExample)

# 步骤1: 找到 Bash 可执行文件
find_program(BASH_EXECUTABLE bash REQUIRED)

# 步骤2: 定义一个普通的可执行文件目标
add_executable(my_app main.cpp)

# 步骤3: 定义运行 Bash 脚本的自定义目标
add_custom_target(
  package_assets_target ALL  # 使用 ALL 确保它自动运行
  
  # 定义要执行的命令
  # 格式: bash脚本路径 [参数1] [参数2] ...
  COMMAND ${BASH_EXECUTABLE} ${CMAKE_CURRENT_SOURCE_DIR}/package_assets.sh
          "${CMAKE_CURRENT_SOURCE_DIR}/assets"   # 参数1: 资源目录
          "${CMAKE_CURRENT_BINARY_DIR}/assets.tar.gz" # 参数2: 输出文件路径
          
  COMMENT "Packaging assets into assets.tar.gz..."
  VERBATIM
)
```

#### 第2步：分析 `CMakeLists.txt`

  * **`find_program(BASH_EXECUTABLE bash REQUIRED)`**: CMake 会在系统中寻找 `bash` 程序，并将其路径存放在 `BASH_EXECUTABLE` 变量中。
  * **`add_custom_target(package_assets_target ...)`**:
      * 我们创建了一个名为 `package_assets_target` 的目标。
      * `ALL` 关键字确保了每次我们运行 `cmake --build .` 时，这个目标都会被执行。
      * `COMMAND` 是核心部分。它调用 `bash` 来执行我们的脚本，并向脚本传递了两个参数：
        1.  `"${CMAKE_CURRENT_SOURCE_DIR}/assets"`：资源文件所在的源目录。
        2.  `"${CMAKE_CURRENT_BINARY_DIR}/assets.tar.gz"`：我们希望生成的压缩文件的完整路径。
  * **依赖关系呢？** 在这个例子中，`my_app` 的编译**不依赖于** `assets.tar.gz` 文件。它们是两个独立的构建任务。因此，我们不需要使用 `add_dependencies`。`ALL` 关键字已经足以确保脚本在每次构建时都会运行。

#### 第3步：构建并运行

确保所有文件都已创建，并且 `package_assets.sh` 已经拥有可执行权限。

```bash
# 1. 创建并进入构建目录
mkdir build
cd build

# 2. 生成构建系统
cmake ..

# 3. 执行构建
cmake --build .
```

在构建过程中，你会看到脚本打印的信息：

```
[ 50%] Packaging assets into assets.tar.gz...
--- Running Asset Packaging Script ---
Source directory: /path/to/your/project/assets
Output archive: /path/to/your/project/build/assets.tar.gz
Successfully created /path/to/your/project/build/assets.tar.gz
------------------------------------
[ 50%] Built target package_assets_target
[100%] Building CXX object CMakeFiles/my_app.dir/main.cpp.o
[100%] Linking CXX executable my_app
[100%] Built target my_app
```

#### 第4步：验证结果

构建完成后，检查你的 `build` 目录：

```bash
# 在 build 目录下
ls
```

你会看到 `assets.tar.gz` 文件已经成功生成了！

你还可以用 `tar` 命令来查看压缩包的内容，确认我们的资源文件确实被打包进去了：

```bash
# 在 build 目录下
tar -tf assets.tar.gz
```

输出应该是：

```
./
./asset2.txt
./asset1.txt
```

这个案例完美地展示了如何将一个外部的 Bash 脚本集成到 CMake 构建流程中，以完成编译代码之外的自动化任务。