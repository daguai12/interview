### 1\. 条件码实战 (以 `addq` 和 `subq` 为例)

我们先不用 `CMP` 或 `TEST`，而是用一个普通的算术指令来看看这四个标志位是如何被设置的。为了方便观察，我们使用 8 位寄存器（大小范围：无符号 0-255，有符号 -128-127）。

#### 案例 1.1: 设置零标志 (`ZF`) 和进位标志 (`CF`)

  * **场景**: 计算 `-5 + 5`
  * **指令序列**:
    ```s
    movb $-5, %al    # %al = -5 (十六进制 0xFB)
    addb $5, %al     # 在 %al 中加上 5 (十六进制 0x05)
    ```
  * **计算**:
      * `-5 + 5 = 0`。
      * 十六进制运算：`0xFB + 0x05 = 0x100`。
  * **结果分析**:
      * **结果值**: 运算结果存入 8 位的 `%al` 中，只能保留低 8 位，所以 `%al` 变为 `0x00`。
      * **`ZF` (零标志)**: 因为结果是 `0`，所以 **`ZF = 1`**。
      * **`SF` (符号标志)**: 结果 `0` 不是负数，所以 **`SF = 0`**。
      * **`CF` (进位标志)**: `0xFB + 0x05` 的计算产生了向第 9 位的进位（`0x100`），所以 **`CF = 1`**。这表示发生了**无符号**溢出（作为无符号数 `251 + 5 = 256`，超出了 8 位范围）。
      * **`OF` (溢出标志)**: 源操作数一正一负，**有符号**运算永远不会溢出，所以 **`OF = 0`**。

#### 案例 1.2: 设置符号标志 (`SF`) 和溢出标志 (`OF`)

  * **场景**: 计算 `100 + 100` (在 8 位有符号数中)
  * **指令序列**:
    ```s
    movb $100, %al   # %al = 100 (0x64)
    addb $100, %al   # 再加上 100 (0x64)
    ```
  * **计算**:
      * `100 + 100 = 200`。
      * 十六进制运算：`0x64 + 0x64 = 0xC8`。
  * **结果分析**:
      * **结果值**: `%al` 变为 `0xC8`。
      * **`ZF`**: 结果不是 `0`，所以 **`ZF = 0`**。
      * **`SF`**: `0xC8` 的二进制是 `11001000`。最高位（符号位）是 `1`，所以它被解释为一个负数（`-56`），因此 **`SF = 1`**。
      * **`CF`**: `0x64 + 0x64` 没有产生向第 9 位的进位，所以 **`CF = 0`**。
      * **`OF` (溢出标志)**: 我们将两个正数 (`100` 和 `100`) 相加，但得到的结果 (`-56`) 却是一个负数。这正是**有符号溢出**的定义，所以 **`OF = 1`**。

-----

### 2\. `CMP` 指令案例 (用于算术比较)

**核心**: `CMP S1, S2` 计算 `S2 - S1`，然后根据**计算结果**设置标志位，但**不保存结果**。

  * **场景**: 比较寄存器 `%rax` 和 `%rbx` 的值。
      * 初始状态: `%rax = 1000`, `%rbx = 500`

#### 案例 2.1: `cmpq %rax, %rbx` (`rbx` 和 `rax` 比较)

  * **计算**: `500 - 1000 = -500`。
  * **结果分析**:
      * 结果 `-500` 不是 0，所以 `ZF = 0`。
      * 结果 `-500` 是负数，所以 `SF = 1`。
  * **后续跳转**: 一条 `jl` (Jump if Less) 指令会跳转，因为 `SF` 被设置了，表明 `S2 < S1`。
  * **寄存器状态**: `%rax` 和 `%rbx` 的值**完全没有改变**。

#### 案例 2.2: `cmpq %rax, %rax` (自己和自己比较)

  * **计算**: `1000 - 1000 = 0`。
  * **结果分析**:
      * 结果是 0，所以 **`ZF = 1`**。
  * **后续跳转**: 一条 `je` (Jump if Equal) 指令会跳转，因为 `ZF` 被设置了。

-----

### 3\. `TEST` 指令案例 (用于位测试)

**核心**: `TEST S1, S2` 计算 `S1 & S2` (按位与)，然后根据**计算结果**设置 `ZF` 和 `SF`，不保存结果。(`CF` 和 `OF` 会被清零)。

#### 案例 3.1: 检查一个数是否为 0 或负数 (常用技巧)

这是 `TEST` 最常见的用法。

  * **指令**: `testq %rax, %rax`
  * **场景 A: `%rax = 0`**
      * **计算**: `0 & 0 = 0`。
      * **结果分析**: 结果为 0，所以 **`ZF = 1`**。一条 `jz` (Jump if Zero) 指令会跳转。
  * **场景 B: `%rax = -10`**
      * **计算**: `-10 & -10 = -10`。
      * **结果分析**: 结果不为 0，所以 `ZF = 0`。结果为负，所以 **`SF = 1`**。一条 `js` (Jump if Sign) 指令会跳转。
  * **场景 C: `%rax = 10`**
      * **计算**: `10 & 10 = 10`。
      * **结果分析**: 结果不为 0 (`ZF=0`)，结果为正 (`SF=0`)。

#### 案例 3.2: 检查特定位是否为 1 (掩码)

  * **场景**: 检查 `%rax` 中的值是否为**奇数**。一个数是奇数，当且仅当它的最低位（第 0 位）是 1。
  * **初始状态**:
      * 情况 1: `%rax = 13` (二进制 `...00001101`)
      * 情况 2: `%rax = 12` (二进制 `...00001100`)
  * **指令**: `testq $1, %rax` (使用立即数 `1` 作为掩码)
  * **操作分析**:
      * **情况 1 (`%rax = 13`)**:
          * **计算**: `...00001101 & ...00000001 = ...00000001` (结果为 1)。
          * **结果分析**: 结果不为 0，所以 **`ZF = 0`**。
          * **后续跳转**: `jnz` (Jump if Not Zero) 指令会跳转，表明“是奇数”。
      * **情况 2 (`%rax = 12`)**:
          * **计算**: `...00001100 & ...00000001 = ...00000000` (结果为 0)。
          * **结果分析**: 结果为 0，所以 **`ZF = 1`**。
          * **后续跳转**: `jnz` 指令**不会**跳转，表明“不是奇数”。

### 总结

  * **算术指令 (`add`, `sub` 等)**: 执行计算，**改变**目的寄存器，**并**设置所有条件码。
  * **`CMP` 指令**: 像 `SUB` 一样计算，**不改变**任何寄存器，只为**算术比较** (`>`, `<`, `==`) 设置条件码。
  * **`TEST` 指令**: 像 `AND` 一样计算，**不改变**任何寄存器，只为**位测试**（检查是否为0，或特定位是否被设置）设置条件码。
