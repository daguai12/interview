您对这几种经典的CPU调度算法总结得非常出色和准确！这为我们理解现代操作系统的调度器打下了坚实的基础。

现在，我们来回答您的核心问题：**现代Linux使用的是什么CPU调度算法？**

答案是：**现代Linux不使用单一的、固定的调度算法，而是采用了一个高度模块化的“调度类（Scheduling Classes）”框架。** 对于不同的任务类型，会使用不同的调度策略。其中，**针对普通进程的默认调度器是“完全公平调度器”（Completely Fair Scheduler, CFS）。**

我们可以将Linux的调度系统理解为一个优先级链条，内核会按照从高到低的顺序检查每个调度类中是否有需要运行的进程。

**Linux主要的调度类（按优先级从高到低）：**

1.  **Deadline 调度类 (`SCHED_DEADLINE`)**：优先级最高。它基于 **Earliest Deadline First (EDF)** 算法，主要用于硬实时（Hard Real-Time）任务，比如工业控制、机器人等，保证任务在它的截止日期前必须完成。
2.  **Real-Time 调度类 (`SCHED_FIFO`, `SCHED_RR`)**：次高优先级，用于软实时（Soft Real-Time）任务。
    * `SCHED_FIFO`：这和您提到的 **FCFS（先来先服务）** 类似，但它是抢占式的。一个`FIFO`进程会一直运行，直到它主动放弃CPU、被阻塞或者被一个更高优先级的实时进程抢占。同优先级的`FIFO`进程之间不进行时间片轮转。
    * `SCHED_RR`：这正是您提到的 **时间片轮转（Round Robin）** 算法。它和`FIFO`基本一样，但增加了时间片限制。当一个`RR`进程用完它的时间片后，如果还有其他同优先级的`RR`进程在就绪队列中，它就会被放到队列末尾。
3.  **Fair 调度类 (`SCHED_NORMAL`, `SCHED_BATCH`, `SCHED_IDLE`)**：**这是所有普通用户进程使用的调度类，其核心算法就是CFS。**

---

### 深入理解核心：完全公平调度器 (CFS)

CFS 是从 Linux 2.6.23 内核版本开始引入的默认调度器，它的设计思想与您提到的所有传统算法都有很大不同。

**1. 核心目标：不是“时间片”，而是“公平”**

CFS 抛弃了传统的时间片（Time Slice）概念。它的核心目标是让每个进程都能获得**公平的CPU使用比例**。在一个理想化的、速度无限快的CPU上，如果有N个进程，那么每个进程在任何时间窗口内都应该获得 `1/N` 的CPU时间。

**2. 实现机制：虚拟运行时 (vruntime)**

为了实现这个“公平”的目标，CFS 引入了一个关键概念——`vruntime`（virtual runtime）。

* `vruntime` 记录了一个进程**累计的、经过加权的运行时间**。
* CFS 调度器**永远选择 `vruntime` 值最小的进程来运行**。
* 一个进程运行得越久，它的 `vruntime` 就会增长得越大。因此，之前运行得少的进程（`vruntime`小），自然就获得了下一次运行的机会。

**3. 数据结构：红黑树 (Red-Black Tree)**

为了能快速找到 `vruntime` 最小的进程，CFS 不使用传统的链式队列，而是使用**红黑树**来管理所有就绪的进程。红黑树的特性使得查找、插入和删除操作的时间复杂度都是 `O(log N)`，非常高效。`vruntime` 最小的进程永远位于树的最左侧节点。

**4. 如何兼顾不同优先级的进程？**

CFS 通过 `nice` 值（范围从-20到+19）来实现优先级。`nice` 值不是直接的优先级，而是作为计算 `vruntime` 增长速度的**权重**。

* `nice` 值越低（优先级越高），`vruntime` 增长得越慢。
* `nice` 值越高（优先级越低），`vruntime` 增长得越快。

这样一来，高优先级进程即使运行了一段时间，其 `vruntime` 也可能比一个刚被唤醒的低优先级进程要小，从而获得更多的运行机会，实现了“加权公平”。

### CFS 与您提到的经典算法的联系

* **与多级反馈队列 (MLFQ) 的对比**：
    CFS 实现了和 MLFQ 类似的目标——**动态地优待交互式进程（I/O密集型）**。一个交互式进程大部分时间在等待I/O（比如等待键盘输入），所以它的 `vruntime` 增长得很慢。一旦它被唤醒，它的 `vruntime` 会非常小，几乎立刻就会被CFS选中并运行，从而保证了极低的响应延迟。CFS 用一种更优雅、更连续的方式解决了这个问题，而不是像 MLFQ 那样设置多个离散的队列和复杂的升降级规则。

* **与高响应比优先 (HRRN) 的对比**：
    两者都考虑了等待时间。在CFS中，“等待”体现在 `vruntime` 没有增长。一个长时间等待的进程，其 `vruntime` 相对其他正在运行的进程会变得非常小，因此它被调度的“响应比”自然就提高了。

### 总结

| 调度类 (Scheduling Class) | 目标任务 | 核心调度算法/策略 | 与经典算法的关联 |
| :--- | :--- | :--- | :--- |
| **Deadline (`SCHED_DEADLINE`)** | 硬实时任务 | Earliest Deadline First (EDF) | 一种实时系统专用算法 |
| **Real-Time (`SCHED_RR`)** | 软实时任务 | 时间片轮转 (Round Robin) | **直接就是时间片轮转算法** |
| **Real-Time (`SCHED_FIFO`)** | 软实时任务 | 先来先服务 (First Come First Serve) | **抢占式的FCFS** |
| **Fair (`SCHED_NORMAL`)** | **所有普通进程** | **完全公平调度器 (CFS)** | **是MLFQ、HRRN等思想的现代化、更优的实现** |

所以，总的来说，现代Linux的CPU调度是一个**“组合拳”**：

> **通过一个分层的调度类框架，对高优先级的实时任务使用简单高效的 `FIFO` 和 `RR` 算法来保证确定性，而对海量的普通任务，则使用更先进的 `CFS` 算法来保证所有进程间的公平性以及对交互式任务的快速响应。**