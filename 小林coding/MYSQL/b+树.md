要理解这句话，我们需要从 **B树和B+树的结构差异** 入手，结合 **磁盘存储的特性**（尤其是“磁盘I/O效率取决于访问的节点数量”），逐步分析为什么B+树会更“矮胖”、磁盘I/O次数更少。


### 一、先明确核心差异：B树与B+树的节点存储内容
在解释“矮胖”和I/O次数之前，必须先明确两者最关键的结构区别：**节点中是否存放实际数据**。

#### 1. B树的节点：既存索引，又存数据
B树的每个节点（包括非叶子节点和叶子节点）中，**每个索引项都对应一条实际的记录数据**。  
例如：假设索引键是“用户ID”，B树的非叶子节点和叶子节点中，每个“用户ID”旁边都会直接存储该用户的详细数据（如姓名、年龄等）。  
这种结构导致B树的节点中，**数据占用了大量空间**，留给索引键的空间被压缩。


#### 2. B+树的节点：非叶子节点只存索引，叶子节点存数据
B+树的结构做了优化：  
- **非叶子节点**：仅存储索引键（如“用户ID”），不存储任何实际记录数据。  
- **叶子节点**：才存储索引键和对应的实际记录数据，且所有叶子节点通过链表连接（方便范围查询）。  
这种结构下，B+树的非叶子节点中，**空间全部用于存储索引键**，没有数据占用额外空间。  


### 二、为什么B+树的非叶子节点能存放更多索引？
磁盘存储中，数据是以“块”（Block）为单位读写的（例如常见的磁盘块大小为4KB、8KB）。数据库的索引树节点大小通常会设计为与磁盘块大小对齐（比如一个节点对应一个磁盘块），这样一次磁盘I/O就能完整读取一个节点。  

假设我们固定磁盘块大小为 **4KB（4096字节）**，对比B树和B+树的非叶子节点能存储的索引数量：  

| 场景                | B树非叶子节点                          | B+树非叶子节点                          |
|---------------------|---------------------------------------|---------------------------------------|
| 单个索引项的占用空间 | 索引键（如8字节）+ 数据（如100字节）= 108字节 | 仅索引键（如8字节）                    |
| 单个节点（4KB）能存储的索引数量 | 4096 ÷ 108 ≈ 37个索引                | 4096 ÷ 8 ≈ 512个索引                  |

显然，**相同节点大小下，B+树的非叶子节点能存储的索引数量远多于B树**（例子中是14倍差距）。  


### 三、为什么B+树更“矮胖”？
树的“高矮”由树的**高度**决定（从根节点到叶子节点的层数）。树的高度越低，结构越“矮胖”；高度越高，结构越“瘦高”。  

索引树的核心功能是通过索引快速定位数据，而树的高度取决于“需要多少层节点才能覆盖所有数据”。由于B+树的非叶子节点能存储更多索引，意味着：  
- 每一层节点能“覆盖”的索引范围更大（比如根节点一个索引项可以指向一个包含512个索引的子节点，而B树根节点一个索引项只能指向包含37个索引的子节点）；  
- 因此，在存储**相同数量的数据**时，B+树需要的层数（高度）更少。  

举例：假设总共有100万条数据  
- B树：每层节点最多存37个索引，树的高度约为 log₃₇(100万) ≈ 4层（37⁴ ≈ 187万）；  
- B+树：每层节点最多存512个索引，树的高度约为 log₅₁₂(100万) ≈ 2层（512² ≈ 262万）。  

显然，B+树的高度更低，结构更“矮胖”。


### 四、为什么磁盘I/O次数更少？
磁盘I/O的效率是数据库性能的核心瓶颈之一，而索引查询的磁盘I/O次数**等于从根节点到叶子节点需要访问的节点数量**（因为每个节点对应一次磁盘读取）。  

例如：  
- 查B树时，需要访问根节点→子节点→孙节点→叶子节点，共4次磁盘I/O；  
- 查B+树时，只需要访问根节点→叶子节点，共2次磁盘I/O。  

由于B+树更“矮胖”（高度低），查询时需要访问的节点数量更少，因此磁盘I/O次数自然更少，查询效率更高。


### 总结
B+树通过让非叶子节点“只存索引、不存数据”，在相同节点大小下容纳了更多索引，从而在相同数据量时树的高度更低（更“矮胖”）。而树的高度直接决定了查询时需要访问的节点数量，最终导致B+树的磁盘I/O次数比B树更少，查询性能更优。这也是为什么B+树成为关系型数据库（如MySQL）索引的主流选择。