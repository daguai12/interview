
面试官你好。

TCP连接中，一端断电和进程崩溃最核心的区别在于：**操作系统内核能否感知到这个异常，并介入处理。**

#### **1. 进程崩溃 (Process Crash)**

* **内核可知，会“优雅”断开**：
    进程崩溃时，操作系统能够感知到。因为TCP连接是由内核负责维护的，所以内核会接管并清理该进程相关的资源。这个清理过程包括**自动进行标准的TCP四次挥手**，向对端发送`FIN`报文，从而正常关闭连接。
* **结果**：对端会收到`FIN`，完成四次挥手，连接被明确关闭。

#### **2. 主机断电 (Host Crash)**

* **内核不知，是“突然”消失**：
    主机断电或宕机是物理层面的问题，操作系统和内核完全来不及反应，因此**不会发送任何报文（比如`FIN`）**给对端。
* **结果**：在对端看来，TCP连接依然处于`ESTABLISHED`状态，它并不知道对方已经消失了。这种连接也被称为“半开连接”（Half-Open Connection）。

这个“半开连接”的后续命运，取决于之后是否有数据交互：

* **情况A：双方一直没有数据交互**
    * 如果**没有**开启TCP Keepalive机制，这个连接将**永远处于`ESTABLISHED`状态**，直到应用层序重启。
    * 如果**开启了**TCP Keepalive机制，在长时间空闲后（Linux默认2小时），系统会发送探测包。由于对端无法响应，在几次尝试后，系统会判定连接死亡，并关闭这个连接。

* **情况B：存活的一方发送数据**
    存活方发送数据后，由于收不到对端的ACK，会触发**超时重传**机制。在多次重传仍然失败，并达到系统设定的最大阈值（由`tcp_retries2`参数决定）后，内核会判定连接失败，最终关闭这个TCP连接。

**总结一下：**

* **进程崩溃**：内核会处理，触发**四次挥手**，连接正常关闭。
* **主机断电**：内核无法处理，对端连接状态不变。连接的最终断开依赖于后续的**数据超时重传**或**TCP Keepalive探测**。