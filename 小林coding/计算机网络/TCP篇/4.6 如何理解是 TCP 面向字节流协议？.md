👌 我帮你整理成一个适合面试的简洁版答案，重点放在**TCP 为什么叫面向字节流**，以及**跟 UDP 的区别**，并顺带提到**粘包问题和解决思路**。

---

### 面试版回答

**1. TCP 是面向字节流，UDP 是面向报文，区别在于：**

* **UDP 面向报文**：应用层交给内核的一次 send，对应到网络上就是一个完整的 UDP 报文。接收端每次 recvfrom() 读到的就是一个完整报文，消息边界天然存在。
* **TCP 面向字节流**：应用层的消息在发送时会被拆分或合并，内核不会保留消息边界，接收端只会看到一个连续的字节流。也就是说，TCP 保证字节的顺序和可靠传输，但不保证消息边界。

**2. 面向字节流的影响：**
比如发送端先 send("Hi.")，再 send("I am Xiaolin")，接收端可能出现：

* 两个消息被合并成一个报文；
* 一个消息被拆开分到多个报文；
* 两个消息部分重叠在同一个报文里。

因此，应用层不能依赖「一次 recv 对应一次 send」，而是要自己定义消息边界。

**3. 粘包/拆包问题与解决方式：**
因为没有边界，可能出现粘包问题，常见的解决方式有：

* **固定长度消息**：每个消息固定 N 字节；
* **特殊分隔符**：如 HTTP 用 `\r\n` 作为报文结束符；
* **自定义协议头**：在消息头里声明消息体的长度，常见于很多自定义 RPC 协议。

**4. 核心结论**

> TCP 的“面向字节流”指的是它提供了一条可靠的、按顺序的字节通道，但不关心应用层消息的边界；而 UDP 的“面向报文”则是天然保留了应用层的消息边界。

---

要不要我帮你再压缩成 **10 秒面试速答版**（比如一句话解释 TCP 面向字节流 + 举个例子）？
