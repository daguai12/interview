好——下面我按图一步步把 **TCP Fast Recovery（以 TCP Reno 为例）** 的流程讲清楚，并把图上的数值（1、2、4、8、9、10、11、12、→9→10→11→12→收到新 ACK → cwnd = ssthresh = 6 → 7、8、9）串成一条容易理解的时间线。

# 先说明几个术语（图里的单位）

* `cwnd`：拥塞窗口，图中用 **MSS 为单位**（所以 `cwnd=12` 意味着能发送 12 个 MSS）。
* `ssthresh`：慢启动阈值（图上初始是 8，后来在发生丢包时更新为 6）。
* `dup ACK`：重复的 ACK（接收端对“最后一个按序收到的字节”重复回 ACK，表示中间某个包丢了但后面的包到达了）。
* “轮次 / RTT” 横轴表示往返时间单位上的窗口变化。

---

# 整体时间线（结合图上的具体数值）

1. **慢启动阶段（Slow Start）**

   * 开始：`cwnd = 1`。每收到一个 ACK，`cwnd` 翻倍（或按每 RTT 翻倍），图上依次是 `1 → 2 → 4 → 8`。
   * 当 `cwnd` 达到初始 `ssthresh = 8` 后，进入拥塞避免（线性增长）阶段。

2. **拥塞避免（Congestion Avoidance）**

   * `cwnd` 线性增长：`8 → 9 → 10 → 11 → 12`（每个 RTT 大约 +1 MSS）。
   * 在 `cwnd=12` 的时候发送了一批包（比如序号 1..12），但中间某个包丢失（假设第 5 个丢了）。接收端收到 6..12，但缺第 5 个，所以连续发出 **重复 ACK（ACK=5）**。

3. **触发 Fast Retransmit（快速重传）**

   * 发送端收到 **3 个重复 ACK**（即第三个 duplicate ACK 出现），根据快速重传规则立刻重传丢失的包（重传第 5 包），避免等待超时。
   * 在收到三次重复 ACK 的那一刻，进入 **Fast Recovery**。

4. **进入 Fast Recovery：更新 ssthresh，临时膨胀 cwnd（图中绿色点）**

   * 设定新的慢启动阈值：`ssthresh = cwnd / 2`（向下取整）。例子：`ssthresh = 12 / 2 = 6`。
   * **为了维持管道中已有的数据不被浪费**，发送端把 `cwnd` 设置为 `ssthresh + 3`（图中 `cwnd = 6 + 3 = 9`）。

     * 这里的 `+3` 来源于“已经收到的 3 个重复 ACK”——每个重复 ACK 说明网络中又有一个数据段离开发送端并到达接收端（只是被缓存因为缺失中间包），所以用 `+3` 来“补偿”这 3 个分段仍在网络中。
     * 严格说：`cwnd = ssthresh + N_dupacks`（按字节就是 `ssthresh + N_dupacks * MSS`）。

5. **在 Fast Recovery 内维持发送：对后续的 duplicate ACK 的处理（图中粉红区）**

   * 对**每**个额外到来的 duplicate ACK（超过触发用的那 3 个），发送端再把 `cwnd` 加 1 MSS 并且立即发送一个新的段（如果有数据可发）。
   * 这保证了丢包发生时 **发送端仍尽可能把管道填满**，不会一下子把发送速率降到很小，从而浪费带宽。
   * 在图中你看到 `cwnd` 被“临时推进”回 `10→11→12`，这是因为收到更多 duplicate ACK 并按规则增长。

6. **收到第一个 ACK 确认新数据（即确认丢失包已经被修复）**

   * 当接收到一个 ACK，它确认了之前丢失的数据（ACK 序号超过被重传的段，表示接收端已经按序收到数据），这表示 fast recovery 成功完成。
   * 此时发送端把 `cwnd` 立刻设置为 `ssthresh`（**不是** `ssthresh + 3`），也就是图中 `cwnd = 6`（绿色点），并退出 Fast Recovery，进入拥塞避免阶段。

     * 解释：`ssthresh` 是“恢复后的稳定窗口”，临时的 `+3` 只是为了维持网络利用率，真正收敛回半窗口值以反映网络发生拥塞的事实。

7. **恢复后的拥塞避免继续线性增长**

   * 之后 `cwnd` 从 `6 → 7 → 8 → 9 ...` 按线性（每 RTT +1 MSS）增长，继续正常的拥塞避免阶段。

---

# 为什么要这么做？（设计动机与直觉）

* **快速重传（Fast Retransmit）**：用 3 个重复 ACK 更快检测丢包，避免等待超时（超时代价大）。
* **Fast Recovery 的关键目标**：在检测到丢包但管道仍有后续到达的数据时，不把连接退回到慢启动（Tahoe 的做法），而是**减半拥塞窗口并在短期内保持管道填满**，这样既响应拥塞又保持吞吐率。

  * `ssthresh = cwnd/2` 是“保守减半”的策略。
  * `cwnd = ssthresh + 3` 与对每个后续 duplicate ACK `cwnd += 1`，都是为了利用那些已经在网络中的数据包（它们告诉发送端“还有数据到达接收端”），从而避免短期内把发送速率降得过低。

---

# 与 TCP Tahoe 的区别（补充）

* **Tahoe**：出现 3 dup-ACK 或超时都把 `cwnd` 直接设为 1（回到慢启动），并把 `ssthresh = cwnd/2`。
* **Reno (Fast Recovery)**：在 3 dup-ACK 时不回到慢启动，而是执行上面描述的 `ssthresh = cwnd/2`, `cwnd = ssthresh + 3`，并在收到新的 ACK 时把 `cwnd` 设为 `ssthresh`。因此 Reno 在丢包时更“温和”，能维持更高吞吐。

---

# 小结（一句话）

当检测到丢包（3 个重复 ACK）时，Reno 会把慢启动阈值减半（`ssthresh = cwnd/2`），临时把 `cwnd` 设为 `ssthresh + 3` 并利用后续的重复 ACK 来继续发包（保持管道满），直到收到确认丢包已恢复的新 ACK，再把 `cwnd` 正式降到 `ssthresh` 并进入拥塞避免——这就是图中从 12 →（触发）→ 9 → 10→11→12 → 收到新 ACK → 6 → 7→8→9 的流程。

---

如果你愿意，我可以：

* 用\*\*包序号时间线（示例 seq=1..12，第 5 包丢失）\*\*把每个 ACK 的产生和发送端的动作写得更“逐包”来帮助理解；或者
* 把上面的步骤标注回原图（把每一步的文字直接贴在图上，便于对照）。你想要哪种？
