### 为什么 TIME_WAIT 状态需要等待 2MSL？

面试官您好，TIME_WAIT 状态设置 2MSL（两倍的报文最大生存时间）的等待时间，主要是基于以下两个核心原因：

**1. 防止旧连接的延迟报文干扰新连接**

* **MSL (Maximum Segment Lifetime)** 是报文在网络中存活的最长时间。任何报文在网络中超过 MSL 时间，都将被丢弃。
* 我们假设 TIME_WAIT 状态只等待一个 MSL。如果网络中还有一个来自旧连接的、延迟的报文（例如，一个数据包），它在一个 MSL 时间内仍然可能到达对端。
* 如果此时我们立即复用这个端口（相同的源IP、源端口、目标IP、目标端口）建立一个新连接，这个延迟到达的旧报文就可能被新连接当成合法数据接收，从而引发数据混乱。
* 因此，通过等待 2MSL，我们可以确保：
    * **第一个 MSL**：保证我们发出的最后一个 ACK 报文能够到达对端。
    * **第二个 MSL**：保证对端在未收到 ACK 时重发的 FIN 报文以及网络中所有来自该旧连接的、延迟的报文，都已经从网络中彻底消失。
* 这样，当 TIME_WAIT 状态结束后，任何新建立的连接都不会被旧连接的残留报文所干扰，保证了连接的可靠性。

**2. 确保连接正常关闭，处理被动关闭方重传的 FIN**

* 在 TCP 四次挥手的最后一步，主动关闭方会发送一个最终的 ACK 报文。
* 这个 ACK 报文有可能会丢失。如果丢失，被动关闭方会因为收不到 ACK 而超时重传它的 FIN 报文。
* 如果主动关闭方发送 ACK 后立即关闭，而不是进入 TIME_WAIT 状态，那么当它收到对方重传的 FIN 时，它将无法识别这个报文，可能会响应一个 RST 报文，导致对端异常关闭。
* 而有了 TIME_WAIT 状态，主动关闭方就能在这 2MSL 时间内接收到对方重传的 FIN。收到后，它会重新发送一次最终的 ACK，并**重置 2MSL 计时器**。这确保了被动关闭方能够正常、优雅地关闭连接。

**总结：**

简单来说，2MSL 的设计目标可以用两句话概括：
* **对内**：保证 TCP 连接的最后一个 ACK 报文能够被对方成功接收，实现连接的可靠关闭。
* **对外**：保证网络中所有与旧连接相关的报文都彻底消失，防止其干扰未来可能建立的新连接。

在 Linux 系统中，一个 MSL 通常被设置为 30 秒，所以 2MSL 就是 60 秒。这是一个兼顾了网络可靠性和系统资源开销的工程选择。