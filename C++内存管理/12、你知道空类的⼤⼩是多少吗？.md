您好，您对这个问题的理解非常准确和全面！这是一个经典的C++面试题，因为它能考察出面试者对C++对象模型（Object Model）底层规则的理解深度。

您提到的四点都是完全正确的，我将基于您的内容，进行一个更系统化的梳理和展开。

-----

### 明确的答案

在C++中，一个空类的大小**不是0，而是1字节**。

```cpp
#include <iostream>

class EmptyClass {};

int main() {
    std::cout << "Size of an empty class object is: " << sizeof(EmptyClass) << std::endl;
    return 0;
}
```

**输出：**

```
Size of an empty class object is: 1
```

-----

### 为什么不是0？—— “唯一地址”原则

正如您在第2点和第4点中正确指出的，C++标准规定，任何两个不同的对象都必须拥有**唯一的内存地址**。这是C++对象模型的一条基本法则。

让我们想象一下，如果空类的大小是0，会发生什么灾难：

```cpp
EmptyClass arr[10]; // 创建一个包含10个空类对象的数组
```

如果 `sizeof(EmptyClass)` 是0，那么数组中所有10个元素的地址都将是相同的：
`&arr[0] == &arr[1] == &arr[2] == ...`

这将导致：

1.  **无法区分对象**：你无法通过地址来区分数组中的不同元素。
2.  **指针算术失效**：`&arr[0] + 1` 仍然会指向 `&arr[0]`，循环和遍历将陷入混乱。
3.  **内存管理崩溃**：很多内存相关的操作都依赖于对象拥有唯一的地址。

为了解决这个问题，编译器会为任何空类“**塞入**”一个**虚拟的字节**。这个字节不为存储任何数据，它仅仅作为一个**占位符**，以确保这个类的每一个实例都能在内存中拥有一个独一无二、可以被寻址的位置。

-----

### 例外情况与变化

空类的大小为1字节是基本情况，但在某些条件下，这个大小会发生变化。

#### 1\. 当类包含虚函数时

正如您在第3点中提到的，一旦一个类（即使它没有任何数据成员）包含了**任何虚函数**（包括虚析构函数），它就不再是一个“空类”了。

  * **原因**：为了实现运行时多态，编译器必须在每个对象实例中**添加一个隐藏的指针**，即**虚函数表指针（`vptr`）**。
  * **大小**：这个 `vptr` 的大小等于一个指针的大小，在32位系统上是4字节，在64位系统上是8字节。

<!-- end list -->

```cpp
class EmptyWithVirtual {
public:
    virtual void do_nothing() {}
    virtual ~EmptyWithVirtual() {}
};

// 在64位系统上
std::cout << "Size of an empty class with virtual functions is: " 
          << sizeof(EmptyWithVirtual) << std::endl; // 输出 8
```

#### 2\. 空基类优化 (Empty Base Optimization - EBO)

这是一个非常重要的优化规则，也是空类大小为1这个规则的唯一“例外”。

  * **规则**：当一个空类**作为基类**被另一个类继承时，编译器**允许**优化掉这个基类所占用的1字节空间。
  * **原因**：派生类自身通常会有自己的数据成员，这些成员足以保证派生类的每个对象都拥有唯一的地址。因此，基类的那个1字节“占位符”就不再是必需的了，可以被安全地优化掉，从而避免空间浪费。

<!-- end list -->

```cpp
class EmptyBase {}; // sizeof(EmptyBase) == 1

class Derived : public EmptyBase {
private:
    int data; // 4字节
};

// sizeof(Derived) 的结果通常是 4
// 而不是 1 (来自EmptyBase) + 4 (来自data) = 5
// 这说明 EmptyBase 的1字节被优化掉了
std::cout << "Size of Derived with Empty Base is: " << sizeof(Derived) << std::endl;
```

-----

### 总结

1.  **基本情况**：一个独立的空类对象，大小为 **1 字节**，以保证其实例在内存中地址的唯一性。
2.  **虚函数情况**：如果类（即使为空）包含虚函数，其大小将变为一个**指针的大小**（`sizeof(vptr)`），在64位系统上通常为**8字节**。
3.  **继承情况**：如果一个空类作为**基类**，它的1字节大小通常会被**优化掉**，不会增加派生类的大小。这被称为**空基类优化**。