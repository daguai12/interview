### 计算 `sizeof(ClassName)` 的核心规则

一个类对象在内存中所占用的空间，主要由以下几个因素决定：

1.  **非静态数据成员（Non-static Data Members）**：这是对象大小的**基本盘**。
2.  **虚函数指针（vptr）**：如果类是多态的（即含有虚函数），编译器会为每个对象添加一个隐藏的 `vptr`。
3.  **内存对齐（Padding）**：编译器为了性能，会在成员之间和末尾插入一些“填充字节”。
4.  **空类特殊规则**：为了保证每个对象地址唯一，空类的大小至少为1字节。

而以下因素**不计入**对象的大小：

  * **静态数据成员（`static` Data Members）**
  * **所有成员函数（包括普通、静态和虚函数）**
  * `typedef`、`enum` 等类型定义

-----

### 逐一分析您的示例

#### 示例 1：空类

```cpp
class A {};
// cout << sizeof(A) << endl; // 输出 1
```

  * **分析**：完全正确。C++标准规定，任何两个不同的对象都必须拥有唯一的内存地址。为了满足这一点，编译器会为空类对象分配**1个字节**的占位空间，以确保可以对其实例进行取地址 `&` 操作并得到不同的结果。
  * **补充（空基类优化）**：正如您所提到的，如果这个空类作为基类，它的1字节大小通常会被优化掉（Empty Base Optimization），不会增加派生类的大小。

#### 示例 2：带虚函数的类

```cpp
class A { virtual void Fun(){} };
// cout << sizeof(A) << endl; // 输出 4 (32位) 或 8 (64位)
```

  * **分析**：完全正确。一旦类中出现了`virtual`关键字（无论是虚函数还是虚析构函数），这个类就成为了**多态类**。为了支持运行时多态，编译器必须在每个对象实例中**添加一个虚函数表指针（vptr）**。因此，类的大小至少是**一个指针的大小**。

#### 示例 3：只带静态成员的类

```cpp
class A { static int a; };
// cout << sizeof(A) << endl; // 输出 1
```

  * **分析**：完全正确。静态成员变量不属于任何一个对象实例，而是被所有对象**共享**。它存储在程序的**静态/全局数据区**，只有一份拷贝。因此，它**不计入**单个对象的大小。从 `sizeof` 的角度看，这个类依然是一个**空类**，所以其大小为1字节。

#### 示例 4：带一个普通数据成员的类

```cpp
class A { int a; };
// cout << sizeof(A) << endl; // 输出 4
```

  * **分析**：完全正确。这个类的大小就是其唯一的非静态数据成员 `a` 的大小，即 `sizeof(int)`，通常是4字节。

#### 示例 5：带静态和非静态数据成员的类

```cpp
class A { static int a; int b; };
// cout << sizeof(A) << endl; // 输出 4
```

  * **分析**：完全正确。计算对象大小时，我们只需要考虑**非静态成员**。静态成员 `a` 被忽略，所以类的大小就是成员 `b` 的大小，即 `sizeof(int)`，为4字节。

-----

### 一个更复杂的例子：内存对齐

您的例子都比较简单，我们来看一个能体现\*\*内存对齐（Padding）\*\*影响的例子：

```cpp
class B {
    char c;     // 1 字节
    int i;      // 4 字节
    short s;    // 2 字节
};
```

  * **天真的计算**：`sizeof(char) + sizeof(int) + sizeof(short) = 1 + 4 + 2 = 7` 字节。
  * **实际的 `sizeof(B)`**：在大多数平台上会是 **12 字节**。

**为什么是12？**

1.  `char c;`：占用1字节，**偏移量为0**。 `[c]`
2.  `int i;`：`int` 需要4字节对齐，所以它的偏移量必须是4的倍数。编译器会在 `c` 之后**填充3个字节**。`i` 的**偏移量为4**。 `[c, pad, pad, pad, i, i, i, i]`
3.  `short s;`：`short` 需要2字节对齐。当前偏移量为8，是2的倍数，所以 `s` 的**偏移量为8**。 `[c, pad, pad, pad, i, i, i, i, s, s]`
4.  **成员总占用**：到目前为止，总共占用了 `8 + 2 = 10` 字节。
5.  **整体对齐**：整个结构体的对齐要求等于其最大成员的对齐要求（这里是 `int` 的4字节）。因此，结构体的总大小必须是4的倍数。10不是4的倍数，需要**在末尾再填充2个字节**，凑成12。
6.  **最终大小**：12字节。

### 总结

您的分析非常出色，准确地覆盖了决定类大小的几个关键因素。总而言之，一个类的 `sizeof` 是其**所有非静态数据成员**的大小、**可能的`vptr`大小**、以及为了满足**内存对齐**而加入的**填充字节**的总和。