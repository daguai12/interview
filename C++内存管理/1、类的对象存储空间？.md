您好，您对C++类对象存储空间的组成总结得**非常准确和全面**！这几个要点确实是决定一个对象`sizeof`大小的核心因素。

这是一个深入C++对象模型（Object Model）的经典问题。下面，我将基于您这份优秀的提纲，进行更系统化的展开和解析，并为每个要点配上清晰的示例。

-----

### 一个C++对象的内存大小由什么决定？

一个对象所占用的存储空间，是其所有**非静态数据成员**、加上由编译器为支持语言特性而添加的**额外开销**（如`vptr`）、再经过\*\*内存对齐（Padding）\*\*调整后的总和。

我们来逐一分解这些组成部分：

#### 1\. 非静态数据成员 (Non-static Data Members)

这是对象大小的**基本构成**。一个对象必须有足够的空间来存储它自己独有的数据。

  * **`static` 成员变量**不包含在内，因为它们不属于任何单个对象，而是被所有对象共享，存储在静态/全局数据区。
  * **成员函数**（非虚函数）也不包含在内，因为函数代码存储在代码段，所有对象共享同一份函数代码。

<!-- end list -->

```cpp
class SimpleObject {
    int a;    // 4 字节
    double b; // 8 字节
    char c;   // 1 字节
};
// 理论上的数据大小 = 4 + 8 + 1 = 13 字节
```

但实际上 `sizeof(SimpleObject)` 通常会大于13字节，这是因为下一个因素。

#### 2\. 内存对齐填充 (Padding)

这是为了**性能**而做出的一种空间牺牲。现代CPU为了提高访问效率，通常会从特定地址（例如4或8的倍数）开始，以块（word）为单位读取内存。

编译器为了保证每个成员都能被高效访问，会按照对齐规则，在成员之间和对象的末尾插入一些“**填充字节（Padding）**”。

  * **规则1**：每个成员的偏移量（offset）必须是其自身对齐要求（通常是其大小）的整数倍。
  * **规则2**：整个对象的总大小必须是其**最大对齐成员**的对齐值的整数倍。

<!-- end list -->

```cpp
class PaddedObject {
    char a;     // 1字节，偏移量 0
                // 下一个成员是int(4字节)，需要从4的倍数地址开始，
                // 因此编译器在此处填充3个字节
    int b;      // 4字节，偏移量 4
    double c;   // 8字节，偏移量 8 (8是8的倍数，OK)
};
// 此时总大小为 1(a)+3(pad)+4(b)+8(c) = 16字节
// 成员中最大对齐值为double的8，16是8的倍数，OK
// 所以 sizeof(PaddedObject) = 16
```

#### 3\. 虚函数指针 (vptr)

这是为了支持**运行时多态**而付出的空间代价。

  * 如果一个类拥有**任何虚函数 (`virtual`)**（或者它继承自一个有虚函数的基类），编译器就会在每个该类的对象实例中，添加一个隐藏的成员——**虚函数表指针（vptr）**。
  * `vptr` 指向一个静态的**虚函数表（vtable）**，用于在运行时查找并调用正确的虚函数实现。
  * `vptr` 的大小等于一个指针的大小（32位系统下4字节，64位系统下8字节）。

<!-- end list -->

```cpp
class VirtualObject {
    virtual void func() {} // 只要有一个虚函数
    int a;                 // 4 字节
};
// 在64位系统上:
// sizeof(VirtualObject) = 8 (vptr) + 4 (a) + 4 (padding) = 16 字节
```

-----

### 特殊情况：空类 (Empty Class)

您对空类的总结非常到位，这涉及到C++对象模型的两个重要特性。

#### a) 独立空对象的大小为 1

```cpp
class Empty {};
// sizeof(Empty) 的结果是 1
```

  * **原因**：C++标准规定，任何两个不同的对象都必须拥有**唯一的内存地址**。为了满足这个要求，即使一个类是空的，编译器也必须为它的对象分配至少**1个字节**的空间，以作为其在内存中的“占位符”，确保可以对它进行取地址（`&`）等操作。

#### b) 空基类优化 (Empty Base Optimization, EBO)

```cpp
class EmptyBase {};

class Derived : public EmptyBase {
    int data; // 4 字节
};
// sizeof(Derived) 的结果通常是 4，而不是 1 (EmptyBase) + 4 (data) = 5
```

  * **原因**：正如您所说，当一个空类作为**基类**时，编译器通常会进行**空基类优化**。编译器知道派生类 `Derived` 自身已经有了数据成员 `data`，这足以保证 `Derived` 的每个对象都有唯一的地址。因此，那个来自 `EmptyBase` 的1字节“占位符”就不再是必需的了，可以被优化掉，从而节省了空间。

### 总结

一个C++对象的存储空间 `sizeof(ClassName)` 计算公式可以概括为：
**（所有非静态成员大小 + `vptr`大小（如果有）+ 虚基类指针大小（如果有）） 经过内存对齐调整后的总大小。**

其中，`static` 成员和所有成员函数（非虚函数）都不占用单个对象的存储空间。