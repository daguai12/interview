您好，您对C++类成员内存分布的理解和示例分析**完全正确**！这是一个深入理解C++对象模型（Object Model）的基石问题。

您得出的核心结论——**类的非静态数据成员占用对象空间，而成员函数不占用对象空间**——是完全准确的。

我将基于您这份优秀的提纲，进行更系统化的梳理和展开，并引入虚函数等情况，以形成一个更完整的知识体系。

-----

### 1\. 核心原则：数据与代码分离

C++ 在设计对象模型时，遵循了一个核心的效率原则：**将每个对象独有的“数据（Data）”与所有对象共享的“代码（Code）”分离开来存储。**

**一个生动的比喻：**

  * **类 (Class)**：就像一份\*\*“调查问卷”的模板\*\*。模板上定义了需要填写的项目（数据成员）和填写说明（成员函数）。
  * **对象 (Object)**：就像一份**具体填写好的“调查问卷”**。
      * 这份填写好的问卷本身只需要存储你填写的**答案（非静态数据成员的值）**。
      * 它**不需要**在每一份问卷上都重复打印一遍长篇大论的“填写说明”（成员函数的代码）。所有的问卷实例都共享同一份“填写说明”模板。

-----

### 2\. 什么东西存储在对象内部？(Per-Object Storage)

一个类对象在内存中所占用的空间，只包含**每个对象实例必须独立拥有的部分**。

#### a) 非静态数据成员 (Non-static Data Members)

这是对象存储空间的主要组成部分。每个对象实例都必须有自己的一套数据成员来记录自身的状态。正如您的 `Person` 示例所示：

```cpp
class Person {
public:
    int age; // 这个age属于每个Person对象实例
};
```

`Person p1;` 和 `Person p2;` 在内存中会有两块独立的空间，每块空间里都存放着各自的 `age` 值。

#### b) 内存对齐填充 (Padding)

编译器为了优化CPU的访问效率，会在成员之间插入一些“填充字节”，以保证每个成员的起始地址都是“对齐”的。这些填充字节也是对象大小的一部分。

#### c) 虚函数指针 (vptr) —— (唯一的函数相关成员)

这是一个重要的例外。如果一个类拥有**任何虚函数 (`virtual`)**（或者继承自一个有虚函数的基类），编译器就会在每个对象实例的内存布局中，安插一个隐藏的**虚函数指针（`vptr`）**。

  * **作用**：`vptr` 指向一个静态的**虚函数表（vtable）**，用于在运行时查找并调用正确的虚函数实现，这是实现多态的关键。
  * **空间成本**：`vptr` 的大小等于一个指针的大小（32位系统下4字节，64位系统下8字节）。

-----

### 3\. 什么东西不存储在对象内部？(Shared Storage)

#### a) 成员函数（包括普通成员函数和 `static` 成员函数）

正如您所正确指出的，所有函数（无论是否为成员函数）的机器码指令，都只会在内存的**代码区（Code/Text Segment）中存储一份**。

**那么，成员函数是如何知道要操作哪个对象的数据呢？**
答案是靠一个隐藏的参数：**`this` 指针**。

当您调用一个普通成员函数时，例如 `p.printAge();`，编译器会自动将 `p` 对象的地址（`&p`）作为一个隐藏的参数传递给 `printAge` 函数。在函数内部，这个隐藏的参数就是 `this` 指针。

```cpp
// 你的代码
p.printAge();

// 编译器“看到”的近似效果
Person::printAge(&p);

// Person::printAge 的近似实现
void Person::printAge(/* Person* const this */) {
    cout << this->age << endl; // 使用 this 指针访问当前对象的成员
}
```

通过这种方式，一份共享的函数代码就可以为无数个不同的对象服务了。

**`static` 成员函数**则更简单，因为它不属于任何特定对象，所以它**没有 `this` 指针**，也因此不能直接访问非静态成员。

#### b) `static` 数据成员

静态数据成员也不属于任何单个对象，而是被所有对象共享。它在内存的**静态/全局数据区**只**存储一份**，不计入 `sizeof(ClassName)` 的大小。

-----

### 4\. 综合示例与内存图

```cpp
class AdvancedPerson {
public:
    // 数据成员
    std::string name; // 非静态成员 (占用对象空间)
    int age;          // 非静态成员 (占用对象空间)

    // 静态数据成员 (不占用对象空间)
    static int person_count; 

    // 成员函数 (不占用对象空间)
    void print_info() const;

    // 静态成员函数 (不占用对象空间)
    static int get_count();

    // 虚函数 -> 将导致 vptr (占用对象空间)
    virtual ~AdvancedPerson(); 
};
```

**内存分布示意图：**

```
/--------------------\      /-------------------------\
|  代码区 (.text)    |      |  静态/全局数据区        |
|--------------------|      |-------------------------|
|                    |      |                         |
|  print_info() 代码 |      |  person_count (一份)    |
|  get_count() 代码  |      |  AdvancedPerson::vtable | <---+
|  ...               |      |  (一份)                 |     |
|                    |      |                         |     |
\--------------------/      \-------------------------/     |
                                                            |
/-------------------------------------------------\         |
|             对象内存 (在栈或堆上)               |         |
|-------------------------------------------------|         |
|  对象 p1:                                       |         |
|  +--------------------+                         |         |
|  | vptr               | ------------------------+ (指向vtable)
|  +--------------------+                         |
|  | name (std::string) |                         |
|  +--------------------+                         |
|  | (padding)          |                         |
|  +--------------------+                         |
|  | age (int)          |                         |
|  +--------------------+                         |
|                                                 |
|  对象 p2:                                       |
|  +--------------------+                         |
|  | vptr               | ------------------------+ (也指向同一个vtable)
|  | ...                |                         |
|  +--------------------+                         |
\-------------------------------------------------/
```

**总结**：一个C++对象的内存只存放**专属于该实例**的数据。所有**共享**的元素——无论是代码（成员函数）还是数据（静态成员）——都存放在对象之外的公共区域。`this` 指针是连接共享代码和专属数据的桥梁。