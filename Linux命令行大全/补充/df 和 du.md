好的，我们来详细讲解一下 `df` 和 `du` 这两个在 Linux/Unix-like 系统中非常基础且重要的命令。

简单来说，它们都与磁盘空间有关，但关注的维度完全不同：

  * `df` (disk free): **查看文件系统（分区）的整体磁盘使用情况**。它告诉你一个分区总共有多大、用了多少、还剩多少。
  * `du` (disk usage): **查看文件或目录占用了多少磁盘空间**。它告诉你某个文件夹或文件具体有多大。

为了更好地理解，我们可以用一个形象的比喻：

> 把你的硬盘想象成一个大仓库 (`/dev/sda1`)，这个仓库被划分成了几个大房间（分区，比如 `/`, `/home`）。
>
>   * `df` 命令就像是仓库管理员，你问他：“每个房间（分区）的总面积是多少？现在被货物占了多少？还空着多少？” 他能迅速告诉你每个房间的整体情况。
>   * `du` 命令就像是一个理货员，你指着仓库里的一个箱子（目录）问他：“这个箱子以及它里面所有东西总共占了多大地方？” 他需要进去，把箱子里每个物品的大小都加起来，然后告诉你结果。

-----

### `df` (disk free) 详解

`df` 命令从文件系统的角度来报告磁盘空间的使用情况。它直接读取文件系统元数据（superblock）中的信息，所以执行速度非常快。

#### 主要用途

  * 检查整个服务器或个人电脑的磁盘空间状态。
  * 确认哪个分区快要满了，以便及时清理或扩容。
  * 查看挂载点信息。

#### 常用法及示例

默认情况下，直接输入 `df` 会以千字节（KB）为单位显示，可读性较差。

```bash
$ df
Filesystem     1K-blocks      Used Available Use% Mounted on
/dev/sda1       51475064  15234567  33605897  32% /
tmpfs            8125412         0   8125412   0% /dev/shm
/dev/sdb1      1024365890 450123456 574242434  44% /data
```

**强烈推荐使用 `-h` 选项**，它会以人类可读的格式（Human-readable），如 `K`, `M`, `G` 来显示大小。

```bash
$ df -h
Filesystem      Size  Used Avail Use% Mounted on
/dev/sda1        49G   15G   33G  32% /
tmpfs           7.8G     0  7.8G   0% /dev/shm
/dev/sdb1       977G  430G  548G  44% /data
```

**输出列解释:**

  * `Filesystem`: 文件系统的来源，通常是设备路径（如 `/dev/sda1`）。
  * `Size`: 该文件系统的总大小。
  * `Used`: 已使用的空间大小。
  * `Avail`: 剩余可用空间大小。**注意**：这部分空间不完全等于 `Size - Used`，因为系统会为 `root` 用户预留一部分空间（通常是5%），以防空间被占满时系统无法正常运行。
  * `Use%`: 已使用空间的百分比。
  * `Mounted on`: 该文件系统挂载到的目录。

**其他常用选项:**

  * `df -T`: 显示文件系统的类型（如 `ext4`, `xfs`, `nfs` 等）。
  * `df -i`: 查看 inode 的使用情况，当磁盘空间还很充足但无法创建新文件时，通常是 inode 用完了。

-----

### `du` (disk usage) 详解

`du` 命令从文件和目录的角度来统计磁盘空间的使用情况。它会递归地进入目录，累加其中每个文件的大小来得到总和。因此，当目标目录文件非常多时，`du` 的执行速度可能会比较慢。

#### 主要用途

  * 查找是哪个目录或文件占用了大量磁盘空间。
  * 统计特定项目或用户文件夹的大小。

#### 常用法及示例

如果直接在一个有很多子目录的文件夹下运行 `du`，它会列出所有子目录的大小，信息非常冗长。

```bash
$ du /var/log
4       /var/log/apt
8       /var/log/unattended-upgrades
...
12345   /var/log/journal/sub
12348   /var/log/journal
...
25678   /var/log
```

**最常用的组合是 `-sh`**：

  * `-s` (summarize): 只显示总计大小，不显示每个子目录的大小。
  * `-h` (human-readable): 以易于阅读的格式显示大小。

<!-- end list -->

```bash
# 查看 /var/log 目录的总大小
$ du -sh /var/log
26M     /var/log

# 查看当前目录下所有一级子目录和文件的大小
$ du -h --max-depth=1
8.0K    ./.cache
4.0K    ./.ssh
12M     ./projectA
2.5G    ./docker-data
2.6G    .
```

  * `--max-depth=1`: 指定了递归的深度。`--max-depth=1` 意味着只看当前目录下的文件和一级子目录。最后的 `.` 代表当前目录的总大小。

**其他常用技巧:**

  * **查找当前目录下最大的几个文件或目录：**

    ```bash
    # 使用 sort 命令配合
    $ du -h --max-depth=1 | sort -rh
    2.6G    .
    2.5G    ./docker-data
    12M     ./projectA
    8.0K    ./.cache
    4.0K    ./.ssh
    ```

    `sort -r` 表示逆序（从大到小），`-h` 表示按人类可读的数字排序。

-----

### `df` 和 `du` 结果为何会不一致？

这是一个非常经典的问题。有时你会发现 `df` 显示已用空间远大于 `du` 统计出的根目录下所有文件的大小总和。

**最常见的原因是：文件已被删除，但进程仍在占用它。**

1.  一个程序（比如日志服务）打开了一个文件 `/var/log/huge.log` 并持续向里面写入。
2.  你通过 `rm /var/log/huge.log` 命令删除了这个文件。
3.  此时，`ls` 命令已经看不到这个文件了，所以 `du` 在统计 `/var/log` 目录大小时，不会包含这个文件。
4.  但是，因为日志服务的进程还持有这个文件的“句柄”（file handle），所以操作系统并没有真正释放它占用的磁盘块。
5.  `df` 从文件系统的层面看，这些磁盘块仍然是“已使用”状态。
6.  **结果**：`df` 显示的 `Used` 空间很大，而 `du` 统计的结果却小得多。

**解决方法**：找到那个仍在占用已删除文件的进程，然后重启该进程。当进程关闭并释放文件句柄后，操作系统才会回收对应的磁盘空间，这时 `df` 的结果就会更新。可以使用 `lsof | grep deleted` 命令来查找这类情况。

### 总结对比

| 特性 | `df` (disk free) | `du` (disk usage) |
| :--- | :--- | :--- |
| **核心功能** | 报告**文件系统**（分区）的整体使用情况 | 估算**文件和目录**的磁盘使用情况 |
| **对象** | 整个分区（如 `/dev/sda1`） | 具体的文件或目录（如 `/home/user`） |
| **视角** | 宏观，从文件系统层面看 | 微观，从文件目录层面看 |
| **速度** | 非常快，直接读取元数据 | 慢，需要遍历目录和文件 |
| **常见问题** | “我的硬盘还剩多少空间？” | “是什么占用了我的硬盘空间？” |
| **常用命令** | `df -h` | `du -sh <目录>` |