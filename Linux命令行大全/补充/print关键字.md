在 Bash 中进行格式化输出，主要有两种核心工具：`echo` 和 `printf`。其中，`echo` 更简单，适合基础输出和添加颜色；而 `printf` 功能极其强大，是进行精确对齐、数字格式化的首选专业工具。

下面我将从简单到复杂，为你详细介绍它们的使用方法。

-----

### 方法一：使用 `echo` 和 ANSI 转义码 (适用于颜色和样式)

这是在终端中实现彩色文本和样式（如下划线、粗体）的最快捷方式。它通过在字符串中嵌入特殊的 “ANSI 转义码” 来告诉终端改变显示方式。

**基本语法：**

```bash
echo -e "\e[<样式代码>;<颜色代码>m你的文本\e[0m"
```

**关键点解释：**

  - `echo -e`: `-e` 选项是**必需的**，它告诉 `echo` 去解释字符串中的 `\e` (转义) 序列。
  - `\e[...m`: 这是控制序列的开始。`m` 是结束符。
  - `<样式代码>;<颜色代码>`: 你可以提供一个或多个用分号 `;` 分隔的代码。
  - `\e[0m`: 这是**重置代码**，作用是清除所有格式，让后面的文本恢复正常。**强烈建议每次都使用它**，否则你的整个终端后续输出都会带上颜色。

**常用代码表：**
| 类型 | 代码 | 效果 |
| :--- | :--- | :--- |
| **样式** | 1 | **粗体 (Bold)** |
| | 4 | \<u\>下划线\</u\> |
| | 5 | 闪烁 |
| **前景色** | 30 | 黑色 |
| | 31 | 红色 |
| | 32 | 绿色 |
| | 33 | 黄色 |
| | 34 | 蓝色 |
| | 37 | 白色 |
| **背景色** | 40 | 黑色 |
| | 41 | 红色 |
| | 42 | 绿色 |
| | 43 | 黄色 |
| | 44 | 蓝色 |
| | 47 | 白色 |

**示例：**

```bash
#!/bin/bash

# 使用 echo -e 添加颜色和样式
echo -e "默认文本"
echo -e "这是一个 \e[31m红色\e[0m 的警告！"
echo -e "这是一个 \e[1;32m粗体绿色\e[0m 的成功消息。"
echo -e "这是一个 \e[4;34m带下划线的蓝色\e[0m 链接。"
echo -e "这是一个 \e[41;37m白字红底\e[0m 的高亮文本。"
echo -e "格式已重置，恢复正常。"
```

-----

### 方法二：使用 `printf` (适用于所有精确格式化场景)

`printf` 命令源自 C 语言，是 Bash 中进行格式化输出的**终极工具**。它提供了对文本对齐、填充、数字精度等各方面的精确控制。

**基本语法：**

```bash
printf "格式化字符串" arg1 arg2 ...
```

**关键点解释：**

  - `格式化字符串`: 这是一个模板，定义了后续参数 `arg1`, `arg2` 等应该如何显示。
  - `printf` **默认不会自动换行**，你需要显式地在格式化字符串末尾加上 `\n`。

**格式化字符串的核心——格式说明符 (Format Specifiers)**
格式说明符以 `%` 开始，用来为参数占位。

  - `%s`: 格式化为**字符串**。
  - `%d`: 格式化为**十进制整数**。
  - `%f`: 格式化为**浮点数**（小数）。
  - `%%`: 打印一个字面意义的 `%` 符号。

**格式化的精髓——修饰符 (Modifiers)**
在 `%` 和字母之间可以加入修饰符来控制格式。

  - **宽度 (Width)**: `%10s` 表示总宽度为10个字符，默认右对齐。
  - **对齐 (Alignment)**: `%-10s` 在宽度前加一个 `-` 号，表示左对齐。
  - **填充 (Padding)**: `%04d` 表示一个宽度为4的整数，不足部分用 `0` 填充。
  - **精度 (Precision)**: `%.2f` 表示一个浮点数，保留小数点后两位。

**示例 1：打印对齐的表格**
这是 `printf` 最典型的应用场景，`echo` 很难做到。

```bash
#!/bin/bash

# 打印表头，- 表示左对齐，数字表示宽度
printf "%-5s %-15s %-10s\n" "ID" "用户名" "状态"
printf "%s\n" "----------------------------------"

# 打印数据行
ID=101
USERNAME="Alice"
STATUS="Active"
printf "%-5d %-15s %-10s\n" "$ID" "$USERNAME" "$STATUS"

ID=8
USERNAME="Bob"
STATUS="Inactive"
printf "%-5d %-15s %-10s\n" "$ID" "$USERNAME" "$STATUS"

ID=2042
USERNAME="Charlie"
STATUS="Pending"
printf "%-5d %-15s %-10s\n" "$ID" "$USERNAME" "$STATUS"
```

**执行结果：**

```
ID    用户名           状态      
----------------------------------
101   Alice           Active    
8     Bob             Inactive  
2042  Charlie         Pending   
```

**示例 2：格式化数字**

```bash
MONTH=9
DAY=5
TEMPERATURE=28.125

# 格式化日期，不足两位的用 0 填充
printf "今天的日期是: 2025-%02d-%02d\n" $MONTH $DAY

# 格式化温度，保留一位小数
printf "当前室外温度是: %.1f°C\n" $TEMPERATURE
```

**执行结果：**

```
今天的日期是: 2025-09-05
当前室外温度是: 28.1°C
```

-----

### 方法三：结合 `tput` 和 `printf` (更专业、可移植的颜色输出)

硬编码 ANSI 转义码 (`\e[31m`) 有时在极少数终端上可能不兼容。`tput` 命令会查询终端的 `terminfo` 数据库，获取当前终端**正确**的控制代码，是更健壮的做法。

```bash
#!/bin/bash

# 1. 使用 tput 将颜色代码存入变量
RED=$(tput setaf 1)
GREEN=$(tput setaf 2)
BOLD=$(tput bold)
RESET=$(tput sgr0) # sgr0 表示重置所有格式

# 2. 使用 printf 和这些变量来输出
printf "这是一条%s错误%s消息。\n" "$RED" "$RESET"
printf "这是一条%s%s成功%s消息。\n" "$BOLD" "$GREEN" "$RESET"
```

这种方式将格式化逻辑（颜色）和内容分离开来，代码更清晰，也更专业。

### 总结

| 特性       | `echo -e`      | `printf`            |
| :------- | :------------- | :------------------ |
| **主要用途** | 简单的单行输出、快速添加颜色 | 精确的文本对齐、数字格式化、多行模板  |
| **自动换行** | **是** (默认)     | **否** (必须手动加 `\n`)  |
| **格式控制** | 弱 (只有颜色和基础样式)  | **强** (宽度、对齐、精度、填充) |
| **可靠性**  | 较弱 (不同版本行为有差异) | **非常可靠** (行为标准、可预测) |

**最终建议：**

  - 如果只是想快速打印一行带颜色的提示信息，用 `echo -e` 没问题。
  - 在任何需要**对齐**、**格式化数字**或**构建结构化文本**的场景，**请毫不犹豫地使用 `printf`**。它是编写高质量、专业 Shell 脚本的不二之选。