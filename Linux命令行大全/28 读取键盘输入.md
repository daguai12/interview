### 28.1 read——从标准输入读取值

  - **核心功能**：`read` 命令用于从标准输入（通常是键盘）读取一行文本，并将其赋值给一个或多个变量。
  - **基本用法**：
      - `read var`：读取整行内容，存入变量 `var`。
      - `read var1 var2`：读取一行，按空格拆分，第一个词存入 `var1`，第二个词存入 `var2`，以此类推。如果输入的值比变量多，剩下的所有值都会存入最后一个变量。
      - `read` (不带变量)：读取的所有内容存入一个默认变量 `REPLY`。

**关键示例 1：读取并验证一个整数**
这个例子展示了如何获取用户输入，然后用我们之前学过的 `[[ ]]` 进行验证。

```bash
#!/bin/bash
# read-integer: 读取并验证整数

echo -n "请输入一个整数 -> " # -n 选项让光标停在同一行
read int

if [[ "$int" =~ ^-?[0-9]+$ ]]; then
  if (( int == 0 )); then
    echo "输入的是 0."
  elif (( int < 0 )); then
    echo "输入的是负数."
  else
    echo "输入的是正数."
  fi
else
  echo "错误：输入的不是整数。" >&2
  exit 1
fi
```

#### 28.1.1 选项

`read` 命令有很多有用的选项来控制其行为。

  - `-p "提示信息"`：\*\*（最常用）\*\*在读取前显示提示语，可以替代 `echo -n`。
  - `-s`：\*\*（用于密码）\*\*静默模式，输入的内容不显示在屏幕上。
  - `-t 秒数`：\*\*（用于超时）\*\*设置一个等待输入的超时时间，超时后 `read` 会失败。
  - `-n 字符数`：读取指定数量的字符后立即结束，而不是等用户按回车。

**关键示例 2：带提示、超时和静默输入的密码输入**

```bash
#!/bin/bash
# read-secret: 读取机密信息

if read -t 10 -sp "请输入你的密码 (10秒内) > " password; then
  echo -e "\n读取成功！" # -e 让 \n 生效
else
  echo -e "\n超时了！" >&2
  exit 1
fi
```

#### 28.1.2 IFS

  - **`IFS` (Internal Field Separator)**：内部字段分隔符。

      - `read` 命令默认使用空格、Tab或换行来分割单词。
      - 你可以**临时**修改 `IFS` 来处理用其他符号（如冒号 `:`）分隔的数据，这在解析文件时非常有用。

  - **`<<<` (Here String)**：将一个字符串作为命令的标准输入。

      - 这是向 `read` 喂送变量数据的**最佳方式**，可以有效避免在管道 `|` 中使用 `read` 导致的变量失效问题。

**关键示例 3：解析以冒号分隔的数据**
这个例子完美结合了 `IFS` 和 `<<<`，是从一个变量中解析结构化数据的经典用法。

```bash
#!/bin/bash
# read-ifs: 解析 /etc/passwd 中的用户信息

# 模拟从文件中查找到的一行数据
user_info="root:x:0:0:root:/root:/bin/bash"

# 临时将 IFS 设置为冒号，然后用 read 解析字符串
IFS=':' read user pass uid gid name home shell <<< "$user_info"

echo "用户名: $user"
echo "家目录: $home"
echo "默认Shell: $shell"
```

> **重点提醒：别把 read 放入管道**
>
> **永远不要**写这样的代码：`echo "data" | read var`。
>
> **原因**：管道符 `|` 会创建一个**子 Shell**来运行右边的命令。`read` 在子 Shell 中成功给 `var` 赋了值，但子 Shell 一结束，这个变量就跟着消失了，无法在当前脚本中继续使用。
>
> **正确做法**：始终使用 **here string**：`read var <<< "$data"`。

### 28.2 验证输入

  - **核心思想**：健壮的脚本必须能处理用户的意外或错误输入。在接收任何用户输入后，都应该进行**验证 (Validation)**，以确保数据的合法性和安全性，特别是当脚本要执行删除文件等高危操作时。

  - **验证方法**：主要利用 `[[ ... ]]` 中的正则表达式和各种测试条件来检查输入格式。

**关键示例：一个多功能输入验证脚本**
这个脚本演示了如何对用户的单行输入进行多种类型的检查。

```bash
#!/bin/bash
# read-validate: 验证输入

# 1. 定义一个用于处理无效输入的函数，避免代码重复
invalid_input () {
  echo "错误: 无效输入 '$REPLY'" >&2
  exit 1
}

read -p "请输入任意内容 > "

# 2. 验证：输入是否为空？
[[ -z "$REPLY" ]] && invalid_input

# 3. 验证：输入是否包含多个单词？（通过管道和 wc -w 统计单词数）
(( "$(echo "$REPLY" | wc -w)" > 1 )) && invalid_input

# 4. 验证：是否为有效的文件名？（只包含字母、数字、点、下划线、连字符）
if [[ "$REPLY" =~ ^[-[:alnum:]\._]+$ ]]; then
  echo "'$REPLY' 是一个有效的文件名。"
  # 如果是，再检查文件是否存在
  if [[ -e "$REPLY" ]]; then
    echo "并且 '$REPLY' 这个文件已存在。"
  else
    echo "但 '$REPLY' 这个文件不存在。"
  fi
else
  echo "'$REPLY' 不是一个有效的文件名。"
fi

# 5. 验证：是否为整数？
if [[ "$REPLY" =~ ^-?[[:digit:]]+$ ]]; then
  echo "'$REPLY' 是一个整数。"
fi
```

**关键技巧总结：**

  - **函数封装**：将重复的错误处理逻辑（如 `invalid_input`）封装成函数。
  - **正则为王**：使用 `[[ ... =~ REGEX ]]` 是验证输入格式最强大的工具。
  - **组合检查**：可以层层嵌套 `if` 语句，进行多维度、由浅入深的检查。

-----

### 28.3 菜单

  - **核心思想**：通过向用户展示一个带编号的选项列表，引导用户进行交互，让程序更友好、易用。这是一种非常常见的交互式程序设计模式。

  - **实现步骤**：

    1.  用 `echo` 显示多行菜单选项。
    2.  用 `read` 获取用户的数字选择。
    3.  用 `if` (或 `case`) 语句判断用户的选择。
    4.  执行与选择对应的命令。
    5.  在每个选项执行完毕后用 `exit` 退出脚本，防止执行后续代码。

**关键示例：一个系统信息查询菜单**
这个脚本清晰地展示了“显示菜单 -\> 获取输入 -\> 判断 -\> 执行”的完整流程。

```bash
#!/bin/bash
# read-menu: 菜单驱动的系统信息程序

clear # 先清屏
# 1. 显示菜单
echo "
请选择:
  1. 显示系统信息
  2. 显示磁盘空间
  3. 显示家目录使用情况
  4. 退出
"
# 2. 获取用户输入
read -p "输入选项 [0-3] > "

# 3. 验证并执行
if [[ "$REPLY" =~ ^[0-3]$ ]]; then # 确保输入是0-3的单个数字
  if [[ "$REPLY" == 0 ]]; then
    echo "程序已终止。"
    exit
  fi
  if [[ "$REPLY" == 1 ]]; then
    echo "主机名: $HOSTNAME"
    uptime
    exit
  fi
  if [[ "$REPLY" == 2 ]]; then
    df -h
    exit
  fi
  if [[ "$REPLY" == 3 ]]; then
    # 判断是否为 root 用户，显示不同内容
    if [[ "$(id -u)" -eq 0 ]]; then
      echo "所有用户的家目录使用情况"
      du -sh /home/*
    else
      echo "当前用户的家目录使用情况 ($USER)"
      du -sh "$HOME"
    fi
    exit
  fi
else
  echo "错误：无效的选项 '$REPLY'" >&2
  exit 1
fi
```