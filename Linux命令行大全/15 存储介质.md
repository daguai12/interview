### 15.1 存储设备的挂载与卸载

本节详细介绍了 Linux 系统中管理存储设备的核心概念——**挂载 (mount)** 和 **卸载 (umount)**。与 Windows 为每个设备分配一个盘符（如 `C:`）不同，Linux 维护着一个单一的文件系统树，所有外部设备都必须“挂接”到这个树上的某个目录（称为**挂载点**）才能被访问。

-----

#### 摘要

##### 1\. `/etc/fstab` 文件 - 自动挂载配置

  * `/etc/fstab` (File System Table) 是一个核心配置文件，它定义了系统在**启动时**需要自动挂载的设备列表。
  * 文件中的每一行代表一个设备，包含六个关键字段：
    1.  **设备标识**: 可以是设备文件名 (`/dev/sda1`)，但现代系统更常用**LABEL**或**UUID**来唯一标识设备，避免因插拔顺序改变导致名称变化。
    2.  **挂载点**: 设备在文件系统树上挂接的目录。
    3.  **文件系统类型**: 如 `ext4` (Linux原生), `vfat` (FAT32), `ntfs`, `iso9660` (CD-ROM) 等。
    4.  **挂载选项**: 如 `rw` (读写), `ro` (只读), `defaults` (默认选项) 等。
    5.  **备份频率**: `dump` 命令使用。
    6.  **检查顺序**: `fsck` 命令在启动时检查文件系统的顺序。

##### 2\. `mount` 和 `umount` 命令 - 手动管理

  * **`mount`**:
      * 不带任何参数执行 `mount`，可以**查看当前已经挂载的所有文件系统**列表。
      * 用于手动挂载设备，基本语法为：`mount -t [文件系统类型] [设备名] [挂载点目录]`。
  * **`umount`**:
      * 用于卸载设备，可以将设备名或挂载点作为参数：`umount [设备名或挂载点]`。
      * **卸载的重要性**: Linux 为了提高性能，会将写入操作的数据先放入内存**缓冲区**，稍后再同步到物理设备。执行 `umount` 会强制将缓冲区的所有数据写入设备，确保数据完整性。**如果在移除设备前不执行卸载，可能会导致数据丢失或文件系统损坏！**
      * **"Device is busy" 错误**: 如果有任何程序正在使用挂载点目录（例如，你当前的终端正位于该目录下），系统会阻止卸载并报错。解决方法是退出该目录再执行卸载。

##### 3\. 如何确定设备名称

在需要手动挂载时，首先要确定系统为设备分配了什么名称。

  * **常见命名规则**:
      * `/dev/sd*`: SCSI 磁盘。在现代 Linux 中，SATA 硬盘、U 盘、SD 卡等都被识别为此类设备 (如 `/dev/sdb`, `/dev/sdc1`)。
      * `/dev/sr*`: 光驱设备。
      * `/dev/hd*`: 老式 IDE 硬盘。
  * **实时查看内核日志 (最可靠的方法)**:
    通过 `tail -f /var/log/messages` 或 `tail -f /var/log/syslog` 命令可以实时监控系统日志。当你插入一个新设备（如 U 盘）时，日志会立即打印出内核识别该设备的过程，并明确显示出分配给它的设备名（如 `[sdb]: sdb1`）。

-----

### 使用案例：手动挂载一个 USB 闪存盘

这个案例模拟了在一个不会自动挂载设备的服务器环境下，如何手动挂载 U 盘。

1.  **第一步：找出 U 盘的设备名**

      * 首先，以超级用户权限打开一个终端，实时监控系统日志。
        ```bash
        sudo tail -f /var/log/syslog
        ```
      * 然后，将你的 U 盘插入电脑。
      * 观察终端输出，你会看到类似下面这样的信息，它告诉你设备被识别为 `sdb`，并且有一个分区 `sdb1`。
        ```
        ... kernel: [sdb] Attached SCSI removable disk
        ... kernel: sdb: sdb1
        ```
      * 记下这个设备名 `/dev/sdb1`，然后按 `Ctrl + C` 退出 `tail` 命令。

2.  **第二步：创建一个挂载点**
    挂载点就是一个普通的目录。我们通常在 `/mnt` 或 `/media` 目录下创建它。

    ```bash
    sudo mkdir /mnt/my_usb
    ```

3.  **第三步：手动挂载 U 盘**
    使用 `mount` 命令将设备挂载到我们刚创建的目录上。假设 U 盘是常见的 FAT32 格式 (`vfat`)。

    ```bash
    # -t vfat 告诉 mount 命令文件系统类型是 vfat
    sudo mount -t vfat /dev/sdb1 /mnt/my_usb
    ```

      * 如果没有报错，就表示挂载成功了。

4.  **第四步：访问 U 盤并验证**
    现在你可以像访问普通目录一样访问 U 盘里的文件了。

    ```bash
    ls /mnt/my_usb
    cd /mnt/my_usb
    ```

    你也可以用不带参数的 `mount` 命令或 `df` 命令来确认它是否被正确挂载。

    ```bash
    mount | grep 'sdb1'
    # 或者
    df -h
    ```

5.  **第五步：安全卸载 U 盘**
    使用完毕后，**必须先卸载再拔出**！

      * **重要**: 确保你当前的终端不在 `/mnt/my_usb` 目录内，否则会遇到 "device is busy" 错误。先 `cd` 到其他地方。
        ```bash
        cd ~
        ```
      * 执行卸载命令。
        ```bash
        sudo umount /dev/sdb1
        ```
      * 卸载完成后，就可以安全地拔出 U 盘了。


### 15.2 创建新文件系统

本节介绍了如何在 Linux 系统上为一个存储设备（如 U 盘）创建新的文件系统，这个过程通常被称为**格式化**。它主要包含两个步骤：**分区**和**创建文件系统**。

**⚠️ 严重警告：** 以下操作将会**完全清除**指定设备上的所有数据！在执行前，请务必备份重要文件，并再三确认你操作的设备名 (`/dev/sdX`) 是正确的，以免误格式化你的系统硬盘。

-----

#### 摘要

##### 1\. 第一步：使用 `fdisk` 管理分区

`fdisk` 是一个强大但底层的命令行分区工具，用于创建、删除和修改磁盘分区表。

  * **启动**: `sudo fdisk [设备名]`，注意这里使用的是整个设备的名称（如 `/dev/sdb`），而不是分区名（如 `/dev/sdb1`）。
  * **交互式命令**: `fdisk` 启动后会进入一个交互式环境，你需要输入单个字母的命令来执行操作。常用命令包括：
      * `m`: 显示帮助菜单。
      * `p`: **打印 (Print)** 并显示当前设备的分区表，这是开始操作前必看的一步。
      * `d`: **删除 (Delete)** 一个已存在的分区。
      * `n`: **新建 (New)** 一个分区。
      * `t`: **更改 (Type)** 一个分区的系统 ID。例如，`83` 代表 Linux 文件系统，`b` 或 `c` 代表 FAT32。
      * `l`: 列出所有已知的文件系统类型 ID。
      * `w`: **写入 (Write)** 并保存所有修改到磁盘，然后退出。**这是真正执行修改的命令**。
      * `q`: **退出 (Quit)** 而不保存任何修改。

**核心机制**：在 `fdisk` 中进行的所有操作都先保存在内存里，只有当你输入 `w` 命令后，这些更改才会被真正写入到物理设备上。

##### 2\. 第二步：使用 `mkfs` 创建文件系统（格式化）

`mkfs` (make filesystem) 命令用于在**一个已经存在的分区上**创建文件系统，即格式化。

  * **基本语法**: `sudo mkfs -t [文件系统类型] [分区名]`
  * **文件系统类型**:
      * `ext4`: 当前 Linux 系统最常用、最推荐的原生文件系统类型。
      * `vfat`: 即 FAT32，用于需要在 Windows、macOS 和 Linux 系统间交换数据，兼容性好。
      * 其他还有 `ntfs`, `xfs` 等。

-----

### 使用案例：将一个 U 盘完整格式化为 `ext4` 格式

这个案例将带你走完从分区到格式化的完整流程。假设我们的 U 盘设备名为 `/dev/sdb`。

1.  **第一步：卸载设备**
    如果 U 盘已经被系统自动挂载，必须先卸载它。

    ```bash
    sudo umount /dev/sdb1
    ```

2.  **第二步：进入 `fdisk` 进行分区**

    ```bash
    sudo fdisk /dev/sdb
    ```

    接下来是在 `fdisk` 的交互环境内操作：

      * 输入 `p` 查看当前分区。假设我们看到一个 `/dev/sdb1` 的分区。
      * 输入 `d` 删除旧分区。如果只有一个分区，它会被自动选中；否则会提示你选择。
      * 输入 `n` 创建一个新分区。它会引导你完成一系列设置（如主分区/扩展分区、分区号、起始和结束扇区）。对于一个 U 盤，通常一路按回车使用默认值即可，这会创建一个占据整个 U 盘空间的主分区。
      * 输入 `p` 再次确认新的分区表是否正确（现在应该有一个新的 `/dev/sdb1`，类型默认为 `Linux`）。
      * 确认无误后，输入 `w` 将更改写入磁盘并退出。

3.  **第三步：格式化新分区**
    现在我们有了一个干净的 `/dev/sdb1` 分区，接下来使用 `mkfs` 将它格式化为 `ext4`。

    ```bash
    sudo mkfs -t ext4 /dev/sdb1
    ```

    等待命令执行完成，屏幕上会输出格式化的详细信息。

4.  **完成**
    至此，你的 U 盤已经被成功地分区并格式化为 `ext4` 文件系统了。现在你可以像之前一样，通过 `mount` 命令将 `/dev/sdb1` 挂载到系统上进行使用了。

    ```bash
    sudo mkdir /mnt/new_usb
    sudo mount /dev/sdb1 /mnt/new_usb
    ls /mnt/new_usb
    ```


### 15.3 文件系统的检查和修复

本节介绍了 Linux 系统中用于**检查和修复文件系统**完整性的重要工具——`fsck` (File System Check)。

-----

#### 摘要

##### 1\. `fsck` 的作用与时机

  * **主要功能**: `fsck` 用于扫描文件系统，查找并尝试修复因意外断电、硬件故障或其他原因导致的错误和不一致性。
  * **自动检查**: 在系统**每次启动时**，`fsck` 会自动运行，检查 `/etc/fstab` 文件中标记需要检查的设备（通常是本地硬盘分区）。
      * `/etc/fstab` 文件每行末尾的数字决定了检查顺序和是否检查。数字 `0` 表示跳过检查。
  * **手动检查**: 你也可以手动对**已卸载**的设备运行 `fsck` 命令，这在怀疑存储设备（如 U 盘）有问题时非常有用。

##### 2\. `lost+found` 目录

  * 如果 `fsck` 在修复过程中发现了无法归类到任何已知文件或目录的数据块（即“孤儿”文件），它会把这些恢复的数据放入该文件系统根目录下的 `lost+found` 目录中。之后你可以检查这个目录，尝试找回丢失的数据。

##### 3\. 现代文件系统的健壮性

  * 现代的文件系统（如 `ext4`）具有**日志 (journaling)** 功能，这极大地增强了其稳定性。因此，在正常情况下，文件系统损坏的事件已经变得非常少见。通常只有在硬件发生故障时，才需要手动进行深度的文件系统修复。

-----

### 使用案例：手动检查 U 盘的文件系统

这个案例演示了当你怀疑一个 U 盘可能有问题时，如何安全地对其进行检查。假设我们的 U 盘分区为 `/dev/sdb1`。

1.  **第一步：必须先卸载设备**
    在执行 `fsck` 之前，目标设备**绝对不能**处于挂载状态，否则可能会导致更严重的数据损坏。

    ```bash
    # 假设U盘挂载在 /mnt/usb
    sudo umount /mnt/usb

    # 或者直接使用设备名卸载
    sudo umount /dev/sdb1
    ```

2.  **第二步：执行 `fsck` 命令**
    以超级用户权限对指定分区运行 `fsck`。

    ```bash
    sudo fsck /dev/sdb1
    ```

3.  **第三步：解读输出结果**

      * **如果文件系统健康**:
        你会看到类似下面的输出，表明文件系统是“干净的”(clean)，没有发现任何问题。
        ```
        fsck from util-linux 2.34
        e2fsck 1.45.5 (07-Jan-2020)
        /dev/sdb1: clean, 11/4880 files, 1325/19531 blocks
        ```
      * **如果文件系统存在问题**:
        `fsck` 会检测到错误，并**交互式地**询问你是否要修复它们。例如：
        ```
        ...
        Inode 123 has an invalid block count. Fix? (y/n)
        ```
        在这种情况下，通常一路输入 `y` (yes) 来让 `fsck` 尝试修复所有它发现的问题。

4.  **第四步：使用 `-y` 选项自动修复**
    如果你信任 `fsck` 的判断，并且不想手动确认每一个修复步骤，可以使用 `-y` 选项来让它自动回答“yes”。

    ```bash
    sudo fsck -y /dev/sdb1
    ```

    这在处理大量错误时非常方便，但要谨慎使用。

完成检查和修复后，你就可以重新挂载设备并正常使用了。