### 11.1 环境中都保存了什么

本节介绍了 Shell **环境 (Environment)** 的概念，它是一个存储着各类数据的集合，这些数据会影响 Shell 会话以及由 Shell 启动的程序的行为。

***

#### 摘要

##### 1. 环境中存储的数据类型

Shell 环境主要包含两种变量类型，以及两种程序化数据：

* **环境变量 (Environment Variables)**: 可被当前 Shell 会话以及它所创建的任何子进程（即从该 Shell 启动的程序）访问和使用。
* **Shell 变量 (Shell Variables)**: 仅在定义它们的 Shell 实例中有效，子进程无法访问。
* **别名 (Aliases)**: 命令的短别名，在第5章已有介绍。
* **Shell 函数 (Shell Functions)**: 更复杂的命令集合，类似于小型脚本。

##### 2. 查看环境内容的命令

有多个内建命令可以用来检查环境中的不同部分：

* **`printenv`**: **只显示环境变量**。可以单独使用 `printenv | less` 查看全部，或用 `printenv VARIABLE_NAME` 查看特定变量的值。
* **`set`**: 显示内容最全面，包括**环境变量、Shell 变量和 Shell 函数**。输出结果按字母顺序排列。
* **`echo $VARIABLE_NAME`**: 最常用于查看**单个变量**的值。例如 `echo $HOME`。
* **`alias`**: **只显示当前定义的所有别名**。

##### 3. 值得注意的关键环境变量

环境中包含了大量变量，其中一些对系统的日常操作至关重要：

| 变量           | 含义和作用                                                           |
| :----------- | :-------------------------------------------------------------- |
| **`PATH`**   | **命令搜索路径**。它是一个由冒号分隔的目录列表，当你输入一个命令时，Shell 会按顺序在这些目录中查找对应的可执行文件。 |
| **`HOME`**   | 当前用户的**主目录**路径。                                                 |
| **`USER`**   | 当前登录的**用户名**。                                                   |
| **`SHELL`**  | 当前正在使用的 **Shell 程序**的路径（如 `/bin/bash`）。                         |
| **`PWD`**    | **当前工作目录** (Present Working Directory) 的路径。                     |
| **`OLDPWD`** | **上一个工作目录**的路径，`cd -` 命令会使用这个变量。                                |
| **`PS1`**    | **主命令提示符**的定义。它决定了你在终端看到的提示符样式（如 `[me@linuxbox ~]$`）。           |
| **`LANG`**   | 定义了系统的**语言和字符集**设置。                                             |
| **`TERM`**   | 当前使用的**终端类型**名称。                                                |
| **`PAGER`**  | 指定用于分页显示长文本的程序，通常是 `less`。                                      |


### 11.2 如何建立环境

本节解释了 Shell 环境是如何在用户启动一个 Shell 会话时建立起来的。这个过程依赖于 Bash 读取一系列被称为**启动文件 (startup files)** 的配置脚本。

-----

#### 摘要

##### 1\. Shell 会话的两种类型

  * **登录 Shell (Login Shell)**: 需要输入用户名和密码进入的会话 (如 SSH 登录)。
      * 加载顺序: `/etc/profile` -\> `~/.bash_profile` 或 `~/.profile`。
  * **非登录 Shell (Non-Login Shell)**: 在图形界面中打开终端窗口。
      * 加载顺序: `/etc/bash.bashrc` -\> `~/.bashrc`。

##### 2\. `~/.bashrc` 的核心地位

由于 `~/.bash_profile` (或 `.profile`) 文件中通常会有一段代码去加载 `~/.bashrc`，因此 `~/.bashrc` 成为了**最常用、最重要的个人配置文件**，无论哪种 Shell 模式通常都会加载它。

-----

### 使用案例 (Practical Examples)

下面通过三个实际操作，来体验如何修改和利用这些启动文件。

#### 案例一：添加自定义别名到 `~/.bashrc`

让我们创建一个自定义别名 `cls` 来实现 `clear` 命令的功能。

1.  **编辑 `~/.bashrc` 文件**
    使用你喜欢的编辑器（这里用 `nano`）打开文件。

    ```bash
    nano ~/.bashrc
    ```

2.  **在文件末尾添加别名**
    滚动到文件最后，添加下面这一行：

    ```bash
    # My custom alias
    alias cls='clear'
    ```

3.  **保存并退出**
    在 `nano` 中，按 `Ctrl + X`，然后按 `Y`，最后按 `Enter` 保存。

4.  **让配置生效**
    新配置不会立即在当前终端生效。你有两个选择：

      * **方法A (推荐)**: 打开一个**新的终端窗口**。新的 Shell 会话会重新读取 `.bashrc` 文件。
      * **方法B (当前终端)**: 使用 `source` 命令立即加载配置。
        ```bash
        source ~/.bashrc
        ```

5.  **测试别名**
    现在，无论是在新终端还是 `source` 过的终端里，你都可以使用新别名了。

    ```bash
    cls  # 这个命令现在等同于 clear
    ```

    这个例子证明了 `~/.bashrc` 是放置个人常用配置（如别名）的绝佳位置。

#### 案例二：将个人脚本目录添加到 `PATH`

假设你写了一些自己的脚本，希望能在任何地方直接运行它们，而不用输入完整路径。

1.  **创建个人脚本目录**
    在家目录下创建一个名为 `bin` 的目录（如果它不存在的话）。

    ```bash
    mkdir -p ~/bin
    ```

2.  **创建一个测试脚本**
    在 `~/bin` 目录里创建一个名为 `hello.sh` 的文件。

    ```bash
    nano ~/bin/hello.sh
    ```

    在文件中写入以下内容：

    ```bash
    #!/bin/bash
    echo "Hello from my custom script in ~/bin!"
    ```

    保存并退出。

3.  **赋予脚本执行权限**
    这是一个非常关键的步骤！

    ```bash
    chmod +x ~/bin/hello.sh
    ```

4.  **将 `~/bin` 添加到 PATH**
    编辑 `~/.bashrc` 或 `~/.profile` 文件（对于别名和函数等，`.bashrc` 更常用）。在文件末尾添加：

    ```bash
    # Add my personal bin directory to PATH
    export PATH="$HOME/bin:$PATH"
    ```

      * **解释**: 这行代码的意思是：将 `$HOME/bin` 目录（也就是 `~/bin`）添加到现有 `PATH` 变量的最前面。加在前面意味着 Shell 会优先搜索你的个人目录。

5.  **让配置生效并测试**
    打开一个**新的终端窗口**，然后切换到**任意其他目录**，比如 `/tmp`。

    ```bash
    cd /tmp
    hello.sh
    ```

    你会看到脚本成功执行并打印出信息。这证明了 `PATH` 变量的作用——让 Shell 能够在指定的目录列表中找到并执行命令。

#### 案例三：理解 `export` 的作用（Shell变量 vs 环境变量）

这个例子清晰地展示了 `export` 命令的威力。

1.  **创建一个普通的 Shell 变量**
    在你的终端里，定义一个变量：

    ```bash
    MY_SECRET="This is a local secret"
    ```

2.  **在当前 Shell 中验证**
    你可以正常打印出它的值：

    ```bash
    echo $MY_SECRET
    # 输出: This is a local secret
    ```

3.  **进入一个子 Shell**
    通过直接输入 `bash`，你会启动一个新的 Shell 会话，它是当前 Shell 的“子进程”。

    ```bash
    bash
    ```

    你的提示符可能看起来没什么变化，但你已经进入了一个新的 Shell 环境。

4.  **在子 Shell 中尝试访问变量**

    ```bash
    echo $MY_SECRET
    # 输出: (一片空白)
    ```

    你会发现，子 Shell **无法访问**在父 Shell 中定义的普通变量。

5.  **退出子 Shell，回到父 Shell**

    ```bash
    exit
    ```

6.  **现在，使用 `export` 导出变量**
    我们将刚才的 Shell 变量“升级”为环境变量。

    ```bash
    export MY_SECRET
    ```

7.  **再次进入子 Shell**

    ```bash
    bash
    ```

8.  **在子 Shell 中再次访问变量**

    ```bash
    echo $MY_SECRET
    # 输出: This is a local secret
    ```

    成功了！`export` 命令的作用就是“发布”一个变量，让所有从当前 Shell 启动的子进程都能看到并使用它。这就是为什么 `PATH` 这样的重要变量必须被 `export` 的原因。


### 11.3 修改环境

本节主要讲述了如何通过编辑 Shell 启动文件来**自定义和修改**你的 Shell 环境，包括应该修改哪些文件、使用什么工具，以及如何让修改生效。

-----

#### 摘要

##### 1\. 应该修改哪些文件？

为了自定义环境，通常需要编辑位于你**主目录 (`~`)** 下的隐藏文件。一个通用的最佳实践是：

  * **`~/.bash_profile`** (或在 Ubuntu 等系统上的 **`~/.profile`**): 用于定义**环境变量**，比如修改 `PATH` 变量。
  * **`~/.bashrc`**: 用于定义别名、Shell 函数，以及设置 Shell 相关的选项（如命令历史记录）。

**核心建议**：除非你是系统管理员且需要为所有用户修改配置，否则应始终编辑你主目录下的个人配置文件，而不是 `/etc/` 目录下的全局配置文件。

##### 2\. 使用文本编辑器

修改配置文件需要使用**文本编辑器**。文本编辑器分为两类：

  * **图形化编辑器**: 如 `gedit` (GNOME桌面) 或 `kate` (KDE桌面)，使用起来像记事本一样直观。
  * **基于终端的编辑器**: 如 `nano` (简单易用)、`vi`/`vim` (功能强大)、`emacs`。

##### 3\. 让修改生效

对启动文件（如 `.bashrc`）的修改不会立即在当前 Shell 中生效，因为这些文件只在 Shell 启动时被读取。你有两种方法来应用这些修改：

1.  **关闭并重新打开**一个新的终端窗口。
2.  在当前终端中，使用 `source` 命令**立即加载**配置文件，例如：
    ```bash
    source ~/.bashrc
    ```

-----

### 使用案例：自定义你的 `.bashrc` 文件

这个案例将带你完成一次完整的环境修改流程：**备份 -\> 编辑 -\> 添加配置 -\> 添加注释 -\> 生效**。

**目标**：优化命令历史记录的设置，并添加几个方便的 `ls` 别名。

1.  **第一步：备份！（重要）**
    在修改任何重要配置文件之前，先创建一个备份，以防出错。

    ```bash
    cp ~/.bashrc ~/.bashrc.bak
    ```

2.  **第二步：使用 `nano` 编辑文件**
    `nano` 是一个对新手非常友好的终端编辑器。

    ```bash
    nano ~/.bashrc
    ```

3.  **第三步：添加新配置和注释**
    使用方向键移动到文件末尾，添加以下内容。**注释 (`#` 开头) 非常重要**，它能帮助你未来回忆起这些代码是做什么的。

    ```bash
    # ===============================================
    # My Custom Bash Settings
    # ===============================================

    # 1. History Control: Ignore duplicate commands and increase history size.
    # 让历史记录忽略连续重复的命令，并将记录上限增加到1000条
    export HISTCONTROL=ignoredups
    export HISTSIZE=1000

    # 2. Make file sharing easier by default.
    # 更改默认的umask，方便目录共享
    umask 0002

    # 3. Add some useful aliases for ls.
    # 添加一些实用的ls别名
    alias ll='ls -l --color=auto'      # ll = 详细列表
    alias l.='ls -d .* --color=auto'  # l. = 只显示隐藏文件和目录
    ```

4.  **第四步：保存并退出 `nano`**

      * 按下 **`Ctrl + O`** (Write**O**ut)，然后按 `Enter` 键保存文件。
      * 按下 **`Ctrl + X`** (e**X**it) 退出编辑器。

5.  **第五步：让配置在当前终端生效**
    执行 `source` 命令来重新加载你的 `.bashrc` 文件。

    ```bash
    source ~/.bashrc
    ```

6.  **第六步：测试新功能**

      * **测试别名**: 输入你新创建的别名 `ll`，看看它是否能正常工作。
        ```bash
        ll
        ```
        你应该能看到 `ls -l` 的长列表格式输出。
      * **测试历史记录**: 连续输入同一个命令两次（例如 `echo "test"`），然后按上方向键，你会发现历史记录中只有一个 `echo "test"`，因为 `ignoredups` 生效了。

通过以上步骤，你就成功地自定义了自己的 Shell 环境！


