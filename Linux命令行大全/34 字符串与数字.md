
### 34.1 参数扩展

  - **核心思想**：参数扩展是 Shell 的一项核心功能，它不仅仅是获取变量值 (`$a`)。Bash 提供了多种强大的扩展语法，可以处理空值、执行字符串操作等，通常比调用外部命令（如 `sed`, `cut`, `wc`）**快得多**。
  - **最佳实践**：除非你特意需要“单词分割”功能，否则**始终用双引号把参数扩展包围起来** (`"${VAR}"`)，以防止因空格等特殊字符导致意外错误。

-----

#### 34.1.1 基本参数

  - **`$a` 与 `${a}`**：这两者基本等价，都是获取变量 `a` 的值。
  - **何时必须用 `${a}`**：当变量名后面紧跟着其他字符，可能引起混淆时，必须使用花括号来明确界定变量名的范围。

**关键示例：**

```bash
[me@linuxbox ~]$ a="foo"

# 错误：Shell 试图扩展一个不存在的变量 $a_file
[me@linuxbox ~]$ echo "$a_file"

# 正确：使用花括号明确指定变量是 a
[me@linuxbox ~]$ echo "${a}_file"
foo_file
```

-----

#### 34.1.2 管理空变量扩展

这些扩展是编写健壮脚本的利器，用于处理变量未设置或为空的情况。

  - `${parameter:-word}` (**使用默认值**): 如果 `parameter` 为空，则使用 `word` 作为本次扩展的结果（`parameter` 本身**不变**）。
    ```bash
    [me@linuxbox ~]$ unset var
    [me@linuxbox ~]$ echo "${var:-default}"
    default
    [me@linuxbox ~]$ echo "$var"
    # (输出为空，var 自身未被赋值)
    ```
  - `${parameter:=word}` (**赋值默认值**): 如果 `parameter` 为空，则使用 `word` 作为结果，**并且将 `word` 赋值给 `parameter`**。
    ```bash
    [me@linuxbox ~]$ unset var
    [me@linuxbox ~]$ echo "${var:=default}"
    default
    [me@linuxbox ~]$ echo "$var"
    default # var 自身也被赋值了
    ```
  - `${parameter:?word}` (**为空则报错**): 如果 `parameter` 为空，则脚本**立即退出**，并打印 `word` 作为错误信息。
    ```bash
    [me@linuxbox ~]$ unset var
    [me@linuxbox ~]$ echo "${var:?Error: Variable is not set.}"
    bash: var: Error: Variable is not set.
    ```
  - `${parameter:+word}` (**不为空则使用 `word`**): 如果 `parameter` **不为空**，则整个表达式的结果是 `word`，否则结果为空。
    ```bash
    [me@linuxbox ~]$ var="value"
    [me@linuxbox ~]$ echo "${var:+replacement}"
    replacement
    ```

-----

#### 34.1.3 返回变量名的扩展

  - `${!prefix*}` 或 `${!prefix@}`：这个特殊的扩展会返回所有以 `prefix` **开头**的**变量名**列表。
    ```bash
    [me@linuxbox ~]$ echo ${!BASH*}
    BASH BASH_ARGC BASH_ARGV BASH_COMMAND ...
    ```

-----

#### 34.1.4 字符串操作

这是参数扩展最强大的部分，可以直接在 Shell 内部对字符串进行高效处理。

  - `${#parameter}` (**获取长度**):
    ```bash
    [me@linuxbox ~]$ foo="hello world"
    [me@linuxbox ~]$ echo ${#foo}
    11
    ```
  - `${parameter:offset:length}` (**提取子字符串**):
    ```bash
    [me@linuxbox ~]$ foo="hello world"
    [me@linuxbox ~]$ echo ${foo:6:5} # 从第6个字符开始，提取5个字符
    world
    ```
  - `${parameter#pattern}` 和 `${parameter##pattern}` (**从开头删除匹配**):
      - `#`：删除**最短**的匹配。
      - `##`：删除**最长**的匹配。
      - 常用于删除路径前缀。
    <!-- end list -->
    ```bash
    [me@linuxbox ~]$ path="/home/user/file.txt"
    [me@linuxbox ~]$ echo "${path#*/}"   # -> home/user/file.txt
    [me@linuxbox ~]$ echo "${path##*/}"  # -> file.txt (basename)
    ```
  - `${parameter%pattern}` 和 `${parameter%%pattern}` (**从结尾删除匹配**):
      - `%`：删除**最短**的匹配。
      - `%%`：删除**最长**的匹配。
      - 常用于删除文件扩展名。
    <!-- end list -->
    ```bash
    [me@linuxbox ~]$ file="archive.tar.gz"
    [me@linuxbox ~]$ echo "${file%.*}"   # -> archive.tar
    [me@linuxbox ~]$ echo "${file%%.*}"  # -> archive
    ```
  - `${parameter/pattern/string}` 和 `${parameter//pattern/string}` (**搜索和替换**):
      - `/`：只替换**第一个**匹配。
      - `//`：替换**所有**匹配。
    <!-- end list -->
    ```bash
    [me@linuxbox ~]$ text="one two two"
    [me@linuxbox ~]$ echo "${text/two/three}"   # -> one three two
    [me@linuxbox ~]$ echo "${text//two/three}"  # -> one three three
    ```

**关键示例：性能的巨大提升**
通过将获取字符串长度的外部命令 `wc` 替换为内置的参数扩展 `${#j}`，脚本的执行效率得到了惊人的提升。

  - **旧版本 (慢)**：`len="$(echo -n "$j" | wc -c)"`
  - **新版本 (快)**：`len="${#j}"`

**性能对比：**

```shell
# 使用外部命令 wc 的版本
[me@linuxbox ~]$ time longest-word2 large_file.txt
...
real    0m3.618s

# 使用内置参数扩展 ${#j} 的版本
[me@linuxbox ~]$ time longest-word3 large_file.txt
...
real    0m0.060s
```

**结论**：在需要处理大量字符串的循环中，优先使用内置的参数扩展，可以**极大提升**脚本性能。

-----

### 34.1.5 大小写转换

  - **核心思想**：在编程中，我们经常需要**规范化 (normalize)** 用户的输入。例如，无论用户输入 `Yes`, `yes` 还是 `YES`，我们都可能希望将其统一转换为小写 `yes` 再进行处理，以简化逻辑判断。Bash 提供了两种主要方式来实现字符串的大小写转换。

-----

#### 方法一：使用 `declare` 命令 (强制变量格式)

  - **作用**：`declare` 命令可以创建一种特殊的变量，这种变量会**自动**将赋给它的任何值转换为指定的大小写格式。这种转换是**持续性的**。
  - **关键选项**：
      - `declare -u variable_name`：创建一个**全部大写**的变量 (upper case)。
      - `declare -l variable_name`：创建一个**全部小写**的变量 (lower case)。

**关键示例 1：使用 `declare` 规范化变量**
这个脚本创建了两个变量，一个强制大写，一个强制小写。

```bash
#!/bin/bash
# ul-declare: 通过声明来演示大小写转换

# 声明 upper 变量，任何赋给它的值都会自动转为大写
declare -u upper
# 声明 lower 变量，任何赋给它的值都会自动转为小写
declare -l lower

# 将命令行第一个参数 "aBc" 同时赋给两个变量
if [[ $1 ]]; then
  upper="$1"
  lower="$1"
  echo "$upper"
  echo "$lower"
fi
```

**执行结果：**

```shell
[me@linuxbox ~]$ ul-declare aBc
ABC
abc
```

**分析**：无论原始输入是什么，`$upper` 变量的值永远是大写，`$lower` 的值永远是小写。

-----

#### 方法二：使用参数扩展 (即时转换)

  - **作用**：这些参数扩展在**使用变量时**进行一次性的、即时的转换，它**不会**改变变量本身存储的原始值。
  - **关键语法**：
      - `${parameter,,}`：将整个字符串转换为**小写**。
      - `${parameter,}`：**仅将首字母**转换为**小写**。
      - `${parameter^^}`：将整个字符串转换为**大写**。
      - `${parameter^}`：**仅将首字母**转换为**大写**。

**关键示例 2：使用参数扩展进行转换**
这个脚本对同一个输入字符串应用四种不同的扩展。

```bash
#!/bin/bash
# ul-param: 通过参数扩展来演示大小写转换

if [[ "$1" ]]; then
  echo "全部小写: ${1,,}"
  echo "首字母小写: ${1,}"
  echo "全部大写: ${1^^}"
  echo "首字母大写: ${1^}"
fi
```

**执行结果：**

```shell
[me@linuxbox ~]$ ul-param aBc
全部小写: abc
首字母小写: aBc
全部大写: ABC
首字母大写: ABc
```

**分析**：参数 `$1` 的原始值 `aBc` 始终没有改变，只是在每次 `echo` 时，通过不同的扩展语法得到了不同的临时结果。

-----

### 34.2 算术求值与扩展

  - **核心思想**：Bash 提供了专门的语法来处理整数算术。这两种形式我们之前都接触过，但功能远比我们想象的要丰富。
      - `$((expression))`: **算术扩展**。它的主要作用是**计算**出一个数学表达式的**结果**。例如 `a=$((2 + 2))`。
      - `((expression))`: **算术求值**。它的主要作用是进行**逻辑判断**，常用于 `if` 或 `while` 循环中。表达式结果非 0 则为“真”，0 则为“假”。例如 `if (( a > 2 ))`。

-----

#### 34.2.1 数字基数

  - **核心思想**：在算术表达式中，Bash 不仅支持十进制数，还支持其他进制的表示法。
  - **表示方法**：
      - `number`: 默认是**十进制** (base-10)。
      - `0number`: 以 `0` 开头表示**八进制** (base-8)。例如 `010` 的值是 8。
      - `0xnumber`: 以 `0x` 开头表示**十六进制** (base-16)。例如 `0xFF` 的值是 255。
      - `base#number`: 表示任意进制。`base` 是进制数，`number` 是该进制下的数值。

**关键示例：**

```shell
# 将十六进制的 ff 转换为十进制
[me@linuxbox ~]$ echo $((0xff))
255

# 将二进制的 11111111 转换为十进制
[me@linuxbox ~]$ echo $((2#11111111))
255
```

-----

#### 34.2.2 一元操作符

  - **核心思想**：就是我们数学中常见的正负号。
  - `+`：正号 (通常省略)。
  - `-`：负号。例如 `a=$((-5))`。

-----

#### 34.2.3 简单算术

  - **核心思想**：在 `((...))` 或 `$((...))` 中，你可以使用我们熟悉的算术操作符。

  - **常用操作符**：

      - `+`：加
      - `-`：减
      - `*`：乘
      - `/`：除
      - `**`：求幂 (乘方)。例如 `2**3` 结果是 8。
      - `%`：**求模** (取余数)。

  - **重要特性：整数除法**

      - Bash 的算术运算**只处理整数**，所以除法 `/` 的结果会**舍弃所有小数部分**（直接截断，不是四舍五入）。
        ```shell
        [me@linuxbox ~]$ echo $(( 5 / 2 ))
        2
        ```
      - 正因为如此，`%` (求模) 运算符就显得尤为重要，它可以帮助我们获得除法的余数。
        ```shell
        [me@linuxbox ~]$ echo $(( 5 % 2 ))
        1
        ```

**关键示例：使用求模运算符 `%`**
求模运算在循环中非常有用，可以用来“每隔 N 次”执行一个特定操作。下面的脚本会找出 0 到 20 之间所有 5 的倍数并用尖括号括起来。

```bash
#!/bin/bash
# modulo: 演示求模运算符

for ((i = 0; i <= 20; i = i + 1)); do
  # 如果 i 除以 5 的余数等于 0，说明 i 是 5 的倍数
  if (( i % 5 == 0 )); then
    printf "<%d> " "$i"
  else
    printf "%d " "$i"
  fi
done
printf "\n"
```

**执行结果：**

```shell
[me@linuxbox ~]$ modulo
<0> 1 2 3 4 <5> 6 7 8 9 <10> 11 12 13 14 <15> 16 17 18 19 <20>
```

-----

#### 34.2.4 赋值

  - **核心思想**：除了简单的 `a=5`，Bash 的算术表达式 `((...))` 内部也支持多种强大的赋值操作。

  - **关键区别：`=` (赋值) vs `==` (比较)**

      - `=` (单个等号): **赋值操作**。`(( a = 5 ))` 的意思是“把 5 赋给 a”，并且这个表达式本身的结果是 5 (非零)，所以在 `if` 中被认为是**真**。
      - `==` (双等号): **比较操作**。`(( a == 5 ))` 的意思是“a 的值是否等于 5？”，表达式结果是 1 (真) 或 0 (假)。

    > 这是从 C 语言沿袭下来的常见模式，也是推荐在 `((...))` 和 `[[...]]` 中使用 `==` 进行比较，而不是在旧式 `[...]` 中使用 `=` 的一个重要原因，以避免混淆。

  - **复合赋值操作符**：这些是常见操作的便捷写法。

      - `a += 5`  等价于 `a = a + 5`
      - `a -= 5`  等价于 `a = a - 5`
      - `a *= 5`  等价于 `a = a * 5`
      - `a /= 5`  等价于 `a = a / 5`
      - `a %= 5`  等价于 `a = a % 5`

  - **自增/自减操作符 (`++`, `--`)**

      - `++` (自增): 将变量的值加 1。
      - `--` (自减): 将变量的值减 1。
      - **前置 vs 后置 (Pre vs Post)**：
          - `++i` (前置): **先**将 `i` 的值加 1，然后返回**新**的值。
          - `i++` (后置): **先**返回 `i` 的**原始**值，然后再将 `i` 的值加 1。

**关键示例：前置与后置的区别**

```shell
[me@linuxbox ~]$ foo=1
[me@linuxbox ~]$ echo $((foo++)) # 后置：先返回原始值 1
1
[me@linuxbox ~]$ echo $foo       # 然后 foo 的值才变成 2
2

[me@linuxbox ~]$ foo=1
[me@linuxbox ~]$ echo $((++foo)) # 前置：先加 1 变成 2，再返回新值
2
[me@linuxbox ~]$ echo $foo
2
```

> 在 `for` 循环等大多数场景下，使用**前置 `++i`** 的行为更符合直觉。

-----

#### 34.2.5 位操作

  - **核心思想**：位操作符直接在数字的**二进制位 (bits)** 层面上进行运算，通常用于更低层的编程任务。
  - **常用操作符**：
      - `<<`：按位**左移** (相当于乘以 2 的幂)。
      - `>>`：按位**右移** (相当于除以 2 的幂)。
      - `&`：按位 **AND**。
      - `|`：按位 **OR**。
      - `^`：按位 **XOR** (异或)。
      - `~`：按位**取反**。

**关键示例：使用左移 `<<` 生成 2 的幂**
`1 << i` 的意思就是将二进制的 `1` 向左移动 `i` 位。

```shell
[me@linuxbox ~]$ for ((i=0; i<8; ++i)); do echo $((1 << i)); done
1
2
4
8
16
32
64
128
```

-----

#### 34.2.6 逻辑操作

  - **核心思想**：`((...))` 内部支持一套完整的 C 语言风格的逻辑和比较操作符。

  - **逻辑规则**：表达式结果为 **0** 被视为**假 (false)**，**非 0** 则被视为**真 (true)**。

  - **常用操作符**：

      - **比较**：`<`, `>`, `<=`, `>=`, `==`, `!=`
      - **逻辑**：`&&` (逻辑 AND), `||` (逻辑 OR)
      - **三元操作符**：`expr1 ? expr2 : expr3`

  - **三元操作符 (Ternary Operator)**：这是一个紧凑的 `if/else` 结构。

      - **工作方式**：如果 `expr1` 为真 (非0)，则执行 `expr2`；否则，执行 `expr3`。

**关键示例 1：使用三元操作符实现“切换”**
下面的命令每执行一次，变量 `a` 的值就会在 0 和 1 之间切换。

```shell
[me@linuxbox ~]$ a=0
[me@linuxbox ~]$ (( a < 1 ? ++a : --a )) # a < 1 为真，执行 ++a
[me@linuxbox ~]$ echo $a
1
[me@linuxbox ~]$ (( a < 1 ? ++a : --a )) # a < 1 为假，执行 --a
[me@linuxbox ~]$ echo $a
0
```

**关键示例 2：综合算术循环**
这个脚本使用 `until`、算术扩展和三元操作符，生成一个数字的平方和立方表。

```bash
#!/bin/bash
# arith-loop: 演示算术运算符的脚本
finished=0
a=0
printf "a\ta**2\ta**3\n"
printf "=\t====\t====\n"

# 循环直到 finished 变量不为0 (真)
until ((finished)); do
  b=$((a**2))
  c=$((a**3))
  printf "%d\t%d\t%d\n" "$a" "$b" "$c"

  # 三元操作符：如果 a<10，则 a 自增；否则，将 finished 设为1，从而结束循环
  ((a<10 ? ++a : (finished=1)))
done
```


-----

### 34.3 bc——任意精度计算器语言

  - **核心思想**：Bash 的内置算术 (`$((...))`) **只能处理整数**。当你需要进行**浮点数（小数）运算**或更复杂的数学计算时，就必须借助外部程序。`bc` 就是一个标准的、强大的命令行计算器。

  - **`bc` 的特点**：它本身是一种类似于 C 语言的编程语言，支持变量、循环、函数等，能够处理任意精度的数字。

-----

#### 34.3.1 使用 bc

`bc` 可以通过多种方式接收并执行计算任务。

  - **方式一：交互模式**
    直接在命令行输入 `bc -q` (`-q` 选项可以隐藏欢迎横幅)，然后就可以像使用计算器一样，输入表达式并立即看到结果。输入 `quit` 退出。

    ```shell
    [me@linuxbox ~]$ bc -q
    2.5 * 4
    10.0
    quit
    ```

  - **方式二：从标准输入读取 (脚本中最常用的方式)**
    由于 `bc` 可以从标准输入读取指令，因此我们可以非常方便地在 Shell 脚本中通过管道、here string 或 here document 将计算任务传递给它。

**关键示例：**

```shell
# 使用管道
[me@linuxbox ~]$ echo "2 + 2" | bc
4

# 使用 here string (推荐用于单行计算)
[me@linuxbox ~]$ bc <<< "scale=2; 10 / 3"
3.33

# 使用 here document (推荐用于多行计算)
[me@linuxbox ~]$ bc << EOF
> scale = 4
> 5 / 3
> EOF
1.6666
```

  - **关键变量 `scale`**：在 `bc` 脚本内部，`scale` 是一个特殊变量，它**控制着小数点后的位数**（精度）。这是进行浮点数运算时最重要的设置。

-----

#### 34.3.2 示例脚本

  - **核心思想**：在 Shell 脚本中，我们通常让 Shell 负责处理用户交互、参数解析等逻辑，然后将核心的、复杂的数学计算部分交给 `bc` 来完成。

**关键示例：贷款月供计算器**
这个脚本接收贷款本金、年利率和月数作为命令行参数，然后使用 `bc` 来计算每月需要偿还的金额。

```bash
#!/bin/bash
# loan-calc: 计算按月偿还的贷款

# --- Shell 负责的部分：参数检查和用法提示 ---
PROGNAME="${0##*/}" # 获取脚本名
usage () {
  cat <<- EOF
Usage: $PROGNAME PRINCIPAL INTEREST MONTHS
Example: $PROGNAME 135000 0.0775 180
EOF
}
if (($# != 3)); then
  usage
  exit 1
fi
principal=$1
interest=$2
months=$3

# --- bc 负责的部分：核心数学计算 ---
# 使用 here document 将一段 bc 脚本传递给 bc 命令
bc <<- EOF
  /* 设置小数精度为 10 位 */
  scale = 10

  /* 从 Shell 接收变量并进行计算 */
  i = $interest / 12 /* 月利率 */
  p = $principal     /* 本金 */
  n = $months        /* 月数 */

  /* 月供计算公式 */
  a = p * ((i * ((1 + i) ^ n)) / (((1 + i) ^ n) - 1))

  /* 打印结果 */
  print a, "\n"
EOF
```

**执行结果：**

```shell
[me@linuxbox ~]$ loan-calc 135000 0.0775 180
1270.7222490000
```

**分析**：这个例子完美地展示了 Shell 与 `bc` 的协作：Shell 负责“外壳”，`bc` 负责“内核”计算。Shell 变量 `$principal` 等在 `here document` 内部被**预先展开**，然后整个 `bc` 脚本被传递给 `bc` 命令执行。