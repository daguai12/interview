### 6.1 标准输入、标准输出及标准错误

我们目前用过的很多程序能够产生某种形式的输出结果。这种输出结果通常有两种类型。

* 程序的运行结果，也就是程序本就要产生的数据。
* 表明程序运行情况的状态和错误消息。

如果观察 `ls` 命令，就能发现它会在屏幕上显示运行结果和错误消息。

秉承“万物皆文件”的 UNIX 主旨，程序（例如 `ls` 命令）实际上将运行结果和状态消息分别发送到了名为 `stdout`（标准输出，standard output 的缩写）和 `stderr`（标准错误，standard error 的缩写）的特殊文件。在默认情况下，标准输出和标准错误与显示器屏幕相关联，并不会保存为磁盘文件。

另外，许多程序从 `stdin`（标准输入，standard input 的缩写）中获取输入，默认情况下，标准输入与键盘相关联。

I/O 重定向允许我们修改输出结果的去处和输入的来源。通常来说，输出结果会显示在屏幕，输入则来自键盘，但有了 I/O 重定向，两者我们都可以改变。

-----

### 6.2 标准输出重定向

I/O 重定向功能可以重新定义标准输出的去处。要想把标准输出重定向到其他文件，而非出现在屏幕上，可以使用重定向操作符`>`，后面跟上文件名即可。为什么要这样做？因为通常需要把命令的输出结果保存在文件中。例如，我们想让 Shell 将 `ls` 命令的输出结果保存在 `ls-output.txt` 中：

```bash
[me@linuxbox ~]$ ls -l /usr/bin > ls-output.txt
```

这里，我们生成了`/usr/bin` 目录的长格式列表并将其发送到 `ls-output.txt`。来检查一下重定向后的命令结果：

```bash
[me@linuxbox ~]$ ls -l ls-output.txt
-rw-rw-r-- 1 me me 167878 2018-02-01 15:07 ls-output.txt
```

我们得到了一个不错的“大块头”文本文件。如果使用 `less` 命令查看该文件，会发现 `ls-output.txt` 中的确包含 `ls` 命令的输出结果：

```bash
[me@linuxbox ~]$ less ls-output.txt
```

现在，重复重定向测试，不过这次要加点儿难度。我们要将目录改成一个并不存在的目录：

```bash
[me@linuxbox ~]$ ls -l /bin/usr > ls-output.txt
ls: cannot access /bin/usr: No such file or directory
```

我们接收到了一条错误消息。得到这个结果一点儿都不亏，因为命令中指定的`/bin/usr` 目录并不存在，但为什么错误消息显示在屏幕上，而不是被重定向到 `ls-output.txt`？答案是 `ls` 命令并没有将错误消息发送到标准输出。和大多数编写良好的 UNIX 程序一样，`ls` 命令将错误消息发送到了标准错误。因为我们只重定向了标准输出，并未重定向标准错误，所以错误消息依旧出现在了屏幕上。我们马上就会学习如何重定向标准错误，不过先来看一下输出文件的情况：

```bash
[me@linuxbox ~]$ ls -l ls-output.txt
-rw-rw-r-- 1 me me 0 2018-02-01 15:08 ls-output.txt
```

文件大小为 0！这是因为当使用重定向符`>`对标准输出进行重定向时，会完全重写目标文件。由于 `ls` 命令除了一条错误消息外没有产生任何输出结果，因此重定向操作一开始准备重写该文件，出现错误后停止了写入操作，最终导致了该文件内容被截断（truncation）。事实上，如果我们打算截断某个文件（或者创建一个新的空文件），就可以利用这个技巧：

```bash
[me@linuxbox ~]$ > ls-output.txt
```

只需使用不加任何命令的重定向操作符，就可以截断现有文件或者创建一个新的空文件。

那么，该怎样才能把重定向的标准输出追加到文件尾部，而不是将其从头覆盖呢？为此，可以使用重定向操作符`>>`来实现：

```bash
[me@linuxbox ~]$ ls -l /usr/bin >> ls-output.txt
```

使用重定向操作符`>>`会将标准输出追加到文件尾部。如果指定的文件不存在，则像操作符`>`一样，新建该文件。让我们来测试一下：

```bash
[me@linuxbox ~]$ ls -l /usr/bin >> ls-output.txt
[me@linuxbox ~]$ ls -l /usr/bin >> ls-output.txt
[me@linuxbox ~]$ ls -l /usr/bin >> ls-output.txt
[me@linuxbox ~]$ ls -l ls-output.txt
-rw-rw-r-- 1 me me 503634 2018-02-01 15:45 ls-output.txt
```

重复执行相同的命令 3 次，输出文件也相应地扩大了 3 倍。



-----

### 6.3 标准错误重定向

标准错误重定向缺少专门的重定向操作符。要想重定向标准错误，必须引用其文件描述符。程序可以在任意经过编号的文件流（numbered file stream）上生成输出结果。虽然我们将前 3 个文件流称为标准输入、标准输出及标准错误，但在 Shell 内部分别是用文件描述符 0、1 及 2 引用它们的。Shell 提供了使用文件描述符编号来重定向文件的写法。由于标准错误对应的文件描述符为 2，因此可以用下列写法来重定向标准错误：

```bash
[me@linuxbox ~]$ ls -l /bin/usr 2> ls-error.txt
```

文件描述符 `2` 紧靠在重定向操作符之前，将标准错误重定向到 `ls-error.txt`。

#### 6.3.1 将标准输出和标准错误重定向到同一个文件中

有时候，我们可能想将命令的所有输出结果全都保存到一个文件中。为此，必须同时重定向标准输出和标准错误。

有两种实现方法。先来看传统方法，适用于旧版 Shell：

```bash
[me@linuxbox ~]$ ls -l /bin/usr > ls-output.txt 2>&1
```

我们执行了两次重定向。先将标准输出重定向到 `ls-output.txt`，然后使用 `2>&1` 将文件描述符 2（标准错误）重定向到文件描述符 1（标准输出）。

> **重定向操作的顺序非常重要**
> 标准错误的重定向操作必须在标准输出重定向之后执行，否则无法奏效。
>
> 在下面的例子中，标准错误被重定向到 `ls-output.txt`：
> `>ls-output.txt 2>&1`
>
> 如果改变了重定向操作的顺序，标准错误会被重定向到屏幕：
> `2>&1 >ls-output.txt`

较新版本的 Bash 提供了另一种更流畅的方法来实现这种联合重定向：

```bash
[me@linuxbox ~]$ ls -l /bin/usr &> ls-output.txt
```

在这个例子中，我们使用 `&>` 将标准输出和标准错误重定向到 `ls-output.txt`。你也许想将标准输出和标准错误追加到单个文件中，可以这样做：

```bash
[me@linuxbox ~]$ ls -l /bin/usr &>> ls-output.txt
```

#### 6.3.2 丢弃用不着的输出结果

“沉默是金”，有时候你并不需要命令的输出结果，而希望将其丢弃掉，尤其是那些错误和状态消息。系统提供了一种解决方法：将输出结果重定向到名为`/dev/null`的特殊文件。该文件是一个系统设备，通常称作位桶（bit bucket），能够接收输入结果但不做任何处理。下列命令可以丢弃命令的错误消息：

```bash
[me@linuxbox ~]$ ls -l /bin/usr 2> /dev/null
```

> **UNIX 文化中的/dev/null**
> 位桶是一个“古老”的 UNIX 概念，由于其广泛性，在 UNIX 文化的诸多方面都有它的身影。如果有人说你的评论被送到了`/dev/null`，现在你应该就知道是什么意思了。更多的例子，参见维基百科上有关`/dev/null` 的条目。

-----

### 6.4 标准输入重定向

到目前为止，我们还没有学过使用标准输入的命令（其实有过，稍后来揭晓“谜底”），现在来介绍一个。

#### Cat—拼接文件

`cat` 命令读取一个或多个文件并将其复制到标准输出：
`cat filename`

在大多数情况下，你可以将 `cat` 命令等同于 DOS 中的 `type` 命令，能够以不分页的形式显示文件内容。例如，下列命令将显示 `ls-output.txt` 的内容：

```bash
[me@linuxbox ~]$ cat ls-output.txt
```

`cat` 命令常用于显示比较短的文本文件。因为 `cat` 命令能够接收多个文件作为参数，所以还可用于将文件拼接在一起。假设我们下载了一个被分割成好几部分的文件（Usenet 上的多媒体文件多采用这种方式），希望能将其组合还原。如果这些文件的命名方式如下：
`movie.mpeg.001 movie.mpeg.002 ... movie.mpeg.099`

我们可以用下列命令将其恢复原状：
`cat movie.mpeg.0* > movie.mpeg`

因为通配符会按照顺序扩展，所以 `cat` 命令的参数排列也不会出错。

一切都很好，不过这和标准输入有什么关系？确实没什么关系，不过让我们来另做一番尝试。如果输入没有任何参数的 `cat` 命令会怎样？

```bash
[me@linuxbox ~]$ cat
```

什么都没发生，就是停在那里，像是被卡住了。看起来似乎如此，但其实这正是 `cat` 命令应该做的事情。

如果没有为 `cat` 命令指定任何参数，它就从标准输入中读取。又因为标准输入默认和键盘关联，所以 `cat` 命令一直在等着我们从键盘输入！试着输入下面的文本，然后按 Enter 键：

```bash
[me@linuxbox ~]$ cat
The quick brown fox jumped over the lazy dog.
```

接着，按 `Ctrl-D` 组合键（也就是按住 Ctrl 键，再按 D 键），告诉 `cat` 命令已经到达了标准输入的文件末尾（End Of File，EOF）：

```bash
[me@linuxbox ~]$ cat
The quick brown fox jumped over the lazy dog.
The quick brown fox jumped over the lazy dog.
```

在缺少文件名参数的情况下，因为 `cat` 命令会将标准输入复制到标准输出，所以我们看到了重复显示的文本行。利用这种行为，可以创建短小的文本文件。假设我们想要创建一个名为 `lazy_dog.txt` 的文件，其中包含先前示例中的文本内容。可以这样做：

```bash
[me@linuxbox ~]$ cat > lazy_dog.txt
The quick brown fox jumped over the lazy dog.
```

在命令后输入想放入文件中的文本。记住最后要按 `Ctrl-D` 组合键。通过命令行，我们实现了世界上最原始的文字处理程序！要想查看结果，我们可以再次使用 `cat` 命令将文件复制到标准输出：

```bash
[me@linuxbox ~]$ cat lazy_dog.txt
The quick brown fox jumped over the lazy dog.
```

现在我们知道除文件名参数之外，`cat` 是如何接收标准输入的，让我们尝试重定向标准输入：

```bash
[me@linuxbox ~]$ cat < lazy_dog.txt
The quick brown fox jumped over the lazy dog.
```

通过重定向操作符`<`，我们将标准输入方式从键盘改为文件 `lazy_dog.txt`。可以看到，结果和传递文件参数一模一样。相较于传递文件参数，重定向标准输入也并未显得特别有用，这里只表明可以使用文件作为标准输入而已。我们很快就会看到其他能够更好地利用标准输入的命令。

在继续学习之前，先查看一下 `cat` 命令的手册页，其中有不少值得注意的选项。


-----

### 6.5 管道

Shell 的管道特性利用了命令能够从标准输入读取数据并将数据发送到标准输出的能力。通过管道操作符`|`，可以将一个命令的标准输出传给另一个命令的标准输入：

`command1 | command2`

为了充分展示管道的用法，需要用到几个命令。还记不记得我们曾经说过其实有一个已经学过的命令能够使用标准输入？这个命令就是 `less`。对于那些将结果发往标准输出的命令，我们都可以使用 `less` 命令将其输出结果逐页显示出来：

```bash
[me@linuxbox ~]$ ls -l /usr/bin | less
```

方便极了！对任何能够产生标准输出的命令，我们都可以利用这个方法检查其输出结果。

管道往往用来执行复杂的数据操作。我们也可以把多个命令组合在一起形成管道，这种方式中用到的命令通常被称为过滤器（filter）。过滤器获取输入，对其做出改动，然后输出。

#### 6.5.1 排序列表

我们先来试一试 `sort` 命令。假设要把`/bin` 和`/usr/bin` 目录下的所有可执行文件合并成一个列表，然后排序，并查看最终结果。

```bash
[me@linuxbox ~]$ ls /bin /usr/bin | sort | less
```

因为我们指定了两个目录（`/bin` 和`/usr/bin`），所以 `ls` 命令的输出结果包含了两 个排序列表，分别对应每个目录。在管道中加入 `sort` 命令，就可以修改 `ls` 命令的输出结果，生成单个有序列表。

> **`>`和`|`之间的差异**
> 乍一看，很难理解管道操作符`|`与重定向操作符`>`执行的重定向有什么不同之处。简单来说，重定向操作符将命令与文件连接在一起，而管道操作符将一个命令的输出结果与另一个命令的输出结果连接在一起：
>
> `command1 > file1`
> `command1 | command2`
>
> 很多人在学习管道时会尝试下面的做法，想看一看会发生些什么：
> `command1 > command2`
> 答案：有时候，结果会很糟糕。
>
> 这里有一个真实的例子，是一位负责管理 Linux 服务器的读者提供的。作为超级用户，他执行了以下操作：
>
> ```bash
> # cd /usr/bin
> # ls > less
> ```
>
> 第一个命令切换到大多数程序所在的目录；第二个命令告诉 Shell，使用 `ls` 命令输出的文件覆盖“less”。因为`/usr/bin` 目录中包含名为 `less` 的文件（也就是 `less` 程序），第二个命令的结果就是使用 `ls` 命令输出的文本覆盖了 `less` 程序，所以系统中的 `less` 程序就再也无法使用了。
>
> 从中得到的教训就是重定向操作符会悄无声息地创建或覆盖文件，一定要小心应对。

#### 6.5.2 uniq—报告或忽略重复行

`uniq` 命令通常与 `sort` 命令配合使用。`uniq` 命令可以从标准输入或单个文件名参数中获取有序的数据列表（详见 `uniq` 命令的手册页），默认删除所有重复行。为了确保输出结果中没有重复行（也就是说，`/bin` 和`/usr/bin` 目录中存在同名程序），我们将 `uniq` 命令加入管道中：

```bash
[me@linuxbox ~]$ ls /bin /usr/bin | sort | uniq | less
```

在这个例子中，我们使用 `uniq` 命令删除 `sort` 命令输出结果中的所有重复行。如果想看都有哪些重复行，可以使用 `uniq` 命令的`-d` 选项：

```bash
[me@linuxbox ~]$ ls /bin /usr/bin | sort | uniq -d | less
```

#### 6.5.3 wc—统计文件中换行符、单词以及字节的数量

`wc`（word count，译为单词统计）命令可用于统计文件中换行符、单词以及字节的数量。例如：

```bash
[me@linuxbox ~]$ wc ls-output.txt
 7902  64566 503634 ls-output.txt
```

在这个例子中，输出了 3 个数字，分别是 `ls-output.txt` 中的行数、单词数、字节数。和之前的命令一样，如果没有指定命令行参数，`wc` 命令会从标准输入中读取。`-l` 选项限制只输出文件行数。将该命令加入管道中，能够方便地完成统计工作。要想知道有序列表包含多少行，可以这样：

```bash
[me@linuxbox ~]$ ls /bin /usr/bin | sort | uniq | wc -l
2728
```

#### 6.5.4 grep—输出与模式匹配的行

`grep` 命令可用于在文件中查找文本模式，功能十分强大。其用法如下：
`grep pattern filename`

当 `grep` 命令在文件中遇到“模式”的时候，会输出包含该模式的行。`grep` 命令能够匹配非常复杂的模式，不过我们目前先关注一些简单的文本匹配。第 19 章中会讲到被称为“正则表达式”（regular expression）的高级模式。

假设想从程序列表中找出名称中包含单词 `zip` 的所有文件，利用这种方法，我们可以得知系统中有多少程序和文件压缩有关。实现方法如下：

```bash
[me@linuxbox ~]$ ls /bin /usr/bin | sort | uniq | grep zip
bunzip2
bzip2
gunzip
gzip
unzip
zip
zipcloak
zipgrep
zipinfo
zipnote
zipsplit
```

`grep` 命令有两个很方便的选项。

  * `-i` 使 `grep` 命令在搜索的时候忽略字母大小写（默认区分大小写）。
  * `-v` 使 `grep` 命令只输出不匹配指定模式的行。

#### 6.5.5 head/tail—输出文件的开头/结尾部分

有时候，你想要的并不是命令的全部输出结果，而只是前几行或后几行。`head` 命令和 `tail` 命令默认分别能够输出文件的前 10 行和后 10 行，不过行数可以通过`-n` 选项来调整：

```bash
[me@linuxbox ~]$ head -n 5 ls-output.txt
total 343496
-rwxr-xr-x 1 root root  31316 2017-12-05 08:58 [
-rwxr-xr-x 1 root root   8240 2017-12-09 13:39 411toppm
-rwxr-xr-x 1 root root 111276 2017-11-26 14:27 a2p
-rwxr-xr-x 1 root root  25368 2016-10-06 20:16 a52dec
[me@linuxbox ~]$ tail -n 5 ls-output.txt
-rwxr-xr-x 1 root root   5234 2017-06-27 10:56 znew
-rwxr-xr-x 1 root root    691 2015-09-10 04:21 zonetab2pot.py
-rw-r--r-- 1 root root    930 2017-11-01 12:23 zonetab2pot.pyc
-rw-r--r-- 1 root root    930 2017-11-01 12:23 zonetab2pot.pyo
lrwxrwxrwx 1 root root      6 2016-01-31 05:22 zsoelim -> soelim
```

这两个命令都可以用在管道中：

```bash
[me@linuxbox ~]$ ls /usr/bin | tail -n 5
znew
zonetab2pot.py
zonetab2pot.pyc
zonetab2pot.pyo
zsoelim
```

`tail` 命令中有一个可以用来实时查看文件的选项。该选项适合同步观察日志被写入的过程。在下面的例子中，我们将查看`/var/log` 目录中的 `messages` 文件（如果 `message` 文件不存在的话，则改用`/var/log/syslog`）。因为`/var/log/messages` 文件可能包含安全信息，所以在一些 Linux 发行版中，需要超级用户的权限才能执行该操作：

```bash
[me@linuxbox ~]$ tail -f /var/log/messages
Feb  8 13:40:05 twin4 dhclient: DHCPACK from 192.168.1.1
Feb  8 13:40:05 twin4 dhclient: bound to 192.168.1.4 -- renewal in 1652 seconds.
Feb  8 13:55:32 twin4 mountd[3953]: /var/NFSv4/musicbox exported to both 192.168.1.0/24 and twin7.localdomain in 192.168.1.0/24,twin7.localdomain
Feb  8 14:07:37 twin4 dhclient: DHCPREQUEST on eth0 to 192.168.1.1 port 67
Feb  8 14:07:37 twin4 dhclient: DHCPACK from 192.168.1.1
Feb  8 14:07:37 twin4 dhclient: bound to 192.168.1.4 -- renewal in 1771 seconds.
Feb  8 14:09:56 twin4 smartd[3468]: Device: /dev/hda, SMART Prefailure Attribute: 8 Seek_Time_Performance changed from 237 to 236
Feb  8 14:10:37 twin4 mountd[3953]: /var/NFSv4/musicbox exported to both 192.168.1.0/24 and twin7.localdomain in 192.168.1.0/24,twin7.localdomain
Feb  8 14:25:07 twin4 sshd(pam_unix)[29234]: session opened for user me by (uid=0)
Feb  8 14:25:36 twin4 su(pam_unix)[29279]: session opened for user root by me(uid=500)
```

通过`-f` 选项，`tail` 命令会持续观察该文件，一旦添加了新行，立即就会显示在屏幕中。这个过程直到按 `Ctrl-C` 组合键后停止。

#### 6.5.6 tee—读取标准输入并将输出结果写入标准输出和文件

为了和管道的比喻保持一致，Linux 还提供了一个名为 `tee` 的命令，可以在管道上安装一个“T 形头”。`tee` 命令从标准输入读取内容，然后将其复制到标准输出（允许数据沿着管道继续向下流动）和其他文件中。捕获管道处理过程中的某个中间阶段的数据会很有用。我们在这里要重复使用之前的一个例子，这次在 `grep` 命令过滤管道内容之前加入 `tee` 命令，将整个目录列表保存到 `ls.txt` 中：

```bash
[me@linuxbox ~]$ ls /usr/bin | tee ls.txt | grep zip
bunzip2
bzip2
gunzip
gzip
unzip
zip
zipcloak
zipgrep
zipinfo
zipnote
zipsplit
```

### 6.6 总结

请查看本章涉及的各个命令的相关文档。我们只介绍了这些命令的基本用法，除此之外，它们都还有很多值得注意的选项。等到积累了一定的 Linux 使用经验，我们会发现命令行的重定向特性对解决某些特定的问题颇有帮助。很多命令都用到了标准输入和标准输出，绝大多数命令行程序使用标准错误来显示提示性信息。

> **充满想象力的 Linux**
> 每当被问到 Windows 和 Linux 之间有什么不同时，我经常会用玩具打比方。
>
> Windows 就像是 Game Boy 游戏机。你去商店买了一台全新的 Game Boy。你把它带回家，启动，开始玩游戏。画面炫丽，声音可人。但是没过多久，你就厌倦了这些游戏，于是你又回到商店，买了另一款游戏。这个过程周而复始。最后，你再次回到商店，对柜台后的售货员说：“我想要一款不一样的游戏！”但是却被告知市面上没有这种游戏，因为不存在针对它的“市场需求”。“但是我只需要改动一样东西就行了”，你接着说。售货员又说你不能进行更改，游戏是被完全密封好的。这时候，你发现你的游戏机只能玩那些别人觉得你需要的游戏。
>
> 而 Linux 就像是世界上最大的建筑拼装玩具。你打开它之后，发现只有一大堆零件，各种钢架、螺丝钉、螺帽、齿轮、滑轮组、马达等，还有一些装配参考。好了，你可以开始“把玩”了。你按照装配参考，拼好了一个又一个部件。没过不久，你有了自己想要的样式。用不着再重返商店，因为要用到的一切你都已经有了。这个建筑拼装玩具就是你想象力的体现。你想要什么，它就能实现什么。
>
> 你想选择哪种玩具自然是你的自由，那么哪种玩具更能让你有满足感？