### 35.1 什么是数组

  - **核心思想**：数组 (Array) 是一种特殊的变量，它可以**一次性存储多个值**。你可以把它想象成一个带编号的列表或单列表格。
  - **关键特性**：
      - Bash 中的数组是**一维**的。
      - 数组中的每个值被称为一个**元素 (element)**。
      - 每个元素都有一个唯一的**索引 (index)** 来访问它。
      - 索引是从 **0** 开始的整数。

-----

#### 35.1.1 创建数组

  - **方式一：隐式创建**
    当你第一次给数组的某个元素赋值时，这个数组就会被自动创建。

    ```bash
    [me@linuxbox ~]$ my_array[0]="foo" # 数组 my_array 在此被创建
    ```

  - **方式二：显式声明 (推荐)**
    使用 `declare -a` 命令可以明确地声明一个变量为数组，这能让你的代码更清晰。

    ```bash
    [me@linuxbox ~]$ declare -a my_array
    ```

-----

#### 35.1.2 为数组赋值

  - **方法一：为单个元素赋值**
    使用 `数组名[索引]=值` 的语法。

    ```bash
    my_array[0]="Apple"
    my_array[1]="Banana"
    my_array[2]="Cherry"
    ```

  - **方法二：一次性为多个元素赋值 (最常用)**
    使用 `数组名=(值1 值2 值3 ...)` 的语法。值会按顺序自动赋给从 0 开始的索引。

    ```bash
    # 简单赋值
    [me@linuxbox ~]$ days=(Sun Mon Tue Wed Thu Fri Sat)

    # 也可以在赋值时指定索引
    [me@linuxbox ~]$ days=([0]=Sun [1]=Mon [2]=Tue)
    ```

-----

#### 35.1.3 访问数组元素

  - **核心思想**：数组最常见的用途之一是**数据聚合 (data aggregation)**，例如对数据进行分类和计数。
  - **访问语法**：`${数组名[索引]}`。花括号 `{}` 在这里是必需的，以避免歧义。

**关键示例：使用数组统计文件修改时间**
下面的 `hours` 脚本是一个绝佳的实战案例。它会分析指定目录下的所有文件，并统计在一天中的每个小时（0-23点）分别有多少个文件被修改过。

```bash
#!/bin/bash
# hours: 对文件的修改时间进行计数

# 1. 检查参数是否是一个目录
if [[ ! -d "$1" ]]; then
  echo "usage: ${0##*/} directory" >&2
  exit 1
fi

# 2. 初始化数组：创建一个包含24个元素的数组，并将每个元素的值都设为0
#    这相当于为每个小时都准备了一个计数器。
declare -a hours
for i in {0..23}; do
  hours[i]=0
done

# 3. 收集数据：遍历目录中的每一个文件
#    stat -c %y         -> 获取文件的修改时间 (例如 2025-09-23 14:30:00)
#    cut -c 12-13       -> 截取代表小时的两位数 (例如 "14")
for i in $(stat -c %y "$1"/* | cut -c 12-13); do
  # 删除可能存在的前导0，避免被当作八进制数处理 (例如 "09" -> "9")
  j="${i#0}"
  # 关键一步：将对应小时的计数器加 1
  ((++hours[j]))
  # 顺便统计总文件数
  ((++count))
done

# 4. 显示数据：以两列表格的形式打印结果
echo -e "Hour\tFiles\tHour\tFiles"
echo -e "----\t-----\t----\t-----"
for i in {0..11}; do
  j=$((i + 12))
  printf "%02d\t%d\t%02d\t%d\n" \
    "$i" "${hours[i]}" \
    "$j" "${hours[j]}"
done

printf "\nTotal files = %d\n" "$count"
```

这个例子完美地展示了数组的核心用途：**使用索引来分类，使用元素的值来计数**。


-----

### 35.2 数组操作

  - **核心思想**：除了基本的赋值和访问，Bash 还提供了一系列强大的参数扩展来对数组进行整体操作，例如遍历、计数等。

-----

#### 35.2.1 输出数组的全部内容

  - **核心思想**：要访问数组的**所有元素**，可以使用两个特殊的索引：`*` 和 `@`。它们的作用类似于位置参数中的 `$*` 和 `$@`。

  - **最重要的区别**：这两个索引在被**双引号 `"` 包围**时的行为截然不同。

      - `"${array[*]}"`：会将数组的**所有元素**合并成**一个单一的字符串**，元素之间默认用空格分隔。
      - `"${array[@]}"`：会将数组的**每个元素**扩展成一个**独立的、带引号的字符串**。它会完美地保留每个元素的原始边界，**即使元素本身包含空格**。

**关键示例：`*` 和 `@` 在循环中的表现**
我们创建一个包含带空格元素的数组，来观察四种形式的区别。

```bash
[me@linuxbox ~]$ animals=("a dog" "a cat" "a fish")

# 1. 不带引号时，* 和 @ 的效果完全一样，都会丢失原始边界
[me@linuxbox ~]$ for i in ${animals[*]}; do echo "$i"; done
a
dog
a
cat
a
fish

# 2. 带引号时，差异巨大
[me@linuxbox ~]$ for i in "${animals[*]}"; do echo "$i"; done
a dog a cat a fish  # <-- 所有元素被压成了一个字符串

[me@linuxbox ~]$ for i in "${animals[@]}"; do echo "$i"; done
a dog               # <-- 每个元素被完美地保留
a cat
a fish
```

> **最终结论和黄金法则：**
>
> 在绝大多数情况下，当你需要遍历数组或将数组元素作为独立参数传递时，**永远使用 `"${array[@]}"`**。这是唯一能确保正确处理带空格元素的方式。

-----

#### 35.2.2 确定数组元素的数量

  - **核心思想**：可以使用 `${#数组名[@]}` 语法来获取数组中**已赋值元素的总数**。

  - **关键区别**：

      - `${#array[@]}`：获取数组 `array` 中元素的**数量**。
      - `${#array[index]}`：获取数组 `array` 中索引为 `index` 的那个元素的**字符串长度**。

**关键示例：**

```bash
[me@linuxbox ~]$ declare -a a
[me@linuxbox ~]$ a[100]=foo

# 获取数组 a 中元素的数量
[me@linuxbox ~]$ echo ${#a[@]}
1

# 获取数组 a 中索引为 100 的元素的字符串长度 ("foo" 的长度)
[me@linuxbox ~]$ echo ${#a[100]}
3
```

  - **重要特性 (稀疏数组)**：Bash 数组是“稀疏”的。上面的例子中，我们只给索引 `100` 赋值了，数组的元素数量就是 `1`。中间未被使用的索引 `0` 到 `99` 并**不存在**，也不会被计入总数。

-----

#### 35.2.3 查找数组使用的索引

  - **核心思想**：由于 Bash 数组是稀疏的，有时我们需要知道到底哪些索引是**实际被使用了的**。
  - **关键语法**：`${!数组名[@]}`。在数组名前加上感叹号 `!`，就会返回所有**已使用的索引**的列表。

**关键示例：获取稀疏数组的索引和值**
创建一个只使用了索引 2, 4, 6 的数组。

```bash
[me@linuxbox ~]$ foo=([2]=a [4]=b [6]=c)

# 使用 "${foo[@]}" 遍历数组的 "值"
[me@linuxbox ~]$ for i in "${foo[@]}"; do echo "Value: $i"; done
Value: a
Value: b
Value: c

# 使用 "${!foo[@]}" 遍历数组的 "索引"
[me@linuxbox ~]$ for i in "${!foo[@]}"; do echo "Index: $i"; done
Index: 2
Index: 4
Index: 6
```


-----

#### 35.2.4 向数组尾部添加元素

  - **核心思想**：当你需要向一个已存在的数组末尾追加一个或多个新元素时，可以使用 `+=` 赋值操作符。
  - **关键语法**：
    ```bash
    数组名+=(值1 值2 ...)
    ```

**关键示例：**

```bash
# 1. 创建一个初始数组
[me@linuxbox ~]$ foo=(a b c)
[me@linuxbox ~]$ echo "${foo[@]}"
a b c

# 2. 使用 += 追加新元素
[me@linuxbox ~]$ foo+=(d e f)
[me@linuxbox ~]$ echo "${foo[@]}"
a b c d e f
```

-----

#### 35.2.5 数组排序

  - **核心思想**：Bash 本身没有内置的数组排序命令，但我们可以巧妙地结合 `for` 循环、管道 `|`、`sort` 命令和命令替换 `$(...)` 来实现。

  - **排序技巧分解**：

    1.  `for i in "${a[@]}"; do echo $i; done`: 逐行打印出数组的每个元素。
    2.  `... | sort`: 将打印出的元素列表通过管道传给 `sort` 命令进行排序。
    3.  `var=($( ... ))`: 使用命令替换 `$(...)` 捕获 `sort` 命令的输出，并用圆括号 `()` 将这个已排序的列表重新存入一个新数组。

**关键示例：对数组进行字母排序**

```bash
#!/bin/bash
# array-sort: 对数组排序

# 原始无序数组
a=(f e d c b a)
echo "Original array: ${a[@]}"

# 使用技巧进行排序，并将结果存入新数组 a_sorted
a_sorted=($(for i in "${a[@]}"; do echo "$i"; done | sort))

echo "Sorted array:   ${a_sorted[@]}"
```

**执行结果：**

```shell
[me@linuxbox ~]$ array-sort
Original array: f e d c b a
Sorted array:   a b c d e f
```

-----

#### 35.2.6 删除数组

  - **核心思想**：使用 `unset` 命令可以删除整个数组，或者只删除数组中的某个特定元素。

  - **删除整个数组**：

      - **语法**：`unset 数组名`

    <!-- end list -->

    ```bash
    [me@linuxbox ~]$ foo=(a b c)
    [me@linuxbox ~]$ unset foo
    [me@linuxbox ~]$ echo "${foo[@]}" # 输出为空
    ```

  - **删除单个元素**：

      - **语法**：`unset '数组名[索引]'`
      - **注意**：删除单个元素时，**强烈建议用单引号 `'...'` 把 `数组名[索引]` 括起来**，以防止 Shell 将 `[` 和 `]` 误认为是通配符而进行路径名扩展。

    <!-- end list -->

    ```bash
    [me@linuxbox ~]$ foo=(a b c d e f)
    [me@linuxbox ~]$ unset 'foo[2]' # 删除索引为2的元素 (即 "c")
    [me@linuxbox ~]$ echo "${foo[@]}"
    a b d e f
    ```

  - **常见的误区 (What NOT to do)**：

    1.  `foo=` **不能**清空数组。这个命令只会清空**索引为 0 的元素** (`${foo[0]}`), 其他元素不受影响。
    2.  不带索引访问数组名 (如 `echo $foo` 或 `echo ${foo}`)，实际上访问的是**索引为 0 的元素** (`${foo[0]}`), 而不是整个数组。

    <!-- end list -->

    ```bash
    [me@linuxbox ~]$ foo=(a b c)
    [me@linuxbox ~]$ foo=A # 这等价于 foo[0]=A
    [me@linuxbox ~]$ echo "${foo[@]}"
    A b c
    ```

-----

### 35.3 关联数组

  - **核心思想**：关联数组 (Associative Array) 是一种更强大的数组，它使用**字符串**作为索引（也称为“键” or "key"），而不是像普通数组那样使用数字。这让你能够以更直观的方式存储和检索“键-值”对 (key-value pairs)。

  - **重要前提**：此功能需要 **Bash 4.0** 或更高版本。

  - **与普通数组的关键区别**：

      - **索引类型**：普通数组用**整数**作索引 (`array[0]`)；关联数组用**字符串**作索引 (`array["name"]`)。
      - **创建方式**：关联数组**必须**在使用前通过 `declare -A` 命令进行**显式声明**。普通数组则可以隐式创建。

  - **关键语法**：

      - **声明**：`declare -A 数组名`
      - **赋值**：`数组名["键"]="值"`
      - **访问**：`${数组名["键"]}`

**关键示例：创建一个存储颜色十六进制代码的关联数组**

```bash
#!/bin/bash

# 1. 必须先用 declare -A 声明一个关联数组
declare -A colors

# 2. 使用字符串作为键 (索引) 来赋值
colors["red"]="#ff0000"
colors["green"]="#00ff00"
colors["blue"]="#0000ff"
colors["white"]="#ffffff"

# 3. 使用键来访问对应的值
echo "The hex code for red is: ${colors["red"]}"
echo "The hex code for blue is: ${colors["blue"]}"
```

**执行结果：**

```shell
The hex code for red is: #ff0000
The hex code for blue is: #0000ff
```

**分析**：关联数组非常适合用于存储具有描述性名称的数据，例如配置项、用户信息、映射关系等，让代码的可读性大大增强。


# 案例学习
好嘞 👍 我给你做一个 **C++ 后端常用 Bash 数组技巧速查表**，只保留你在写 **部署/测试/日志分析/脚本自动化** 时最有用的部分，并且给出实际场景例子。

---

# 🚀 C++ 后端 Bash 数组速查表

## 1. 创建数组

```bash
# 一次性赋值
servers=("10.0.0.1" "10.0.0.2" "10.0.0.3")

# 显式声明（推荐，可读性好）
declare -a ports
ports=(8080 8081 8082)
```

👉 **应用场景**：存储一组服务器 IP、端口、配置参数。

---

## 2. 访问数组元素

```bash
echo "第1个服务器: ${servers[0]}"
echo "第2个端口: ${ports[1]}"
```

👉 **应用场景**：部署脚本中逐一取出 IP 地址，执行远程操作。

---

## 3. 遍历数组

```bash
for ip in "${servers[@]}"; do
    echo "连接服务器: $ip"
    ssh "$ip" "systemctl restart myservice"
done
```

⚠️ **黄金法则**：永远用 `"${array[@]}"`，否则带空格的元素会被拆开。

👉 **应用场景**：批量启动/停止服务，批量部署。

---

## 4. 数组长度

```bash
echo "服务器数量: ${#servers[@]}"
```

👉 **应用场景**：写脚本时判断数组是否为空，或者遍历时做条件判断。

---

## 5. 获取数组索引

```bash
for idx in "${!servers[@]}"; do
    echo "服务器索引=$idx, IP=${servers[$idx]}"
done
```

👉 **应用场景**：需要用到 **索引+值** 的场合，比如日志里打印出来更清晰。

---

## 6. 向数组追加元素

```bash
servers+=("10.0.0.4")
```

👉 **应用场景**：动态添加新的服务器/端口，不用重新定义数组。

---

## 7. 关联数组（键值对）

```bash
declare -A http_codes
http_codes["200"]="OK"
http_codes["404"]="Not Found"
http_codes["500"]="Internal Server Error"

echo "404 means: ${http_codes["404"]}"
```

👉 **应用场景**：存储 **映射关系**，比如错误码 → 错误描述，配置项 → 值。

---

## 8. 遍历关联数组

```bash
for code in "${!http_codes[@]}"; do
    echo "Code $code = ${http_codes[$code]}"
done
```

👉 **应用场景**：日志统计结果（用户ID → 请求次数），打印配置表。

---

## 9. 删除数组或元素

```bash
unset 'servers[1]'   # 删除某个元素
unset servers        # 删除整个数组
```

👉 **应用场景**：动态调整数组，比如去掉不健康的服务器。

---

## 🎯 总结（后端必会的 Bash 数组用法）

* **批量操作服务器**：存放 IP/端口，用 `for` 遍历。
* **日志分析**：用关联数组做统计（user → 请求数）。
* **部署脚本**：用数组管理配置参数，避免硬编码。
* **统计 & 条件判断**：`${#array[@]}` 获取元素数，判断是否为空。

---

要不要我给你写一个 **实战脚本案例**（比如“统计 Nginx 日志中每个 IP 的访问次数”，用 Bash 关联数组实现），这样你能看到 Bash 数组在后端运维中的真实应用？
