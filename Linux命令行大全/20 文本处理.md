好的，这是对您提供文本的摘要总结和使用案例。

### 20.2.1 cat—连接文件并打印

本节重点介绍了 `cat` 命令除基本的文件内容显示功能之外的几个实用选项，这些选项能够帮助我们**观察和处理文本中的特殊字符及格式**。

-----

#### 摘要

##### 1\. 显示非打印字符 (`-A`)

  * **核心功能**: `-A` (或 `--show-all`) 选项能够将文本中所有**不可见的特殊字符**可视化，这对于调试文件格式问题非常有用。
  * **常见可视化字符**:
      * **制表符 (Tab)**: 显示为 `^I`。
      * **行尾**: 在每行的实际结尾处显示一个 `$` 符号。这可以非常清晰地看出行末是否有多余的**结尾空格**。
      * **回车符 (Carriage Return)**: 在 MS-DOS/Windows 格式的文件中，行尾的回车符会显示为 `^M`。

##### 2\. MS-DOS vs. UNIX 文本格式

  * 这是一个常见的文件兼容性问题。
      * **UNIX/Linux**: 行尾只使用一个**换行符 (LF)**。
      * **MS-DOS/Windows**: 行尾使用**回车符 (CR) + 换行符 (LF)** 的组合。
  * 这导致从 Windows 系统来的文本文件在 Linux 下打开时，可能会在每行末尾多出一个看不见的 `^M` 字符，从而引发各种问题。`cat -A` 是发现这个问题的利器。

##### 3\. 简单文本处理

  * **`-n` (number)**: 为输出的**所有行**（包括空行）添加行号。
  * **`-s` (squeeze-blank)**: 将连续两行或更多的**空白行压缩为一行**。

-----

### 使用案例

#### 案例一：创建文件并检查特殊字符

这个案例演示如何用 `cat` 创建一个包含特殊字符的文件，并用 `-A` 选项来观察它们。

1.  **第一步：创建文件**

      * 使用 `cat >` 命令创建一个名为 `testfile.txt` 的文件。
      * 在输入时，第一行开头按一下 `Tab` 键，第二行末尾多按几个空格。
      * 输入完成后，按 `Ctrl + D` 结束并保存。

    <!-- end list -->

    ```bash
    cat > testfile.txt
        This line starts with a tab.
    This line has trailing spaces.    
    (这里按下 Ctrl + D)
    ```

2.  **第二步：使用 `-A` 选项检查文件**

    ```bash
    cat -A testfile.txt
    ```

3.  **分析输出**
    你会看到如下结果，特殊字符一目了然：

    ```
    ^IThis line starts with a tab.$
    This line has trailing spaces.    $
    ```

      * `^I` 清晰地标示出了行首的制表符。
      * `$` 紧跟在 `spaces.` 之后，暴露了第二行末尾的多个空格。

#### 案例二：压缩空行并添加行号

这个案例演示如何用 `-n` 和 `-s` 选项处理一个格式不整齐的文件。

1.  **第一步：创建一个包含多个连续空行的文件**

    ```bash
    cat > report.txt
    Line 1


    Line 2
    Line 3
    (这里按下 Ctrl + D)
    ```

2.  **第二步：使用 `-s` 压缩空行**

    ```bash
    cat -s report.txt
    ```

    输出结果会将中间的多个空行压缩成一个：

    ```
    Line 1

    Line 2
    Line 3
    ```

3.  **第三步：组合使用 `-n` 和 `-s`**
    在压缩空行的同时，为剩余的行添加行号。

    ```bash
    cat -ns report.txt
    ```

    输出结果既整洁又带有行号：

    ```
      1  Line 1
      2
      3  Line 2
      4  Line 3
    ```

      * **注意**: 被保留的那个空行也被编号了。如果你只想给非空行编号，可以使用 `-b` 选项 (`cat -bs report.txt`)。

### 20.2.2 sort—排序

本节详细介绍了 `sort` 命令，这是一个强大的文本处理工具，用于对文件内容或标准输入进行逐行排序，并将结果输出到标准输出。

-----

#### 摘要

##### 1\. 基本功能与常用选项

  * **基本用法**: `sort` 默认按**字母顺序 (lexicographical order)** 对整行进行排序。
  * **常用选项**:
      * `-r`: **反向 (Reverse)** 排序，即降序。
      * `-n`: **按数值 (Numeric)** 大小进行排序，而不是按字符顺序（例如，这能确保 "10" 排在 "9" 之后，而不是 "1" 之后）。
      * `-f`: **忽略 (Fold)** 大小写差异。
      * `-o file`: 将排序结果**输出 (Output)** 到指定文件 `file`，而不是标准输出。

##### 2\. 高级功能：按字段 (Key) 排序

`sort` 最强大的功能是能够处理表格型数据，即按特定的\*\*列（字段）\*\*进行排序。

  * **`-k [字段号]` (Key)**: 指定用于排序的**关键字段**。
      * 字段默认由**空白字符**（空格或制表符）分隔。
      * 可以在字段号后直接附加排序选项，如 `n` (数值) 或 `r` (反向)，例如 `-k 5nr` 表示按第5个字段进行数值反向排序。
  * **`-t [分隔符]` (Separator)**: 当字段不是由空白分隔时，使用此选项指定**自定义的字段分隔符**，例如 `-t ':'` 用于处理 `/etc/passwd` 文件。
  * **多关键字排序**: 可以使用多个 `-k` 选项来实现**主、次关键字排序**。例如，先按第1列排序，如果第1列相同，再按第2列排序。
  * **按字段内的部分内容排序**: `sort` 甚至支持按字段内的**字符偏移量**进行排序，语法为 `-k [字段号].[起始字符位置]`。这对于处理非标准格式的日期等复杂数据非常有用。

-----

### 使用案例

#### 案例一：找出占用磁盘空间最大的目录

这个案例展示了 `-n` (数值) 和 `-r` (反向) 选项的威力。

1.  **生成磁盘使用情况报告**
    `du -s /usr/share/*` 会计算 `/usr/share/` 下每个文件和目录的大小。

2.  **排序并查看前10名**
    我们将 `du` 的输出通过管道传给 `sort`，并使用 `-nr` 选项，最后用 `head` 查看结果。

    ```bash
    du -s /usr/share/* | sort -nr | head -n 10
    ```

      * **`-n`**: 确保按第一列的**数值大小**排序。
      * **`-r`**: 将结果**反向**，让最大的排在最前面。
      * 这样就能快速找到占用空间最大的前10个目录。

#### 案例二：按文件大小对 `ls -l` 的输出进行排序

`ls -l` 的输出中，文件大小是第5个字段。我们可以用 `-k 5` 来对其排序。

```bash
ls -l /usr/bin | sort -nrk 5 | head -n 10
```

  * **`-k 5`**: 指定使用第5个字段（文件大小）作为排序关键字。
  * **`nr`**: `n` 和 `r` 作为 `-k` 的修饰符，附加在字段号之后，表示对该字段进行**数值反向**排序。

#### 案例三：处理多关键字排序问题

假设有一个 `distros.txt` 文件，内容为 `[发行版名称] [版本号] [日期]`。如果直接排序，"Fedora 10" 会排在 "Fedora 5" 前面，因为 "1" 的字母顺序在 "5" 前面。我们需要多关键字排序来修正它。

```bash
# distros.txt 内容示例:
# Fedora 10 ...
# Fedora 5 ...
sort -k 1,1 -k 2n distros.txt
```

  * **`-k 1,1`**: 第一个排序规则。表示排序关键字**仅限于**第1个字段（从第1字段开始，到第1字段结束）。
  * **`-k 2n`**: 第二个排序规则。当第1字段相同时，使用第2个字段按**数值 (`n`)** 进行排序。
  * 这样就能保证先按发行版名称排序，再按版本号大小正确排序。

#### 案例四：处理自定义分隔符和复杂日期

1.  **自定义分隔符**: 对 `/etc/passwd` 文件按用户 ID (第3字段) 进行数值排序。

    ```bash
    # /etc/passwd 文件使用 ":" 作为分隔符
    sort -t ':' -k 3n /etc/passwd | head
    ```

      * **`-t ':'`**: 指定字段分隔符为冒号。
      * **`-k 3n`**: 按第3个字段进行数值排序。

2.  **复杂日期排序**: 对 `MM/DD/YYYY` 格式的日期进行降序排序。

    ```bash
    # 假设日期在第3个字段
    sort -k 3.7nr -k 3.1nr -k 3.4nr distros.txt
    ```

      * **`-k 3.7nr`**: 先按第3字段的第7个字符（年份）进行数值反向排序。
      * **`-k 3.1nr`**: 年份相同时，按第3字段的第1个字符（月份）进行数值反向排序。
      * **`-k 3.4nr`**: 月份相同时，按第3字段的第4个字符（日期）进行数值反向排序。

### 20.2.3 uniq—删除重复行

本节介绍了 `uniq` 命令，这是一个用于处理文本数据、报告或删除其中重复行的工具。它通常与 `sort` 命令配合使用。

-----

#### 摘要

##### 1\. 核心工作原理（最重要的一点）

  * `uniq` 的核心功能是**找出并处理连续的重复行**。
  * **关键前提**：`uniq` 命令**只能**检测和处理**相邻**的重复行。如果文件中存在重复行但它们不挨在一起，`uniq` 将无法识别它们。
  * **标准工作流程**：正因为如此，`uniq` 几乎总是与 `sort` 命令通过管道 (`|`) 结合使用。首先用 `sort` 对文本进行排序，确保所有相同的行都排列在一起，然后交给 `uniq` 进行处理。
    ```bash
    sort file.txt | uniq
    ```

##### 2\. `sort -u` 快捷方式

  * 文本中提到了一个重要的技巧：GNU 版本的 `sort` 命令提供了一个 `-u` (`--unique`) 选项，它可以在排序的同时直接删除重复行，其效果等同于 `sort file.txt | uniq`。在很多简单场景下，使用 `sort -u` 会更加简洁高效。

##### 3\. 常用选项

  * **`-c` (--count)**: **统计**每行连续重复的次数，并在每行开头处显示该计数值。这是 `uniq` 最强大的功能之一。
  * **`-d` (--repeated)**: **只显示**那些**重复出现过的行**（每组重复行只显示一次）。
  * **`-u` (--unique)**: **只显示**那些**从未重复过的行**（即唯一的行）。
  * **`-i` (--ignore-case)**: 在比较行是否重复时**忽略大小写**。

-----

### 使用案例

我们将使用一个名为 `data.txt` 的文件，其内容如下：

```
apple
banana
APPLE
apple
cherry
banana
```

#### 案例一：正确与错误的用法对比

1.  **错误的用法 (直接使用 `uniq`)**
    因为重复的行不相邻，`uniq` 几乎不起作用。

    ```bash
    uniq data.txt
    # 输出:
    # apple
    # banana
    # APPLE
    # apple
    # cherry
    # banana
    ```

2.  **正确的用法 (先 `sort` 再 `uniq`)**

    ```bash
    sort data.txt | uniq
    # 输出:
    # apple
    # APPLE
    # banana
    # cherry
    ```

      * 注意：`apple` 和 `APPLE` 因为大小写不同，被视为不同的行。

3.  **更简洁的用法 (`sort -u`)**

    ```bash
    sort -u data.txt
    # 输出与上面完全相同
    ```

#### 案例二：统计每个水果出现的次数 (`-c`)

这个案例展示了如何统计数据中各项的出现频率。

```bash
sort data.txt | uniq -c
# 输出:
#      2 apple
#      1 APPLE
#      2 banana
#      1 cherry
```

  * **解读**: `apple` 出现了2次，`APPLE` 出现了1次，`banana` 出现了2次，`cherry` 出现了1次。

#### 案例三：结合 `-i` 忽略大小写

如果我们认为 `apple` 和 `APPLE` 是同一样东西，可以加入 `-i` 选项。

```bash
sort -f data.txt | uniq -ic
# sort -f 也是忽略大小写排序，确保 APPLE 和 apple 排在一起
# 输出:
#      3 apple   (或者 APPLE，取决于排序结果)
#      2 banana
#      1 cherry
```

#### 案例四：找出哪些是重复项，哪些是独有项

1.  **只看重复出现过的水果 (`-d`)**

    ```bash
    sort data.txt | uniq -d
    # 输出:
    # apple
    # banana
    ```

2.  **只看从未重复过的水果 (`-u`)**

    ```bash
    sort data.txt | uniq -u
    # 输出:
    # APPLE
    # cherry
    ```


### 20.3.1 cut——从每行中删除部分内容

本节介绍了 `cut` 命令，这是一个用于从文件或标准输入的**每一行**中\*\*提取（剪切）\*\*出特定部分文本的工具。它非常适合处理结构化的、按列组织的文本数据。

-----

#### 摘要

##### 1\. 核心功能与选项

`cut` 主要通过两种方式来指定要提取的内容：

  * **按字符 (`-c list, --characters=list`)**:

      * 根据**字符的位置**进行提取。
      * `list` 可以是单个数字、一个范围或逗号分隔的列表。例如：
          * `-c 5`: 提取第5个字符。
          * `-c 1-10`: 提取第1到第10个字符。
          * `-c 1,5,10`: 提取第1、第5和第10个字符。

  * **按字段 (`-f list, --fields=list`)**:

      * 根据\*\*字段（列）\*\*进行提取。
      * `list` 的格式与 `-c` 选项类似。例如 `-f 1,3` 表示提取第1和第3个字段。

  * **指定分隔符 (`-d delim, --delimiter=delim`)**:

      * 当使用 `-f` 按字段提取时，`cut` **默认使用制表符 (Tab)** 作为字段之间的分隔符。
      * 如果你的数据使用其他字符分隔（如逗号、冒号），则必须使用 `-d` 选项来**指定新的分隔符**。

##### 2\. 辅助工具 `expand`

  * `expand` 命令可以将文件中的**制表符转换为空格**。这在处理制表符分隔的文件，但又想使用 `cut -c` 按固定字符位置进行精确提取时非常有用，因为 `expand` 可以将非对齐的列转换为对齐的固定宽度列。

-----

### 使用案例

#### 案例一：从制表符分隔的文件中提取字段 (`-f`)

假设我们有一个 `distros.txt` 文件，其内容使用**制表符**分隔 `[发行版] [版本] [日期]`。

1.  **提取第三个字段（日期）**:

    ```bash
    # 因为默认分隔符就是制表符，所以无需 -d 选项
    cut -f 3 distros.txt
    ```

    **输出**:

    ```
    12/07/2006
    11/25/2008
    ...
    ```

2.  **提取第一个和第三个字段**:

    ```bash
    cut -f 1,3 distros.txt
    ```

    **输出**: (发行版和日期，中间由制表符分隔)

    ```
    SUSE    12/07/2006
    Fedora  11/25/2008
    ...
    ```

#### 案例二：从结果中提取特定字符 (`-c`)

我们可以将多个命令通过管道连接起来，进行更精细的操作。例如，从上一个案例的结果中只提取出年份。

```bash
# 先用 -f 3 提取出日期字段 "MM/DD/YYYY"，再用 -c 7-10 从结果中提取第7到10个字符（年份）
cut -f 3 distros.txt | cut -c 7-10
```

**输出**:

```
2006
2008
...
```

#### 案例三：处理自定义分隔符的文件 (`-d`)

`/etc/passwd` 文件是一个典型的使用\*\*冒号 (`:`)\*\*作为分隔符的文件。我们可以用 `cut` 轻松地从中提取出用户名（第1字段）和用户的 Shell (第7字段)。

1.  **提取所有用户名 (第1字段)**:

    ```bash
    cut -d ':' -f 1 /etc/passwd | head
    ```

      * `-d ':'`: 明确告诉 `cut` 命令，字段是由冒号分隔的。
      * `-f 1`: 提取第一个字段。

    **输出**:

    ```
    root
    daemon
    bin
    ...
    ```

2.  **提取用户名和对应的 Shell (第1和第7字段)**:

    ```bash
    cut -d ':' -f 1,7 /etc/passwd | head
    ```

    **输出**:

    ```
    root:/bin/bash
    daemon:/usr/sbin/nologin
    bin:/usr/sbin/nologin
    ...
    ```