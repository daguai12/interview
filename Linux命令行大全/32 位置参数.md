### 32.1 访问命令行

  - **核心思想**：当你在命令行上执行一个脚本并跟上一些单词（参数）时，Shell 会将这些参数自动存入一组名为\*\*“位置参数” (positional parameters)\*\* 的特殊变量中。
  - **关键变量**：
      - `$0`：永远是**脚本自身的名称**（包含路径）。
      - `$1`：命令行上的**第一个**参数。
      - `$2`：命令行上的**第二个**参数。
      - `$3`...`$9`：以此类推，直到第九个参数。

**关键示例：查看位置参数**
这个脚本会打印出前 10 个位置参数的值。

```bash
#!/bin/bash
# posit-param: 查看命令行参数的脚本

echo "\$0 (脚本名) = $0"
echo "\$1 (第一个参数) = $1"
echo "\$2 (第二个参数) = $2"
echo "\$3 (第三个参数) = $3"
# ... 等等 ...
```

**执行结果 1：不带参数运行**
`$0` 总是有值的，而其他参数为空。

```shell
[me@linuxbox ~]$ posit-param
$0 (脚本名) = /home/me/bin/posit-param
$1 (第一个参数) =
$2 (第二个参数) =
$3 (第三个参数) =
```

**执行结果 2：带参数运行**
参数被依次赋值给 `$1`, `$2`, `$3`...

```shell
[me@linuxbox ~]$ posit-param foo bar baz
$0 (脚本名) = /home/me/bin/posit-param
$1 (第一个参数) = foo
$2 (第二个参数) = bar
$3 (第三个参数) = baz
```

> **提示**：要访问第 9 个之后的参数（例如第 10 个），不能直接用 `$10`，因为 Shell 会把它看作 `$1` 后面跟着一个 `0`。正确语法是使用花括号：`${10}`, `${11}` 等。

-----

#### 32.1.1 确定参数个数

  - **核心思想**：除了可以直接访问参数，Shell 还提供了一个特殊变量来告诉你总共接收了多少个参数。
  - **关键变量 `$#`**：这个变量包含了命令行上传递的**参数总数**（**不**包括脚本名 `$0`）。

**关键示例：显示参数个数**

```bash
#!/bin/bash
# posit-param2: 显示参数个数和值

echo "你输入了 $# 个参数。"
echo "第一个参数是: $1"
echo "第二个参数是: $2"
```

**执行结果：**

```shell
[me@linuxbox ~]$ posit-param2 foo bar baz
你输入了 3 个参数。
第一个参数是: foo
第二个参数是: bar
```


-----

#### 32.1.2 shift——访问多个参数

  - **核心思想**：当你需要处理的参数超过 9 个，或者不确定总共有多少个参数时，`shift` 命令是标准的解决方案。它提供了一种**逐个处理**所有命令行参数的简单方法。
  - **工作原理**：每执行一次 `shift` 命令：
    1.  `$1` 的值被**丢弃**。
    2.  所有剩余的参数**向左移动一位**（`$2` 变成 `$1`，`$3` 变成 `$2`，依此类推）。
    3.  参数总数 `$#` 的值**减 1**。

**关键示例：使用 `while` 和 `shift` 遍历所有参数**
这个 `while` 循环是处理所有命令行参数的**经典模式 (classic pattern)**，必须掌握。

```bash
#!/bin/bash
# posit-param2: 脚本显示所有参数
count=1

# 只要参数个数大于0，就一直循环
while [[ $# -gt 0 ]]; do
  echo "第 $count 个参数是: $1"
  count=$((count + 1))
  shift # 移走 $1，让下一个参数成为新的 $1
done
```

**执行结果：**

```shell
[me@linuxbox ~]$ posit-param2 a b c d
第 1 个参数是: a
第 2 个参数是: b
第 3 个参数是: c
第 4 个参数是: d
```

-----

#### 32.1.3 简单应用

  - **核心思想**：位置参数最直接的用途就是让你的脚本可以接受输入，变得更通用。例如，编写一个脚本来处理用户指定的任意文件。

**关键示例：一个简单的文件信息脚本**
这个脚本接收一个文件名作为它的第一个参数 (`$1`)，然后显示该文件的信息。

```bash
#!/bin-bash
# file-info: 简单文件信息程序

# 使用 basename "$0" 获取脚本自己的名字，而不是完整路径
PROGNAME="$(basename "$0")"

# 检查第一个参数 ($1) 对应的文件是否存在
if [[ -e "$1" ]]; then
  echo "文件类型:"
  file "$1"
  echo
  echo "文件状态:"
  stat "$1"
else
  # 如果文件不存在或未提供参数，打印用法信息并退出
  echo "用法: $PROGNAME <文件名>" >&2
  exit 1
fi
```

  - **关键技巧**：`PROGNAME="$(basename "$0")"` 是一个非常有用的技巧。它能让你的脚本在打印错误或用法信息时，总是显示正确的脚本名，即使你以后重命名了该脚本文件。

-----

#### 32.1.4 在 Shell 函数中使用位置参数

  - **核心思想**：Shell 函数**拥有自己独立的位置参数集** (`$1`, `$2`, `$#` 等)。当你调用一个函数并向它传递参数时，这些参数会成为函数**内部**的位置参数，它们与脚本自身的位置参数是分开的、互不影响的。

  - **关键变量 `$FUNCNAME`**：在函数内部，`$FUNCNAME` 变量包含了**当前函数的名字**，这在打印函数相关的错误信息时非常有用。（类似于 `$0` 对于脚本的作用）。

**关键示例：将 `file-info` 脚本改写为函数**
注意看 `$PROGNAME` 如何变成了 `$FUNCNAME`，`exit 1` 如何变成了 `return 1`。

```bash
# 定义一个可以被其他脚本调用的函数
file_info () {
  # 在函数内部，$1 指的是调用函数时传递的第一个参数
  if [[ -e "$1" ]]; then
    echo "文件类型:"
    file "$1"
    echo
    echo "文件状态:"
    stat "$1"
  else
    # 在函数内部，用 $FUNCNAME 获取函数名
    echo "用法: $FUNCNAME <文件名>" >&2
    # 在函数内部，用 return 返回退出状态，而不是 exit
    return 1
  fi
}

# 如何在脚本中调用这个函数：
# file_info "/etc/passwd"  # 这时函数内的 $1 就是 "/etc/passwd"
```


-----

### 32.2 批量处理位置参数

  - **核心思想**：有时候，我们不想逐个处理参数，而是需要将**所有**的命令行参数一次性地、原封不动地传递给另一个命令。这在编写“包装器”(wrapper)脚本时尤其常见。

  - **关键变量**：Shell 提供了两个特殊变量来实现这个目的：

      - `$*`：代表所有位置参数。
      - `$@`：也代表所有位置参数。

  - **最重要的区别**：这两个变量的行为差异，体现在它们被**双引号**`" "`包围的时候。

      - `"$*"`：会将**所有**参数合并成**一个**单一的字符串。参数之间默认用空格分隔。
      - `"$@"`：会将**每个**参数都当作一个**独立**的字符串。它会完美地保留所有参数的原始边界，即使参数本身包含空格。

**关键示例：演示 `"$*"` 和 `"$@"` 的巨大差异**
下面的脚本通过一个函数调用来清晰地展示四种形式（带引号和不带引号）的区别。

```bash
#!/bin/bash
# posit-params3: 演示 $* 和 $@ 的脚本

# 这个函数只是为了打印它接收到的前4个参数
print_params () {
  echo "\$1 = '$1'"
  echo "\$2 = '$2'"
  echo "\$3 = '$3'"
  echo "\$4 = '$4'"
}

# 我们给脚本传递两个参数："word" 和 "words with spaces"
# 然后用4种不同方式把它们再传给 print_params 函数
echo "--- 1. 使用 \$* (不带引号) ---"
print_params $*

echo "--- 2. 使用 \"\$*\" (带引号) ---"
print_params "$*"

echo "--- 3. 使用 \$@ (不带引号) ---"
print_params $@

echo "--- 4. 使用 \"\$@\" (带引号) ---"
print_params "$@"
```

**脚本的调用和执行结果分析：**

假设我们这样调用脚本：`./posit-params3 "word" "words with spaces"`
那么脚本最初收到的参数是：`$1="word"`, `$2="words with spaces"`。

**执行结果：**

```shell
--- 1. 使用 $* (不带引号) ---
$1 = 'word'
$2 = 'words'
$3 = 'with'
$4 = 'spaces'
# 分析： "words with spaces" 被拆分成了三个独立的单词。错了！

--- 2. 使用 "$*" (带引号) ---
$1 = 'word words with spaces'
$2 = ''
$3 = ''
$4 = ''
# 分析：所有参数被合并成了一个单一的字符串。也错了！

--- 3. 使用 $@ (不带引号) ---
$1 = 'word'
$2 = 'words'
$3 = 'with'
$4 = 'spaces'
# 分析：和 $* 不带引号时一样，也被拆分了。还是错了！

--- 4. 使用 "$@" (带引号) ---
$1 = 'word'
$2 = 'words with spaces'
$3 = ''
$4 = ''
# 分析：完美！参数被原封不动地传递了，保留了原始的边界。正确！
```

> **最终结论和黄金法则：**
>
> 在绝大多数情况下，当你需要将所有参数传递给另一个命令或函数时，**永远使用 `"$@"`**。这是唯一能确保参数（特别是包含空格的参数）被正确、安全地传递的方式。


-----

### 32.3 一个更完整的应用

  - **核心思想**：现在我们将之前学到的所有知识——位置参数、`shift`、`while` 循环、`case` 语句和函数——结合起来，为一个脚本添加专业级的命令行选项处理功能。

  - **目标功能**：为我们的 `sys_info_page` 脚本添加以下选项：

      - `-f file` 或 `--file file`：将输出保存到指定文件。
      - `-i` 或 `--interactive`：进入交互模式，提示用户输入文件名。
      - `-h` 或 `--help`：显示帮助信息并退出。

-----

#### 1\. 核心逻辑：用 `while/case/shift` 解析命令行选项

这是 Shell 脚本中处理命令行选项的**标准模式 (standard pattern)**，必须掌握。

  - **`while [[ -n "$1" ]]`**：当 `$1` (第一个位置参数) 不为空时，就一直循环。
  - **`case "$1" in ... esac`**：在循环内部，用 `case` 语句判断当前的 `$1` 是哪个选项。
  - **`shift`**：在每次循环的末尾，用 `shift` 丢弃当前的 `$1`，让下一个参数成为新的 `$1`，从而驱动循环前进，直到所有参数都被处理完。

**关键示例 1：命令行选项处理循环**

```bash
# ... (usage 函数定义省略) ...
interactive=
filename=

# 只要 $1 不为空，就一直循环处理参数
while [[ -n "$1" ]]; do
  case "$1" in
    -f | --file)
      shift # 移走 -f 选项本身
      filename="$1" # 将紧跟其后的参数作为文件名
      ;;
    -i | --interactive)
      interactive=1 # 设置一个标志变量
      ;;
    -h | --help)
      usage # 调用 usage 函数显示帮助
      exit
      ;;
    *) # 捕获所有未知的选项
      usage >&2
      exit 1
      ;;
  esac
  shift # 移走刚刚处理过的选项或参数，准备处理下一个
done
```

> **重点**：对于 `-f file` 这种需要一个额外参数的选项，`case` 块内部需要一个额外的 `shift` 来“吃掉”这个参数。

-----

#### 2\. 实现交互模式

  - **核心思想**：如果用户指定了 `-i` 选项（`$interactive` 变量被设为 1），则进入一个无限循环，反复提示用户输入文件名，直到获得一个有效的文件名或用户选择退出。

**关键示例 2：交互模式的文件名提示**

```bash
# 如果 interactive 变量不为空 (即用户使用了 -i 选项)
if [[ -n "$interactive" ]]; then
  while true; do # 无限循环
    read -p "请输入输出文件名: " filename
    if [[ -e "$filename" ]]; then # 检查文件是否已存在
      read -p "'$filename' 已存在。是否覆盖? [y/n/q] > "
      case "$REPLY" in
        Y|y)
          break # 用户同意覆盖，跳出无限循环
          ;;
        Q|q)
          echo "程序已终止。"
          exit  # 用户选择退出，结束脚本
          ;;
        *)
          continue # 其他任何输入，继续循环，重新提示
          ;;
      esac
    elif [[ -z "$filename" ]]; then # 检查用户是否只按了回车
      continue # 输入为空，继续循环，重新提示
    else
      break # 文件不存在且输入不为空，是有效文件名，跳出循环
    fi
  done
fi
```

-----

#### 3\. 将核心代码封装成函数以实现重用

  - **核心思想**：脚本的最终输出可能有两个去向：1) 标准输出（屏幕）；2) 指定的文件。为了避免复制粘贴同样一段生成页面的代码，我们应该将其封装成一个**函数**。

**关键示例 3：封装与调用**

```bash
# 1. 将页面生成逻辑封装成一个函数
write_html_page () {
  cat <<- _EOF_
    <html>
    <body>
      <h1>$TITLE</h1>
      <p>$TIMESTAMP</p>
      ...
    </body>
    </html>
_EOF_
}

# 2. 在脚本末尾根据条件调用函数
# 如果 filename 变量不为空 (即用户使用了 -f 或 -i 选项)
if [[ -n "$filename" ]]; then
  # 测试文件是否可写，然后将函数输出重定向到文件
  if touch "$filename" && [[ -f "$filename" ]]; then
    write_html_page > "$filename"
  else
    echo "错误: 无法写入文件 '$filename'" >&2
    exit 1
  fi
else
  # 否则，直接调用函数，输出到屏幕
  write_html_page
fi
```


-----

### 32.4 总结

  - **核心思想**：通过学习位置参数，我们现在已经能够编写出功能强大且交互友好的 Shell 脚本。位置参数允许我们的脚本像标准的 Linux 命令一样接收输入，极大地扩展了其实用性。

  - **最终成果**：下面是本章逐步构建的 `sys_info_page` 脚本的最终完整代码。它集成了我们学到的多个核心概念，是一个很好的综合性范例。

**关键示例：完整的 `sys_info_page` 脚本**

这个脚本展示了如何将以下所有功能融合在一起：

  - **全局常量**：定义标题和时间戳。
  - **模块化函数**：将报告的每个部分（uptime, disk space 等）封装在独立的函数中。
  - **命令行选项解析**：使用 `while/case/shift` 模式处理 `-f`, `-i`, `-h` 等选项。
  - **交互模式**：在 `-i` 模式下提示用户输入并处理文件覆盖确认。
  - **代码重用**：将主要的 HTML 生成逻辑封装在 `write_html_page` 函数中，根据需要将其输出到屏幕或文件。

<!-- end list -->

```bash
#!/bin/bash
# sys_info_page: 程序输出系统显示页

# --- 1. 全局变量和常量 ---
PROGNAME="$(basename "$0")"
TITLE="System Information Report For $HOSTNAME"
CURRENT_TIME="$(date +"%x %r %Z")"
TIMESTAMP="Generated $CURRENT_TIME, by $USER"

# --- 2. 报告生成函数 (模块化) ---
report_uptime () {
  cat <<- _EOF_
    <h2>System Uptime</h2>
    <pre>$(uptime)</pre>
_EOF_
}

report_disk_space () {
  cat <<- _EOF_
    <h2>Disk Space Utilization</h2>
    <pre>$(df -h)</pre>
_EOF_
}

report_home_space () {
  if [[ "$(id -u)" -eq 0 ]]; then
    cat <<- _EOF_
      <h2>Home Space Utilization (All Users)</h2>
      <pre>$(du -sh /home/*)</pre>
_EOF_
  else
    cat <<- _EOF_
      <h2>Home Space Utilization ($USER)</h2>
      <pre>$(du -sh "$HOME")</pre>
_EOF_
  fi
}

# --- 3. 辅助函数 ---
usage () {
  echo "$PROGNAME: usage: $PROGNAME [-f file | -i]"
}

# --- 4. 核心输出函数 (代码重用) ---
write_html_page () {
  cat <<- _EOF_
    <html>
      <head><title>$TITLE</title></head>
      <body>
        <h1>$TITLE</h1>
        <p>$TIMESTAMP</p>
        $(report_uptime)
        $(report_disk_space)
        $(report_home_space)
      </body>
    </html>
_EOF_
}

# --- 5. 命令行选项解析 ---
interactive=
filename=
while [[ -n "$1" ]]; do
  case "$1" in
    -f | --file)        shift; filename="$1" ;;
    -i | --interactive) interactive=1 ;;
    -h | --help)        usage; exit ;;
    *)                  usage >&2; exit 1 ;;
  esac
  shift
done

# --- 6. 交互模式逻辑 ---
if [[ -n "$interactive" ]]; then
  while true; do
    read -p "Enter name of output file: " filename
    if [[ -e "$filename" ]]; then
      read -p "'$filename' exists. Overwrite? [y/n/q] > "
      case "$REPLY" in
        Y|y) break ;;
        Q|q) echo "Program terminated."; exit ;;
        *)   continue ;;
      esac
    elif [[ -z "$filename" ]]; then
      continue
    else
      break
    fi
  done
fi

# --- 7. 最终输出逻辑 ---
if [[ -n "$filename" ]]; then
  if touch "$filename" && [[ -f "$filename" ]]; then
    write_html_page > "$filename"
  else
    echo "$PROGNAME: Cannot write file '$filename'" >&2
    exit 1
  fi
else
  write_html_page
fi
```

> 这个程序还不完善，有几处地方仍有改善的空间。