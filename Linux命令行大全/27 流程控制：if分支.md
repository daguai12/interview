
### 27.1 if 语句

  - **核心功能**：`if` 语句是 Shell 编程中用于**做出决策**的基础。它允许你根据某个条件是否成立来执行不同的代码块。
  - **基本语法**：
    ```shell
    if [ 条件 ]; then
      # 条件为真 (true) 时执行这里的代码
    elif [ 另一个条件 ]; then
      # 另一个条件为真时执行这里的代码
    else
      # 所有条件都为假 (false) 时执行这里的代码
    fi
    ```

**关键示例：判断一个变量的值**
这个例子展示了 `if` 语句最常见的用法：

```bash
x=5

# -eq 是 "equal" 的意思，用于比较数字
if [ "$x" -eq 5 ]; then
  echo "x 等于 5."
else
  echo "x 不等于 5."
fi
```

> **思考**：`if` 是如何知道 `[ "$x" -eq 5 ]` 是“真”还是“假”的呢？答案就在下一节：退出状态。

-----

### 27.2 退出状态

  - **核心思想**：在 Shell 中，**所有命令**在执行完毕后都会返回一个数字，称为“**退出状态**”(Exit Status)，这个数字告诉 Shell 命令是成功了还是失败了。

      - `0` 代表 **成功**。
      - `任何非 0` 的数字（1-255）都代表 **失败**。

  - **关键变量 `$?`**：这个特殊变量永远保存着**上一个**执行命令的退出状态。

**关键示例 1：检查命令的成功与失败**

```shell
# 尝试列出一个存在的目录
[me@linuxbox ~]$ ls -d /usr/bin
/usr/bin
[me@linuxbox ~]$ echo $?
0        # 上一条命令成功了，所以返回 0

# 尝试列出一个不存在的目录
[me@linuxbox ~]$ ls -d /a/b/c
ls: cannot access /a/b/c: No such file or directory
[me@linuxbox ~]$ echo $?
2        # 上一条命令失败了，返回一个非 0 值
```

  - **`if` 的工作原理**：`if` 语句的本质，就是检查其后跟随的那个命令的**退出状态是否为 0**。
      - 如果退出状态为 `0` (成功)，`if` 就认为条件为“真”，并执行 `then` 后面的代码。
      - 如果退出状态为 `非 0` (失败)，`if` 就认为条件为“假”，并跳到 `else` 或 `fi`。

**关键示例 2：`true` 和 `false` 命令**
`true` 命令永远返回 `0` (成功)，`false` 命令永远返回 `1` (失败)。用它们可以最清晰地看到 `if` 的工作原理。

```shell
# true 命令返回 0，if 判断为真
[me@linuxbox ~]$ if true; then echo "It's true."; fi
It's true.

# false 命令返回 1，if 判断为假，then 后的代码不执行
[me@linuxbox ~]$ if false; then echo "It's true."; fi
[me@linuxbox ~]$
```

-----

### 27.3 使用 test

  - **核心思想**：我们之前在 `if` 语句中使用的 `[ ... ]`，其实是一个叫做 `test` 的命令。它的唯一作用就是评估一个表达式，然后根据结果是真是假，返回退出状态 `0` (真) 或 `1` (假)。
  - **两种形式**：
    1.  `test expression`
    2.  `[ expression ]` （更常用，**注意 `[` 后和 `]` 前必须有空格**）

`test` 命令支持三种主要的表达式类型：文件、字符串和整数。

#### 27.3.1 文件表达式

  - **作用**：用于检查文件或目录的状态。
  - **常用操作符**：
      - `-e file`：文件是否存在 (exist)？
      - `-f file`：是否为普通文件 (file)？
      - `-d file`：是否为目录 (directory)？
      - `-r file`：是否可读 (readable)？
      - `-w file`：是否可写 (writable)？
      - `-x file`：是否可执行 (executable)？

**关键示例：评估一个文件的多种状态**

```bash
#!/bin/bash
# test-file: 评估文件的状态
FILE=~/.bashrc

if [ -e "$FILE" ]; then
  echo "$FILE 存在。"
  if [ -f "$FILE" ]; then
    echo "它是一个普通文件。"
  fi
  if [ -r "$FILE" ]; then
    echo "它可读。"
  fi
else
  echo "$FILE 不存在。"
  exit 1
fi
```

> **重要习惯**：在 `[ ... ]` 中使用变量时，一定要用双引号 `"$VAR"` 括起来。这可以防止当变量为空或包含空格时，脚本出错。

#### 27.3.2 字符串表达式

  - **作用**：用于比较字符串或判断字符串是否为空。
  - **常用操作符**：
      - `-z "$str"`：字符串是否为空 (zero length)？
      - `-n "$str"`：字符串是否不为空 (non-zero length)？
      - `"$str1" == "$str2"`：两个字符串是否相等？(推荐用 `==`)
      - `"$str1" != "$str2"`：两个字符串是否不相等？

**关键示例：根据字符串内容执行不同操作**

```bash
#!/bin/bash
# test-string: 判断字符串的值
ANSWER="maybe"

if [ -z "$ANSWER" ]; then
  echo "错误: 字符串为空。" >&2
  exit 1
fi

if [ "$ANSWER" == "yes" ]; then
  echo "答案是 YES."
elif [ "$ANSWER" == "no" ]; then
  echo "答案是 NO."
else
  echo "答案是 UNKNOWN."
fi
```

#### 27.3.3 整数表达式

  - **作用**：专门用于比较整数。**注意，它的操作符和字符串比较完全不同。**
  - **常用操作符**：
      - `$int1 -eq $int2`：等于 (equal)
      - `$int1 -ne $int2`：不等于 (not equal)
      - `$int1 -gt $int2`：大于 (greater than)
      - `$int1 -lt $int2`：小于 (less than)
      - `$int1 -ge $int2`：大于或等于
      - `$int1 -le $int2`：小于或等于

**关键示例：判断整数的正负与奇偶**

```bash
#!/bin/bash
# test-integer: 判断整数的值
INT=-5

if [ "$INT" -eq 0 ]; then
  echo "INT 是 0."
else
  if [ "$INT" -lt 0 ]; then
    echo "INT 是负数。"
  else
    echo "INT 是正数。"
  fi

  # 使用算术扩展 ((...)) 和取余运算符 % 来判断奇偶
  if [ $((INT % 2)) -eq 0 ]; then
    echo "INT 是偶数。"
  else
    echo "INT 是奇数。"
  fi
fi
```

-----

### 27.4 更现代的 test

  - **核心思想**：`[[ ... ]]` 是 `[ ... ]` 的现代化增强版，专门为 Bash 设计，功能更强，语法更容错。**在编写 Bash 脚本时，应优先使用 `[[ ... ]]`**。

  - **`[[ ... ]]` 的两大杀手锏**：

    1.  **正则表达式匹配**：使用 `=~` 操作符，可以方便地验证字符串格式。
    2.  **通配符匹配**：在 `[[ ... ]]` 内部，`==` 的右侧可以像文件名一样使用通配符（如 `*`）。

**关键示例 1：使用正则表达式验证输入是否为整数**
这是 `[[ ... ]]` 最典型的应用场景：在进行数学运算前，先确保变量里真的是数字。

```bash
#!/bin/bash
# test-integer2: 使用 [[ ]] 验证整数
INT=-5

# 使用正则表达式 =~ 检查变量是否匹配整数模式
if [[ "$INT" =~ ^-?[0-9]+$ ]]; then
  # 验证通过后，再安全地使用旧的 [ ] 或新的 (( )) 进行数学比较
  if [ "$INT" -lt 0 ]; then
    echo "INT is negative."
  fi
else
  echo "INT is not an integer." >&2
  exit 1
fi
```

**关键示例 2：使用通配符匹配文件名**

```shell
[me@linuxbox ~]$ FILE=foo.bar
[me@linuxbox ~]$ if [[ $FILE == foo.* ]]; then
> echo "文件名匹配 'foo.*'"
> fi
文件名匹配 'foo.*'
```

-----

### 27.5 (())——为整数设计

  - **核心思想**：`(( ... ))` 是专门为**整数运算和比较**设计的复合命令。如果你的操作只涉及数字，用它就对了。

  - **`(( ... ))` 的核心优势**：

    1.  **更自然的数学语法**：可以直接使用 `>`、`<`、`==`、`!=`、`>=`、`<=` 等C语言风格的比较符。
    2.  **变量无需 `$` 前缀**：在 `(( ... ))` 内部，可以直接使用变量名 `VAR`，而无需写成 `$VAR`。

**关键示例：用 `(( ))` 简化整数判断脚本**
这个例子展示了如何结合 `[[ ]]` 和 `(( ))` 写出既安全又简洁的代码：先用 `[[ ]]` 验证，再用 `(( ))` 比较。

```bash
#!/bin/bash
# test-integer2a: 结合 [[ ]] 和 (( ))
INT=-5

# 步骤 1: 使用 [[ ... ]] 通过正则表达式验证输入是整数
if [[ "$INT" =~ ^-?[0-9]+$ ]]; then
  # 步骤 2: 验证通过后，使用 (( ... )) 进行清爽的数学比较
  if (( INT == 0 )); then
    echo "INT is zero."
  elif (( INT < 0 )); then
    echo "INT is negative."
  else
    echo "INT is positive."
  fi

  if (( (INT % 2) == 0 )); then
    echo "INT is even."
  else
    echo "INT is odd."
  fi
else
  echo "INT is not an integer." >&2
  exit 1
fi
```

-----

### 27.6 组合表达式

  - **核心思想**：我们可以使用逻辑操作符（AND, OR, NOT）将多个测试条件组合在一起，形成更复杂的判断。

  - **关键区别：`[ ]` vs `[[ ]]`**

      - `[[ ... ]]` (推荐): 使用更现代、更直观的操作符。
          - **AND**: `&&`
          - **OR**: `||`
          - **NOT**: `!`
      - `[ ... ]` (旧式): 使用字母选项。
          - **AND**: `-a`
          - **OR**: `-o`
          - **NOT**: `!`

**关键示例 1：使用 `&&` (AND) 检查数值范围**
这个脚本检查一个整数是否同时大于等于 `MIN_VAL` **并且**小于等于 `MAX_VAL`。

```bash
#!/bin/bash
# test-integer3: 检查整数是否在 [1, 100] 区间内
MIN_VAL=1
MAX_VAL=100
INT=50

if [[ "$INT" -ge "$MIN_VAL" && "$INT" -le "$MAX_VAL" ]]; then
  echo "$INT 在 $MIN_VAL 到 $MAX_VAL 范围内。"
else
  echo "$INT 超出范围。"
fi
```

**关键示例 2：使用 `!` (NOT) 进行逻辑取反**
这个脚本检查一个整数是否**不**在指定的范围内。注意 `!` 后面用括号将整个组合条件括起来，确保 `!` 作用于整个结果。

```bash
#!/bin/bash
# test-integer4: 检查整数是否在范围之外
MIN_VAL=1
MAX_VAL=100
INT=50

if [[ ! ("$INT" -ge "$MIN_VAL" && "$INT" -le "$MAX_VAL") ]]; then
  echo "$INT 在 $MIN_VAL 到 $MAX_VAL 范围之外。"
else
  echo "$INT 在范围内。"
fi
```

> **最终建议：`[ ]` vs `[[ ]]` 哪个更好？**
>
>   - **`[ ]` (test)**：优点是**可移植性**，遵循 POSIX 标准，在所有 shell 中都能运行。
>   - **`[[ ]]`**：优点是**功能更强、更安全、语法更友好**（例如支持正则和通配符）。
>   - **结论**：除非你在为非常古老的系统编写脚本，否则**在现代 Bash 脚本中，应始终优先使用 `[[ ]]`**。

-----

### 27.7 控制操作符：另一种分支方式

  - **核心思想**：`&&` (AND) 和 `||` (OR) 不仅可以用在 `[[ ]]` 内部，还可以直接用来连接**任意两个命令**，实现简洁的条件执行。这是一种 `if` 语句的快捷方式。

  - **工作原理**：

      - `command1 && command2`：只有 `command1` **成功** (退出状态为0)，才会执行 `command2`。
      - `command1 || command2`：只有 `command1` **失败** (退出状态非0)，才会执行 `command2`。

**关键示例：**
这些是 Shell 编程中非常常见且强大的用法。

```shell
# 示例 1: "AND" 逻辑
# 只有在成功创建 temp 目录后，才会 cd 进入该目录。
[me@linuxbox ~]$ mkdir temp && cd temp

# 示例 2: "OR" 逻辑
# 如果目录 temp 不存在 ([ -d temp ] 测试失败)，则创建它。
[me@linuxbox ~]$ [ -d temp ] || mkdir temp

# 示例 3: 简单的错误处理
# 如果 temp 目录不存在，则脚本以失败状态退出。
[ -d temp ] || exit 1
```